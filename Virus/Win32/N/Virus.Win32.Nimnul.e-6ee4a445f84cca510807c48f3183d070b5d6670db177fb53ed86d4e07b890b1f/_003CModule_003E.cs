// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: msvcm90, Version=9.0.21022.8, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: FDAF5784-DC0A-4D49-89A5-C0D00E7CE244
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Virus.Win32.Nimnul.e-6ee4a445f84cca510807c48f3183d070b5d6670db177fb53ed86d4e07b890b1f.exe

using \u003CCppImplementationDetails\u003E;
using \u003CCrtImplementationDetails\u003E;
using msclr._detail;
using std;
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;

internal class \u003CModule\u003E
{
  internal static __FnPtr<int (_exception*)> pusermatherr;
  internal static __FnPtr<void ()> \u003FA0xdf95c15d\u002Epusermatherr\u0024initializer\u0024;
  internal static int _matherr_flag;
  public static unsafe int** __unep\u0040\u003F_matherr\u0040\u0040\u0024\u0024J0YAHPAU_exception\u0040\u0040\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BI\u0040LCAMKDOP\u0040\u003F\u0024AAv\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AA9\u003F\u0024AA0\u003F\u0024AA\u003F4\u003F\u0024AAd\u003F\u0024AAl\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0M\u0040JLENCBNC\u0040_vcomp_fork\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BK\u0040GHOADEIL\u0040\u003F\u0024AAv\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AA9\u003F\u0024AA0\u003F\u0024AAd\u003F\u0024AA\u003F4\u003F\u0024AAd\u003F\u0024AAl\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static __s_GUID _GUID_90f1a06e_7712_4762_86b5_7a5eba6bdb02;
  internal static __s_GUID _GUID_cb2f6722_ab3a_11d2_9c40_00c04fa30a3e;
  internal static __s_GUID _GUID_00000000_0000_0000_c000_000000000046;
  [FixedAddressValueType]
  internal static volatile __FnPtr<int (uint)> __mpnhHeap;
  [FixedAddressValueType]
  internal static volatile __FnPtr<void ()> __nhmHeap;
  internal static __FnPtr<void ()> \u003FA0x2cb8ed13\u002E__nhmHeap\u0024initializer\u0024;
  internal static __signal_init \u003FA0x2cb8ed13\u002E_init;
  internal static __FnPtr<void ()> \u003FA0x2cb8ed13\u002E_init\u0024initializer\u0024;
  internal static __s_GUID _GUID_cb2f6723_ab3a_11d2_9c40_00c04fa30a3e;
  internal static __FnPtr<void ()> \u003FA0x2cb8ed13\u002E__mpnhHeap\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static volatile \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040R6MXH\u0040Z \u003FA0x2cb8ed13\u002E__psignal_func;
  internal static __s_GUID _GUID_90f1a06c_7712_4762_86b5_7a5eba6bdb02;
  public static unsafe int** __unep\u0040\u003F_callnewh_thunk\u0040\u003FA0x2cb8ed13\u0040\u0040\u0024\u0024FYAHI\u0040Z;
  public static unsafe int** __unep\u0040\u003F_callnewhandler_thunk\u0040\u003FA0x2cb8ed13\u0040\u0040\u0024\u0024FYAHI\u0040Z;
  public static unsafe int** __unep\u0040\u003F__signal_thunk\u0040\u003FA0x2cb8ed13\u0040\u0040\u0024\u0024FYAXH\u0040Z;
  [FixedAddressValueType]
  internal static volatile __FnPtr<void (char*, char*, char*, uint, uint)> __pParameter_m;
  [FixedAddressValueType]
  internal static __FnPtr<void ()> \u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0x90ec3f08\u002E\u003F__pPurecall_m\u0024initializer\u0024\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0x90ec3f08\u002E__pParameter_m\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static __FnPtr<void ()> \u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0x90ec3f08\u002E\u003F__pTerminate_m\u0024initializer\u0024\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static __FnPtr<void ()> \u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0x90ec3f08\u002E\u003F__pUnexpected_m\u0024initializer\u0024\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  public static unsafe int** __unep\u0040\u003F__invalid_parameter_handler_thunk\u0040\u0040\u0024\u0024FYAXPB_W00II\u0040Z;
  public static unsafe int** __unep\u0040\u003F__terminate_thunk\u0040\u0040\u0024\u0024FYAXXZ;
  public static unsafe int** __unep\u0040\u003F__purecall_thunk\u0040\u003FA0x90ec3f08\u0040\u0040\u0024\u0024FYAXXZ;
  public static unsafe int** __unep\u0040\u003F__unexpected_thunk\u0040\u0040\u0024\u0024FYAXXZ;
  [FixedAddressValueType]
  internal static __FnPtr<int (_FPIEEE_RECORD*)> \u003F__pFilter_m\u0040HandlersFP\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MHPAU_FPIEEE_RECORD\u0040\u0040\u0040ZA;
  internal static __FnPtr<void ()> \u003FA0xdfaa356a\u002E\u003F__pFilter_m\u0024initializer\u0024\u0040HandlersFP\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  public static unsafe int** __unep\u0040\u003Ffpieee_flt_thunk_func\u0040\u0040\u0024\u0024FYAHPAU_FPIEEE_RECORD\u0040\u0040\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xc_mp_z;
  [FixedAddressValueType]
  internal static int \u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FUninitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xi_vt_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitializedPerAppDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static bool \u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FIsDefaultDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xc_ma_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitializedNative\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static int \u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xc_ma_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitializedVtables\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xi_vt_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitializedPerProcess\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static bool \u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static int \u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA;
  internal static TriBool.State \u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static TriBool.State \u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static bool \u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xc_mp_a;
  public static unsafe int** __unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  public static unsafe int** __unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040GHFPNOJB\u0040bad\u003F5allocation\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BC\u0040EOODALEL\u0040Unknown\u003F5exception\u003F\u0024AA\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7exception\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4exception\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040exception\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVexception\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2bad_alloc\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040bad_alloc\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x2d544943\u002E\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3bad_alloc\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2exception\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3exception\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x2d544943\u002E\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x2d544943\u002E_bad_alloc_Message;
  internal static _GUID IID_ICLRRuntimeHost;
  internal static _GUID CLSID_CLRRuntimeHost;
  public static unsafe int** __unep\u0040\u003Fcallback\u0040callback_cdecl_void_struct0\u0040_detail\u0040msclr\u0040\u0040\u0024\u0024FSGJPAX\u0040Z;
  public static unsafe int** __unep\u0040\u003F_callthreadstart\u0040\u003FA0x88c9395d\u0040\u0040\u0024\u0024FYAXXZ;
  public static unsafe int** __unep\u0040\u003F_threadstart\u0040\u003FA0x88c9395d\u0040\u0040\u0024\u0024FYGKPAX\u0040Z;
  public static unsafe int** __unep\u0040\u003F_callthreadstartex\u0040\u003FA0x8428c990\u0040\u0040\u0024\u0024FYAXXZ;
  public static unsafe int** __unep\u0040\u003F_threadstartex\u0040\u003FA0x8428c990\u0040\u0040\u0024\u0024FYGKPAX\u0040Z;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_25 \u003F\u003F_R0\u003FAV_Locimp\u0040locale\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY08Q6AXXZ \u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024ctype\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY04Q6AXXZ \u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3ios_base\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040A\u00403FA\u0040\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_52 \u003F\u003F_R0\u003FAV\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2_Locimp\u0040locale\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024ctype\u0040G\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3_Locimp\u0040locale\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2facet\u0040locale\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2codecvt_base\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4_Locimp\u0040locale\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4ios_base\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040A\u00403FA\u0040\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040A\u00403EA\u0040ios_base\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040codecvt_base\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAV\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAVcodecvt_base\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024ctype\u0040_W\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_25 \u003F\u003F_R0\u003FAV\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_52 \u003F\u003F_R0\u003FAV\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_50 \u003F\u003F_R0\u003FAV\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_19 \u003F\u003F_R0\u003FAVios_base\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2ctype_base\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_50 \u003F\u003F_R0\u003FAV\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_21 \u003F\u003F_R0\u003FAV\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_46 \u003F\u003F_R0\u003FAV\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3facet\u0040locale\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R13\u003F0A\u0040EA\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAV\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_24 \u003F\u003F_R0\u003FAV\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_52 \u003F\u003F_R0\u003FAV\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3codecvt_base\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040_Locimp\u0040locale\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2ios_base\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024ctype\u0040_W\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4ctype_base\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_46 \u003F\u003F_R0\u003FAV\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAV\u003F\u0024_Iosb\u0040H\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040ctype_base\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040facet\u0040locale\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R13A\u00403EA\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4facet\u0040locale\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY08Q6AXXZ \u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_21 \u003F\u003F_R0\u003FAUctype_base\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_50 \u003F\u003F_R0\u003FAV\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_54 \u003F\u003F_R0\u003FAV\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024ctype\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040ios_base\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_50 \u003F\u003F_R0\u003FAV\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAVfacet\u0040locale\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3ctype_base\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static unsafe sbyte* std\u002E\u003FA0xc4d0f765\u002E_bad_alloc_Message;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_48 \u003F\u003F_R0\u003FAV\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_52 \u003F\u003F_R0\u003FAV\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040A\u00403FA\u0040\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4codecvt_base\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024ctype\u0040G\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0xc4d0f765\u002E\u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  public static unsafe int** __unep\u0040\u003Frsfun\u0040\u003FA0xc4d0f765\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
  public static unsafe int** __unep\u0040\u003Fsifun\u0040\u003FA0xc4d0f765\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
  public static unsafe int** __unep\u0040\u003Fsbfun\u0040\u003FA0xc4d0f765\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
  public static unsafe int** __unep\u0040\u003Fspfun\u0040\u003FA0xc4d0f765\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
  public static unsafe int** __unep\u0040\u003Fswfun\u0040\u003FA0xc4d0f765\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY09PAVios_base\u0040std\u0040\u0040 std\u002E\u003FA0x46a0984e\u002Estdstr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x46a0984e\u002Estdstr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static bool \u003F_Sync\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0_NA;
  internal static __FnPtr<void ()> \u003FA0x46a0984e\u002E\u003F_Sync\u0024initializer\u0024\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  [FixedAddressValueType]
  internal static int \u003F_Index\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA;
  internal static __FnPtr<void ()> \u003FA0x46a0984e\u002E\u003F_Index\u0024initializer\u0024\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY09D std\u002E\u003FA0x46a0984e\u002Estdopens;
  internal static __FnPtr<void ()> std\u002E\u003FA0x46a0984e\u002Estdopens\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x46a0984e\u002E_bad_alloc_Message;
  internal static int std\u002E_BADOFF;
  internal static long std\u002E_Fpz;
  [FixedAddressValueType]
  internal static int \u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA;
  internal static __FnPtr<void ()> \u003FA0x98d5b6ac\u002E\u003F_Init_cnt\u0024initializer\u0024\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  internal static unsafe sbyte* std\u002E\u003FA0x98d5b6ac\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static int \u003F_Init_cnt\u0040_Winit\u0040std\u0040\u0040\u0024\u0024Q0HA;
  internal static __FnPtr<void ()> \u003FA0xf9d05183\u002E\u003F_Init_cnt\u0024initializer\u0024\u0040_Winit\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  internal static unsafe sbyte* std\u002E\u003FA0xf9d05183\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static _Init_atexit \u003FA0x483a8775\u002Einit_atexit;
  [FixedAddressValueType]
  internal static uint \u003FA0x483a8775\u002Eatcount_cdecl;
  internal static __FnPtr<void ()> \u003FA0x483a8775\u002Einit_atexit\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Ptr_cin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x483a8775\u002E_Ptr_cin\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Ptr_wcout;
  internal static __FnPtr<void ()> std\u002E\u003FA0x483a8775\u002E_Ptr_wcout\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Ptr_cout;
  internal static __FnPtr<void ()> std\u002E\u003FA0x483a8775\u002E_Ptr_cout\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0FL\u0040D _PJP_CPP_Copyright;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY09P6AXXZ \u003FA0x483a8775\u002Eatfuns_cdecl;
  internal static __FnPtr<void ()> \u003FA0x483a8775\u002Eatcount_cdecl\u0024initializer\u0024;
  internal static _Init_locks std\u002E\u003FA0x483a8775\u002Einitlocks;
  internal static __FnPtr<void ()> std\u002E\u003FA0x483a8775\u002Einitlocks\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Ptr_clog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x483a8775\u002E_Ptr_clog\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Ptr_wcerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x483a8775\u002E_Ptr_wcerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Ptr_wcin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x483a8775\u002E_Ptr_wcin\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Ptr_wclog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x483a8775\u002E_Ptr_wclog\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x483a8775\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Ptr_cerr;
  internal static __FnPtr<void ()> \u003FA0x483a8775\u002Eatfuns_cdecl\u0024initializer\u0024;
  internal static __FnPtr<void ()> std\u002E\u003FA0x483a8775\u002E_Ptr_cerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static int \u003F_Init_cnt\u0040_UShinit\u0040std\u0040\u0040\u0024\u0024Q0HA;
  internal static __FnPtr<void ()> \u003FA0xc0c0de8a\u002E\u003F_Init_cnt\u0024initializer\u0024\u0040_UShinit\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Ptr_wcout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xc0c0de8a\u002E_Ptr_wcout\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Ptr_wcerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0xc0c0de8a\u002E_Ptr_wcerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Ptr_wcin;
  internal static __FnPtr<void ()> std\u002E\u003FA0xc0c0de8a\u002E_Ptr_wcin\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Ptr_wclog;
  internal static __FnPtr<void ()> std\u002E\u003FA0xc0c0de8a\u002E_Ptr_wclog\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0xc0c0de8a\u002E_bad_alloc_Message;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_24 \u003F\u003F_R0\u003FAV\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY08Q6AXXZ \u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _Init_locks \u003FA0x8507841e\u002Einitlocks;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x8507841e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static int \u003F_Stinit\u0040\u003F1\u003F\u003F_Init\u0040\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040IAMXPAU_iobuf\u0040\u0040W4_Initfl\u004023\u0040\u0040Z\u00404HA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBH \u003F\u003F_8\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_50 \u003F\u003F_R0\u003FAV\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x8507841e\u002E\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x8507841e\u002Einitlocks\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static _Init_cerr std\u002E\u003FA0x8507841e\u002Einit_cerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x8507841e\u002Einit_cerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002Ecerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x8507841e\u002Ecerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x8507841e\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002E\u003FA0x8507841e\u002Eferr;
  internal static unsafe sbyte* std\u002E\u003FA0x8507841e\u002E_bad_alloc_Message;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x8507841e\u002E\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> std\u002E\u003FA0x8507841e\u002Eferr\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00408;
  internal static _Init_locks \u003FA0x0bf8a0f9\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002Ecin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x0bf8a0f9\u002Ecin\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x0bf8a0f9\u002Einitlocks\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBH \u003F\u003F_8\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
  internal static __FnPtr<void ()> std\u002E\u003FA0x0bf8a0f9\u002Einit_cin\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x0bf8a0f9\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002E\u003FA0x0bf8a0f9\u002Efin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x0bf8a0f9\u002Efin\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002Eclog;
  internal static __FnPtr<void ()> std\u002E\u003FA0xcf5af113\u002Eclog\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002E\u003FA0xcf5af113\u002Eflog;
  internal static __FnPtr<void ()> std\u002E\u003FA0xcf5af113\u002Eflog\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0xcf5af113\u002E_bad_alloc_Message;
  internal static __FnPtr<void ()> std\u002E\u003FA0xcf5af113\u002Einit_clog\u0024initializer\u0024;
  internal static _Init_locks \u003FA0x07394545\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002Ecout;
  internal static __FnPtr<void ()> std\u002E\u003FA0x07394545\u002Ecout\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x07394545\u002Einitlocks\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002E\u003FA0x07394545\u002Efout;
  internal static __FnPtr<void ()> std\u002E\u003FA0x07394545\u002Efout\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x07394545\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static _Init_cout std\u002E\u003FA0x07394545\u002Einit_cout;
  internal static __FnPtr<void ()> std\u002E\u003FA0x07394545\u002Einit_cout\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static _Init_ushcerr std\u002E\u003FA0xd48a97bf\u002Einit_ushcerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0xd48a97bf\u002Einit_ushcerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xd48a97bf\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002Ewcerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0xd48a97bf\u002Ewcerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002E\u003FA0xd48a97bf\u002Ewferr;
  internal static __FnPtr<void ()> std\u002E\u003FA0xd48a97bf\u002Ewferr\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _Init_locks \u003FA0xd48a97bf\u002Einitlocks;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBH \u003F\u003F_8\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
  internal static __FnPtr<void ()> \u003FA0xd48a97bf\u002E\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static int \u003F_Stinit\u0040\u003F1\u003F\u003F_Init\u0040\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040IAMXPAU_iobuf\u0040\u0040W4_Initfl\u004023\u0040\u0040Z\u00404HA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_50 \u003F\u003F_R0\u003FAV\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0xd48a97bf\u002Einitlocks\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static unsafe sbyte* std\u002E\u003FA0xd48a97bf\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002Ewcin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x58eb3bc8\u002Ewcin\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBH \u003F\u003F_8\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
  internal static _Init_locks \u003FA0x58eb3bc8\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002E\u003FA0x58eb3bc8\u002Ewfin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x58eb3bc8\u002Ewfin\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x58eb3bc8\u002Einitlocks\u0024initializer\u0024;
  internal static __FnPtr<void ()> std\u002E\u003FA0x58eb3bc8\u002Einit_ushcin\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x58eb3bc8\u002E_bad_alloc_Message;
  internal static _Init_locks \u003FA0x9ed7e2b2\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002E\u003FA0x9ed7e2b2\u002Ewflog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x9ed7e2b2\u002Ewflog\u0024initializer\u0024;
  internal static __FnPtr<void ()> std\u002E\u003FA0x9ed7e2b2\u002Einit_ushclog\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x9ed7e2b2\u002Einitlocks\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002Ewclog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x9ed7e2b2\u002Ewclog\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x9ed7e2b2\u002E_bad_alloc_Message;
  internal static _Init_locks \u003FA0x56b456e4\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002E\u003FA0x56b456e4\u002Ewfout;
  internal static __FnPtr<void ()> std\u002E\u003FA0x56b456e4\u002Ewfout\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static _Init_ushcout std\u002E\u003FA0x56b456e4\u002Einit_ushcout;
  internal static __FnPtr<void ()> std\u002E\u003FA0x56b456e4\u002Einit_ushcout\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x56b456e4\u002Einitlocks\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x56b456e4\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002Ewcout;
  internal static __FnPtr<void ()> std\u002E\u003FA0x56b456e4\u002Ewcout\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_52 \u003F\u003F_R0\u003FAV\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static int \u003F_Stinit\u0040\u003F1\u003F\u003F_Init\u0040\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040IAMXPAU_iobuf\u0040\u0040W4_Initfl\u004023\u0040\u0040Z\u00404HA;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002Ewcerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x67178f3e\u002Ewcerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002E\u003FA0x67178f3e\u002Ewferr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x67178f3e\u002Ewferr\u0024initializer\u0024;
  internal static _Init_locks \u003FA0x67178f3e\u002Einitlocks;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x67178f3e\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBH \u003F\u003F_8\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
  internal static __FnPtr<void ()> \u003FA0x67178f3e\u002Einitlocks\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static _Init_wcerr std\u002E\u003FA0x67178f3e\u002Einit_wcerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x67178f3e\u002Einit_wcerr\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x67178f3e\u002E\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x67178f3e\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002Ewcin;
  internal static __FnPtr<void ()> std\u002E\u003FA0xa3899430\u002Ewcin\u0024initializer\u0024;
  internal static _Init_locks \u003FA0xa3899430\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002E\u003FA0xa3899430\u002Ewfin;
  internal static __FnPtr<void ()> std\u002E\u003FA0xa3899430\u002Ewfin\u0024initializer\u0024;
  internal static __FnPtr<void ()> std\u002E\u003FA0xa3899430\u002Einit_wcin\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0xa3899430\u002Einitlocks\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBH \u003F\u003F_8\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
  internal static unsafe sbyte* std\u002E\u003FA0xa3899430\u002E_bad_alloc_Message;
  internal static _Init_locks \u003FA0x2d4afa33\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002E\u003FA0x2d4afa33\u002Ewflog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x2d4afa33\u002Ewflog\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x2d4afa33\u002Einitlocks\u0024initializer\u0024;
  internal static __FnPtr<void ()> std\u002E\u003FA0x2d4afa33\u002Einit_wclog\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002Ewclog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x2d4afa33\u002Ewclog\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x2d4afa33\u002E_bad_alloc_Message;
  internal static _Init_locks \u003FA0xe5294e65\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002E\u003FA0xe5294e65\u002Ewfout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xe5294e65\u002Ewfout\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0xe5294e65\u002Einitlocks\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static _Init_wcout std\u002E\u003FA0xe5294e65\u002Einit_wcout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xe5294e65\u002Einit_wcout\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0xe5294e65\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002Ewcout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xe5294e65\u002Ewcout\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01NBENCBCI\u0040\u003F\u0024CK\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CBD \u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVexception\u0040std\u0040\u0040\u00408\u003F\u003F0exception\u0040std\u0040\u0040\u0024\u0024FQAM\u0040ABV01\u0040\u0040Z12;
  internal static bad_alloc \u003FA0x484de624\u002E\u003Fnomem\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404Vbad_alloc\u00404\u0040B;
  internal static uint \u003FA0x484de624\u002E\u003F\u0024S2\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404IA;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_8 _CTA2\u003FAVbad_alloc\u0040std\u0040\u0040;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x484de624\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x484de624\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__ThrowInfo _TI2\u003FAVbad_alloc\u0040std\u0040\u0040;
  internal static unsafe sbyte* std\u002E\u003FA0x484de624\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408\u003F\u003F0bad_alloc\u0040std\u0040\u0040\u0024\u0024FQAE\u0040ABV01\u0040\u0040Z12;
  internal static __FnPtr<void ()> \u003FA0x484de624\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xc867d7a3\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xc867d7a3\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static unsafe _Fac_node* std\u002E\u003FA0xc867d7a3\u002E_Fac_head;
  internal static __FnPtr<void ()> std\u002E\u003FA0xc867d7a3\u002E_Fac_head\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe locale._Locimp* \u003FA0xc867d7a3\u002Eglobal_locale;
  [FixedAddressValueType]
  internal static locale std\u002E\u003FA0xc867d7a3\u002Eclassic_locale;
  internal static __FnPtr<void ()> std\u002E\u003FA0xc867d7a3\u002Eclassic_locale\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static bool \u003FA0xc867d7a3\u002E\u003Fregistered\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404_NA;
  [FixedAddressValueType]
  internal static unsafe locale._Locimp* \u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A;
  internal static __FnPtr<void ()> \u003FA0xc867d7a3\u002E\u003F_Clocptr\u0024initializer\u0024\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xc867d7a3\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xc867d7a3\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static int \u003F_Id_cnt\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0HA;
  internal static __FnPtr<void ()> \u003FA0xc867d7a3\u002E\u003F_Id_cnt\u0024initializer\u0024\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xc867d7a3\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static unsafe sbyte* std\u002E\u003FA0xc867d7a3\u002E_bad_alloc_Message;
  internal static uint \u003FA0xc867d7a3\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404IA;
  internal static __FnPtr<void ()> \u003FA0xc867d7a3\u002Eglobal_locale\u0024initializer\u0024;
  public static unsafe int** __unep\u0040\u003Ftidy_global\u0040\u003FA0xc867d7a3\u0040\u0040\u0024\u0024J0YAXXZ;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x388f666f\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x388f666f\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x388f666f\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x388f666f\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x388f666f\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x388f666f\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static unsafe sbyte* std\u002E\u003FA0x388f666f\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x388f666f\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0x388f666f\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4a1bf91e\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static unsafe sbyte* std\u002E\u003FA0x4a1bf91e\u002E_bad_alloc_Message;
  internal static unsafe sbyte* std\u002E\u003FA0x5e14f41c\u002E_bad_alloc_Message;
  internal static volatile \u0024ArrayType\u0024\u0024\u0024BY0DO\u0040RAU_CPLocEntry\u0040\u0040 \u003FA0xba4dcdd5\u002E_CPLocHash;
  internal static __FnPtr<int ()> \u003FA0xba4dcdd5\u002Epinit;
  internal static _Init_locks std\u002E\u003FA0x3d15c383\u002Einitlocks;
  internal static __FnPtr<void ()> std\u002E\u003FA0x3d15c383\u002Einitlocks\u0024initializer\u0024;
  internal static int std\u002E\u003FA0x3d15c383\u002Einit;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03U_RTL_CRITICAL_SECTION\u0040\u0040 std\u002E\u003FA0x3d15c383\u002Emtx;
  internal static double \u003FA0xbcbee40e\u002Ec1;
  internal static double \u003FA0xbcbee40e\u002Ec2;
  internal static double \u003FA0xbcbee40e\u002Einvln2;
  internal static double \u003FA0xbcbee40e\u002Ehugexp;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBN \u003FA0xbcbee40e\u002Eq;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBN \u003FA0xbcbee40e\u002Ep;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBN \u003FA0x7cbde3dc\u002Ep;
  internal static _Dconst _Snan;
  internal static double _Xbig;
  internal static _Dconst _Denorm;
  internal static double _Zero;
  internal static _Dconst _Inf;
  internal static _Dconst _Nan;
  internal static _Dconst _Eps;
  internal static _Dconst _Hugeval;
  internal static _Dconst _Rteps;
  internal static float \u003FA0x44948d9c\u002Ec1;
  internal static float \u003FA0x44948d9c\u002Ec2;
  internal static float \u003FA0x44948d9c\u002Einvln2;
  internal static float \u003FA0x44948d9c\u002Ehugexp;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBM \u003FA0x44948d9c\u002Eq;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBM \u003FA0x44948d9c\u002Ep;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBM \u003FA0x62443bdd\u002Ep;
  internal static float _FZero;
  internal static _Dconst _FDenorm;
  internal static float _FXbig;
  internal static _Dconst _FNan;
  internal static _Dconst _FRteps;
  internal static _Dconst _FEps;
  internal static _Dconst _FInf;
  internal static _Dconst _FSnan;
  internal static double \u003FA0xe0e4d2d2\u002Ec1;
  internal static double \u003FA0xe0e4d2d2\u002Ec2;
  internal static double \u003FA0xe0e4d2d2\u002Einvln2;
  internal static double \u003FA0xe0e4d2d2\u002Ehugexp;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBO \u003FA0xe0e4d2d2\u002Eq;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBO \u003FA0xe0e4d2d2\u002Ep;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBO \u003FA0xf3842715\u002Ep;
  internal static _Dconst _LEps;
  internal static _Dconst _LNan;
  internal static _Dconst _LRteps;
  internal static _Dconst _LDenorm;
  internal static _Dconst _LInf;
  internal static double _LXbig;
  internal static _Dconst _LSnan;
  internal static double _LZero;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13BPINEIPE\u0040\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13CIFDLIMG\u0040\u003F\u0024AAw\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13FNCBLAIF\u0040\u003F\u0024AAa\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15JJPIMNBO\u0040\u003F\u0024AAr\u003F\u0024AAb\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15MJDFFMKN\u0040\u003F\u0024AAw\u003F\u0024AAb\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15BMLKLNCL\u0040\u003F\u0024AAa\u003F\u0024AAb\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15HPOENKKJ\u0040\u003F\u0024AAr\u003F\u0024AA\u003F\u0024CL\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15CPCJELBK\u0040\u003F\u0024AAw\u003F\u0024AA\u003F\u0024CL\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15PKKGKKJM\u0040\u003F\u0024AAa\u003F\u0024AA\u003F\u0024CL\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003F\u003F_C\u0040_17IIOMHMAG\u0040\u003F\u0024AAr\u003F\u0024AA\u003F\u0024CL\u003F\u0024AAb\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003F\u003F_C\u0040_17MAAMHCGC\u0040\u003F\u0024AAw\u003F\u0024AA\u003F\u0024CL\u003F\u0024AAb\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003F\u003F_C\u0040_17HKNIEKMO\u0040\u003F\u0024AAa\u003F\u0024AA\u003F\u0024CL\u003F\u0024AAb\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBH \u003FA0x0e86b956\u002E\u003Fvalid\u0040\u003F1\u003F\u003F_Fiopen\u0040std\u0040\u0040YAPAU_iobuf\u0040\u0040PB_WHH\u0040Z\u00404QBHB;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040PB_W \u003FA0x0e86b956\u002E\u003Fmods\u0040\u003F1\u003F\u003F_Fiopen\u0040std\u0040\u0040YAPAU_iobuf\u0040\u0040PB_WHH\u0040Z\u00404PAPB_WA;
  internal static unsafe sbyte* std\u002E\u003FA0x0e86b956\u002E_bad_alloc_Message;
  internal static unsafe sbyte* std\u002E\u003FA0x18045193\u002E_bad_alloc_Message;
  internal static unsafe sbyte* stdext\u002E\u003FA0x51284497\u002E_bad_alloc_Message;
  internal static bad_alloc \u003FA0xfd82e259\u002E\u003Fnomem\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404Vbad_alloc\u00402\u0040B;
  internal static uint \u003FA0xfd82e259\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404IA;
  internal static unsafe sbyte* std\u002E\u003FA0xfd82e259\u002E_bad_alloc_Message;
  internal static unsafe sbyte* std\u002E\u003FA0xd5b917b1\u002E_bad_alloc_Message;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07OJACGNH\u0040tolower\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07FFCOENGO\u0040toupper\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBUwctab\u0040\u0040 \u003FA0x5d638340\u002Etab;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05IIMHCHIO\u0040alnum\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05IAEKHIAN\u0040alpha\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05JMDPEFNK\u0040cntrl\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05ODNOIFML\u0040digit\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05KCJBMLII\u0040graph\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05IPJEPLHL\u0040lower\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05IJDJACGD\u0040print\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05KOBGHFJJ\u0040punct\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05OLNILLAB\u0040space\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05NECKJAMC\u0040upper\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003F\u003F_C\u0040_06BAPHGFFK\u0040xdigit\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBUwctab\u0040\u0040 \u003FA0x1ed63743\u002Etab;
  [FixedAddressValueType]
  internal static uint __exit_list_size_app_domain;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitbegin_app_domain;
  internal static uint \u003FA0x11773762\u002E__exit_list_size;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitend_app_domain;
  internal static unsafe __FnPtr<void ()>* \u003FA0x11773762\u002E__onexitbegin_m;
  internal static unsafe __FnPtr<void ()>* \u003FA0x11773762\u002E__onexitend_m;
  [FixedAddressValueType]
  internal static unsafe void* \u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA;
  [FixedAddressValueType]
  internal static int \u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CF\u0040\u0024\u0024CBD \u003FA0xddb3e8c5\u002Edigits;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CF\u0040\u0024\u0024CBD \u003FA0xddb3e8c5\u002Endigs;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CF\u0040\u0024\u0024CBD \u003FA0xec5c3396\u002Edigits;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CF\u0040\u0024\u0024CBD \u003FA0xec5c3396\u002Endigs;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_z;
  public static volatile uint __native_vcclrit_reason;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_a;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_a;
  public static volatile __enative_startup_state __native_startup_state;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_z;
  public static volatile unsafe void* __native_startup_lock;
  public static volatile uint __native_dllmain_reason;
  public static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7type_info\u0040\u00406B\u0040;

  internal static void \u003FA0xdf95c15d\u002E\u003F\u003F__Epusermatherr\u0040\u0040YMXXZ()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static unsafe int _matherr(_exception* pexcept)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<int (_exception*)> local = (__FnPtr<int (_exception*)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.pusermatherr);
    if (local == null)
      return 0;
    _exception* exceptionPtr = pexcept;
    // ISSUE: function pointer call
    return __calli(local)(exceptionPtr);
  }

  internal static unsafe void __setusermatherr_m(__FnPtr<int (_exception*)> pf)
  {
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.pusermatherr = (__FnPtr<int (_exception*)>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pf);
    if (pf != null)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__setusermatherr((__FnPtr<int (_exception*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_matherr\u0040\u0040\u0024\u0024J0YAHPAU_exception\u0040\u0040\u0040Z);
    }
    \u003CModule\u003E._matherr_flag = 0;
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(
    Exception innerException,
    Exception nestedException)
  {
    throw new ModuleLoadExceptionHandlerException("A nested exception occurred after the primary exception that caused the C++ module to fail to load.\n", innerException, nestedException);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    string errorMessage)
  {
    throw new ModuleLoadException(errorMessage);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    string errorMessage,
    Exception innerException)
  {
    throw new ModuleLoadException(errorMessage, innerException);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(
    EventHandler handler)
  {
    ModuleUninitializer._ModuleUninitializer.AddHandler(handler);
  }

  internal static unsafe int __get_default_appdomain(IUnknown** ppUnk)
  {
    int defaultAppdomain = 0;
    IUnknown* iunknownPtr1 = (IUnknown*) 0;
    ICorRuntimeHost* icorRuntimeHostPtr1 = (ICorRuntimeHost*) 0;
    try
    {
      defaultAppdomain = \u003CModule\u003E.CoCreateInstance((_GUID*) &\u003CModule\u003E._GUID_cb2f6723_ab3a_11d2_9c40_00c04fa30a3e, (IUnknown*) 0, 1U, (_GUID*) &\u003CModule\u003E._GUID_00000000_0000_0000_c000_000000000046, (void**) &iunknownPtr1);
      if (defaultAppdomain >= 0)
      {
        IUnknown* iunknownPtr2 = iunknownPtr1;
        ref __s_GUID local1 = ref \u003CModule\u003E._GUID_cb2f6722_ab3a_11d2_9c40_00c04fa30a3e;
        ref ICorRuntimeHost* local2 = ref icorRuntimeHostPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        defaultAppdomain = __calli((__FnPtr<int (IntPtr, _GUID*, void**)>) *(int*) *(int*) iunknownPtr1)((void**) iunknownPtr2, (_GUID*) ref local1, (IntPtr) ref local2);
        if (defaultAppdomain >= 0)
        {
          ICorRuntimeHost* icorRuntimeHostPtr2 = icorRuntimeHostPtr1;
          IUnknown** iunknownPtr3 = ppUnk;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          defaultAppdomain = __calli((__FnPtr<int (IntPtr, IUnknown**)>) *(int*) (*(int*) icorRuntimeHostPtr1 + 52))((IUnknown**) icorRuntimeHostPtr2, (IntPtr) iunknownPtr3);
        }
      }
    }
    finally
    {
      if ((IntPtr) iunknownPtr1 != IntPtr.Zero)
      {
        IUnknown* iunknownPtr4 = iunknownPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iunknownPtr4 + 8))((IntPtr) iunknownPtr4);
      }
      if ((IntPtr) icorRuntimeHostPtr1 != IntPtr.Zero)
      {
        ICorRuntimeHost* icorRuntimeHostPtr3 = icorRuntimeHostPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) icorRuntimeHostPtr3 + 8))((IntPtr) icorRuntimeHostPtr3);
      }
    }
    return defaultAppdomain;
  }

  internal static unsafe void __release_appdomain(IUnknown* ppUnk)
  {
    IUnknown* iunknownPtr = ppUnk;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iunknownPtr + 8))((IntPtr) iunknownPtr);
  }

  internal static unsafe AppDomain \u003CCrtImplementationDetails\u003E\u002EGetDefaultDomain()
  {
    IUnknown* ppUnk = (IUnknown*) 0;
    int defaultAppdomain = \u003CModule\u003E.__get_default_appdomain(&ppUnk);
    if (defaultAppdomain >= 0)
    {
      try
      {
        return (AppDomain) Marshal.GetObjectForIUnknown(new IntPtr((void*) ppUnk));
      }
      finally
      {
        \u003CModule\u003E.__release_appdomain(ppUnk);
      }
    }
    else
    {
      Marshal.ThrowExceptionForHR(defaultAppdomain);
      return (AppDomain) null;
    }
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain(
    __FnPtr<int (void*)> function,
    void* cookie)
  {
    ICLRRuntimeHost* iclrRuntimeHostPtr1 = (ICLRRuntimeHost*) 0;
    try
    {
      int runtimeEx = \u003CModule\u003E.CorBindToRuntimeEx((char*) 0, (char*) 0, 0U, (_GUID*) &\u003CModule\u003E._GUID_90f1a06e_7712_4762_86b5_7a5eba6bdb02, (_GUID*) &\u003CModule\u003E._GUID_90f1a06c_7712_4762_86b5_7a5eba6bdb02, (void**) &iclrRuntimeHostPtr1);
      if (runtimeEx < 0)
        Marshal.ThrowExceptionForHR(runtimeEx);
      AppDomain defaultDomain = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EGetDefaultDomain();
      // ISSUE: cast to a function pointer type
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int errorCode = __calli((__FnPtr<int (IntPtr, uint, __FnPtr<int (void*)>, void*)>) *(int*) (*(int*) iclrRuntimeHostPtr1 + 32))((void*) iclrRuntimeHostPtr1, (__FnPtr<int (void*)>) defaultDomain.Id, (uint) function, (IntPtr) cookie);
      if (errorCode >= 0)
        return;
      Marshal.ThrowExceptionForHR(errorCode);
    }
    finally
    {
      if ((IntPtr) iclrRuntimeHostPtr1 != IntPtr.Zero)
      {
        ICLRRuntimeHost* iclrRuntimeHostPtr2 = iclrRuntimeHostPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr2 + 8))((IntPtr) iclrRuntimeHostPtr2);
      }
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EIsUsingOpenMP()
  {
    HINSTANCE__* moduleHandleW1 = \u003CModule\u003E.GetModuleHandleW((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BI\u0040LCAMKDOP\u0040\u003F\u0024AAv\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AA9\u003F\u0024AA0\u003F\u0024AA\u003F4\u003F\u0024AAd\u003F\u0024AAl\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040);
    if ((IntPtr) moduleHandleW1 != IntPtr.Zero && \u003CModule\u003E.GetProcAddress(moduleHandleW1, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040JLENCBNC\u0040_vcomp_fork\u003F\u0024AA\u0040) != null)
      return true;
    HINSTANCE__* moduleHandleW2 = \u003CModule\u003E.GetModuleHandleW((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BK\u0040GHOADEIL\u0040\u003F\u0024AAv\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AA9\u003F\u0024AA0\u003F\u0024AAd\u003F\u0024AA\u003F4\u003F\u0024AAd\u003F\u0024AAl\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040);
    return (IntPtr) moduleHandleW2 != IntPtr.Zero && \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040JLENCBNC\u0040_vcomp_fork\u003F\u0024AA\u0040) != null;
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation()
  {
    if (!AppDomain.CurrentDomain.IsDefaultAppDomain() && \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EIsUsingOpenMP())
      throw new OpenMPWithMultipleAppdomainsException();
  }

  internal static void \u003FA0x2cb8ed13\u002E\u003F\u003F__E__mpnhHeap\u0040\u0040YMXXZ()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static void \u003FA0x2cb8ed13\u002E\u003F\u003F__E__nhmHeap\u0040\u0040YMXXZ()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static unsafe int \u003FA0x2cb8ed13\u002E_callnewh_thunk(uint size)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<int (uint)> local = (__FnPtr<int (uint)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__mpnhHeap);
    if (local == null)
      return 0;
    int num = (int) size;
    // ISSUE: function pointer call
    return __calli(local)((uint) num);
  }

  internal static unsafe void \u003FA0x2cb8ed13\u002E_callnewh_cleanup()
  {
    __FnPtr<int (uint)> local1 = \u003CModule\u003E._query_new_handler();
    // ISSUE: cast to a function pointer type
    __FnPtr<int (uint)> local2 = (__FnPtr<int (uint)>) (IntPtr) \u003CModule\u003E._encoded_null();
    int** a0x2cb8ed13FyahiZ = \u003CModule\u003E.__unep\u0040\u003F_callnewh_thunk\u0040\u003FA0x2cb8ed13\u0040\u0040\u0024\u0024FYAHI\u0040Z;
    if (local1 == (IntPtr) a0x2cb8ed13FyahiZ && \u003CModule\u003E.__mpnhHeap != local2)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._set_new_handler((__FnPtr<int (uint)>) 0);
    }
    \u003CModule\u003E.__mpnhHeap = local2;
  }

  internal static unsafe int \u003FA0x2cb8ed13\u002E_callnewhandler_thunk(uint size)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__nhmHeap);
    if (local == null)
      return 0;
    // ISSUE: function pointer call
    __calli(local)();
    return 1;
  }

  internal static unsafe void \u003FA0x2cb8ed13\u002E_callnewhandler_cleanup()
  {
    __FnPtr<int (uint)> local1 = \u003CModule\u003E._query_new_handler();
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local2 = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();
    int** a0x2cb8ed13FyahiZ = \u003CModule\u003E.__unep\u0040\u003F_callnewhandler_thunk\u0040\u003FA0x2cb8ed13\u0040\u0040\u0024\u0024FYAHI\u0040Z;
    if (local1 == (IntPtr) a0x2cb8ed13FyahiZ && \u003CModule\u003E.__nhmHeap != local2)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._set_new_handler((__FnPtr<int (uint)>) 0);
    }
    \u003CModule\u003E.__nhmHeap = local2;
  }

  internal static unsafe __FnPtr<int (uint)> _set_new_handler(__FnPtr<int (uint)> pnh)
  {
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x2cb8ed13\u002E_callnewh_cleanup)) != 0)
    {
      // ISSUE: cast to a function pointer type
      return (__FnPtr<int (uint)>) 0;
    }
    void* voidPtr = \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__mpnhHeap);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.__mpnhHeap = (__FnPtr<int (uint)>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pnh);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._set_new_handler((__FnPtr<int (uint)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_callnewh_thunk\u0040\u003FA0x2cb8ed13\u0040\u0040\u0024\u0024FYAHI\u0040Z);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<int (uint)>) (IntPtr) voidPtr;
  }

  internal static unsafe __FnPtr<void ()> std\u002Eset_new_handler(__FnPtr<void ()> _NewHandler)
  {
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x2cb8ed13\u002E_callnewhandler_cleanup)) != 0)
    {
      // ISSUE: cast to a function pointer type
      return (__FnPtr<void ()>) 0;
    }
    void* voidPtr = \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__nhmHeap);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.__nhmHeap = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) _NewHandler);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._set_new_handler((__FnPtr<int (uint)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_callnewhandler_thunk\u0040\u003FA0x2cb8ed13\u0040\u0040\u0024\u0024FYAHI\u0040Z);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void ()>) (IntPtr) voidPtr;
  }

  internal static unsafe __FnPtr<int (uint)> __query_new_handler_m() => (__FnPtr<int (uint)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__mpnhHeap);

  internal static unsafe __signal_init* __signal_init\u002E\u007Bctor\u007D(
    [In] __signal_init* obj0)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void (int)> local1 = (__FnPtr<void (int)>) (IntPtr) \u003CModule\u003E._encoded_null();
    __FnPtr<void (int)>* local2 = (__FnPtr<void (int)>*) &\u003CModule\u003E.\u003FA0x2cb8ed13\u002E__psignal_func;
    // ISSUE: cast to a reference type
    do
    {
      *(int*) local2 = (int) local1;
      local2 += 4;
    }
    while ((IntPtr) local2 < (\u0024ArrayType\u0024\u0024\u0024BY0BH\u0040R6MXH\u0040Z&) ((IntPtr) &\u003CModule\u003E.\u003FA0x2cb8ed13\u002E__psignal_func + 92));
    return obj0;
  }

  internal static void \u003FA0x2cb8ed13\u002E\u003F\u003F__E\u003FA0x2cb8ed13\u0040_init\u0040\u0040YMXXZ()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static unsafe void \u003FA0x2cb8ed13\u002E__signal_thunk(int i)
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a function pointer type
    __FnPtr<void (int)> local = (__FnPtr<void (int)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) ^(int&) (i * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x2cb8ed13\u002E__psignal_func));
    if (local == null)
      return;
    int num = i;
    // ISSUE: function pointer call
    __calli(local)(num);
  }

  internal static unsafe void \u003FA0x2cb8ed13\u002E_signal_cleanup()
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void (int)> local = (__FnPtr<void (int)>) (IntPtr) \u003CModule\u003E._encoded_null();
    int num = 0;
    do
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) (num * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x2cb8ed13\u002E__psignal_func) != local)
      {
        // ISSUE: cast to a function pointer type
        if (\u003CModule\u003E.signal(num, (__FnPtr<void (int)>) 2) == (IntPtr) \u003CModule\u003E.__unep\u0040\u003F__signal_thunk\u0040\u003FA0x2cb8ed13\u0040\u0040\u0024\u0024FYAXH\u0040Z)
        {
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.signal(num, (__FnPtr<void (int)>) 0);
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) (num * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x2cb8ed13\u002E__psignal_func) = (int) local;
      }
      ++num;
    }
    while (num < 23);
  }

  internal static unsafe __FnPtr<void (int)> signal(int signum, __FnPtr<void (int)> sigact)
  {
    if ((uint) signum <= 22U)
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x2cb8ed13\u002E_signal_cleanup)) != 0)
      {
        // ISSUE: cast to a function pointer type
        return (__FnPtr<void (int)>) 0;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a function pointer type
      __FnPtr<void (int)> local1 = (__FnPtr<void (int)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) ^(int&) (signum * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x2cb8ed13\u002E__psignal_func));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) (signum * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x2cb8ed13\u002E__psignal_func) = (int) \u003CModule\u003E._encode_pointer((void*) sigact);
      int a0x2cb8ed13FyaxhZ = (int) \u003CModule\u003E.__unep\u0040\u003F__signal_thunk\u0040\u003FA0x2cb8ed13\u0040\u0040\u0024\u0024FYAXH\u0040Z;
      // ISSUE: cast to a function pointer type
      __FnPtr<void (int)> local2 = \u003CModule\u003E.signal(signum, (__FnPtr<void (int)>) a0x2cb8ed13FyaxhZ);
      if (local2 == a0x2cb8ed13FyaxhZ)
        return local1;
      int num = 0;
      // ISSUE: cast to a function pointer type
      // ISSUE: cast to a function pointer type
      return local2 == 0 ? (__FnPtr<void (int)>) num : (__FnPtr<void (int)>) ~num;
    }
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.signal(signum, (__FnPtr<void (int)>) 0);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void (int)>) -1;
  }

  internal static unsafe __FnPtr<void (int)> signal(int signum, int sigact)
  {
    if (sigact == 0)
    {
      // ISSUE: cast to a function pointer type
      return \u003CModule\u003E.signal(signum, (__FnPtr<void (int)>) 0);
    }
    *\u003CModule\u003E._errno() = 22;
    \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void (int)>) 0;
  }

  internal static unsafe void \u003FA0x90ec3f08\u002E\u003F\u003F__E__pParameter_m\u0040\u0040YMXXZ() => \u003CModule\u003E.__pParameter_m = (__FnPtr<void (char*, char*, char*, uint, uint)>) (IntPtr) \u003CModule\u003E._encoded_null();

  internal static unsafe void __invalid_parameter_handler_thunk(
    char* pszExpression,
    char* pszFunction,
    char* pszFile,
    uint nLine,
    uint pReserved)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void (char*, char*, char*, uint, uint)> local = (__FnPtr<void (char*, char*, char*, uint, uint)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__pParameter_m);
    if (local == null)
      return;
    char* chPtr1 = pszExpression;
    char* chPtr2 = pszFunction;
    char* chPtr3 = pszFile;
    int num1 = (int) nLine;
    int num2 = (int) pReserved;
    // ISSUE: function pointer call
    __calli(local)((uint) chPtr1, (uint) chPtr2, chPtr3, (char*) num1, (char*) num2);
  }

  internal static unsafe void \u003FA0x90ec3f08\u002E__invalid_parameter_handler_cleanup()
  {
    if (\u003CModule\u003E._get_invalid_parameter_handler() == (IntPtr) \u003CModule\u003E.__unep\u0040\u003F__invalid_parameter_handler_thunk\u0040\u0040\u0024\u0024FYAXPB_W00II\u0040Z && \u003CModule\u003E.__pParameter_m != null)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._set_invalid_parameter_handler((__FnPtr<void (char*, char*, char*, uint, uint)>) 0);
    }
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.__pParameter_m = (__FnPtr<void (char*, char*, char*, uint, uint)>) 0;
  }

  internal static unsafe __FnPtr<void (char*, char*, char*, uint, uint)> _set_invalid_parameter_handler(
    __FnPtr<void (char*, char*, char*, uint, uint)> pNew)
  {
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x90ec3f08\u002E__invalid_parameter_handler_cleanup)) != 0)
    {
      // ISSUE: cast to a function pointer type
      return (__FnPtr<void (char*, char*, char*, uint, uint)>) 0;
    }
    void* voidPtr = \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__pParameter_m);
    // ISSUE: cast to a function pointer type
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._set_invalid_parameter_handler(pNew == null ? (__FnPtr<void (char*, char*, char*, uint, uint)>) (ValueType) 0 : (__FnPtr<void (char*, char*, char*, uint, uint)>) (ValueType) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F__invalid_parameter_handler_thunk\u0040\u0040\u0024\u0024FYAXPB_W00II\u0040Z);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.__pParameter_m = (__FnPtr<void (char*, char*, char*, uint, uint)>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pNew);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void (char*, char*, char*, uint, uint)>) (IntPtr) voidPtr;
  }

  internal static unsafe void \u003FA0x90ec3f08\u002E\u003F\u003F__E\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();

  internal static unsafe void \u003FA0x90ec3f08\u002E\u003F\u003F__E\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();

  internal static unsafe void \u003FA0x90ec3f08\u002E\u003F\u003F__E\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();

  internal static unsafe void __terminate_thunk()
  {
    if ((IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA) == IntPtr.Zero)
      return;
    // ISSUE: function pointer call
    __calli(\u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA)();
  }

  internal static unsafe void \u003FA0x90ec3f08\u002E__terminate_cleanup()
  {
    __FnPtr<void ()> terminate = \u003CModule\u003E._get_terminate();
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();
    int** terminateThunkFyaxxz = \u003CModule\u003E.__unep\u0040\u003F__terminate_thunk\u0040\u0040\u0024\u0024FYAXXZ;
    if (terminate == (IntPtr) terminateThunkFyaxxz && \u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA != local)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.set_terminate((__FnPtr<void ()>) 0);
    }
    \u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = local;
  }

  internal static unsafe __FnPtr<void ()> set_terminate(__FnPtr<void ()> pNew)
  {
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x90ec3f08\u002E__terminate_cleanup)) != 0)
    {
      // ISSUE: cast to a function pointer type
      return (__FnPtr<void ()>) 0;
    }
    \u003CModule\u003E._encoded_null();
    void* voidPtr = \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pNew);
    // ISSUE: cast to a function pointer type
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.set_terminate(pNew != null ? (__FnPtr<void ()>) (ValueType) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F__terminate_thunk\u0040\u0040\u0024\u0024FYAXXZ : (__FnPtr<void ()>) (ValueType) 0);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void ()>) (IntPtr) voidPtr;
  }

  internal static unsafe void \u003FA0x90ec3f08\u002E__purecall_thunk()
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA);
    if (local == null)
      return;
    // ISSUE: function pointer call
    __calli(local)();
  }

  internal static unsafe void \u003FA0x90ec3f08\u002E__purecall_cleanup()
  {
    __FnPtr<void ()> purecallHandler = \u003CModule\u003E._get_purecall_handler();
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();
    int** a0x90ec3f08Fyaxxz = \u003CModule\u003E.__unep\u0040\u003F__purecall_thunk\u0040\u003FA0x90ec3f08\u0040\u0040\u0024\u0024FYAXXZ;
    if (purecallHandler == (IntPtr) a0x90ec3f08Fyaxxz && \u003CModule\u003E.\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA != local)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._set_purecall_handler((__FnPtr<void ()>) 0);
    }
    \u003CModule\u003E.\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = local;
  }

  internal static unsafe __FnPtr<void ()> _set_purecall_handler(__FnPtr<void ()> pNew)
  {
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x90ec3f08\u002E__purecall_cleanup)) != 0)
    {
      // ISSUE: cast to a function pointer type
      return (__FnPtr<void ()>) 0;
    }
    \u003CModule\u003E._encoded_null();
    void* voidPtr = \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pNew);
    // ISSUE: cast to a function pointer type
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._set_purecall_handler(pNew != null ? (__FnPtr<void ()>) (ValueType) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F__purecall_thunk\u0040\u003FA0x90ec3f08\u0040\u0040\u0024\u0024FYAXXZ : (__FnPtr<void ()>) (ValueType) 0);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void ()>) (IntPtr) voidPtr;
  }

  internal static unsafe void __unexpected_thunk()
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA);
    if (local == null)
      return;
    // ISSUE: function pointer call
    __calli(local)();
  }

  internal static unsafe void \u003FA0x90ec3f08\u002E__unexpected_cleanup()
  {
    __FnPtr<void ()> unexpected = \u003CModule\u003E._get_unexpected();
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();
    int** unexpectedThunkFyaxxz = \u003CModule\u003E.__unep\u0040\u003F__unexpected_thunk\u0040\u0040\u0024\u0024FYAXXZ;
    if (unexpected == (IntPtr) unexpectedThunkFyaxxz && \u003CModule\u003E.\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA != null)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.set_unexpected((__FnPtr<void ()>) 0);
    }
    \u003CModule\u003E.\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = local;
  }

  internal static unsafe __FnPtr<void ()> set_unexpected(__FnPtr<void ()> pNew)
  {
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x90ec3f08\u002E__unexpected_cleanup)) != 0)
    {
      // ISSUE: cast to a function pointer type
      return (__FnPtr<void ()>) 0;
    }
    \u003CModule\u003E._encoded_null();
    void* voidPtr = \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pNew);
    // ISSUE: cast to a function pointer type
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.set_unexpected(pNew != null ? (__FnPtr<void ()>) (ValueType) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F__unexpected_thunk\u0040\u0040\u0024\u0024FYAXXZ : (__FnPtr<void ()>) (ValueType) 0);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void ()>) (IntPtr) voidPtr;
  }

  internal static unsafe __FnPtr<void (char*, char*, char*, uint, uint)> _set_invalid_parameter_handler(
    int pNew)
  {
    if (pNew == 0)
    {
      // ISSUE: cast to a function pointer type
      return \u003CModule\u003E._set_invalid_parameter_handler((__FnPtr<void (char*, char*, char*, uint, uint)>) 0);
    }
    *\u003CModule\u003E._errno() = 22;
    \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void (char*, char*, char*, uint, uint)>) 0;
  }

  internal static unsafe __FnPtr<void ()> _set_purecall_handler(int pNew)
  {
    if (pNew == 0)
    {
      // ISSUE: cast to a function pointer type
      return \u003CModule\u003E._set_purecall_handler((__FnPtr<void ()>) 0);
    }
    *\u003CModule\u003E._errno() = 22;
    \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void ()>) 0;
  }

  internal static unsafe void \u003FA0xdfaa356a\u002E\u003F\u003F__E\u003F__pFilter_m\u0040HandlersFP\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MHPAU_FPIEEE_RECORD\u0040\u0040\u0040ZA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F__pFilter_m\u0040HandlersFP\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MHPAU_FPIEEE_RECORD\u0040\u0040\u0040ZA = (__FnPtr<int (_FPIEEE_RECORD*)>) (IntPtr) \u003CModule\u003E._encoded_null();

  internal static unsafe int fpieee_flt_thunk_func(_FPIEEE_RECORD* pfpieee_record)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<int (_FPIEEE_RECORD*)> local = (__FnPtr<int (_FPIEEE_RECORD*)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pFilter_m\u0040HandlersFP\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MHPAU_FPIEEE_RECORD\u0040\u0040\u0040ZA);
    if (local == null)
      return 0;
    _FPIEEE_RECORD* fpieeeRecordPtr = pfpieee_record;
    // ISSUE: function pointer call
    return __calli(local)(fpieeeRecordPtr);
  }

  internal static unsafe int _fpieee_flt(
    uint exceptionCode,
    _EXCEPTION_POINTERS* pExceptionPointers,
    __FnPtr<int (_FPIEEE_RECORD*)> pFunc)
  {
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.\u003F__pFilter_m\u0040HandlersFP\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MHPAU_FPIEEE_RECORD\u0040\u0040\u0040ZA = (__FnPtr<int (_FPIEEE_RECORD*)>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pFunc);
    // ISSUE: cast to a function pointer type
    return \u003CModule\u003E._fpieee_flt(exceptionCode, pExceptionPointers, (__FnPtr<int (_FPIEEE_RECORD*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003Ffpieee_flt_thunk_func\u0040\u0040\u0024\u0024FYAHPAU_FPIEEE_RECORD\u0040\u0040\u0040Z);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode() => (\u003CModule\u003E.__native_dllmain_reason != uint.MaxValue ? 1 : 0) == 0 || (\u003CModule\u003E.__native_vcclrit_reason != uint.MaxValue ? 1 : 0) != 0 || \u003CModule\u003E.__native_dllmain_reason != 1U && \u003CModule\u003E.__native_dllmain_reason != 0U;

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EDoNothing(
    void* cookie)
  {
    GC.KeepAlive((object) int.MaxValue);
    return 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess()
  {
    if (\u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr = (void**) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_a;
    if (ref \u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_a < ref \u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_z)
    {
      while (*(int*) voidPtr == 0)
      {
        voidPtr += 4;
        if ((IntPtr) voidPtr >= ref \u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative()
  {
    if (\u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr1 = (void**) &\u003CModule\u003E.__xi_a;
    if (ref \u003CModule\u003E.__xi_a < ref \u003CModule\u003E.__xi_z)
    {
      while (*(int*) voidPtr1 == 0)
      {
        voidPtr1 += 4;
        if ((IntPtr) voidPtr1 >= ref \u003CModule\u003E.__xi_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    void** voidPtr2 = (void**) &\u003CModule\u003E.__xc_a;
    if (ref \u003CModule\u003E.__xc_a < ref \u003CModule\u003E.__xc_z)
    {
      while (*(int*) voidPtr2 == 0)
      {
        voidPtr2 += 4;
        if ((IntPtr) voidPtr2 >= ref \u003CModule\u003E.__xc_z)
          goto label_9;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_9:
    \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess() && !\u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA || \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative() && !\u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA && \u003CModule\u003E.__native_startup_state == (__enative_startup_state) 0;

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = false;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during vtable initialization.\n");
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xi_vt_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xi_vt_z);
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize();
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during native initialization.\n");
    \u003CModule\u003E.__security_init_cookie();
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode())
      \u003CModule\u003E._amsg_exit(33);
    switch (\u003CModule\u003E.__native_startup_state)
    {
      case (__enative_startup_state) 0:
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 1;
        if (\u003CModule\u003E._initterm_e((__FnPtr<int ()>*) &\u003CModule\u003E.__xi_a, (__FnPtr<int ()>*) &\u003CModule\u003E.__xi_z) != 0)
          \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0));
        \u003CModule\u003E._initterm((__FnPtr<void ()>*) &\u003CModule\u003E.__xc_a, (__FnPtr<void ()>*) &\u003CModule\u003E.__xc_z);
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 2;
        \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
        break;
      case (__enative_startup_state) 1:
        \u003CModule\u003E._amsg_exit(33);
        break;
    }
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during process initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_m();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_z);
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during appdomain initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_app_domain();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_ma_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_ma_z);
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during registration for the unload events.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(new EventHandler(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload));
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = AppDomain.CurrentDomain.IsDefaultAppDomain();
    if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation();
    void* fiberPtrId = \u003CModule\u003E._getFiberPtrId();
    int num1 = 0;
    int num2 = 0;
    int num3 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      while (num2 == 0)
      {
        try
        {
        }
        finally
        {
          IntPtr comparand = (IntPtr) 0;
          IntPtr num4 = (IntPtr) fiberPtrId;
          // ISSUE: cast to a reference type
          void* voidPtr = (void*) Interlocked.CompareExchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num4, comparand);
          if ((IntPtr) voidPtr == IntPtr.Zero)
            num2 = 1;
          else if (voidPtr == fiberPtrId)
          {
            num1 = 1;
            num2 = 1;
          }
        }
        if (num2 == 0)
          \u003CModule\u003E.Sleep(1000U);
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(obj0);
      if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      {
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(obj0);
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(obj0);
      }
      else if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization())
        num3 = 1;
    }
    finally
    {
      if (num1 == 0)
      {
        IntPtr num5 = (IntPtr) 0;
        // ISSUE: cast to a reference type
        Interlocked.Exchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num5);
      }
    }
    if (num3 != 0)
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(obj0);
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(obj0);
    \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 1;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(obj0);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain() => \u003CModule\u003E._app_exit_callback();

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain(
    void* cookie)
  {
    \u003CModule\u003E._exit_callback();
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    if (\u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
    {
      \u003CModule\u003E._cexit();
      \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 0;
      \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    }
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    return 0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain()
  {
    if (!\u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
      return;
    if (AppDomain.CurrentDomain.IsDefaultAppDomain())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain((void*) 0);
    }
    else
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);
    }
  }

  [PrePrepareMethod]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload(
    object source,
    EventArgs arguments)
  {
    if (\u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA == 0 || Interlocked.Exchange(ref \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA, 1) != 0)
      return;
    int num = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0 ? 1 : 0;
    \u003CModule\u003E._app_exit_callback();
    if ((byte) num == (byte) 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(
    [In] LanguageSupport* obj0,
    Exception innerException)
  {
    try
    {
      bool flag = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
      if (!flag)
        return;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, ex);
    }
    catch
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, (Exception) null);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(
    [In] LanguageSupport* obj0)
  {
    bool flag = false;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load.\n");
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        Interlocked.Increment(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA);
        flag = true;
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(obj0);
    }
    catch (Exception ex)
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, ex);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), ex);
    }
    catch
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, (Exception) null);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), (Exception) null);
    }
  }

  [DebuggerStepThrough]
  static unsafe \u003CModule\u003E()
  {
    LanguageSupport languageSupport;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(&languageSupport);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(&languageSupport);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D), (void*) &languageSupport);
    }
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) &languageSupport);
  }

  internal static unsafe LanguageSupport* \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
    return obj0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(int*) obj0 = (int) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
    *(int*) obj0 = 0;
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0,
    string t)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) t;
    return obj0;
  }

  internal static unsafe string gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    return (string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target;
  }

  internal static unsafe void std\u002Ebad_alloc\u002E\u007Bdtor\u007D([In] bad_alloc* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe void* std\u002Ebad_alloc\u002E__vecDelDtor([In] bad_alloc* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      bad_alloc* badAllocPtr = (bad_alloc*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 12U, *(int*) badAllocPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebad_alloc\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete((void*) badAllocPtr);
      return (void*) badAllocPtr;
    }
    \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Eexception\u002E__vecDelDtor([In] exception* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      exception* exceptionPtr = (exception*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 12U, *(int*) exceptionPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete((void*) exceptionPtr);
      return (void*) exceptionPtr;
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe exception* std\u002Eexception\u002E\u007Bctor\u007D(
    [In] exception* obj0,
    sbyte** _param1,
    int _param2)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = *(int*) _param1;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    return obj0;
  }

  [SpecialName]
  internal static unsafe exception* std\u002Eexception\u002E\u007Bctor\u007D(
    [In] exception* obj0,
    exception* _param1)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040 + 4);
    int num1 = *(int*) ((IntPtr) _param1 + 8);
    *(int*) ((IntPtr) obj0 + 8) = num1;
    if (num1 != 0)
    {
      uint num2 = (uint) *(int*) ((IntPtr) _param1 + 4);
      if (num2 != 0U)
      {
        uint num3 = \u003CModule\u003E.strlen((sbyte*) num2) + 1U;
        void* voidPtr = \u003CModule\u003E.malloc(num3);
        *(int*) ((IntPtr) obj0 + 4) = (int) voidPtr;
        if ((IntPtr) voidPtr != IntPtr.Zero)
          \u003CModule\u003E.strcpy_s((sbyte*) voidPtr, num3, (sbyte*) *(int*) ((IntPtr) _param1 + 4));
      }
      else
        *(int*) ((IntPtr) obj0 + 4) = 0;
    }
    else
      *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) _param1 + 4);
    return obj0;
  }

  internal static unsafe void std\u002Eexception\u002E\u007Bdtor\u007D([In] exception* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040 + 4);
    if (*(int*) ((IntPtr) obj0 + 8) == 0)
      return;
    \u003CModule\u003E.free((void*) *(int*) ((IntPtr) obj0 + 4));
  }

  internal static unsafe sbyte* std\u002Eexception\u002Ewhat([In] exception* obj0)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 4);
    return num != 0U ? (sbyte*) num : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BC\u0040EOODALEL\u0040Unknown\u003F5exception\u003F\u0024AA\u0040;
  }

  internal static unsafe void \u003FA0x2d544943\u002E\u003F\u003F__E\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4exception\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Eexception\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Eexception\u002Ewhat);
  }

  internal static unsafe void \u003FA0x2d544943\u002E\u003F\u003F__E\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4bad_alloc\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebad_alloc\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Eexception\u002Ewhat);
  }

  internal static unsafe ICLRRuntimeHost* msclr\u002E_detail\u002Eget_clr_runtime_host()
  {
    ICLRRuntimeHost* clrRuntimeHost = (ICLRRuntimeHost*) 0;
    int runtimeEx = \u003CModule\u003E.CorBindToRuntimeEx((char*) 0, (char*) 0, 0U, &\u003CModule\u003E.CLSID_CLRRuntimeHost, &\u003CModule\u003E.IID_ICLRRuntimeHost, (void**) &clrRuntimeHost);
    if (runtimeEx < 0)
    {
      if ((IntPtr) clrRuntimeHost != IntPtr.Zero)
      {
        ICLRRuntimeHost* iclrRuntimeHostPtr = clrRuntimeHost;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr + 8))((IntPtr) iclrRuntimeHostPtr);
      }
      Marshal.ThrowExceptionForHR(runtimeEx);
    }
    return clrRuntimeHost;
  }

  internal static unsafe int msclr\u002E_detail\u002Ecallback_cdecl_void_struct0\u002Ecallback(
    void* cookie)
  {
    if ((IntPtr) cookie == IntPtr.Zero)
      return -2147467259;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    __calli((__FnPtr<void ()>) *(int*) cookie)();
    return 0;
  }

  internal static unsafe void msclr\u002Ecall_in_appdomain(
    uint dwAppDomainId,
    __FnPtr<void ()> func)
  {
    ICLRRuntimeHost* clrRuntimeHost = \u003CModule\u003E.msclr\u002E_detail\u002Eget_clr_runtime_host();
    callback_cdecl_void_struct0 cdeclVoidStruct0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref cdeclVoidStruct0 = (int) func;
    ICLRRuntimeHost* iclrRuntimeHostPtr1 = clrRuntimeHost;
    int num1 = (int) dwAppDomainId;
    int** detailMsclrFsgjpaxZ = \u003CModule\u003E.__unep\u0040\u003Fcallback\u0040callback_cdecl_void_struct0\u0040_detail\u0040msclr\u0040\u0040\u0024\u0024FSGJPAX\u0040Z;
    ref callback_cdecl_void_struct0 local = ref cdeclVoidStruct0;
    // ISSUE: cast to a function pointer type
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int errorCode = __calli((__FnPtr<int (IntPtr, uint, __FnPtr<int (void*)>, void*)>) *(int*) (*(int*) clrRuntimeHost + 32))((void*) iclrRuntimeHostPtr1, (__FnPtr<int (void*)>) num1, (uint) detailMsclrFsgjpaxZ, (IntPtr) ref local);
    ICLRRuntimeHost* iclrRuntimeHostPtr2 = clrRuntimeHost;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num2 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr2 + 8))((IntPtr) iclrRuntimeHostPtr2);
    if (errorCode >= 0)
      return;
    Marshal.ThrowExceptionForHR(errorCode);
  }

  internal static unsafe int \u003FA0x88c9395d\u002E_getdomain(uint* pDomain)
  {
    *pDomain = 0U;
    ICLRRuntimeHost* iclrRuntimeHostPtr1 = (ICLRRuntimeHost*) 0;
    if (\u003CModule\u003E.CorBindToRuntimeEx((char*) 0, (char*) 0, 0U, &\u003CModule\u003E.CLSID_CLRRuntimeHost, &\u003CModule\u003E.IID_ICLRRuntimeHost, (void**) &iclrRuntimeHostPtr1) < 0)
    {
      if ((IntPtr) iclrRuntimeHostPtr1 != IntPtr.Zero)
      {
        ICLRRuntimeHost* iclrRuntimeHostPtr2 = iclrRuntimeHostPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr2 + 8))((IntPtr) iclrRuntimeHostPtr2);
      }
      return 0;
    }
    uint num1 = 0;
    ICLRRuntimeHost* iclrRuntimeHostPtr3 = iclrRuntimeHostPtr1;
    ref uint local = ref num1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num2 = __calli((__FnPtr<int (IntPtr, uint*)>) *(int*) (*(int*) iclrRuntimeHostPtr1 + 36))((uint*) iclrRuntimeHostPtr3, (IntPtr) ref local);
    ICLRRuntimeHost* iclrRuntimeHostPtr4 = iclrRuntimeHostPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr4 + 8))((IntPtr) iclrRuntimeHostPtr4);
    if (num2 < 0)
      return 0;
    *pDomain = num1;
    return 1;
  }

  internal static unsafe uint _beginthread(
    __FnPtr<void (void*)> initialcode,
    uint stacksize,
    void* argument)
  {
    uint num = 0;
    if (initialcode == null)
    {
      *\u003CModule\u003E._errno() = 22;
      \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
      return uint.MaxValue;
    }
    \u003CModule\u003E.__set_flsgetvalue();
    _tiddata* tiddataPtr = (_tiddata*) \u003CModule\u003E.calloc(1U, 532U);
    if ((IntPtr) tiddataPtr != IntPtr.Zero)
    {
      \u003CModule\u003E._initptd(tiddataPtr, (threadlocaleinfostruct*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 108));
      *(int*) ((IntPtr) tiddataPtr + 84) = (int) initialcode;
      *(int*) ((IntPtr) tiddataPtr + 88) = (int) argument;
      if (\u003CModule\u003E.\u003FA0x88c9395d\u002E_getdomain((uint*) ((IntPtr) tiddataPtr + 528)) != 0)
      {
        // ISSUE: cast to a function pointer type
        uint thread = (uint) \u003CModule\u003E.CreateThread((_SECURITY_ATTRIBUTES*) 0, stacksize, (__FnPtr<uint (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_threadstart\u0040\u003FA0x88c9395d\u0040\u0040\u0024\u0024FYGKPAX\u0040Z, (void*) tiddataPtr, 4U, (uint*) tiddataPtr);
        *(int*) ((IntPtr) tiddataPtr + 4) = (int) thread;
        if (thread == 0U)
        {
          num = \u003CModule\u003E.GetLastError();
        }
        else
        {
          if (\u003CModule\u003E.ResumeThread((void*) thread) != uint.MaxValue)
            return thread;
          num = \u003CModule\u003E.GetLastError();
        }
      }
    }
    \u003CModule\u003E.free((void*) tiddataPtr);
    if (num != 0U)
      \u003CModule\u003E._dosmaperr(num);
    return uint.MaxValue;
  }

  internal static unsafe uint \u003FA0x88c9395d\u002E_threadstart(void* ptd)
  {
    \u003CModule\u003E.__set_flsgetvalue();
    _tiddata* tiddataPtr = (_tiddata*) \u003CModule\u003E.__fls_getvalue(\u003CModule\u003E.__get_flsindex());
    if ((IntPtr) tiddataPtr == IntPtr.Zero)
    {
      if (\u003CModule\u003E.__fls_setvalue(\u003CModule\u003E.__get_flsindex(), ptd) == 0)
        \u003CModule\u003E.ExitThread(\u003CModule\u003E.GetLastError());
      else
        goto label_4;
    }
    *(int*) ((IntPtr) tiddataPtr + 84) = *(int*) ((IntPtr) ptd + 84);
    *(int*) ((IntPtr) tiddataPtr + 88) = *(int*) ((IntPtr) ptd + 88);
    *(int*) ((IntPtr) tiddataPtr + 4) = *(int*) ((IntPtr) ptd + 4);
    *(int*) ((IntPtr) tiddataPtr + 528) = *(int*) ((IntPtr) ptd + 528);
    \u003CModule\u003E._freefls(ptd);
label_4:
    uint num = 0;
    if (\u003CModule\u003E.\u003FA0x88c9395d\u002E_getdomain(&num) == 0)
      \u003CModule\u003E.ExitThread(0U);
    uint dwAppDomainId = (uint) *(int*) ((IntPtr) tiddataPtr + 528);
    if ((int) num != (int) dwAppDomainId)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.msclr\u002Ecall_in_appdomain(dwAppDomainId, (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_callthreadstart\u0040\u003FA0x88c9395d\u0040\u0040\u0024\u0024FYAXXZ);
      return 0;
    }
    \u003CModule\u003E.\u003FA0x88c9395d\u002E_callthreadstart();
    return 0;
  }

  internal static unsafe void \u003FA0x88c9395d\u002E_callthreadstart()
  {
    _tiddata* tiddataPtr = \u003CModule\u003E._getptd();
    try
    {
      int num = *(int*) ((IntPtr) tiddataPtr + 88);
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      __calli((__FnPtr<void (void*)>) *(int*) ((IntPtr) tiddataPtr + 84))((void*) num);
      \u003CModule\u003E._endthread();
    }
    catch (Exception ex) when (\u003CModule\u003E._XcptFilter((uint) Marshal.GetExceptionCode(), (_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
      \u003CModule\u003E._exit(Marshal.GetExceptionCode());
    }
  }

  internal static unsafe int \u003FA0x8428c990\u002E_getdomain(uint* pDomain)
  {
    *pDomain = 0U;
    ICLRRuntimeHost* iclrRuntimeHostPtr1 = (ICLRRuntimeHost*) 0;
    if (\u003CModule\u003E.CorBindToRuntimeEx((char*) 0, (char*) 0, 0U, &\u003CModule\u003E.CLSID_CLRRuntimeHost, &\u003CModule\u003E.IID_ICLRRuntimeHost, (void**) &iclrRuntimeHostPtr1) < 0)
    {
      if ((IntPtr) iclrRuntimeHostPtr1 != IntPtr.Zero)
      {
        ICLRRuntimeHost* iclrRuntimeHostPtr2 = iclrRuntimeHostPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr2 + 8))((IntPtr) iclrRuntimeHostPtr2);
      }
      return 0;
    }
    uint num1 = 0;
    ICLRRuntimeHost* iclrRuntimeHostPtr3 = iclrRuntimeHostPtr1;
    ref uint local = ref num1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num2 = __calli((__FnPtr<int (IntPtr, uint*)>) *(int*) (*(int*) iclrRuntimeHostPtr1 + 36))((uint*) iclrRuntimeHostPtr3, (IntPtr) ref local);
    ICLRRuntimeHost* iclrRuntimeHostPtr4 = iclrRuntimeHostPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr4 + 8))((IntPtr) iclrRuntimeHostPtr4);
    if (num2 < 0)
      return 0;
    *pDomain = num1;
    return 1;
  }

  internal static unsafe uint _beginthreadex(
    void* security,
    uint stacksize,
    __FnPtr<uint (void*)> initialcode,
    void* argument,
    uint createflag,
    uint* thrdaddr)
  {
    uint num1 = 0;
    if (initialcode == null)
    {
      *\u003CModule\u003E._errno() = 22;
      \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
      return 0;
    }
    \u003CModule\u003E.__set_flsgetvalue();
    _tiddata* tiddataPtr = (_tiddata*) \u003CModule\u003E.calloc(1U, 532U);
    if ((IntPtr) tiddataPtr != IntPtr.Zero)
    {
      \u003CModule\u003E._initptd(tiddataPtr, (threadlocaleinfostruct*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 108));
      *(int*) ((IntPtr) tiddataPtr + 84) = (int) initialcode;
      *(int*) ((IntPtr) tiddataPtr + 88) = (int) argument;
      *(int*) ((IntPtr) tiddataPtr + 4) = -1;
      if (\u003CModule\u003E.\u003FA0x8428c990\u002E_getdomain((uint*) ((IntPtr) tiddataPtr + 528)) != 0)
      {
        if ((IntPtr) thrdaddr == IntPtr.Zero)
        {
          uint num2;
          thrdaddr = &num2;
        }
        // ISSUE: cast to a function pointer type
        uint thread = (uint) \u003CModule\u003E.CreateThread((_SECURITY_ATTRIBUTES*) security, stacksize, (__FnPtr<uint (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_threadstartex\u0040\u003FA0x8428c990\u0040\u0040\u0024\u0024FYGKPAX\u0040Z, (void*) tiddataPtr, createflag, thrdaddr);
        if (thread != 0U)
          return thread;
        num1 = \u003CModule\u003E.GetLastError();
      }
    }
    \u003CModule\u003E.free((void*) tiddataPtr);
    if (num1 != 0U)
      \u003CModule\u003E._dosmaperr(num1);
    return 0;
  }

  internal static unsafe uint \u003FA0x8428c990\u002E_threadstartex(void* ptd)
  {
    \u003CModule\u003E.__set_flsgetvalue();
    _tiddata* tiddataPtr = (_tiddata*) \u003CModule\u003E.__fls_getvalue(\u003CModule\u003E.__get_flsindex());
    if ((IntPtr) tiddataPtr == IntPtr.Zero)
    {
      if (\u003CModule\u003E.__fls_setvalue(\u003CModule\u003E.__get_flsindex(), ptd) == 0)
        \u003CModule\u003E.ExitThread(\u003CModule\u003E.GetLastError());
      *(int*) ptd = (int) \u003CModule\u003E.GetCurrentThreadId();
    }
    else
    {
      *(int*) ((IntPtr) tiddataPtr + 84) = *(int*) ((IntPtr) ptd + 84);
      *(int*) ((IntPtr) tiddataPtr + 88) = *(int*) ((IntPtr) ptd + 88);
      *(int*) ((IntPtr) tiddataPtr + 4) = *(int*) ((IntPtr) ptd + 4);
      *(int*) ((IntPtr) tiddataPtr + 528) = *(int*) ((IntPtr) ptd + 528);
      \u003CModule\u003E._freefls(ptd);
    }
    uint num = 0;
    if (\u003CModule\u003E.\u003FA0x8428c990\u002E_getdomain(&num) == 0)
      \u003CModule\u003E.ExitThread(0U);
    uint dwAppDomainId = (uint) *(int*) ((IntPtr) tiddataPtr + 528);
    if ((int) num != (int) dwAppDomainId)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.msclr\u002Ecall_in_appdomain(dwAppDomainId, (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_callthreadstartex\u0040\u003FA0x8428c990\u0040\u0040\u0024\u0024FYAXXZ);
      return 0;
    }
    \u003CModule\u003E.\u003FA0x8428c990\u002E_callthreadstartex();
    return 0;
  }

  internal static unsafe void \u003FA0x8428c990\u002E_callthreadstartex()
  {
    _tiddata* tiddataPtr = \u003CModule\u003E._getptd();
    try
    {
      int num = *(int*) ((IntPtr) tiddataPtr + 88);
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      \u003CModule\u003E._endthreadex(__calli((__FnPtr<uint (void*)>) *(int*) ((IntPtr) tiddataPtr + 84))((void*) num));
    }
    catch (Exception ex) when (\u003CModule\u003E._XcptFilter((uint) Marshal.GetExceptionCode(), (_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
      \u003CModule\u003E._exit(Marshal.GetExceptionCode());
    }
  }

  internal static unsafe void std\u002E_Mutex\u002E\u007Bdtor\u007D([In] _Mutex* obj0) => \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_dtor(obj0);

  internal static unsafe void std\u002Elocale\u002Efacet\u002E_Incref([In] locale.facet* obj0)
  {
    bool flag = false;
    int num1 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num1);
        flag = true;
      }
      uint num2 = (uint) *(int*) ((IntPtr) obj0 + 4);
      if (num2 >= uint.MaxValue)
        return;
      *(int*) ((IntPtr) obj0 + 4) = (int) num2 + 1;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num1);
    }
  }

  internal static unsafe locale.facet* std\u002Elocale\u002Efacet\u002E_Decref(
    [In] locale.facet* obj0)
  {
    bool flag = false;
    int num1 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num1);
        flag = true;
      }
      uint num2 = (uint) *(int*) ((IntPtr) obj0 + 4);
      if (0U < num2 && num2 < uint.MaxValue)
        *(int*) ((IntPtr) obj0 + 4) = (int) num2 - 1;
      return *(int*) ((IntPtr) obj0 + 4) == 0 ? (locale.facet*) (ValueType) (IntPtr) obj0 : (locale.facet*) (ValueType) 0;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num1);
    }
  }

  internal static unsafe void std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D([In] locale.facet* obj0) => *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);

  internal static unsafe void std\u002Elocale\u002E_Locimp\u002E\u007Bdtor\u007D(
    [In] locale._Locimp* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Locimp_dtor(obj0);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 24));
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 24), true, 0U);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe void std\u002Elocale\u002E\u007Bdtor\u007D([In] locale* obj0)
  {
    uint num = (uint) *(int*) obj0;
    if (num == 0U)
      return;
    locale.facet* facetPtr1 = \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Decref((locale.facet*) num);
    if ((IntPtr) facetPtr1 == IntPtr.Zero)
      return;
    locale.facet* facetPtr2 = facetPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(int*) *(int*) facetPtr1)((uint) facetPtr2, new IntPtr(1));
  }

  internal static unsafe void* std\u002Elocale\u002Efacet\u002E__vecDelDtor(
    [In] locale.facet* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      locale.facet* facetPtr = (locale.facet*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) facetPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) facetPtr);
      return (void*) facetPtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Elocale\u002E_Locimp\u002E__vecDelDtor(
    [In] locale._Locimp* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      locale._Locimp* locimpPtr = (locale._Locimp*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) locimpPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E_Locimp\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) locimpPtr);
      return (void*) locimpPtr;
    }
    \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ecodecvt_base\u002E\u007Bdtor\u007D([In] codecvt_base* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ecodecvt_base\u002Edo_always_noconv([In] codecvt_base* obj0) => true;

  internal static unsafe int std\u002Ecodecvt_base\u002Edo_max_length([In] codecvt_base* obj0) => 1;

  internal static unsafe int std\u002Ecodecvt_base\u002Edo_encoding([In] codecvt_base* obj0) => 1;

  internal static unsafe void* std\u002Ecodecvt_base\u002E__vecDelDtor(
    [In] codecvt_base* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      codecvt_base* codecvtBasePtr = (codecvt_base*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) codecvtBasePtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt_base\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) codecvtBasePtr);
      return (void*) codecvtBasePtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_in(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    sbyte** _Mid1,
    char* _First2,
    char* _Last2,
    char** _Mid2)
  {
    *(int*) _Mid1 = (int) _First1;
    *(int*) _Mid2 = (int) _First2;
    uint num1 = (uint) *(int*) _Mid1;
    int num2 = (IntPtr) (int) num1 == (IntPtr) _Last1 ? 0 : 1;
    if ((IntPtr) (int) num1 != (IntPtr) _Last1)
    {
      do
      {
        uint pwc = (uint) *(int*) _Mid2;
        if ((IntPtr) (int) pwc != (IntPtr) _Last2)
        {
          uint s = (uint) *(int*) _Mid1;
          int num3 = \u003CModule\u003E._Mbrtowc((char*) pwc, (sbyte*) s, (uint) (_Last1 - (int) s), _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
          if (num3 != -2)
          {
            if (num3 != -1)
            {
              if (num3 == 0)
              {
                if (*(ushort*) *(int*) _Mid2 == (ushort) 0)
                  num3 = (int) \u003CModule\u003E.strlen((sbyte*) *(int*) _Mid1) + 1;
                else
                  goto label_9;
              }
              if (num3 == -3)
                num3 = 0;
label_9:
              sbyte** numPtr = _Mid1;
              int num4 = *(int*) numPtr + num3;
              *(int*) numPtr = num4;
              char** chPtr = _Mid2;
              int num5 = *(int*) chPtr + 2;
              *(int*) chPtr = num5;
              num2 = 0;
            }
            else
              goto label_10;
          }
          else
            goto label_11;
        }
        else
          break;
      }
      while ((IntPtr) *(int*) _Mid1 != (IntPtr) _Last1);
      goto label_12;
label_10:
      return 2;
label_11:
      *(int*) _Mid1 = (int) _Last1;
      return num2;
    }
label_12:
    return num2;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_out(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    char* _First1,
    char* _Last1,
    char** _Mid1,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    *(int*) _Mid1 = (int) _First1;
    *(int*) _Mid2 = (int) _First2;
    uint num1 = (uint) *(int*) _Mid1;
    int num2 = (IntPtr) (int) num1 == (IntPtr) _Last1 ? 0 : 1;
    if ((IntPtr) (int) num1 != (IntPtr) _Last1)
    {
      while ((IntPtr) *(int*) _Mid2 != (IntPtr) _Last2)
      {
        uint s = (uint) *(int*) _Mid2;
        if ((IntPtr) \u003CModule\u003E.___mb_cur_max_func() <= (IntPtr) (_Last2 - (int) s))
        {
          int num3 = \u003CModule\u003E._Wcrtomb((sbyte*) s, (char) *(ushort*) *(int*) _Mid1, _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
          if (num3 < 0)
            return 2;
          char** chPtr = _Mid1;
          int num4 = *(int*) chPtr + 2;
          *(int*) chPtr = num4;
          sbyte** numPtr = _Mid2;
          int num5 = *(int*) numPtr + num3;
          *(int*) numPtr = num5;
          num2 = 0;
        }
        else
        {
          int num6 = *_State;
          \u0024ArrayType\u0024\u0024\u0024BY04D arrayTypeBy04D;
          int num7 = \u003CModule\u003E._Wcrtomb((sbyte*) &arrayTypeBy04D, (char) *(ushort*) *(int*) _Mid1, _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
          if (num7 < 0)
            return 2;
          uint num8 = (uint) *(int*) _Mid2;
          sbyte* numPtr1 = _Last2 - (int) num8;
          if ((IntPtr) numPtr1 >= (IntPtr) num7)
          {
            \u003CModule\u003E.memcpy_s((void*) num8, (uint) numPtr1, (void*) &arrayTypeBy04D, (uint) num7);
            char** chPtr = _Mid1;
            int num9 = *(int*) chPtr + 2;
            *(int*) chPtr = num9;
            sbyte** numPtr2 = _Mid2;
            int num10 = *(int*) numPtr2 + num7;
            *(int*) numPtr2 = num10;
            num2 = 0;
          }
          else
          {
            *_State = num6;
            return num2;
          }
        }
        if ((IntPtr) *(int*) _Mid1 == (IntPtr) _Last1)
          break;
      }
    }
    return num2;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_unshift(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    *(int*) _Mid2 = (int) _First2;
    int num1 = 0;
    int num2 = *_State;
    \u0024ArrayType\u0024\u0024\u0024BY04D arrayTypeBy04D;
    int num3 = \u003CModule\u003E._Wcrtomb((sbyte*) &arrayTypeBy04D, char.MinValue, _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
    if (num3 <= 0)
    {
      num1 = 2;
    }
    else
    {
      int num4 = num3 - 1;
      int num5 = *(int*) _Mid2;
      sbyte* numPtr1 = _Last2 - num5;
      if ((IntPtr) numPtr1 < (IntPtr) num4)
      {
        *_State = num2;
        num1 = 1;
      }
      else if (0 < num4)
      {
        \u003CModule\u003E.memcpy_s((void*) num5, (uint) numPtr1, (void*) &arrayTypeBy04D, (uint) num4);
        sbyte** numPtr2 = _Mid2;
        int num6 = *(int*) numPtr2 + num4;
        *(int*) numPtr2 = num6;
      }
    }
    return num1;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_length(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    uint _Count)
  {
    int num1 = *_State;
    int num2 = 0;
    sbyte* s = _First1;
    if (0U < _Count)
    {
      while (s != _Last1)
      {
        char ch;
        int num3 = \u003CModule\u003E._Mbrtowc(&ch, s, (uint) ((IntPtr) _Last1 - (IntPtr) s), &num1, (_Cvtvec*) ((IntPtr) obj0 + 8));
        if (num3 == -2 || num3 == -1)
          return num2;
        if (num3 == 0)
        {
          if (ch == char.MinValue)
            num3 = (int) \u003CModule\u003E.strlen(s) + 1;
          else
            goto label_8;
        }
        if (num3 == -3)
          num3 = 0;
label_8:
        s = (sbyte*) (num3 + (IntPtr) s);
        ++num2;
        if ((uint) num2 >= _Count)
          break;
      }
    }
    return num2;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_always_noconv(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0)
  {
    return false;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_max_length(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0)
  {
    return 5;
  }

  internal static unsafe void* std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E__vecDelDtor(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr = (codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) codecvtWcharTCharIntPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) codecvtWcharTCharIntPtr);
      return (void*) codecvtWcharTCharIntPtr;
    }
    \u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_in(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    sbyte** _Mid1,
    ushort* _First2,
    ushort* _Last2,
    ushort** _Mid2)
  {
    *(int*) _Mid1 = (int) _First1;
    *(int*) _Mid2 = (int) _First2;
    uint num1 = (uint) *(int*) _Mid1;
    int num2 = (IntPtr) (int) num1 == (IntPtr) _Last1 ? 0 : 1;
    if ((IntPtr) (int) num1 != (IntPtr) _Last1)
    {
      do
      {
        uint pwc = (uint) *(int*) _Mid2;
        if ((IntPtr) (int) pwc != (IntPtr) _Last2)
        {
          uint s = (uint) *(int*) _Mid1;
          int num3 = \u003CModule\u003E._Mbrtowc((char*) pwc, (sbyte*) s, (uint) (_Last1 - (int) s), _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
          if (num3 != -2)
          {
            if (num3 != -1)
            {
              if (num3 == 0)
              {
                if (*(ushort*) *(int*) _Mid2 == (ushort) 0)
                  num3 = (int) \u003CModule\u003E.strlen((sbyte*) *(int*) _Mid1) + 1;
                else
                  goto label_9;
              }
              if (num3 == -3)
                num3 = 0;
label_9:
              sbyte** numPtr1 = _Mid1;
              int num4 = *(int*) numPtr1 + num3;
              *(int*) numPtr1 = num4;
              ushort** numPtr2 = _Mid2;
              int num5 = *(int*) numPtr2 + 2;
              *(int*) numPtr2 = num5;
              num2 = 0;
            }
            else
              goto label_10;
          }
          else
            goto label_11;
        }
        else
          break;
      }
      while ((IntPtr) *(int*) _Mid1 != (IntPtr) _Last1);
      goto label_12;
label_10:
      return 2;
label_11:
      *(int*) _Mid1 = (int) _Last1;
      return num2;
    }
label_12:
    return num2;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_out(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    ushort* _First1,
    ushort* _Last1,
    ushort** _Mid1,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    *(int*) _Mid1 = (int) _First1;
    *(int*) _Mid2 = (int) _First2;
    uint num1 = (uint) *(int*) _Mid1;
    int num2 = (IntPtr) (int) num1 == (IntPtr) _Last1 ? 0 : 1;
    if ((IntPtr) (int) num1 != (IntPtr) _Last1)
    {
      int num3;
      do
      {
        uint s = (uint) *(int*) _Mid2;
        if ((IntPtr) (int) s != (IntPtr) _Last2)
        {
          if (new IntPtr(5) <= (IntPtr) (_Last2 - (int) s))
          {
            int num4 = \u003CModule\u003E._Wcrtomb((sbyte*) s, (char) *(ushort*) *(int*) _Mid1, _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
            if (num4 >= 0)
            {
              ushort** numPtr1 = _Mid1;
              int num5 = *(int*) numPtr1 + 2;
              *(int*) numPtr1 = num5;
              sbyte** numPtr2 = _Mid2;
              int num6 = *(int*) numPtr2 + num4;
              *(int*) numPtr2 = num6;
              num2 = 0;
            }
            else
              goto label_9;
          }
          else
          {
            num3 = *_State;
            \u0024ArrayType\u0024\u0024\u0024BY04D arrayTypeBy04D;
            int num7 = \u003CModule\u003E._Wcrtomb((sbyte*) &arrayTypeBy04D, (char) *(ushort*) *(int*) _Mid1, _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
            if (num7 >= 0)
            {
              uint num8 = (uint) *(int*) _Mid2;
              sbyte* numPtr3 = _Last2 - (int) num8;
              if ((IntPtr) numPtr3 >= (IntPtr) num7)
              {
                \u003CModule\u003E.memcpy_s((void*) num8, (uint) numPtr3, (void*) &arrayTypeBy04D, (uint) num7);
                ushort** numPtr4 = _Mid1;
                int num9 = *(int*) numPtr4 + 2;
                *(int*) numPtr4 = num9;
                sbyte** numPtr5 = _Mid2;
                int num10 = *(int*) numPtr5 + num7;
                *(int*) numPtr5 = num10;
                num2 = 0;
              }
              else
                goto label_11;
            }
            else
              goto label_10;
          }
        }
        else
          break;
      }
      while ((IntPtr) *(int*) _Mid1 != (IntPtr) _Last1);
      goto label_12;
label_9:
      return 2;
label_10:
      return 2;
label_11:
      *_State = num3;
      return num2;
    }
label_12:
    return num2;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_unshift(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    *(int*) _Mid2 = (int) _First2;
    int num1 = 0;
    int num2 = *_State;
    \u0024ArrayType\u0024\u0024\u0024BY04D arrayTypeBy04D;
    int num3 = \u003CModule\u003E._Wcrtomb((sbyte*) &arrayTypeBy04D, char.MinValue, _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
    if (num3 <= 0)
    {
      num1 = 2;
    }
    else
    {
      int num4 = num3 - 1;
      int num5 = *(int*) _Mid2;
      sbyte* numPtr1 = _Last2 - num5;
      if ((IntPtr) numPtr1 < (IntPtr) num4)
      {
        *_State = num2;
        num1 = 1;
      }
      else if (0 < num4)
      {
        \u003CModule\u003E.memcpy_s((void*) num5, (uint) numPtr1, (void*) &arrayTypeBy04D, (uint) num4);
        sbyte** numPtr2 = _Mid2;
        int num6 = *(int*) numPtr2 + num4;
        *(int*) numPtr2 = num6;
      }
    }
    return num1;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_length(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    uint _Count)
  {
    int num1 = *_State;
    int num2 = 0;
    sbyte* s = _First1;
    if (0U < _Count)
    {
      while (s != _Last1)
      {
        ushort num3;
        int num4 = \u003CModule\u003E._Mbrtowc((char*) &num3, s, (uint) ((IntPtr) _Last1 - (IntPtr) s), &num1, (_Cvtvec*) ((IntPtr) obj0 + 8));
        if (num4 == -2 || num4 == -1)
          return num2;
        if (num4 == 0)
        {
          if (num3 == (ushort) 0)
            num4 = (int) \u003CModule\u003E.strlen(s) + 1;
          else
            goto label_8;
        }
        if (num4 == -3)
          num4 = 0;
label_8:
        s = (sbyte*) (num4 + (IntPtr) s);
        ++num2;
        if ((uint) num2 >= _Count)
          break;
      }
    }
    return num2;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_always_noconv(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0)
  {
    return false;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_max_length(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0)
  {
    return 5;
  }

  internal static unsafe void* std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E__vecDelDtor(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr = (codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) unsignedShortCharIntPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) unsignedShortCharIntPtr);
      return (void*) unsignedShortCharIntPtr;
    }
    \u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ectype_base\u002E\u007Bdtor\u007D([In] ctype_base* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe void* std\u002Ectype_base\u002E__vecDelDtor([In] ctype_base* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      ctype_base* ctypeBasePtr = (ctype_base*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) ctypeBasePtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) ctypeBasePtr);
      return (void*) ctypeBasePtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ectype\u003Cchar\u003E\u002E\u007Bdtor\u007D(
    [In] ctype\u003Cchar\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ectype\u003Cchar\u003E\u002E_Tidy(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe void std\u002Ectype\u003Cchar\u003E\u002E_Tidy([In] ctype\u003Cchar\u003E* obj0)
  {
    int num = *(int*) ((IntPtr) obj0 + 20);
    if (0 < num)
    {
      \u003CModule\u003E.free((void*) *(int*) ((IntPtr) obj0 + 16));
    }
    else
    {
      if (num >= 0)
        return;
      \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 16));
    }
  }

  internal static unsafe sbyte std\u002Ectype\u003Cchar\u003E\u002Edo_tolower(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte _Ch)
  {
    return (sbyte) \u003CModule\u003E._Tolower((int) (byte) _Ch, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cchar\u003E\u002Edo_tolower(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte* _First,
    sbyte* _Last)
  {
    if (_First != _Last)
    {
      ctype\u003Cchar\u003E* ploc = (ctype\u003Cchar\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        sbyte* numPtr = _First;
        int num = \u003CModule\u003E._Tolower((int) (byte) *numPtr, (_Ctypevec*) ploc);
        *numPtr = (sbyte) num;
        ++_First;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cchar\u003E\u002Edo_toupper(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte _Ch)
  {
    return (sbyte) \u003CModule\u003E._Toupper((int) (byte) _Ch, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cchar\u003E\u002Edo_toupper(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte* _First,
    sbyte* _Last)
  {
    if (_First != _Last)
    {
      ctype\u003Cchar\u003E* ploc = (ctype\u003Cchar\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        sbyte* numPtr = _First;
        int num = \u003CModule\u003E._Toupper((int) (byte) *numPtr, (_Ctypevec*) ploc);
        *numPtr = (sbyte) num;
        ++_First;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cchar\u003E\u002Edo_widen(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte _Byte)
  {
    return _Byte;
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cchar\u003E\u002Edo_widen(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    sbyte* _Dest)
  {
    ctype\u003Cchar\u003E* ctypeCharPtr = obj0;
    sbyte* numPtr1 = _First;
    sbyte* numPtr2 = _Last;
    sbyte* numPtr3 = _Dest;
    IntPtr num = (IntPtr) _Last - (IntPtr) _First;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte* (IntPtr, sbyte*, sbyte*, sbyte*, uint)>) *(int*) (*(int*) obj0 + 28))((uint) ctypeCharPtr, numPtr1, numPtr2, numPtr3, num);
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cchar\u003E\u002E_Do_widen_s(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    sbyte* _Dest,
    uint _Dest_size)
  {
    sbyte* numPtr = (sbyte*) ((IntPtr) _Last - (IntPtr) _First);
    if ((UIntPtr) (int) _Dest_size < (UIntPtr) numPtr)
      \u003CModule\u003E._invalid_parameter_noinfo();
    \u003CModule\u003E.memcpy_s((void*) _Dest, _Dest_size, (void*) _First, (uint) numPtr);
    return _Last;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cchar\u003E\u002Edo_narrow(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte _Ch,
    sbyte __unnamed001)
  {
    return _Ch;
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cchar\u003E\u002Edo_narrow(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    sbyte _Dflt,
    sbyte* _Dest)
  {
    ctype\u003Cchar\u003E* ctypeCharPtr = obj0;
    sbyte* numPtr1 = _First;
    sbyte* numPtr2 = _Last;
    int num1 = (int) _Dflt;
    sbyte* numPtr3 = _Dest;
    IntPtr num2 = (IntPtr) _Last - (IntPtr) _First;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte* (IntPtr, sbyte*, sbyte*, sbyte, sbyte*, uint)>) *(int*) (*(int*) obj0 + 40))((uint) ctypeCharPtr, numPtr1, (sbyte) numPtr2, (sbyte*) num1, numPtr3, num2);
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cchar\u003E\u002E_Do_narrow_s(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    sbyte __unnamed002,
    sbyte* _Dest,
    uint _Dest_size)
  {
    sbyte* numPtr = (sbyte*) ((IntPtr) _Last - (IntPtr) _First);
    if ((UIntPtr) (int) _Dest_size < (UIntPtr) numPtr)
      \u003CModule\u003E._invalid_parameter_noinfo();
    \u003CModule\u003E.memcpy_s((void*) _Dest, _Dest_size, (void*) _First, (uint) numPtr);
    return _Last;
  }

  internal static unsafe void* std\u002Ectype\u003Cchar\u003E\u002E__vecDelDtor(
    [In] ctype\u003Cchar\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      ctype\u003Cchar\u003E* ctypeCharPtr = (ctype\u003Cchar\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 24U, *(int*) ctypeCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ectype\u003Cchar\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) ctypeCharPtr);
      return (void*) ctypeCharPtr;
    }
    \u003CModule\u003E.std\u002Ectype\u003Cchar\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ectype\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D(
    [In] ctype\u003Cwchar_t\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      if (*(int*) ((IntPtr) obj0 + 20) != 0)
        \u003CModule\u003E.free((void*) *(int*) ((IntPtr) obj0 + 16));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ectype\u003Cwchar_t\u003E\u002Edo_is(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    short _Maskval,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    return (short) ((int) \u003CModule\u003E._Getwctype(_Ch, (_Ctypevec*) ((IntPtr) obj0 + 8)) & (int) _Maskval) != (short) 0;
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_is(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    char* _First,
    char* _Last,
    short* _Dest)
  {
    return \u003CModule\u003E._Getwctypes(_First, _Last, _Dest, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_scan_is(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    short _Maskval,
    char* _First,
    char* _Last)
  {
    if (_First != _Last)
    {
      do
      {
        char ch = *_First;
        ctype\u003Cwchar_t\u003E* ctypeWcharTPtr = obj0;
        int num1 = (int) _Maskval;
        int num2 = (int) ch;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        if (__calli((__FnPtr<byte (IntPtr, short, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) ctypeWcharTPtr, (short) num1, (IntPtr) num2) == (byte) 0)
          ++_First;
        else
          break;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_scan_not(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    short _Maskval,
    char* _First,
    char* _Last)
  {
    if (_First != _Last)
    {
      do
      {
        char ch = *_First;
        ctype\u003Cwchar_t\u003E* ctypeWcharTPtr = obj0;
        int num1 = (int) _Maskval;
        int num2 = (int) ch;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        if (__calli((__FnPtr<byte (IntPtr, short, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) ctypeWcharTPtr, (short) num1, (IntPtr) num2) != (byte) 0)
          ++_First;
        else
          break;
      }
      while (_First != _Last);
    }
    return _First;
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Ectype\u003Cwchar_t\u003E\u002Edo_tolower(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    return \u003CModule\u003E._Towlower(_Ch, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_tolower(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    char* _First,
    char* _Last)
  {
    if (_First != _Last)
    {
      ctype\u003Cwchar_t\u003E* _Ctype = (ctype\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        char* chPtr = _First;
        int num = (int) \u003CModule\u003E._Towlower(*chPtr, (_Ctypevec*) _Ctype);
        *chPtr = (char) num;
        ++_First;
      }
      while (_First != _Last);
    }
    return _First;
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Ectype\u003Cwchar_t\u003E\u002Edo_toupper(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    return \u003CModule\u003E._Towupper(_Ch, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_toupper(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    char* _First,
    char* _Last)
  {
    if (_First != _Last)
    {
      ctype\u003Cwchar_t\u003E* _Ctype = (ctype\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        char* chPtr = _First;
        int num = (int) \u003CModule\u003E._Towupper(*chPtr, (_Ctypevec*) _Ctype);
        *chPtr = (char) num;
        ++_First;
      }
      while (_First != _Last);
    }
    return _First;
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Ectype\u003Cwchar_t\u003E\u002E_Dowiden(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    sbyte _Byte)
  {
    int num = 0;
    char ch;
    return \u003CModule\u003E._Mbrtowc(&ch, &_Byte, 1U, &num, (_Cvtvec*) ((IntPtr) obj0 + 24)) >= 0 ? ch : char.MaxValue;
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Ectype\u003Cwchar_t\u003E\u002Edo_widen(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    sbyte _Byte)
  {
    return \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E_Dowiden(obj0, _Byte);
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_widen(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    char* _Dest)
  {
    ctype\u003Cwchar_t\u003E* ctypeWcharTPtr = obj0;
    sbyte* numPtr1 = _First;
    sbyte* numPtr2 = _Last;
    char* chPtr = _Dest;
    IntPtr num = (IntPtr) _Last - (IntPtr) _First;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte* (IntPtr, sbyte*, sbyte*, char*, uint)>) *(int*) (*(int*) obj0 + 44))((uint) ctypeWcharTPtr, (char*) numPtr1, numPtr2, (sbyte*) chPtr, num);
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cwchar_t\u003E\u002E_Do_widen_s(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    char* _Dest,
    uint _Dest_size)
  {
    if ((UIntPtr) (int) _Dest_size < (UIntPtr) _Last - (UIntPtr) _First)
      \u003CModule\u003E._invalid_parameter_noinfo();
    if (_First != _Last)
    {
      do
      {
        *_Dest = \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E_Dowiden(obj0, *_First);
        ++_First;
        ++_Dest;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cwchar_t\u003E\u002E_Donarrow(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    [MarshalAs(UnmanagedType.U2)] char _Ch,
    sbyte _Dflt)
  {
    int num = 0;
    \u0024ArrayType\u0024\u0024\u0024BY04D arrayTypeBy04D;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    return \u003CModule\u003E._Wcrtomb((sbyte*) &arrayTypeBy04D, _Ch, &num, (_Cvtvec*) ((IntPtr) obj0 + 24)) == 1 ? ^(sbyte&) ref arrayTypeBy04D : _Dflt;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cwchar_t\u003E\u002Edo_narrow(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    [MarshalAs(UnmanagedType.U2)] char _Ch,
    sbyte _Dflt)
  {
    return \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E_Donarrow(obj0, _Ch, _Dflt);
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_narrow(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    char* _First,
    char* _Last,
    sbyte _Dflt,
    sbyte* _Dest)
  {
    ctype\u003Cwchar_t\u003E* ctypeWcharTPtr = obj0;
    char* chPtr1 = _First;
    char* chPtr2 = _Last;
    int num1 = (int) _Dflt;
    sbyte* numPtr = _Dest;
    IntPtr num2 = (IntPtr) _Last - (IntPtr) _First >> 1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<char* (IntPtr, char*, char*, sbyte, sbyte*, uint)>) *(int*) (*(int*) obj0 + 56))((uint) ctypeWcharTPtr, (sbyte*) chPtr1, (sbyte) chPtr2, (char*) num1, (char*) numPtr, num2);
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002E_Do_narrow_s(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    char* _First,
    char* _Last,
    sbyte _Dflt,
    sbyte* _Dest,
    uint _Dest_size)
  {
    if ((UIntPtr) (int) _Dest_size < (UIntPtr) ((IntPtr) _Last - (IntPtr) _First >> 1))
      \u003CModule\u003E._invalid_parameter_noinfo();
    if (_First != _Last)
    {
      do
      {
        *_Dest = \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E_Donarrow(obj0, *_First, _Dflt);
        ++_First;
        ++_Dest;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe void* std\u002Ectype\u003Cwchar_t\u003E\u002E__vecDelDtor(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      ctype\u003Cwchar_t\u003E* ctypeWcharTPtr = (ctype\u003Cwchar_t\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 32U, *(int*) ctypeWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) ctypeWcharTPtr);
      return (void*) ctypeWcharTPtr;
    }
    \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      if (*(int*) ((IntPtr) obj0 + 20) != 0)
        \u003CModule\u003E.free((void*) *(int*) ((IntPtr) obj0 + 16));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_is(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    short _Maskval,
    ushort _Ch)
  {
    return (short) ((int) \u003CModule\u003E._Getwctype((char) _Ch, (_Ctypevec*) ((IntPtr) obj0 + 8)) & (int) _Maskval) != (short) 0;
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_is(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort* _First,
    ushort* _Last,
    short* _Dest)
  {
    return (ushort*) \u003CModule\u003E._Getwctypes((char*) _First, (char*) _Last, _Dest, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_scan_is(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    short _Maskval,
    ushort* _First,
    ushort* _Last)
  {
    if (_First != _Last)
    {
      do
      {
        ushort num1 = *_First;
        ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr = obj0;
        int num2 = (int) _Maskval;
        int num3 = (int) num1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        if (__calli((__FnPtr<byte (IntPtr, short, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) ctypeUnsignedShortPtr, (short) num2, (IntPtr) num3) == (byte) 0)
          ++_First;
        else
          break;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_scan_not(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    short _Maskval,
    ushort* _First,
    ushort* _Last)
  {
    if (_First != _Last)
    {
      do
      {
        ushort num1 = *_First;
        ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr = obj0;
        int num2 = (int) _Maskval;
        int num3 = (int) num1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        if (__calli((__FnPtr<byte (IntPtr, short, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) ctypeUnsignedShortPtr, (short) num2, (IntPtr) num3) != (byte) 0)
          ++_First;
        else
          break;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe ushort std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_tolower(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort _Ch)
  {
    return (ushort) \u003CModule\u003E._Towlower((char) _Ch, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_tolower(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort* _First,
    ushort* _Last)
  {
    if (_First != _Last)
    {
      ctype\u003Cunsigned\u0020short\u003E* _Ctype = (ctype\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        ushort* numPtr = _First;
        int num = (int) \u003CModule\u003E._Towlower((char) *numPtr, (_Ctypevec*) _Ctype);
        *numPtr = (ushort) num;
        ++_First;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe ushort std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_toupper(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort _Ch)
  {
    return (ushort) \u003CModule\u003E._Towupper((char) _Ch, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_toupper(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort* _First,
    ushort* _Last)
  {
    if (_First != _Last)
    {
      ctype\u003Cunsigned\u0020short\u003E* _Ctype = (ctype\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        ushort* numPtr = _First;
        int num = (int) \u003CModule\u003E._Towupper((char) *numPtr, (_Ctypevec*) _Ctype);
        *numPtr = (ushort) num;
        ++_First;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe ushort std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Dowiden(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    sbyte _Byte)
  {
    int num1 = 0;
    ushort num2;
    return \u003CModule\u003E._Mbrtowc((char*) &num2, &_Byte, 1U, &num1, (_Cvtvec*) ((IntPtr) obj0 + 24)) >= 0 ? num2 : ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_widen(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    sbyte _Byte)
  {
    return \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Dowiden(obj0, _Byte);
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_widen(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    ushort* _Dest)
  {
    ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr = obj0;
    sbyte* numPtr1 = _First;
    sbyte* numPtr2 = _Last;
    ushort* numPtr3 = _Dest;
    IntPtr num = (IntPtr) _Last - (IntPtr) _First;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte* (IntPtr, sbyte*, sbyte*, ushort*, uint)>) *(int*) (*(int*) obj0 + 44))((uint) ctypeUnsignedShortPtr, (ushort*) numPtr1, numPtr2, (sbyte*) numPtr3, num);
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Do_widen_s(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    ushort* _Dest,
    uint _Dest_size)
  {
    if ((UIntPtr) (int) _Dest_size < (UIntPtr) _Last - (UIntPtr) _First)
      \u003CModule\u003E._invalid_parameter_noinfo();
    if (_First != _Last)
    {
      do
      {
        *_Dest = \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Dowiden(obj0, *_First);
        ++_First;
        ++_Dest;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Donarrow(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort _Ch,
    sbyte _Dflt)
  {
    int num = 0;
    \u0024ArrayType\u0024\u0024\u0024BY04D arrayTypeBy04D;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    return \u003CModule\u003E._Wcrtomb((sbyte*) &arrayTypeBy04D, (char) _Ch, &num, (_Cvtvec*) ((IntPtr) obj0 + 24)) == 1 ? ^(sbyte&) ref arrayTypeBy04D : _Dflt;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_narrow(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort _Ch,
    sbyte _Dflt)
  {
    return \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Donarrow(obj0, _Ch, _Dflt);
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_narrow(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort* _First,
    ushort* _Last,
    sbyte _Dflt,
    sbyte* _Dest)
  {
    ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr = obj0;
    ushort* numPtr1 = _First;
    ushort* numPtr2 = _Last;
    int num1 = (int) _Dflt;
    sbyte* numPtr3 = _Dest;
    IntPtr num2 = (IntPtr) _Last - (IntPtr) _First >> 1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<ushort* (IntPtr, ushort*, ushort*, sbyte, sbyte*, uint)>) *(int*) (*(int*) obj0 + 56))((uint) ctypeUnsignedShortPtr, (sbyte*) numPtr1, (sbyte) numPtr2, (ushort*) num1, (ushort*) numPtr3, num2);
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Do_narrow_s(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort* _First,
    ushort* _Last,
    sbyte _Dflt,
    sbyte* _Dest,
    uint _Dest_size)
  {
    if ((UIntPtr) (int) _Dest_size < (UIntPtr) ((IntPtr) _Last - (IntPtr) _First >> 1))
      \u003CModule\u003E._invalid_parameter_noinfo();
    if (_First != _Last)
    {
      do
      {
        *_Dest = \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Donarrow(obj0, *_First, _Dflt);
        ++_First;
        ++_Dest;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe void* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E__vecDelDtor(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr = (ctype\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 32U, *(int*) ctypeUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) ctypeUnsignedShortPtr);
      return (void*) ctypeUnsignedShortPtr;
    }
    \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Eios_base\u002Eclear(
    [In] ios_base* obj0,
    int _State,
    [MarshalAs(UnmanagedType.U1)] bool _Reraise)
  {
    int num1 = _State & 23;
    *(int*) ((IntPtr) obj0 + 8) = num1;
    int num2 = *(int*) ((IntPtr) obj0 + 12) & num1;
    if (num2 == 0)
      return;
    if (_Reraise)
      \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
    if ((num2 & 4) != 0)
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    else if ((num2 & 2) != 0)
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    else
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
  }

  internal static unsafe void std\u002Eios_base\u002E\u007Bdtor\u007D([In] ios_base* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Eios_base\u002E_Ios_base_dtor(obj0);
  }

  internal static unsafe void* std\u002Eios_base\u002E__vecDelDtor([In] ios_base* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      ios_base* iosBasePtr = (ios_base*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 40U, *(int*) iosBasePtr, (__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) iosBasePtr);
      return (void*) iosBasePtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Eios_base\u002E_Ios_base_dtor(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002E\u003FA0xc4d0f765\u002Ersfun(ios_base* iostr, int mask) => *(int*) ((IntPtr) iostr + 16) = *(int*) ((IntPtr) iostr + 16) & ~mask;

  internal static unsafe void std\u002E\u003FA0xc4d0f765\u002Esifun(ios_base* iostr, int mask) => *(int*) ((IntPtr) iostr + 16) = ~mask & *(int*) ((IntPtr) iostr + 16) | mask & (int) ushort.MaxValue;

  internal static unsafe void std\u002E\u003FA0xc4d0f765\u002Esbfun(ios_base* iostr, int @base)
  {
    _Iosb\u003Cint\u003E._Fmtflags fmtflags1;
    _Iosb\u003Cint\u003E._Fmtflags fmtflags2;
    _Iosb\u003Cint\u003E._Fmtflags fmtflags3;
    switch (@base)
    {
      case 8:
        fmtflags1 = (_Iosb\u003Cint\u003E._Fmtflags) 1024;
        goto label_7;
      case 10:
        fmtflags2 = (_Iosb\u003Cint\u003E._Fmtflags) 512;
        goto label_6;
      case 16:
        fmtflags3 = (_Iosb\u003Cint\u003E._Fmtflags) 2048;
        break;
      default:
        fmtflags3 = (_Iosb\u003Cint\u003E._Fmtflags) 0;
        break;
    }
    fmtflags2 = fmtflags3;
label_6:
    fmtflags1 = fmtflags2;
label_7:
    *(int*) ((IntPtr) iostr + 16) = (int) ((_Iosb\u003Cint\u003E._Fmtflags) *(int*) ((IntPtr) iostr + 16) ^ ((_Iosb\u003Cint\u003E._Fmtflags) *(int*) ((IntPtr) iostr + 16) ^ fmtflags1) & (_Iosb\u003Cint\u003E._Fmtflags) 3584);
  }

  internal static unsafe void std\u002E\u003FA0xc4d0f765\u002Espfun(ios_base* iostr, int prec) => *(int*) ((IntPtr) iostr + 20) = prec;

  internal static unsafe void std\u002E\u003FA0xc4d0f765\u002Eswfun(ios_base* iostr, int wide) => *(int*) ((IntPtr) iostr + 24) = wide;

  internal static unsafe _Smanip\u003Cint\u003E* std\u002Eresetiosflags(
    [In] _Smanip\u003Cint\u003E* obj0,
    int mask)
  {
    *(int*) obj0 = (int) \u003CModule\u003E.__unep\u0040\u003Frsfun\u0040\u003FA0xc4d0f765\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
    *(int*) ((IntPtr) obj0 + 4) = mask;
    return obj0;
  }

  internal static unsafe _Smanip\u003Cint\u003E* std\u002Esetiosflags(
    [In] _Smanip\u003Cint\u003E* obj0,
    int mask)
  {
    *(int*) obj0 = (int) \u003CModule\u003E.__unep\u0040\u003Fsifun\u0040\u003FA0xc4d0f765\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
    *(int*) ((IntPtr) obj0 + 4) = mask;
    return obj0;
  }

  internal static unsafe _Smanip\u003Cint\u003E* std\u002Esetbase(
    [In] _Smanip\u003Cint\u003E* obj0,
    int @base)
  {
    *(int*) obj0 = (int) \u003CModule\u003E.__unep\u0040\u003Fsbfun\u0040\u003FA0xc4d0f765\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
    *(int*) ((IntPtr) obj0 + 4) = @base;
    return obj0;
  }

  internal static unsafe _Smanip\u003Cint\u003E* std\u002Esetprecision(
    [In] _Smanip\u003Cint\u003E* obj0,
    int prec)
  {
    *(int*) obj0 = (int) \u003CModule\u003E.__unep\u0040\u003Fspfun\u0040\u003FA0xc4d0f765\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
    *(int*) ((IntPtr) obj0 + 4) = prec;
    return obj0;
  }

  internal static unsafe _Smanip\u003Cint\u003E* std\u002Esetw(
    [In] _Smanip\u003Cint\u003E* obj0,
    int wide)
  {
    *(int*) obj0 = (int) \u003CModule\u003E.__unep\u0040\u003Fswfun\u0040\u003FA0xc4d0f765\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
    *(int*) ((IntPtr) obj0 + 4) = wide;
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(obj0, _Ptr);
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Count,
    sbyte _Ch)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(obj0, _Count, _Ch);
    return obj0;
  }

  [SpecialName]
  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(obj0, _Right, 0U, uint.MaxValue);
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Count,
    sbyte _Ch)
  {
    if ((uint) (-1 - *(int*) ((IntPtr) obj0 + 20)) <= _Count)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (0U < _Count)
    {
      uint _Newsize = _Count + (uint) *(int*) ((IntPtr) obj0 + 20);
      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(obj0, _Newsize, false))
      {
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = obj0;
        int _Off = *(int*) ((IntPtr) stdAllocatorCharPtr + 20);
        int _Count1 = (int) _Count;
        int _Ch1 = (int) _Ch;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Chassign(stdAllocatorCharPtr, (uint) _Off, (uint) _Count1, (sbyte) _Ch1);
        *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Newsize] = (sbyte) 0;
      }
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right,
    uint _Roff,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) _Right + 20) < _Roff)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint _Newsize = (uint) *(int*) ((IntPtr) _Right + 20) - _Roff;
    if (_Count < _Newsize)
      _Newsize = _Count;
    if (obj0 == _Right)
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(obj0, _Newsize + _Roff, uint.MaxValue);
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(obj0, 0U, _Roff);
    }
    else if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(obj0, _Newsize, false))
    {
      \u003CModule\u003E.memcpy_s((void*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0), (uint) *(int*) ((IntPtr) obj0 + 24), (void*) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(_Right) + (int) _Roff), _Newsize);
      *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Newsize] = (sbyte) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr,
    uint _Count)
  {
    if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Inside(obj0, _Ptr))
    {
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right = obj0;
      IntPtr _Roff = (IntPtr) _Ptr - (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0);
      int _Count1 = (int) _Count;
      return \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(_Right, _Right, (uint) _Roff, (uint) _Count1);
    }
    if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(obj0, _Count, false))
    {
      \u003CModule\u003E.memcpy_s((void*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0), (uint) *(int*) ((IntPtr) obj0 + 24), (void*) _Ptr, _Count);
      *(int*) ((IntPtr) obj0 + 20) = (int) _Count;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Count] = (sbyte) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr)
  {
    uint _Count = \u003CModule\u003E.strlen(_Ptr);
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(obj0, _Ptr, _Count);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Count,
    sbyte _Ch)
  {
    if (_Count == uint.MaxValue)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(obj0, _Count, false))
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Chassign(obj0, 0U, _Count, _Ch);
      *(int*) ((IntPtr) obj0 + 20) = (int) _Count;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Count] = (sbyte) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) obj0 + 20) < _Off)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num = (uint) *(int*) ((IntPtr) obj0 + 20) - _Off;
    if (num < _Count)
      _Count = num;
    if (0U < _Count)
    {
      \u003CModule\u003E.std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + (int) _Off, (uint) *(int*) ((IntPtr) obj0 + 24) - _Off, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + (int) _Off + (int) _Count, num - _Count);
      uint index = (uint) *(int*) ((IntPtr) obj0 + 20) - _Count;
      *(int*) ((IntPtr) obj0 + 20) = (int) index;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) index] = (sbyte) 0;
    }
    return obj0;
  }

  internal static unsafe _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) obj1, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0), (_Container_base_secure*) obj0);
    return obj1;
  }

  internal static unsafe int std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ecompare(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr)
  {
    uint _Count = \u003CModule\u003E.strlen(_Ptr);
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ecompare(obj0, 0U, (uint) *(int*) ((IntPtr) obj0 + 20), _Ptr, _Count);
  }

  internal static unsafe int std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ecompare(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _N0,
    sbyte* _Ptr,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) obj0 + 20) < _Off)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 20) - _Off;
    if (num1 < _N0)
      _N0 = num1;
    uint num2 = _N0 >= _Count ? _Count : _N0;
    uint num3 = (uint) \u003CModule\u003E.memcmp((void*) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + (int) _Off), (void*) _Ptr, num2);
    return num3 == 0U ? (_N0 >= _Count ? ((int) _N0 == (int) _Count ? 0 : 1) : -1) : (int) num3;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Chassign(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _Count,
    sbyte _Ch)
  {
    if (_Count == 1U)
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Off] = _Ch;
    else
      \u003CModule\u003E.memset((void*) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + (int) _Off), (int) _Ch, _Count);
  }

  internal static unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Copy(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Newsize,
    uint _Oldlen)
  {
    uint num1 = (uint) \u003CModule\u003E.__CxxQueryExceptionSize();
    // ISSUE: untyped stack allocation
    int num2 = (int) __untypedstackalloc((int) num1 << 1);
    uint num3 = _Newsize | 15U;
    if (4294967294U < num3)
    {
      num3 = _Newsize;
    }
    else
    {
      uint num4 = (uint) *(int*) ((IntPtr) obj0 + 24);
      uint num5 = num4 >> 1;
      if (num3 / 3U < num5 && num4 <= 4294967294U - num5)
        num3 = num5 + num4;
    }
    sbyte* _First1 = (sbyte*) 0;
    int num6;
    try
    {
      num6 = (int) num1 + num2;
      _First1 = \u003CModule\u003E.std\u002E_Allocate\u003Cchar\u003E(num3 + 1U, (sbyte*) 0);
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode1 = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num7 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num6);
      try
      {
        try
        {
          num3 = _Newsize;
          try
          {
            _First1 = \u003CModule\u003E.std\u002E_Allocate\u003Cchar\u003E(_Newsize + 1U, (sbyte*) 0);
            goto label_23;
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            uint exceptionCode2 = (uint) Marshal.GetExceptionCode();
            if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
            uint num8 = 0;
            \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num2);
            try
            {
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
                \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
              }
              catch (Exception ex3) when (
              {
                // ISSUE: unable to correctly present filter
                num8 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
                if (num8 != 0U)
                {
                  SuccessfulFiltering;
                }
                else
                  throw;
              }
              )
              {
              }
              if (num8 != 0U)
                throw;
              else
                goto label_23;
            }
            finally
            {
              \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num2, (int) num8);
            }
          }
        }
        catch (Exception ex4) when (
        {
          // ISSUE: unable to correctly present filter
          num7 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num7 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num7 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num6, (int) num7);
      }
    }
label_23:
    if (0U < _Oldlen)
      \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First1, num3 + 1U, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0), _Oldlen);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
    *(int*) ((IntPtr) obj0 + 4) = (int) _First1;
    *(int*) ((IntPtr) obj0 + 24) = (int) num3;
    *(int*) ((IntPtr) obj0 + 20) = (int) _Oldlen;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Oldlen] = (sbyte) 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Newsize,
    [MarshalAs(UnmanagedType.U1)] bool _Trim)
  {
    if (4294967294U < _Newsize)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if ((uint) *(int*) ((IntPtr) obj0 + 24) < _Newsize)
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Copy(obj0, _Newsize, (uint) *(int*) ((IntPtr) obj0 + 20));
    else if (_Trim && _Newsize < 16U)
    {
      uint num = (uint) *(int*) ((IntPtr) obj0 + 20);
      uint _Newsize1 = _Newsize >= num ? num : _Newsize;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, true, _Newsize1);
    }
    else if (_Newsize == 0U)
    {
      *(int*) ((IntPtr) obj0 + 20) = 0;
      *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) = (sbyte) 0;
    }
    return 0U < _Newsize;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Inside(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr)
  {
    return (IntPtr) _Ptr != IntPtr.Zero && _Ptr >= \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) && \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + *(int*) ((IntPtr) obj0 + 20) > _Ptr;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _Built,
    uint _Newsize)
  {
    if (_Built && 16U <= (uint) *(int*) ((IntPtr) obj0 + 24))
    {
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
      sbyte* numPtr = (sbyte*) *(int*) stdAllocatorCharPtr;
      if (0U < _Newsize)
        \u003CModule\u003E.memcpy_s((void*) stdAllocatorCharPtr, 16U, (void*) numPtr, _Newsize);
      \u003CModule\u003E.delete((void*) numPtr);
    }
    *(int*) ((IntPtr) obj0 + 24) = 15;
    *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Newsize] = (sbyte) 0;
  }

  internal static unsafe sbyte* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return 16U <= (uint) *(int*) ((IntPtr) obj0 + 24) ? (sbyte*) *(int*) ((IntPtr) obj0 + 4) : (sbyte*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe sbyte* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return 16U <= (uint) *(int*) ((IntPtr) obj0 + 24) ? (sbyte*) *(int*) ((IntPtr) obj0 + 4) : (sbyte*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eflush(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    int _State = 0;
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = obj0;
    int num1 = *(int*) (*(int*) stdCharTraitsCharPtr1 + 4);
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) stdCharTraitsCharPtr1 + num1);
    if (((*(int*) ((IntPtr) stdCharTraitsCharPtr2 + 8) & 6) != 0 ? 1 : 0) == 0)
    {
      int num2 = *(int*) ((IntPtr) stdCharTraitsCharPtr2 + 40);
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      if (__calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) num2 + 48))((IntPtr) num2) == -1)
        _State = 4;
    }
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetstate((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _State, false);
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Eios_base\u002E_Ios_base_dtor((ios_base*) obj0);
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetstate(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    int _State,
    [MarshalAs(UnmanagedType.U1)] bool _Reraise)
  {
    if (_State == 0)
      return;
    basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    int _State1 = *(int*) ((IntPtr) stdCharTraitsCharPtr + 8) | _State;
    int num = _Reraise ? 1 : 0;
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclear(stdCharTraitsCharPtr, _State1, num != 0);
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Eios_base\u002E_Ios_base_dtor((ios_base*) obj0);
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Eios_base\u002E_Ios_base_dtor((ios_base*) obj0);
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      locale* localePtr = (locale*) *(int*) ((IntPtr) obj0 + 56);
      if ((IntPtr) localePtr != IntPtr.Zero)
      {
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(localePtr);
        \u003CModule\u003E.delete((void*) localePtr);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mutex\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_dtor((_Mutex*) ((IntPtr) obj0 + 4));
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eoverflow(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    int _param1)
  {
    return -1;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Epbackfail(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    int _param1)
  {
    return -1;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eshowmanyc(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eunderflow(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return -1;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Euflow(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return -1 == __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) stdCharTraitsCharPtr + 16))((IntPtr) stdCharTraitsCharPtr) ? -1 : (int) (byte) *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Gninc(obj0);
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Exsgetn(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr,
    int _Count)
  {
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    sbyte* numPtr = _Ptr;
    int num = _Count;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, sbyte*, uint, int)>) *(int*) (*(int*) obj0 + 28))((int) stdCharTraitsCharPtr, (uint) numPtr, (sbyte*) -1, (IntPtr) num);
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Xsgetn_s(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr,
    uint _Ptr_size,
    int _Count)
  {
    int num1 = 0;
    if (0 < _Count)
    {
      do
      {
        int num2 = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Gnavail(obj0);
        if (0 < num2)
        {
          int _Count1 = num2;
          if (_Count < num2)
            _Count1 = _Count;
          \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_Ptr, _Ptr_size, (sbyte*) *(int*) *(int*) ((IntPtr) obj0 + 32), (uint) _Count1);
          _Ptr = (sbyte*) (_Count1 + (IntPtr) _Ptr);
          num1 = _Count1 + num1;
          _Count -= _Count1;
          int num3 = *(int*) ((IntPtr) obj0 + 48);
          *(int*) num3 = *(int*) num3 - _Count1;
          int num4 = *(int*) ((IntPtr) obj0 + 32);
          *(int*) num4 = *(int*) num4 + _Count1;
        }
        else
        {
          basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          int num5 = __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) stdCharTraitsCharPtr + 20))((IntPtr) stdCharTraitsCharPtr);
          if (-1 != num5)
          {
            *_Ptr = (sbyte) num5;
            ++_Ptr;
            ++num1;
            --_Count;
          }
          else
            break;
        }
      }
      while (0 < _Count);
    }
    return num1;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Exsputn(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr,
    int _Count)
  {
    int num1 = 0;
    if (0 < _Count)
    {
      do
      {
        int num2 = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Pnavail(obj0);
        if (0 < num2)
        {
          int num3 = num2;
          if (_Count < num2)
            num3 = _Count;
          \u003CModule\u003E.memcpy_s((void*) *(int*) *(int*) ((IntPtr) obj0 + 36), (uint) num2, (void*) _Ptr, (uint) num3);
          _Ptr = (sbyte*) (num3 + (IntPtr) _Ptr);
          num1 = num3 + num1;
          _Count -= num3;
          int num4 = *(int*) ((IntPtr) obj0 + 52);
          *(int*) num4 = *(int*) num4 - num3;
          int num5 = *(int*) ((IntPtr) obj0 + 36);
          *(int*) num5 = *(int*) num5 + num3;
        }
        else
        {
          int num6 = (int) (byte) *_Ptr;
          basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
          int num7 = num6;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          if (-1 != __calli((__FnPtr<int (IntPtr, int)>) *(int*) (*(int*) obj0 + 4))((int) stdCharTraitsCharPtr, (IntPtr) num7))
          {
            ++_Ptr;
            ++num1;
            --_Count;
          }
          else
            break;
        }
      }
      while (0 < _Count);
    }
    return num1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekoff(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    int _param2,
    int _param3,
    int _param4)
  {
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekpos(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    fpos\u003Cint\u003E _param2,
    int _param3)
  {
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetbuf(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _param1,
    int _param2)
  {
    return obj0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esync(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eimbue(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    locale* _param1)
  {
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      locale* localePtr = (locale*) *(int*) ((IntPtr) obj0 + 56);
      if ((IntPtr) localePtr != IntPtr.Zero)
      {
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(localePtr);
        \u003CModule\u003E.delete((void*) localePtr);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mutex\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_dtor((_Mutex*) ((IntPtr) obj0 + 4));
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eoverflow(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    ushort _param1)
  {
    return ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Epbackfail(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    ushort _param1)
  {
    return ushort.MaxValue;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eshowmanyc(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eunderflow(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Euflow(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return ushort.MaxValue != __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) charTraitsWcharTPtr + 16))((IntPtr) charTraitsWcharTPtr) ? (ushort) *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Gninc(obj0) : ushort.MaxValue;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Exsgetn(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Ptr,
    int _Count)
  {
    basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
    char* chPtr = _Ptr;
    int num = _Count;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, char*, uint, int)>) *(int*) (*(int*) obj0 + 28))((int) charTraitsWcharTPtr, (uint) chPtr, (char*) -1, (IntPtr) num);
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Xsgetn_s(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Ptr,
    uint _Ptr_size,
    int _Count)
  {
    int num1 = 0;
    if (0 < _Count)
    {
      do
      {
        int num2 = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Gnavail(obj0);
        if (0 < num2)
        {
          int _Count1 = num2;
          if (_Count < num2)
            _Count1 = _Count;
          \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_Ptr, _Ptr_size, (char*) *(int*) *(int*) ((IntPtr) obj0 + 32), (uint) _Count1);
          _Ptr = (char*) (_Count1 * 2 + (IntPtr) _Ptr);
          num1 = _Count1 + num1;
          _Count -= _Count1;
          int num3 = *(int*) ((IntPtr) obj0 + 48);
          *(int*) num3 = *(int*) num3 - _Count1;
          int num4 = *(int*) ((IntPtr) obj0 + 32);
          *(int*) num4 = *(int*) num4 + _Count1 * 2;
        }
        else
        {
          basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          ushort num5 = __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) charTraitsWcharTPtr + 20))((IntPtr) charTraitsWcharTPtr);
          if (ushort.MaxValue != num5)
          {
            *_Ptr = (char) num5;
            ++_Ptr;
            ++num1;
            --_Count;
          }
          else
            break;
        }
      }
      while (0 < _Count);
    }
    return num1;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Exsputn(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Ptr,
    int _Count)
  {
    int num1 = 0;
    if (0 < _Count)
    {
      do
      {
        int _Size = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Pnavail(obj0);
        if (0 < _Size)
        {
          int _Count1 = _Size;
          if (_Count < _Size)
            _Count1 = _Count;
          \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E((char*) *(int*) *(int*) ((IntPtr) obj0 + 36), (uint) _Size, _Ptr, (uint) _Count1);
          _Ptr = (char*) (_Count1 * 2 + (IntPtr) _Ptr);
          num1 = _Count1 + num1;
          _Count -= _Count1;
          int num2 = *(int*) ((IntPtr) obj0 + 52);
          *(int*) num2 = *(int*) num2 - _Count1;
          int num3 = *(int*) ((IntPtr) obj0 + 36);
          *(int*) num3 = *(int*) num3 + _Count1 * 2;
        }
        else
        {
          ushort num4 = (ushort) *_Ptr;
          basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
          int num5 = (int) num4;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          if (ushort.MaxValue != __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) charTraitsWcharTPtr, (IntPtr) num5))
          {
            ++_Ptr;
            ++num1;
            --_Count;
          }
          else
            break;
        }
      }
      while (0 < _Count);
    }
    return num1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekoff(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    int _param2,
    int _param3,
    int _param4)
  {
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekpos(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    fpos\u003Cint\u003E _param2,
    int _param3)
  {
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esetbuf(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _param1,
    int _param2)
  {
    return obj0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esync(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eimbue(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    locale* _param1)
  {
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      locale* localePtr = (locale*) *(int*) ((IntPtr) obj0 + 56);
      if ((IntPtr) localePtr != IntPtr.Zero)
      {
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(localePtr);
        \u003CModule\u003E.delete((void*) localePtr);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mutex\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_dtor((_Mutex*) ((IntPtr) obj0 + 4));
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eoverflow(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort _param1)
  {
    return ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Epbackfail(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort _param1)
  {
    return ushort.MaxValue;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eshowmanyc(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eunderflow(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Euflow(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return ushort.MaxValue != __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) traitsUnsignedShortPtr + 16))((IntPtr) traitsUnsignedShortPtr) ? *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Gninc(obj0) : ushort.MaxValue;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Exsgetn(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Ptr,
    int _Count)
  {
    basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
    ushort* numPtr = _Ptr;
    int num = _Count;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, ushort*, uint, int)>) *(int*) (*(int*) obj0 + 28))((int) traitsUnsignedShortPtr, (uint) numPtr, (ushort*) -1, (IntPtr) num);
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Xsgetn_s(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Ptr,
    uint _Ptr_size,
    int _Count)
  {
    int num1 = 0;
    if (0 < _Count)
    {
      do
      {
        int num2 = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Gnavail(obj0);
        if (0 < num2)
        {
          int _Count1 = num2;
          if (_Count < num2)
            _Count1 = _Count;
          \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_Ptr, _Ptr_size, (ushort*) *(int*) *(int*) ((IntPtr) obj0 + 32), (uint) _Count1);
          _Ptr = (ushort*) (_Count1 * 2 + (IntPtr) _Ptr);
          num1 = _Count1 + num1;
          _Count -= _Count1;
          int num3 = *(int*) ((IntPtr) obj0 + 48);
          *(int*) num3 = *(int*) num3 - _Count1;
          int num4 = *(int*) ((IntPtr) obj0 + 32);
          *(int*) num4 = *(int*) num4 + _Count1 * 2;
        }
        else
        {
          basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          ushort num5 = __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) traitsUnsignedShortPtr + 20))((IntPtr) traitsUnsignedShortPtr);
          if (ushort.MaxValue != num5)
          {
            *_Ptr = num5;
            ++_Ptr;
            ++num1;
            --_Count;
          }
          else
            break;
        }
      }
      while (0 < _Count);
    }
    return num1;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Exsputn(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Ptr,
    int _Count)
  {
    int num1 = 0;
    if (0 < _Count)
    {
      do
      {
        int _Size = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Pnavail(obj0);
        if (0 < _Size)
        {
          int _Count1 = _Size;
          if (_Count < _Size)
            _Count1 = _Count;
          \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E((ushort*) *(int*) *(int*) ((IntPtr) obj0 + 36), (uint) _Size, _Ptr, (uint) _Count1);
          _Ptr = (ushort*) (_Count1 * 2 + (IntPtr) _Ptr);
          num1 = _Count1 + num1;
          _Count -= _Count1;
          int num2 = *(int*) ((IntPtr) obj0 + 52);
          *(int*) num2 = *(int*) num2 - _Count1;
          int num3 = *(int*) ((IntPtr) obj0 + 36);
          *(int*) num3 = *(int*) num3 + _Count1 * 2;
        }
        else
        {
          ushort num4 = *_Ptr;
          basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
          int num5 = (int) num4;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          if (ushort.MaxValue != __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) traitsUnsignedShortPtr, (IntPtr) num5))
          {
            ++_Ptr;
            ++num1;
            --_Count;
          }
          else
            break;
        }
      }
      while (0 < _Count);
    }
    return num1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekoff(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    int _param2,
    int _param3,
    int _param4)
  {
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekpos(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    fpos\u003Cint\u003E _param2,
    int _param3)
  {
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esetbuf(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _param1,
    int _param2)
  {
    return obj0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esync(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eimbue(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    locale* _param1)
  {
  }

  internal static unsafe void* std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 8);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) ((IntPtr) obj0 - 4), 56U, *(int*) stdCharTraitsCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) stdCharTraitsCharPtr);
      return (void*) stdCharTraitsCharPtr;
    }
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(stdCharTraitsCharPtr1);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr1);
    return (void*) stdCharTraitsCharPtr1;
  }

  internal static unsafe void* std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) stdCharTraitsCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) stdCharTraitsCharPtr);
      return (void*) stdCharTraitsCharPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 8);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) ((IntPtr) obj0 - 4), 56U, *(int*) charTraitsWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) charTraitsWcharTPtr);
      return (void*) charTraitsWcharTPtr;
    }
    basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = (basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(charTraitsWcharTPtr1);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) charTraitsWcharTPtr1);
    return (void*) charTraitsWcharTPtr1;
  }

  internal static unsafe void* std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) charTraitsWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) charTraitsWcharTPtr);
      return (void*) charTraitsWcharTPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 8);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) ((IntPtr) obj0 - 4), 56U, *(int*) traitsUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsUnsignedShortPtr);
      return (void*) traitsUnsignedShortPtr;
    }
    basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(traitsUnsignedShortPtr1);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr1);
    return (void*) traitsUnsignedShortPtr1;
  }

  internal static unsafe void* std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) traitsUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsUnsignedShortPtr);
      return (void*) traitsUnsignedShortPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 12);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) ((IntPtr) obj0 - 8), 60U, *(int*) stdCharTraitsCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) stdCharTraitsCharPtr);
      return (void*) stdCharTraitsCharPtr;
    }
    basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 8);
    \u003CModule\u003E.std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(stdCharTraitsCharPtr1);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr1);
    return (void*) stdCharTraitsCharPtr1;
  }

  internal static unsafe void* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 60U, *(int*) stdCharTraitsCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) stdCharTraitsCharPtr);
      return (void*) stdCharTraitsCharPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 12);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) ((IntPtr) obj0 - 8), 60U, *(int*) charTraitsWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) charTraitsWcharTPtr);
      return (void*) charTraitsWcharTPtr;
    }
    basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = (basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 8);
    \u003CModule\u003E.std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(charTraitsWcharTPtr1);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) charTraitsWcharTPtr1);
    return (void*) charTraitsWcharTPtr1;
  }

  internal static unsafe void* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 60U, *(int*) charTraitsWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) charTraitsWcharTPtr);
      return (void*) charTraitsWcharTPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 12);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) ((IntPtr) obj0 - 8), 60U, *(int*) traitsUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsUnsignedShortPtr);
      return (void*) traitsUnsignedShortPtr;
    }
    basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 8);
    \u003CModule\u003E.std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(traitsUnsignedShortPtr1);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr1);
    return (void*) traitsUnsignedShortPtr1;
  }

  internal static unsafe void* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 60U, *(int*) traitsUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsUnsignedShortPtr);
      return (void*) traitsUnsignedShortPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = stdCharTraitsCharPtr1;
    int num = *(int*) (*(int*) ((IntPtr) stdCharTraitsCharPtr2 - 4) + 4);
    *(int*) ((IntPtr) stdCharTraitsCharPtr2 + num - 4) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) stdCharTraitsCharPtr1);
  }

  internal static unsafe void std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = (basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
    basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr2 = charTraitsWcharTPtr1;
    int num = *(int*) (*(int*) ((IntPtr) charTraitsWcharTPtr2 - 4) + 4);
    *(int*) ((IntPtr) charTraitsWcharTPtr2 + num - 4) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) charTraitsWcharTPtr1);
  }

  internal static unsafe void std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
    basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr2 = traitsUnsignedShortPtr1;
    int num = *(int*) (*(int*) ((IntPtr) traitsUnsignedShortPtr2 - 4) + 4);
    *(int*) ((IntPtr) traitsUnsignedShortPtr2 + num - 4) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) traitsUnsignedShortPtr1);
  }

  internal static unsafe void std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
    basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = stdCharTraitsCharPtr1;
    int num = *(int*) (*(int*) ((IntPtr) stdCharTraitsCharPtr2 - 8) + 4);
    *(int*) ((IntPtr) stdCharTraitsCharPtr2 + num - 8) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) stdCharTraitsCharPtr1);
  }

  internal static unsafe void std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = (basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
    basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr2 = charTraitsWcharTPtr1;
    int num = *(int*) (*(int*) ((IntPtr) charTraitsWcharTPtr2 - 8) + 4);
    *(int*) ((IntPtr) charTraitsWcharTPtr2 + num - 8) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) charTraitsWcharTPtr1);
  }

  internal static unsafe void std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
    basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr2 = traitsUnsignedShortPtr1;
    int num = *(int*) (*(int*) ((IntPtr) traitsUnsignedShortPtr2 - 8) + 4);
    *(int*) ((IntPtr) traitsUnsignedShortPtr2 + num - 8) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) traitsUnsignedShortPtr1);
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclear(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    int _State,
    [MarshalAs(UnmanagedType.U1)] bool _Reraise)
  {
    int _State1 = *(int*) ((IntPtr) obj0 + 40) != 0 ? _State : _State | 4;
    \u003CModule\u003E.std\u002Eios_base\u002Eclear((ios_base*) obj0, _State1, _Reraise);
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eclear(
    [In] basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    int _State,
    [MarshalAs(UnmanagedType.U1)] bool _Reraise)
  {
    int _State1 = *(int*) ((IntPtr) obj0 + 40) != 0 ? _State : _State | 4;
    \u003CModule\u003E.std\u002Eios_base\u002Eclear((ios_base*) obj0, _State1, _Reraise);
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eclear(
    [In] basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    int _State,
    [MarshalAs(UnmanagedType.U1)] bool _Reraise)
  {
    int _State1 = *(int*) ((IntPtr) obj0 + 40) != 0 ? _State : _State | 4;
    \u003CModule\u003E.std\u002Eios_base\u002Eclear((ios_base*) obj0, _State1, _Reraise);
  }

  internal static unsafe sbyte* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Gninc(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 48);
    *(int*) num1 = *(int*) num1 - 1;
    int num2 = *(int*) ((IntPtr) obj0 + 32);
    int num3 = *(int*) num2;
    int num4 = num3;
    *(int*) num2 = num3 + 1;
    return (sbyte*) num4;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Gnavail(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return *(int*) *(int*) ((IntPtr) obj0 + 32) != 0 ? *(int*) *(int*) ((IntPtr) obj0 + 48) : 0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Pnavail(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return *(int*) *(int*) ((IntPtr) obj0 + 36) != 0 ? *(int*) *(int*) ((IntPtr) obj0 + 52) : 0;
  }

  internal static unsafe char* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Gninc(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 48);
    *(int*) num1 = *(int*) num1 - 1;
    int num2 = *(int*) ((IntPtr) obj0 + 32);
    int num3 = *(int*) num2;
    int num4 = num3;
    *(int*) num2 = num3 + 2;
    return (char*) num4;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Gnavail(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return *(int*) *(int*) ((IntPtr) obj0 + 32) != 0 ? *(int*) *(int*) ((IntPtr) obj0 + 48) : 0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Pnavail(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return *(int*) *(int*) ((IntPtr) obj0 + 36) != 0 ? *(int*) *(int*) ((IntPtr) obj0 + 52) : 0;
  }

  internal static unsafe ushort* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Gninc(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 48);
    *(int*) num1 = *(int*) num1 - 1;
    int num2 = *(int*) ((IntPtr) obj0 + 32);
    int num3 = *(int*) num2;
    int num4 = num3;
    *(int*) num2 = num3 + 2;
    return (ushort*) num4;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Gnavail(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return *(int*) *(int*) ((IntPtr) obj0 + 32) != 0 ? *(int*) *(int*) ((IntPtr) obj0 + 48) : 0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Pnavail(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return *(int*) *(int*) ((IntPtr) obj0 + 36) != 0 ? *(int*) *(int*) ((IntPtr) obj0 + 52) : 0;
  }

  internal static unsafe _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr,
    _Container_base_secure* _Pstring)
  {
    *(int*) obj0 = 0;
    if ((IntPtr) _Pstring != IntPtr.Zero && (IntPtr) _Ptr != IntPtr.Zero)
    {
      sbyte* numPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) _Pstring);
      if (numPtr <= _Ptr && (UIntPtr) _Ptr <= (UIntPtr) *(int*) ((IntPtr) _Pstring + 20) + (UIntPtr) numPtr)
        goto label_3;
    }
    \u003CModule\u003E._invalid_parameter_noinfo();
label_3:
    *(int*) obj0 = (int) _Pstring;
    *(int*) ((IntPtr) obj0 + 4) = (int) _Ptr;
    return obj0;
  }

  internal static unsafe sbyte* std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A(
    [In] _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    int num1;
    switch ((uint) *(int*) obj0)
    {
      case 0:
        num1 = 0;
        break;
      case 4294967292:
label_7:
        return (sbyte*) *(int*) ((IntPtr) obj0 + 4);
      default:
        num1 = 1;
        break;
    }
    if ((byte) num1 == (byte) 0)
      \u003CModule\u003E._invalid_parameter_noinfo();
    uint num2 = (uint) *(int*) obj0;
    if ((UIntPtr) *(int*) ((IntPtr) obj0 + 4) >= (UIntPtr) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) num2) + *(int*) ((int) num2 + 20)))
    {
      \u003CModule\u003E._invalid_parameter_noinfo();
      goto label_7;
    }
    else
      goto label_7;
  }

  internal static unsafe sbyte* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Pninc(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 52);
    *(int*) num1 = *(int*) num1 - 1;
    int num2 = *(int*) ((IntPtr) obj0 + 36);
    int num3 = *(int*) num2;
    int num4 = num3;
    *(int*) num2 = num3 + 1;
    return (sbyte*) num4;
  }

  internal static unsafe char* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Pninc(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 52);
    *(int*) num1 = *(int*) num1 - 1;
    int num2 = *(int*) ((IntPtr) obj0 + 36);
    int num3 = *(int*) num2;
    int num4 = num3;
    *(int*) num2 = num3 + 2;
    return (char*) num4;
  }

  internal static unsafe ushort* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Pninc(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 52);
    *(int*) num1 = *(int*) num1 - 1;
    int num2 = *(int*) ((IntPtr) obj0 + 36);
    int num3 = *(int*) num2;
    int num4 = num3;
    *(int*) num2 = num3 + 2;
    return (ushort*) num4;
  }

  internal static unsafe sbyte* std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(
    sbyte* _First1,
    uint _Size,
    sbyte* _First2,
    uint _Count)
  {
    \u003CModule\u003E.memcpy_s((void*) _First1, _Size, (void*) _First2, _Count);
    return _First1;
  }

  internal static unsafe sbyte* std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(
    sbyte* _First1,
    uint _Size,
    sbyte* _First2,
    uint _Count)
  {
    \u003CModule\u003E.memmove_s((void*) _First1, _Size, (void*) _First2, _Count);
    return _First1;
  }

  internal static unsafe char* std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(
    char* _First1,
    uint _Size,
    char* _First2,
    uint _Count)
  {
    \u003CModule\u003E.memcpy_s((void*) _First1, _Size << 1, (void*) _First2, _Count << 1);
    return _First1;
  }

  internal static unsafe ushort* std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(
    ushort* _First1,
    uint _Size,
    ushort* _First2,
    uint _Count)
  {
    \u003CModule\u003E.memcpy_s((void*) _First1, _Size << 1, (void*) _First2, _Count << 1);
    return _First1;
  }

  internal static unsafe sbyte* std\u002E_Allocate\u003Cchar\u003E(uint _Count, sbyte* __unnamed001)
  {
    if (_Count <= 0U)
      _Count = 0U;
    else if (uint.MaxValue / _Count < 1U)
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    return (sbyte*) \u003CModule\u003E.@new(_Count);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4ios_base\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Eios_base\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eoverflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Epbackfail);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eshowmanyc);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eunderflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Euflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Exsgetn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Xsgetn_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Exsputn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekoff);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekpos);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetbuf);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esync);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eimbue);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eoverflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Epbackfail);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eshowmanyc);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eunderflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Euflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Exsgetn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Xsgetn_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Exsputn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekoff);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekpos);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esetbuf);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esync);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eimbue);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4_Locimp\u0040locale\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Elocale\u002E_Locimp\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4facet\u0040locale\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Elocale\u002Efacet\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4codecvt_base\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ecodecvt_base\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_always_noconv);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_max_length);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_encoding);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_always_noconv);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_max_length);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_encoding);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_in);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_out);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_unshift);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_length);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_always_noconv);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_max_length);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_encoding);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_in);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_out);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_unshift);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_length);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4ctype_base\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ectype_base\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_tolower);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_tolower);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_toupper);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_toupper);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_widen);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_widen);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002E_Do_widen_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_narrow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_narrow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002E_Do_narrow_s);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_is);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_is);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_scan_is);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_scan_not);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_tolower);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_tolower);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_toupper);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_toupper);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_widen);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_widen);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002E_Do_widen_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_narrow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_narrow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 60) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002E_Do_narrow_s);
  }

  internal static unsafe void \u003FA0xc4d0f765\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_is);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_is);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_scan_is);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_scan_not);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_tolower);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_tolower);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_toupper);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_toupper);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_widen);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_widen);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Do_widen_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_narrow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_narrow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 60) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Do_narrow_s);
  }

  internal static unsafe void std\u002Eios_base\u002E_Callfns([In] ios_base* obj0, ios_base.@event _Ev)
  {
    ios_base._Fnarray* fnarrayPtr = (ios_base._Fnarray*) *(int*) ((IntPtr) obj0 + 32);
    if ((IntPtr) fnarrayPtr == IntPtr.Zero)
      return;
    do
    {
      int num1 = (int) _Ev;
      ios_base* iosBasePtr = obj0;
      int num2 = *(int*) ((IntPtr) fnarrayPtr + 4);
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      __calli((__FnPtr<void (ios_base.@event, ios_base*, int)>) *(int*) ((IntPtr) fnarrayPtr + 8))(num1, iosBasePtr, (ios_base.@event) num2);
      fnarrayPtr = (ios_base._Fnarray*) *(int*) fnarrayPtr;
    }
    while ((IntPtr) fnarrayPtr != IntPtr.Zero);
  }

  internal static unsafe void std\u002Eios_base\u002E_Tidy([In] ios_base* obj0)
  {
    \u003CModule\u003E.std\u002Eios_base\u002E_Callfns(obj0, (ios_base.@event) 0);
    ios_base._Iosarray* iosarrayPtr1 = (ios_base._Iosarray*) *(int*) ((IntPtr) obj0 + 28);
    if ((IntPtr) iosarrayPtr1 != IntPtr.Zero)
    {
      ios_base._Iosarray* iosarrayPtr2;
      do
      {
        iosarrayPtr2 = (ios_base._Iosarray*) *(int*) iosarrayPtr1;
        \u003CModule\u003E.delete((void*) iosarrayPtr1);
        iosarrayPtr1 = iosarrayPtr2;
      }
      while ((IntPtr) iosarrayPtr2 != IntPtr.Zero);
    }
    *(int*) ((IntPtr) obj0 + 28) = 0;
    ios_base._Fnarray* fnarrayPtr1 = (ios_base._Fnarray*) *(int*) ((IntPtr) obj0 + 32);
    if ((IntPtr) fnarrayPtr1 != IntPtr.Zero)
    {
      ios_base._Fnarray* fnarrayPtr2;
      do
      {
        fnarrayPtr2 = (ios_base._Fnarray*) *(int*) fnarrayPtr1;
        \u003CModule\u003E.delete((void*) fnarrayPtr1);
        fnarrayPtr1 = fnarrayPtr2;
      }
      while ((IntPtr) fnarrayPtr2 != IntPtr.Zero);
    }
    *(int*) ((IntPtr) obj0 + 32) = 0;
  }

  internal static unsafe long* std\u002E_Fpz_func() => &\u003CModule\u003E.std\u002E_Fpz;

  internal static unsafe int* std\u002E_BADOFF_func() => &\u003CModule\u003E.std\u002E_BADOFF;

  internal static void \u003FA0x46a0984e\u002E\u003F\u003F__E\u003F_Index\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Index\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA = 0;

  internal static void \u003FA0x46a0984e\u002E\u003F\u003F__E\u003F_Sync\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0_NA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Sync\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0_NA = true;

  internal static unsafe int* std\u002Eios_base\u002E_Index_func() => &\u003CModule\u003E.\u003F_Index\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA;

  internal static unsafe bool* std\u002Eios_base\u002E_Sync_func() => &\u003CModule\u003E.\u003F_Sync\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0_NA;

  internal static unsafe void \u003FA0x46a0984e\u002E\u003F\u003F__E\u003FA0x46a0984e\u0040stdstr\u0040std\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.std\u002E\u003FA0x46a0984e\u002Estdstr = 0;
    // ISSUE: cast to a reference type
    // ISSUE: initblk instruction
    __memset((\u0024ArrayType\u0024\u0024\u0024BY09PAVios_base\u0040std\u0040\u0040&) ((IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x46a0984e\u002Estdstr + 4), 0, 36);
  }

  internal static unsafe void \u003FA0x46a0984e\u002E\u003F\u003F__E\u003FA0x46a0984e\u0040stdopens\u0040std\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ref \u003CModule\u003E.std\u002E\u003FA0x46a0984e\u002Estdopens = (sbyte) 0;
    // ISSUE: cast to a reference type
    // ISSUE: initblk instruction
    __memset((\u0024ArrayType\u0024\u0024\u0024BY09D&) ((IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x46a0984e\u002Estdopens + 1), 0, 9);
  }

  internal static unsafe void std\u002Eios_base\u002E_Ios_base_dtor(ios_base* _param0)
  {
    if (0U < (uint) *(int*) ((IntPtr) _param0 + 4))
    {
      // ISSUE: cast to a reference type
      ref \u0024ArrayType\u0024\u0024\u0024BY09D local = (\u0024ArrayType\u0024\u0024\u0024BY09D&) (*(int*) ((IntPtr) _param0 + 4) + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x46a0984e\u002Estdopens);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ref local = (sbyte) ((int) ^(sbyte&) ref local - 1);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if ((sbyte) 0 < ^(sbyte&) (*(int*) ((IntPtr) _param0 + 4) + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x46a0984e\u002Estdopens))
        return;
    }
    \u003CModule\u003E.std\u002Eios_base\u002E_Tidy(_param0);
    locale* localePtr = (locale*) *(int*) ((IntPtr) _param0 + 36);
    if ((IntPtr) localePtr == IntPtr.Zero)
      return;
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(localePtr);
    \u003CModule\u003E.delete((void*) localePtr);
  }

  internal static unsafe void std\u002Eios_base\u002E_Addstd(ios_base* _param0)
  {
    bool flag = false;
    int num1 = 2;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num1);
        flag = true;
      }
      *(int*) ((IntPtr) _param0 + 4) = 0;
      uint num2;
      uint num3;
      do
      {
        *(int*) ((IntPtr) _param0 + 4) = *(int*) ((IntPtr) _param0 + 4) + 1;
        num2 = (uint) *(int*) ((IntPtr) _param0 + 4);
        if (num2 < 8U)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          num3 = (uint) ^(int&) ((int) num2 * 4 + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x46a0984e\u002Estdstr);
        }
        else
          break;
      }
      while (num3 != 0U && (IntPtr) (int) num3 != (IntPtr) _param0);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((int) num2 * 4 + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x46a0984e\u002Estdstr) = (int) _param0;
      // ISSUE: cast to a reference type
      ref \u0024ArrayType\u0024\u0024\u0024BY09D local = (\u0024ArrayType\u0024\u0024\u0024BY09D&) (*(int*) ((IntPtr) _param0 + 4) + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x46a0984e\u002Estdopens);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ref local = (sbyte) ((int) ^(sbyte&) ref local + 1);
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num1);
    }
  }

  internal static void \u003FA0x98d5b6ac\u002E\u003F\u003F__E\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA = -1;

  internal static unsafe int* std\u002Eios_base\u002EInit\u002E_Init_cnt_func() => &\u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA;

  internal static unsafe void std\u002Eios_base\u002EInit\u002E_Init_ctor(ios_base.Init* _param0)
  {
    if (0 <= \u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA)
      ++\u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA;
    else
      \u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA = 1;
  }

  internal static unsafe void std\u002Eios_base\u002EInit\u002E_Init_dtor(ios_base.Init* _param0)
  {
    --\u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA;
    if (\u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA != 0)
      return;
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_cerr != IntPtr.Zero)
      \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eflush(\u003CModule\u003E.std\u002E_Ptr_cerr);
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_clog != IntPtr.Zero)
      \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eflush(\u003CModule\u003E.std\u002E_Ptr_clog);
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_cout == IntPtr.Zero)
      return;
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eflush(\u003CModule\u003E.std\u002E_Ptr_cout);
  }

  internal static void \u003FA0xf9d05183\u002E\u003F\u003F__E\u003F_Init_cnt\u0040_Winit\u0040std\u0040\u0040\u0024\u0024Q0HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Init_cnt\u0040_Winit\u0040std\u0040\u0040\u0024\u0024Q0HA = -1;

  internal static unsafe void \u003FA0x483a8775\u002E\u003F\u003F__E\u003FA0x483a8775\u0040initlocks\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.std\u002E\u003FA0x483a8775\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x483a8775\u002E\u003F\u003F__F\u003FA0x483a8775\u0040initlocks\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x483a8775\u002E\u003F\u003F__F\u003FA0x483a8775\u0040initlocks\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.std\u002E\u003FA0x483a8775\u002Einitlocks);

  internal static unsafe void \u003FA0x483a8775\u002E\u003F\u003F__E_Ptr_cin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_cin = (basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0x483a8775\u002E\u003F\u003F__E_Ptr_cout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_cout = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0x483a8775\u002E\u003F\u003F__E_Ptr_cerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_cerr = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0x483a8775\u002E\u003F\u003F__E_Ptr_clog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_clog = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0x483a8775\u002E\u003F\u003F__E_Ptr_wcin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wcin = (basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0x483a8775\u002E\u003F\u003F__E_Ptr_wcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wcout = (basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0x483a8775\u002E\u003F\u003F__E_Ptr_wcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wcerr = (basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0x483a8775\u002E\u003F\u003F__E_Ptr_wclog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wclog = (basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0x483a8775\u002E\u003F\u003F__E\u003FA0x483a8775\u0040atfuns_cdecl\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003FA0x483a8775\u002Eatfuns_cdecl = 0;
    // ISSUE: cast to a reference type
    // ISSUE: initblk instruction
    __memset((\u0024ArrayType\u0024\u0024\u0024BY09P6AXXZ&) ((IntPtr) &\u003CModule\u003E.\u003FA0x483a8775\u002Eatfuns_cdecl + 4), 0, 36);
  }

  internal static void \u003FA0x483a8775\u002E\u003F\u003F__E\u003FA0x483a8775\u0040atcount_cdecl\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0x483a8775\u002Eatcount_cdecl = 10U;

  internal static unsafe void _Atexit(__FnPtr<void ()> pf)
  {
    if (\u003CModule\u003E.\u003FA0x483a8775\u002Eatcount_cdecl == 0U)
    {
      \u003CModule\u003E.abort();
    }
    else
    {
      --\u003CModule\u003E.\u003FA0x483a8775\u002Eatcount_cdecl;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((int) \u003CModule\u003E.\u003FA0x483a8775\u002Eatcount_cdecl * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x483a8775\u002Eatfuns_cdecl) = (int) pf;
    }
  }

  internal static unsafe void _Init_atexit\u002E\u007Bdtor\u007D([In] _Init_atexit* obj0)
  {
    if (\u003CModule\u003E.\u003FA0x483a8775\u002Eatcount_cdecl >= 10U)
      return;
    do
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num = ^(int&) ((int) \u003CModule\u003E.\u003FA0x483a8775\u002Eatcount_cdecl * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x483a8775\u002Eatfuns_cdecl);
      ++\u003CModule\u003E.\u003FA0x483a8775\u002Eatcount_cdecl;
      if (num != 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) ^(int&) ((int) \u003CModule\u003E.\u003FA0x483a8775\u002Eatcount_cdecl * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x483a8775\u002Eatfuns_cdecl - 4))();
      }
    }
    while (\u003CModule\u003E.\u003FA0x483a8775\u002Eatcount_cdecl < 10U);
  }

  internal static void \u003FA0x483a8775\u002E\u003F\u003F__E\u003FA0x483a8775\u0040init_atexit\u0040\u0040YMXXZ() => \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x483a8775\u002E\u003F\u003F__F\u003FA0x483a8775\u0040init_atexit\u0040\u0040YMXXZ));

  internal static unsafe void \u003FA0x483a8775\u002E\u003F\u003F__F\u003FA0x483a8775\u0040init_atexit\u0040\u0040YMXXZ() => \u003CModule\u003E._Init_atexit\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x483a8775\u002Einit_atexit);

  internal static unsafe void \u003FA0xc0c0de8a\u002E\u003F\u003F__E_Ptr_wcin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wcin = (basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xc0c0de8a\u002E\u003F\u003F__E_Ptr_wcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wcout = (basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xc0c0de8a\u002E\u003F\u003F__E_Ptr_wcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wcerr = (basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xc0c0de8a\u002E\u003F\u003F__E_Ptr_wclog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wclog = (basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;

  internal static void \u003FA0xc0c0de8a\u002E\u003F\u003F__E\u003F_Init_cnt\u0040_UShinit\u0040std\u0040\u0040\u0024\u0024Q0HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Init_cnt\u0040_UShinit\u0040std\u0040\u0040\u0024\u0024Q0HA = -1;

  internal static unsafe _Locinfo* std\u002E_Locinfo\u002E\u007Bctor\u007D(
    [In] _Locinfo* obj0,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* locstr)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 4));
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 32));
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 60));
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 88));
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002E_Locinfo\u002E_Locinfo_ctor(obj0, locstr);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 88));
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 60));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 32));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    return obj0;
  }

  internal static unsafe void std\u002E_Locinfo\u002E\u007Bdtor\u007D([In] _Locinfo* obj0)
  {
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002E_Locinfo\u002E_Locinfo_dtor(obj0);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 88));
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 88), true, 0U);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 60));
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 60), true, 0U);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 32));
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 32), true, 0U);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 4), true, 0U);
  }

  internal static unsafe uint std\u002Elocale\u002Eid\u002E\u002EI([In] locale.id* obj0)
  {
    if (*(int*) obj0 == 0)
    {
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        if (*(int*) obj0 == 0)
        {
          ++\u003CModule\u003E.\u003F_Id_cnt\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0HA;
          *(int*) obj0 = \u003CModule\u003E.\u003F_Id_cnt\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0HA;
        }
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    return (uint) *(int*) obj0;
  }

  internal static unsafe void std\u002Elocale\u002Efacet\u002E_Register([In] locale.facet* obj0) => \u003CModule\u003E.std\u002Elocale\u002Efacet\u002Efacet_Register_m(obj0);

  internal static unsafe locale* std\u002Elocale\u002E\u007Bctor\u007D([In] locale* obj0)
  {
    *(int*) obj0 = (int) \u003CModule\u003E.std\u002Elocale\u002E_Init();
    \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref((locale.facet*) \u003CModule\u003E.std\u002Elocale\u002E_Getgloballocale());
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Elocale\u002Ename(
    [In] locale* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) (*(int*) obj0 + 24));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe locale.facet* std\u002Elocale\u002E_Getfacet([In] locale* obj0, uint _Id)
  {
    int num = *(int*) obj0;
    locale.facet* facetPtr = _Id >= (uint) *(int*) (num + 12) ? (locale.facet*) 0 : (locale.facet*) *(int*) ((int) _Id * 4 + *(int*) (num + 8));
    if ((IntPtr) facetPtr != IntPtr.Zero || *(byte*) (num + 20) == (byte) 0)
      return facetPtr;
    locale._Locimp* locimpPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getgloballocale();
    return _Id < (uint) *(int*) ((IntPtr) locimpPtr + 12) ? (locale.facet*) *(int*) ((int) _Id * 4 + *(int*) ((IntPtr) locimpPtr + 8)) : (locale.facet*) 0;
  }

  internal static unsafe ctype\u003Cchar\u003E* std\u002Ectype\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] ctype\u003Cchar\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 4);
      _Ctypevec ctypevec = \u003CModule\u003E._Getctype();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref ctypevec, 16);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Ectype\u003Cchar\u003E\u002E_Getcat(
    locale.facet** _Ppf,
    locale* _Ploc)
  {
    uint num1 = 0;
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      ctype\u003Cchar\u003E* ctypeCharPtr1 = (ctype\u003Cchar\u003E*) \u003CModule\u003E.@new(24U);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
      _Locinfo locinfo;
      ctype\u003Cchar\u003E* ctypeCharPtr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) ctypeCharPtr1 != IntPtr.Zero)
        {
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* locstr = \u003CModule\u003E.std\u002Elocale\u002Ename(_Ploc, &stdAllocatorChar);
          // ISSUE: fault handler
          try
          {
            num1 = 1U;
            _Locinfo* _Lobj = \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, locstr);
            // ISSUE: fault handler
            try
            {
              num1 = 3U;
              ctypeCharPtr2 = \u003CModule\u003E.std\u002Ectype\u003Cchar\u003E\u002E\u007Bctor\u007D(ctypeCharPtr1, _Lobj, 0U);
            }
            __fault
            {
              if (((int) num1 & 2) != 0)
              {
                num1 &= 4294967293U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
              }
            }
          }
          __fault
          {
            if (((int) num1 & 1) != 0)
            {
              num1 &= 4294967294U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
            }
          }
        }
        else
          ctypeCharPtr2 = (ctype\u003Cchar\u003E*) 0;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) ctypeCharPtr1);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          *(int*) _Ppf = (int) ctypeCharPtr2;
        }
        __fault
        {
          if (((int) num1 & 2) != 0)
          {
            num1 &= 4294967293U;
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
          }
        }
        if (((int) num1 & 2) != 0)
        {
          num1 &= 4294967293U;
          \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
        }
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
        }
      }
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      }
    }
    return 2;
  }

  internal static unsafe locale* std\u002Eios_base\u002Egetloc([In] ios_base* obj0, [In] locale* obj1)
  {
    uint num1 = 0;
    int num2 = *(int*) *(int*) ((IntPtr) obj0 + 36);
    *(int*) obj1 = num2;
    \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref((locale.facet*) num2);
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num3 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe void std\u002Eios_base\u002E_Init([In] ios_base* obj0)
  {
    *(int*) ((IntPtr) obj0 + 36) = 0;
    *(int*) ((IntPtr) obj0 + 4) = 0;
    *(int*) ((IntPtr) obj0 + 12) = 0;
    *(int*) ((IntPtr) obj0 + 16) = 513;
    *(int*) ((IntPtr) obj0 + 20) = 6;
    *(int*) ((IntPtr) obj0 + 24) = 0;
    *(int*) ((IntPtr) obj0 + 28) = 0;
    *(int*) ((IntPtr) obj0 + 32) = 0;
    \u003CModule\u003E.std\u002Eios_base\u002Eclear(obj0, 0, false);
    locale* localePtr1 = (locale*) \u003CModule\u003E.@new(4U);
    locale* localePtr2 = (IntPtr) localePtr1 == IntPtr.Zero ? (locale*) 0 : \u003CModule\u003E.std\u002Elocale\u002E\u007Bctor\u007D(localePtr1);
    *(int*) ((IntPtr) obj0 + 36) = (int) localePtr2;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Fgetc\u003Cchar\u003E(sbyte* _Byte, _iobuf* _File)
  {
    int num = \u003CModule\u003E.fgetc(_File);
    if (num == -1)
      return false;
    *_Byte = (sbyte) num;
    return true;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Fputc\u003Cchar\u003E(sbyte _Byte, _iobuf* _File) => \u003CModule\u003E.fputc((int) _Byte, _File) != -1;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Ungetc\u003Cchar\u003E(sbyte* _Byte, _iobuf* _File) => \u003CModule\u003E.ungetc((int) (byte) *_Byte, _File) != -1;

  internal static unsafe void \u003FA0x8507841e\u002E\u003F\u003F__E\u003FA0x8507841e\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x8507841e\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x8507841e\u002E\u003F\u003F__F\u003FA0x8507841e\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x8507841e\u002E\u003F\u003F__F\u003FA0x8507841e\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x8507841e\u002Einitlocks);

  internal static unsafe void \u003FA0x8507841e\u002E\u003F\u003F__E\u003FA0x8507841e\u0040ferr\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x8507841e\u002Eferr, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x8507841e\u002E\u003F\u003F__F\u003FA0x8507841e\u0040ferr\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x8507841e\u002E\u003F\u003F__F\u003FA0x8507841e\u0040ferr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x8507841e\u002Eferr);

  internal static unsafe void \u003FA0x8507841e\u002E\u003F\u003F__Ecerr\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ecerr, (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x8507841e\u002Eferr, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x8507841e\u002E\u003F\u003F__Fcerr\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x8507841e\u002E\u003F\u003F__Fcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ecerr);

  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Cerr_func() => &\u003CModule\u003E.std\u002Ecerr;

  internal static unsafe _Init_cerr* std\u002E_Init_cerr\u002E\u007Bctor\u007D(
    [In] _Init_cerr* obj0)
  {
    \u003CModule\u003E.std\u002E_Ptr_cerr = &\u003CModule\u003E.std\u002Ecerr;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ecerr + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ecerr + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_cout;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ios_base* iosBasePtr = (ios_base*) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ecerr + 4) + (IntPtr) &\u003CModule\u003E.std\u002Ecerr);
    *(int*) ((IntPtr) iosBasePtr + 16) = *(int*) ((IntPtr) iosBasePtr + 16) | 2;
    return obj0;
  }

  internal static unsafe void \u003FA0x8507841e\u002E\u003F\u003F__E\u003FA0x8507841e\u0040init_cerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_cerr\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x8507841e\u002Einit_cerr);

  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd,
    [In] int obj3)
  {
    uint num1 = 0;
    if (obj3 != 0)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_8\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
      basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* pThis = (basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
      *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
      // ISSUE: fault handler
      try
      {
        *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
        }
      }
    }
    // ISSUE: fault handler
    try
    {
      *(int*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Einit((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _Strbuf, _Isstd);
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
      }
    }
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      if (*(byte*) ((IntPtr) obj0 + 72) != (byte) 0)
        \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0);
  }

  internal static unsafe basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    _iobuf* _File)
  {
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init(obj0, _File, (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E._Initfl) 0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eoverflow(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    int _Meta)
  {
    if (-1 == _Meta)
      return _Meta == -1 ? 0 : _Meta;
    int num1 = *(int*) ((IntPtr) obj0 + 36);
    if (*(int*) num1 != 0)
    {
      int num2 = *(int*) num1;
      if ((uint) num2 < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 52) + num2))
      {
        *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Pninc((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0) = (sbyte) _Meta;
        return _Meta;
      }
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U)
      return -1;
    if (*(int*) ((IntPtr) obj0 + 60) == 0)
      return \u003CModule\u003E.std\u002E_Fputc\u003Cchar\u003E((sbyte) _Meta, (_iobuf*) _File) ? _Meta : -1;
    sbyte _Byte = (sbyte) _Meta;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 8U, (sbyte) 0);
    int num3;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      sbyte* numPtr1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num4 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
      sbyte* _First2_1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
      sbyte* numPtr2;
      sbyte* numPtr3;
      int num5 = \u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Eout((codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) ((IntPtr) obj0 + 68), &_Byte, &_Byte + 1, &numPtr2, _First2_1, (sbyte*) ((int) num4 + (IntPtr) numPtr1), &numPtr3);
      if (num5 >= 0)
      {
        do
        {
          if (num5 <= 1)
          {
            _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
            sbyte* numPtr4 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
            uint num6 = (uint) ((IntPtr) numPtr3 - (IntPtr) numPtr4);
            if (0U < num6)
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
              sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5));
              if ((int) num6 != (int) \u003CModule\u003E.fwrite((void*) numPtr5, 1U, num6, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
                goto label_27;
            }
            *(sbyte*) ((IntPtr) obj0 + 65) = (sbyte) 1;
            if ((IntPtr) numPtr2 == ref _Byte)
            {
              if (0U >= num6)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if ((uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) < 32U)
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 8U, (sbyte) 0);
                else
                  goto label_29;
              }
              sbyte* numPtr6 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              uint num7 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
              sbyte* _First2_2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
              num5 = \u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Eout((codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) ((IntPtr) obj0 + 68), &_Byte, &_Byte + 1, &numPtr2, _First2_2, (sbyte*) ((int) num7 + (IntPtr) numPtr6), &numPtr3);
            }
            else
              goto label_28;
          }
          else
            goto label_23;
        }
        while (num5 >= 0);
        goto label_30;
label_23:
        if (num5 == 3)
          num3 = !\u003CModule\u003E.std\u002E_Fputc\u003Cchar\u003E(_Byte, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)) ? -1 : _Meta;
        else
          goto label_30;
      }
      else
        goto label_30;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num3;
label_27:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return -1;
label_28:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return _Meta;
label_29:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return -1;
label_30:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return -1;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Epbackfail(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    int _Meta)
  {
    int num1 = *(int*) *(int*) ((IntPtr) obj0 + 32);
    if (num1 != 0 && (uint) *(int*) *(int*) ((IntPtr) obj0 + 16) < (uint) num1 && (-1 == _Meta || (int) (byte) *(sbyte*) (num1 - 1) == _Meta))
    {
      int num2 = *(int*) ((IntPtr) obj0 + 48);
      *(int*) num2 = *(int*) num2 + 1;
      int num3 = *(int*) ((IntPtr) obj0 + 32);
      *(int*) num3 = *(int*) num3 - 1;
      return _Meta == -1 ? 0 : _Meta;
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    return _File != 0U && -1 != _Meta && *(int*) ((IntPtr) obj0 + 60) == 0 && \u003CModule\u003E.std\u002E_Ungetc\u003Cchar\u003E(&(sbyte) _Meta, (_iobuf*) _File) ? _Meta : -1;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eunderflow(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) *(int*) ((IntPtr) obj0 + 32);
    if (num1 != 0)
    {
      uint num2 = (uint) *(int*) *(int*) ((IntPtr) obj0 + 32);
      if (num2 < (uint) *(int*) *(int*) ((IntPtr) obj0 + 48) + num2)
        return (int) (byte) *(sbyte*) num1;
    }
    basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) stdCharTraitsCharPtr1 + 20))((IntPtr) stdCharTraitsCharPtr1);
    if (-1 == num3)
      return num3;
    basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = obj0;
    int num4 = num3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = __calli((__FnPtr<int (IntPtr, int)>) *(int*) (*(int*) obj0 + 8))((int) stdCharTraitsCharPtr2, (IntPtr) num4);
    return num3;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Euflow(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    if (*(int*) *(int*) ((IntPtr) obj0 + 32) != 0)
    {
      int num = *(int*) *(int*) ((IntPtr) obj0 + 32);
      if ((uint) num < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 48) + num))
        return (int) (byte) *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Gninc((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0);
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U)
      return -1;
    if (*(int*) ((IntPtr) obj0 + 60) == 0)
    {
      sbyte num;
      return \u003CModule\u003E.std\u002E_Fgetc\u003Cchar\u003E(&num, (_iobuf*) _File) ? (int) (byte) num : -1;
    }
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, false, 0U);
    sbyte* numPtr1;
    sbyte num1;
    // ISSUE: fault handler
    try
    {
      int _Ch = \u003CModule\u003E.fgetc((_iobuf*) *(int*) ((IntPtr) obj0 + 76));
      if (_Ch != -1)
      {
        basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _State = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 68);
        do
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 1U, (sbyte) _Ch);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          sbyte* numPtr2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num2 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          sbyte* _First1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
          sbyte* numPtr3;
          int num3 = \u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Ein((codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) _State, _First1, numPtr2 + (int) num2, &numPtr1, &num1, &num1 + 1, &numPtr3);
          if (num3 >= 0)
          {
            if (num3 > 1)
            {
              if (num3 == 3)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if ((uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) >= 1U)
                  goto label_21;
              }
              else
                goto label_29;
            }
            else if ((IntPtr) numPtr3 == ref num1)
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              sbyte* numPtr4 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(&stdAllocatorChar1, 0U, (uint) ((IntPtr) numPtr1 - (IntPtr) numPtr4));
            }
            else
              goto label_24;
            _Ch = \u003CModule\u003E.fgetc((_iobuf*) *(int*) ((IntPtr) obj0 + 76));
          }
          else
            goto label_29;
        }
        while (_Ch != -1);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return -1;
label_21:
    int num4;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5);
      \u003CModule\u003E.memcpy_s((void*) &num1, 1U, (void*) \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) stdAllocatorCharPtr), 1U);
      num4 = (int) (byte) num1;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num4;
label_24:
    int num5;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
      sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar6));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num6 = (int) (^(int&) ((IntPtr) &stdAllocatorChar1 + 20) - (IntPtr) numPtr1 + (IntPtr) numPtr5);
      if (0 < num6)
      {
        do
        {
          --num6;
          \u003CModule\u003E.ungetc((int) *(sbyte*) (num6 + (IntPtr) numPtr1), (_iobuf*) *(int*) ((IntPtr) obj0 + 76));
        }
        while (num6 > 0);
      }
      num5 = (int) (byte) num1;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num5;
label_29:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return -1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekoff(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    int _Off,
    int _Way,
    int __unnamed002)
  {
    if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) obj0 + 64 && _Way == 1 && *(int*) ((IntPtr) obj0 + 60) == 0)
      --_Off;
    long num;
    if (*(int*) ((IntPtr) obj0 + 76) != 0 && \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Endwrite(obj0) && (_Off == 0 && _Way == 1 || \u003CModule\u003E.fseek((_iobuf*) *(int*) ((IntPtr) obj0 + 76), _Off, _Way) == 0) && \u003CModule\u003E.fgetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num) == 0)
    {
      if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) obj0 + 64)
      {
        sbyte* numPtr = (sbyte*) ((IntPtr) obj0 + 65);
        *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) ((IntPtr) obj0 + 64);
        *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) numPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) numPtr + 65);
      }
      *(int*) obj1 = 0;
      *(long*) ((IntPtr) obj1 + 8) = num;
      *(int*) ((IntPtr) obj1 + 16) = *(int*) ((IntPtr) obj0 + 68);
      return obj1;
    }
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekpos(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    fpos\u003Cint\u003E _Pos,
    int __unnamed001)
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    long num1 = ^(long&) ((IntPtr) &_Pos + 8);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    int num2 = ^(int&) ref _Pos;
    if (*(int*) ((IntPtr) obj0 + 76) != 0 && \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Endwrite(obj0) && \u003CModule\u003E.fsetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num1) == 0 && (num2 == 0 || \u003CModule\u003E.fseek((_iobuf*) *(int*) ((IntPtr) obj0 + 76), num2, 1) == 0) && \u003CModule\u003E.fgetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num1) == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      *(int*) ((IntPtr) obj0 + 68) = ^(int&) ((IntPtr) &_Pos + 16);
      basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 64);
      if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) stdCharTraitsCharPtr)
      {
        sbyte* numPtr = (sbyte*) ((IntPtr) obj0 + 65);
        *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) stdCharTraitsCharPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) numPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) numPtr + 65);
      }
      *(int*) obj1 = 0;
      *(long*) ((IntPtr) obj1 + 8) = num1;
      *(int*) ((IntPtr) obj1 + 16) = *(int*) ((IntPtr) obj0 + 68);
      return obj1;
    }
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetbuf(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Buffer,
    int _Count)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (num1 != 0U)
    {
      int num2 = (IntPtr) _Buffer != IntPtr.Zero || _Count != 0 ? 0 : 4;
      if (\u003CModule\u003E.setvbuf((_iobuf*) num1, _Buffer, num2, (uint) _Count) == 0)
      {
        basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
        int _File = *(int*) ((IntPtr) stdCharTraitsCharPtr + 76);
        \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init(stdCharTraitsCharPtr, (_iobuf*) _File, (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E._Initfl) 1);
        return (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0;
      }
    }
    return (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esync(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    int num;
    if (*(int*) ((IntPtr) obj0 + 76) != 0)
    {
      basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      if (-1 != __calli((__FnPtr<int (IntPtr, int)>) *(int*) (*(int*) obj0 + 4))((int) stdCharTraitsCharPtr, new IntPtr(-1)) && 0 > \u003CModule\u003E.fflush((_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
      {
        num = -1;
        goto label_4;
      }
    }
    num = 0;
label_4:
    return num;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eimbue(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    locale* _Loc)
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Initcvt(obj0, \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u0020\u003E(_Loc));
  }

  internal static unsafe void* std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 80U, *(int*) stdCharTraitsCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) stdCharTraitsCharPtr);
      return (void*) stdCharTraitsCharPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Einit(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd)
  {
    \u003CModule\u003E.std\u002Eios_base\u002E_Init((ios_base*) obj0);
    *(int*) ((IntPtr) obj0 + 40) = (int) _Strbuf;
    *(int*) ((IntPtr) obj0 + 44) = 0;
    *(sbyte*) ((IntPtr) obj0 + 48) = \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Ewiden(obj0, (sbyte) 32);
    if (*(int*) ((IntPtr) obj0 + 40) == 0)
    {
      basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
      int _State = *(int*) ((IntPtr) stdCharTraitsCharPtr + 8) | 4;
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclear(stdCharTraitsCharPtr, _State, false);
    }
    if (_Isstd)
      \u003CModule\u003E.std\u002Eios_base\u002E_Addstd((ios_base*) obj0);
    else
      *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_ctor((_Mutex*) ((IntPtr) obj0 + 4));
    // ISSUE: fault handler
    try
    {
      locale* localePtr1 = (locale*) \u003CModule\u003E.@new(4U);
      locale* localePtr2 = (IntPtr) localePtr1 == IntPtr.Zero ? (locale*) 0 : \u003CModule\u003E.std\u002Elocale\u002E\u007Bctor\u007D(localePtr1);
      *(int*) ((IntPtr) obj0 + 56) = (int) localePtr2;
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mutex\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    return obj0;
  }

  internal static unsafe basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    if (*(int*) ((IntPtr) obj0 + 76) == 0)
    {
      stdCharTraitsCharPtr = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;
    }
    else
    {
      if (!\u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Endwrite(obj0))
        stdCharTraitsCharPtr = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;
      if (\u003CModule\u003E.fclose((_iobuf*) *(int*) ((IntPtr) obj0 + 76)) != 0)
        stdCharTraitsCharPtr = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;
    }
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init(obj0, (_iobuf*) 0, (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E._Initfl) 2);
    return stdCharTraitsCharPtr;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    _iobuf* _File,
    basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E._Initfl _Which)
  {
    int num = _Which == (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E._Initfl) 1 ? 1 : 0;
    *(sbyte*) ((IntPtr) obj0 + 72) = (sbyte) num;
    *(sbyte*) ((IntPtr) obj0 + 65) = (sbyte) 0;
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0);
    if ((IntPtr) _File != IntPtr.Zero)
    {
      sbyte** numPtr = (sbyte**) ((IntPtr) _File + 8);
      *(int*) ((IntPtr) obj0 + 16) = (int) numPtr;
      *(int*) ((IntPtr) obj0 + 20) = (int) numPtr;
      *(int*) ((IntPtr) obj0 + 32) = (int) _File;
      *(int*) ((IntPtr) obj0 + 36) = (int) _File;
      _iobuf* iobufPtr = (_iobuf*) ((IntPtr) _File + 4);
      *(int*) ((IntPtr) obj0 + 48) = (int) iobufPtr;
      *(int*) ((IntPtr) obj0 + 52) = (int) iobufPtr;
    }
    *(int*) ((IntPtr) obj0 + 76) = (int) _File;
    *(int*) ((IntPtr) obj0 + 68) = \u003CModule\u003E.\u003F_Stinit\u0040\u003F1\u003F\u003F_Init\u0040\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040IAMXPAU_iobuf\u0040\u0040W4_Initfl\u004023\u0040\u0040Z\u00404HA;
    *(int*) ((IntPtr) obj0 + 60) = 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Endwrite(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    if (*(int*) ((IntPtr) obj0 + 60) == 0 || *(byte*) ((IntPtr) obj0 + 65) == (byte) 0)
      return true;
    basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    if (-1 == __calli((__FnPtr<int (IntPtr, int)>) *(int*) (*(int*) obj0 + 4))((int) stdCharTraitsCharPtr1, new IntPtr(-1)))
      return false;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 8U, (sbyte) 0);
    // ISSUE: fault handler
    try
    {
      basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 68);
      while (true)
      {
        uint num1;
        do
        {
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          sbyte* numPtr1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num2 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          sbyte* numPtr2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
          codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr1 = (codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60);
          codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr2 = codecvtCharCharIntPtr1;
          basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr3 = stdCharTraitsCharPtr2;
          sbyte* numPtr3 = numPtr2;
          IntPtr num3 = (int) num2 + (IntPtr) numPtr1;
          sbyte* numPtr4;
          ref sbyte* local = ref numPtr4;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          switch (__calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) codecvtCharCharIntPtr1 + 24))((sbyte**) codecvtCharCharIntPtr2, (sbyte*) stdCharTraitsCharPtr3, numPtr3, (int*) num3, (IntPtr) ref local))
          {
            case 0:
              *(sbyte*) ((IntPtr) obj0 + 65) = (sbyte) 0;
              goto case 1;
            case 1:
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
              num1 = (uint) ((IntPtr) numPtr4 - (IntPtr) numPtr5);
              if (0U < num1)
              {
                _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
                sbyte* numPtr6 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5));
                if ((int) num1 != (int) \u003CModule\u003E.fwrite((void*) numPtr6, 1U, num1, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
                  goto label_15;
              }
              if (*(byte*) ((IntPtr) obj0 + 65) != (byte) 0)
                continue;
              goto label_16;
            case 3:
              goto label_14;
            default:
              goto label_13;
          }
        }
        while (num1 != 0U);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 8U, (sbyte) 0);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
label_13:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return false;
label_14:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return true;
label_15:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return false;
label_16:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return true;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Initcvt(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    codecvt\u003Cchar\u002Cchar\u002Cint\u003E* _Newpcvt)
  {
    codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr = _Newpcvt;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    if (__calli((__FnPtr<byte (IntPtr)>) *(int*) (*(int*) codecvtCharCharIntPtr + 4))((IntPtr) codecvtCharCharIntPtr) != (byte) 0)
    {
      *(int*) ((IntPtr) obj0 + 60) = 0;
    }
    else
    {
      *(int*) ((IntPtr) obj0 + 60) = (int) _Newpcvt;
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0);
    }
  }

  internal static unsafe int std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Ein(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    sbyte** _Mid1,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr = obj0;
    int* numPtr1 = _State;
    sbyte* numPtr2 = _First1;
    sbyte* numPtr3 = _Last1;
    sbyte** numPtr4 = _Mid1;
    sbyte* numPtr5 = _First2;
    sbyte* numPtr6 = _Last2;
    sbyte** numPtr7 = _Mid2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) obj0 + 16))((sbyte**) codecvtCharCharIntPtr, (sbyte*) numPtr1, numPtr2, (sbyte**) numPtr3, (sbyte*) numPtr4, numPtr5, (int*) numPtr6, (IntPtr) numPtr7);
  }

  internal static unsafe int std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Eout(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    sbyte** _Mid1,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr = obj0;
    int* numPtr1 = _State;
    sbyte* numPtr2 = _First1;
    sbyte* numPtr3 = _Last1;
    sbyte** numPtr4 = _Mid1;
    sbyte* numPtr5 = _First2;
    sbyte* numPtr6 = _Last2;
    sbyte** numPtr7 = _Mid2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) obj0 + 20))((sbyte**) codecvtCharCharIntPtr, (sbyte*) numPtr1, numPtr2, (sbyte**) numPtr3, (sbyte*) numPtr4, numPtr5, (int*) numPtr6, (IntPtr) numPtr7);
  }

  internal static unsafe void std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe int std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_in(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    int* __unnamed000,
    sbyte* _First1,
    sbyte* __unnamed002,
    sbyte** _Mid1,
    sbyte* _First2,
    sbyte* __unnamed005,
    sbyte** _Mid2)
  {
    *(int*) _Mid1 = (int) _First1;
    *(int*) _Mid2 = (int) _First2;
    return 3;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_out(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    int* __unnamed000,
    sbyte* _First1,
    sbyte* __unnamed002,
    sbyte** _Mid1,
    sbyte* _First2,
    sbyte* __unnamed005,
    sbyte** _Mid2)
  {
    *(int*) _Mid1 = (int) _First1;
    *(int*) _Mid2 = (int) _First2;
    return 3;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_unshift(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    int* __unnamed000,
    sbyte* _First2,
    sbyte* __unnamed002,
    sbyte** _Mid2)
  {
    *(int*) _Mid2 = (int) _First2;
    return 3;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_length(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    int* __unnamed000,
    sbyte* _First1,
    sbyte* _Last1,
    uint _Count)
  {
    sbyte* numPtr = (sbyte*) ((IntPtr) _Last1 - (IntPtr) _First1);
    return (UIntPtr) (int) _Count < (UIntPtr) numPtr ? (int) _Count : (int) numPtr;
  }

  internal static unsafe void* std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E__vecDelDtor(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr = (codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) codecvtCharCharIntPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) codecvtCharCharIntPtr);
      return (void*) codecvtCharCharIntPtr;
    }
    \u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe sbyte std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Ewiden(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte _Byte)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc((ios_base*) obj0, &locale);
    ctype\u003Cchar\u003E* ctypeCharPtr1;
    // ISSUE: fault handler
    try
    {
      ctypeCharPtr1 = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cchar\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    ctype\u003Cchar\u003E* ctypeCharPtr2 = ctypeCharPtr1;
    int num = (int) _Byte;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte (IntPtr, sbyte)>) *(int*) (*(int*) ctypeCharPtr1 + 24))((sbyte) ctypeCharPtr2, (IntPtr) num);
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 16) = (int) ((IntPtr) obj0 + 8);
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12);
    *(int*) ((IntPtr) obj0 + 20) = (int) stdCharTraitsCharPtr;
    *(int*) ((IntPtr) obj0 + 32) = (int) ((IntPtr) obj0 + 24);
    *(int*) ((IntPtr) obj0 + 36) = (int) ((IntPtr) obj0 + 28);
    *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 + 40);
    *(int*) ((IntPtr) obj0 + 52) = (int) ((IntPtr) obj0 + 44);
    *(int*) stdCharTraitsCharPtr = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 36) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 52) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 16) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 32) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 48) = 0;
  }

  internal static unsafe ctype\u003Cchar\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cchar\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ectype\u003Cchar\u003E\u002E_Getcat(&pbVfacetLocale2B, _Loc) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (ctype\u003Cchar\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe codecvt\u003Cchar\u002Cchar\u002Cint\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E_Getcat(&pbVfacetLocale2B, _Loc) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe uint std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E_Getcat(
    locale.facet** _Ppf,
    locale* _Ploc)
  {
    uint num1 = 0;
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr1 = (codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) \u003CModule\u003E.@new(8U);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
      _Locinfo locinfo;
      codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) codecvtCharCharIntPtr1 != IntPtr.Zero)
        {
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* locstr = \u003CModule\u003E.std\u002Elocale\u002Ename(_Ploc, &stdAllocatorChar);
          // ISSUE: fault handler
          try
          {
            num1 = 1U;
            _Locinfo* _Lobj = \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, locstr);
            // ISSUE: fault handler
            try
            {
              num1 = 3U;
              codecvtCharCharIntPtr2 = \u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(codecvtCharCharIntPtr1, _Lobj, 0U);
            }
            __fault
            {
              if (((int) num1 & 2) != 0)
              {
                num1 &= 4294967293U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
              }
            }
          }
          __fault
          {
            if (((int) num1 & 1) != 0)
            {
              num1 &= 4294967294U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
            }
          }
        }
        else
          codecvtCharCharIntPtr2 = (codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) 0;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) codecvtCharCharIntPtr1);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          *(int*) _Ppf = (int) codecvtCharCharIntPtr2;
        }
        __fault
        {
          if (((int) num1 & 2) != 0)
          {
            num1 &= 4294967293U;
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
          }
        }
        if (((int) num1 & 2) != 0)
        {
          num1 &= 4294967293U;
          \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
        }
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
        }
      }
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      }
    }
    return 2;
  }

  internal static unsafe codecvt\u003Cchar\u002Cchar\u002Cint\u003E* std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void \u003FA0x8507841e\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static void \u003FA0x8507841e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe void \u003FA0x8507841e\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eoverflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Epbackfail);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eshowmanyc);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eunderflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Euflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Exsgetn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Xsgetn_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Exsputn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekoff);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekpos);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetbuf);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esync);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eimbue);
  }

  internal static unsafe void \u003FA0x8507841e\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_always_noconv);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_max_length);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_encoding);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_in);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_out);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_unshift);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_length);
  }

  internal static unsafe void \u003FA0x0bf8a0f9\u002E\u003F\u003F__E\u003FA0x0bf8a0f9\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x0bf8a0f9\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x0bf8a0f9\u002E\u003F\u003F__F\u003FA0x0bf8a0f9\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x0bf8a0f9\u002E\u003F\u003F__F\u003FA0x0bf8a0f9\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x0bf8a0f9\u002Einitlocks);

  internal static unsafe void \u003FA0x0bf8a0f9\u002E\u003F\u003F__E\u003FA0x0bf8a0f9\u0040fin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x0bf8a0f9\u002Efin, \u003CModule\u003E.__iob_func());
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x0bf8a0f9\u002E\u003F\u003F__F\u003FA0x0bf8a0f9\u0040fin\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x0bf8a0f9\u002E\u003F\u003F__F\u003FA0x0bf8a0f9\u0040fin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x0bf8a0f9\u002Efin);

  internal static unsafe void \u003FA0x0bf8a0f9\u002E\u003F\u003F__Ecin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ecin, (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x0bf8a0f9\u002Efin, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x0bf8a0f9\u002E\u003F\u003F__Fcin\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x0bf8a0f9\u002E\u003F\u003F__Fcin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ecin);

  internal static unsafe basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Cin_func() => &\u003CModule\u003E.std\u002Ecin;

  internal static unsafe void \u003FA0x0bf8a0f9\u002E\u003F\u003F__E\u003FA0x0bf8a0f9\u0040init_cin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Ptr_cin = &\u003CModule\u003E.std\u002Ecin;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ecin + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ecin + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_cout;
  }

  internal static unsafe basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd,
    [In] int obj3)
  {
    uint num1 = 0;
    if (obj3 != 0)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_8\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
      basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* pThis = (basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
      *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
      // ISSUE: fault handler
      try
      {
        *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
        }
      }
    }
    // ISSUE: fault handler
    try
    {
      *(int*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 4) = 0;
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Einit((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _Strbuf, _Isstd);
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
      }
    }
    return obj0;
  }

  internal static unsafe void \u003FA0xcf5af113\u002E\u003F\u003F__E\u003FA0xcf5af113\u0040flog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xcf5af113\u002Eflog, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xcf5af113\u002E\u003F\u003F__F\u003FA0xcf5af113\u0040flog\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xcf5af113\u002E\u003F\u003F__F\u003FA0xcf5af113\u0040flog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xcf5af113\u002Eflog);

  internal static unsafe void \u003FA0xcf5af113\u002E\u003F\u003F__Eclog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Eclog, (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0xcf5af113\u002Eflog, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xcf5af113\u002E\u003F\u003F__Fclog\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xcf5af113\u002E\u003F\u003F__Fclog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Eclog);

  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Clog_func() => &\u003CModule\u003E.std\u002Eclog;

  internal static unsafe void \u003FA0xcf5af113\u002E\u003F\u003F__E\u003FA0xcf5af113\u0040init_clog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Ptr_clog = &\u003CModule\u003E.std\u002Eclog;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Eclog + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Eclog + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_cout;
  }

  internal static unsafe void \u003FA0x07394545\u002E\u003F\u003F__E\u003FA0x07394545\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x07394545\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x07394545\u002E\u003F\u003F__F\u003FA0x07394545\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x07394545\u002E\u003F\u003F__F\u003FA0x07394545\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x07394545\u002Einitlocks);

  internal static unsafe void \u003FA0x07394545\u002E\u003F\u003F__E\u003FA0x07394545\u0040fout\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x07394545\u002Efout, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 32));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x07394545\u002E\u003F\u003F__F\u003FA0x07394545\u0040fout\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x07394545\u002E\u003F\u003F__F\u003FA0x07394545\u0040fout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x07394545\u002Efout);

  internal static unsafe void \u003FA0x07394545\u002E\u003F\u003F__Ecout\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ecout, (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x07394545\u002Efout, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x07394545\u002E\u003F\u003F__Fcout\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x07394545\u002E\u003F\u003F__Fcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ecout);

  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Cout_func() => &\u003CModule\u003E.std\u002Ecout;

  internal static unsafe _Init_cout* std\u002E_Init_cout\u002E\u007Bctor\u007D(
    [In] _Init_cout* obj0)
  {
    \u003CModule\u003E.std\u002E_Ptr_cout = &\u003CModule\u003E.std\u002Ecout;
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_cin != IntPtr.Zero)
    {
      basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdPtrCin = \u003CModule\u003E.std\u002E_Ptr_cin;
      int num = *(int*) (*(int*) stdPtrCin + 4);
      *(int*) ((IntPtr) stdPtrCin + num + 44) = (int) &\u003CModule\u003E.std\u002Ecout;
    }
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_cerr != IntPtr.Zero)
    {
      basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdPtrCerr = \u003CModule\u003E.std\u002E_Ptr_cerr;
      int num = *(int*) (*(int*) stdPtrCerr + 4);
      *(int*) ((IntPtr) stdPtrCerr + num + 44) = (int) \u003CModule\u003E.std\u002E_Ptr_cout;
    }
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_clog != IntPtr.Zero)
    {
      basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdPtrClog = \u003CModule\u003E.std\u002E_Ptr_clog;
      int num = *(int*) (*(int*) stdPtrClog + 4);
      *(int*) ((IntPtr) stdPtrClog + num + 44) = (int) \u003CModule\u003E.std\u002E_Ptr_cout;
    }
    return obj0;
  }

  internal static unsafe void \u003FA0x07394545\u002E\u003F\u003F__E\u003FA0x07394545\u0040init_cout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_cout\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x07394545\u002Einit_cout);

  internal static unsafe ushort std\u002Echar_traits\u003Cunsigned\u0020short\u003E\u002Enot_eof(
    ushort* _Meta)
  {
    ushort num = *_Meta;
    return num == ushort.MaxValue ? (ushort) 0 : num;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Ein(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    sbyte** _Mid1,
    ushort* _First2,
    ushort* _Last2,
    ushort** _Mid2)
  {
    codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr = obj0;
    int* numPtr1 = _State;
    sbyte* numPtr2 = _First1;
    sbyte* numPtr3 = _Last1;
    sbyte** numPtr4 = _Mid1;
    ushort* numPtr5 = _First2;
    ushort* numPtr6 = _Last2;
    ushort** numPtr7 = _Mid2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**, ushort*, ushort*, ushort**)>) *(int*) (*(int*) obj0 + 16))((ushort**) unsignedShortCharIntPtr, (ushort*) numPtr1, (ushort*) numPtr2, (sbyte**) numPtr3, (sbyte*) numPtr4, (sbyte*) numPtr5, (int*) numPtr6, (IntPtr) numPtr7);
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Eout(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    ushort* _First1,
    ushort* _Last1,
    ushort** _Mid1,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr = obj0;
    int* numPtr1 = _State;
    ushort* numPtr2 = _First1;
    ushort* numPtr3 = _Last1;
    ushort** numPtr4 = _Mid1;
    sbyte* numPtr5 = _First2;
    sbyte* numPtr6 = _Last2;
    sbyte** numPtr7 = _Mid2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, int*, ushort*, ushort*, ushort**, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) obj0 + 20))((sbyte**) unsignedShortCharIntPtr, (sbyte*) numPtr1, (sbyte*) numPtr2, (ushort**) numPtr3, (ushort*) numPtr4, (ushort*) numPtr5, (int*) numPtr6, (IntPtr) numPtr7);
  }

  internal static unsafe codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E_Getcat(
    locale.facet** _Ppf,
    locale* _Ploc)
  {
    uint num1 = 0;
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr1 = (codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) \u003CModule\u003E.@new(16U);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
      _Locinfo locinfo;
      codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) unsignedShortCharIntPtr1 != IntPtr.Zero)
        {
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* locstr = \u003CModule\u003E.std\u002Elocale\u002Ename(_Ploc, &stdAllocatorChar);
          // ISSUE: fault handler
          try
          {
            num1 = 1U;
            _Locinfo* _Lobj = \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, locstr);
            // ISSUE: fault handler
            try
            {
              num1 = 3U;
              unsignedShortCharIntPtr2 = \u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(unsignedShortCharIntPtr1, _Lobj, 0U);
            }
            __fault
            {
              if (((int) num1 & 2) != 0)
              {
                num1 &= 4294967293U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
              }
            }
          }
          __fault
          {
            if (((int) num1 & 1) != 0)
            {
              num1 &= 4294967294U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
            }
          }
        }
        else
          unsignedShortCharIntPtr2 = (codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) 0;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) unsignedShortCharIntPtr1);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          *(int*) _Ppf = (int) unsignedShortCharIntPtr2;
        }
        __fault
        {
          if (((int) num1 & 2) != 0)
          {
            num1 &= 4294967293U;
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
          }
        }
        if (((int) num1 & 2) != 0)
        {
          num1 &= 4294967293U;
          \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
        }
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
        }
      }
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      }
    }
    return 2;
  }

  internal static unsafe ctype\u003Cunsigned\u0020short\u003E* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 4);
      _Ctypevec ctypevec = \u003CModule\u003E._Getctype();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref ctypevec, 16);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 24, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Getcat(
    locale.facet** _Ppf,
    locale* _Ploc)
  {
    uint num1 = 0;
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr1 = (ctype\u003Cunsigned\u0020short\u003E*) \u003CModule\u003E.@new(32U);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
      _Locinfo locinfo;
      ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) ctypeUnsignedShortPtr1 != IntPtr.Zero)
        {
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* locstr = \u003CModule\u003E.std\u002Elocale\u002Ename(_Ploc, &stdAllocatorChar);
          // ISSUE: fault handler
          try
          {
            num1 = 1U;
            _Locinfo* _Lobj = \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, locstr);
            // ISSUE: fault handler
            try
            {
              num1 = 3U;
              ctypeUnsignedShortPtr2 = \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(ctypeUnsignedShortPtr1, _Lobj, 0U);
            }
            __fault
            {
              if (((int) num1 & 2) != 0)
              {
                num1 &= 4294967293U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
              }
            }
          }
          __fault
          {
            if (((int) num1 & 1) != 0)
            {
              num1 &= 4294967294U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
            }
          }
        }
        else
          ctypeUnsignedShortPtr2 = (ctype\u003Cunsigned\u0020short\u003E*) 0;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) ctypeUnsignedShortPtr1);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          *(int*) _Ppf = (int) ctypeUnsignedShortPtr2;
        }
        __fault
        {
          if (((int) num1 & 2) != 0)
          {
            num1 &= 4294967293U;
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
          }
        }
        if (((int) num1 & 2) != 0)
        {
          num1 &= 4294967293U;
          \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
        }
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
        }
      }
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      }
    }
    return 2;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Fgetc\u003Cunsigned\u0020short\u003E(
    ushort* _Wchar,
    _iobuf* _File)
  {
    ushort num = \u003CModule\u003E.fgetwc(_File);
    if (num == ushort.MaxValue)
      return false;
    *_Wchar = num;
    return true;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Fputc\u003Cunsigned\u0020short\u003E(
    ushort _Wchar,
    _iobuf* _File)
  {
    return \u003CModule\u003E.fputwc((char) _Wchar, _File) != ushort.MaxValue;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Ungetc\u003Cunsigned\u0020short\u003E(
    ushort* _Wchar,
    _iobuf* _File)
  {
    return \u003CModule\u003E.ungetwc(*_Wchar, _File) != ushort.MaxValue;
  }

  internal static unsafe void \u003FA0xd48a97bf\u002E\u003F\u003F__E\u003FA0xd48a97bf\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0xd48a97bf\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0xd48a97bf\u002E\u003F\u003F__F\u003FA0xd48a97bf\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xd48a97bf\u002E\u003F\u003F__F\u003FA0xd48a97bf\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0xd48a97bf\u002Einitlocks);

  internal static unsafe void \u003FA0xd48a97bf\u002E\u003F\u003F__E\u003FA0xd48a97bf\u0040wferr\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xd48a97bf\u002Ewferr, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xd48a97bf\u002E\u003F\u003F__F\u003FA0xd48a97bf\u0040wferr\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xd48a97bf\u002E\u003F\u003F__F\u003FA0xd48a97bf\u0040wferr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xd48a97bf\u002Ewferr);

  internal static unsafe void \u003FA0xd48a97bf\u002E\u003F\u003F__Ewcerr\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewcerr, (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0xd48a97bf\u002Ewferr, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xd48a97bf\u002E\u003F\u003F__Fwcerr\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xd48a97bf\u002E\u003F\u003F__Fwcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewcerr);

  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Wcerr_func() => &\u003CModule\u003E.std\u002Ewcerr;

  internal static unsafe _Init_ushcerr* std\u002E_Init_ushcerr\u002E\u007Bctor\u007D(
    [In] _Init_ushcerr* obj0)
  {
    \u003CModule\u003E.std\u002E_Ptr_wcerr = &\u003CModule\u003E.std\u002Ewcerr;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewcerr + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ewcerr + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ios_base* iosBasePtr = (ios_base*) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewcerr + 4) + (IntPtr) &\u003CModule\u003E.std\u002Ewcerr);
    *(int*) ((IntPtr) iosBasePtr + 16) = *(int*) ((IntPtr) iosBasePtr + 16) | 2;
    return obj0;
  }

  internal static unsafe void \u003FA0xd48a97bf\u002E\u003F\u003F__E\u003FA0xd48a97bf\u0040init_ushcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_ushcerr\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xd48a97bf\u002Einit_ushcerr);

  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd,
    [In] int obj3)
  {
    uint num1 = 0;
    if (obj3 != 0)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_8\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
      basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* pThis = (basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
      *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
      // ISSUE: fault handler
      try
      {
        *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
        }
      }
    }
    // ISSUE: fault handler
    try
    {
      *(int*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Einit((basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _Strbuf, _Isstd);
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
      }
    }
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      if (*(byte*) ((IntPtr) obj0 + 72) != (byte) 0)
        \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eclose(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0);
  }

  internal static unsafe basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    _iobuf* _File)
  {
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init(obj0, _File, (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E._Initfl) 0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eoverflow(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort _Meta)
  {
    if (ushort.MaxValue == _Meta)
      return \u003CModule\u003E.std\u002Echar_traits\u003Cunsigned\u0020short\u003E\u002Enot_eof(&_Meta);
    int num1 = *(int*) ((IntPtr) obj0 + 36);
    if (*(int*) num1 != 0)
    {
      int num2 = *(int*) num1;
      if ((uint) num2 < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 52) * 2 + num2))
      {
        *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Pninc((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0) = _Meta;
        return _Meta;
      }
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U)
      return ushort.MaxValue;
    if (*(int*) ((IntPtr) obj0 + 60) == 0)
      return !\u003CModule\u003E.std\u002E_Fputc\u003Cunsigned\u0020short\u003E(_Meta, (_iobuf*) _File) ? ushort.MaxValue : _Meta;
    ushort _Wchar = _Meta;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 8U, (sbyte) 0);
    ushort num3;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      sbyte* numPtr1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num4 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
      sbyte* _First2_1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
      ushort* numPtr2;
      sbyte* numPtr3;
      int num5 = \u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Eout((codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) ((IntPtr) obj0 + 68), &_Wchar, &_Wchar + 1, &numPtr2, _First2_1, (sbyte*) ((int) num4 + (IntPtr) numPtr1), &numPtr3);
      if (num5 >= 0)
      {
        do
        {
          if (num5 <= 1)
          {
            _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
            sbyte* numPtr4 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
            uint num6 = (uint) ((IntPtr) numPtr3 - (IntPtr) numPtr4);
            if (0U < num6)
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
              sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5));
              if ((int) num6 != (int) \u003CModule\u003E.fwrite((void*) numPtr5, 1U, num6, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
                goto label_23;
            }
            *(sbyte*) ((IntPtr) obj0 + 66) = (sbyte) 1;
            if ((IntPtr) numPtr2 == ref _Wchar)
            {
              if (0U >= num6)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if ((uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) < 32U)
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 8U, (sbyte) 0);
                else
                  goto label_25;
              }
              sbyte* numPtr6 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              uint num7 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
              sbyte* _First2_2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
              num5 = \u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Eout((codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) ((IntPtr) obj0 + 68), &_Wchar, &_Wchar + 1, &numPtr2, _First2_2, (sbyte*) ((int) num7 + (IntPtr) numPtr6), &numPtr3);
            }
            else
              goto label_24;
          }
          else
            goto label_19;
        }
        while (num5 >= 0);
        goto label_26;
label_19:
        if (num5 == 3)
          num3 = !\u003CModule\u003E.std\u002E_Fputc\u003Cunsigned\u0020short\u003E(_Wchar, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)) ? ushort.MaxValue : _Meta;
        else
          goto label_26;
      }
      else
        goto label_26;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num3;
label_23:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
label_24:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return _Meta;
label_25:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
label_26:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Epbackfail(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort _Meta)
  {
    int num1 = *(int*) *(int*) ((IntPtr) obj0 + 32);
    if (num1 != 0 && (uint) *(int*) *(int*) ((IntPtr) obj0 + 16) < (uint) num1 && (ushort.MaxValue == _Meta || (int) *(ushort*) (num1 - 2) == (int) _Meta))
    {
      int num2 = *(int*) ((IntPtr) obj0 + 48);
      *(int*) num2 = *(int*) num2 + 1;
      int num3 = *(int*) ((IntPtr) obj0 + 32);
      *(int*) num3 = *(int*) num3 - 2;
      return \u003CModule\u003E.std\u002Echar_traits\u003Cunsigned\u0020short\u003E\u002Enot_eof(&_Meta);
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U || ushort.MaxValue == _Meta)
      return ushort.MaxValue;
    if (*(int*) ((IntPtr) obj0 + 60) == 0 && \u003CModule\u003E.std\u002E_Ungetc\u003Cunsigned\u0020short\u003E(&_Meta, (_iobuf*) _File))
      return _Meta;
    basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 64);
    if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) traitsUnsignedShortPtr)
      return ushort.MaxValue;
    *(short*) traitsUnsignedShortPtr = (short) _Meta;
    ushort* numPtr = (ushort*) traitsUnsignedShortPtr;
    *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) traitsUnsignedShortPtr;
    *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) numPtr;
    *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) numPtr + 66 >> 1);
    return _Meta;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eunderflow(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) *(int*) ((IntPtr) obj0 + 32);
    if (num1 != 0)
    {
      uint num2 = (uint) *(int*) *(int*) ((IntPtr) obj0 + 32);
      if (num2 < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 48) * 2) + num2)
        return *(ushort*) num1;
    }
    basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    ushort num3 = __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) traitsUnsignedShortPtr1 + 20))((IntPtr) traitsUnsignedShortPtr1);
    if (ushort.MaxValue == num3)
      return num3;
    basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr2 = obj0;
    int num4 = (int) num3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = (int) __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) traitsUnsignedShortPtr2, (IntPtr) num4);
    return num3;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Euflow(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    if (*(int*) *(int*) ((IntPtr) obj0 + 32) != 0)
    {
      int num = *(int*) *(int*) ((IntPtr) obj0 + 32);
      if ((uint) num < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 48) * 2 + num))
        return *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Gninc((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0);
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U)
      return ushort.MaxValue;
    if (*(int*) ((IntPtr) obj0 + 60) == 0)
    {
      ushort num;
      return !\u003CModule\u003E.std\u002E_Fgetc\u003Cunsigned\u0020short\u003E(&num, (_iobuf*) _File) ? ushort.MaxValue : num;
    }
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, false, 0U);
    sbyte* numPtr1;
    ushort num1;
    // ISSUE: fault handler
    try
    {
      int _Ch = \u003CModule\u003E.fgetc((_iobuf*) *(int*) ((IntPtr) obj0 + 76));
      if (_Ch != -1)
      {
        basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _State = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 68);
        do
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 1U, (sbyte) _Ch);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          sbyte* numPtr2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num2 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          sbyte* _First1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
          ushort* numPtr3;
          int num3 = \u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Ein((codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) _State, _First1, numPtr2 + (int) num2, &numPtr1, &num1, &num1 + 1, &numPtr3);
          if (num3 >= 0)
          {
            if (num3 > 1)
            {
              if (num3 == 3)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if ((uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) >= 2U)
                  goto label_19;
              }
              else
                goto label_27;
            }
            else if ((IntPtr) numPtr3 == ref num1)
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              sbyte* numPtr4 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(&stdAllocatorChar1, 0U, (uint) ((IntPtr) numPtr1 - (IntPtr) numPtr4));
            }
            else
              goto label_22;
            _Ch = \u003CModule\u003E.fgetc((_iobuf*) *(int*) ((IntPtr) obj0 + 76));
          }
          else
            goto label_27;
        }
        while (_Ch != -1);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
label_19:
    ushort num4;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5);
      \u003CModule\u003E.memcpy_s((void*) &num1, 2U, (void*) \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) stdAllocatorCharPtr), 2U);
      num4 = num1;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num4;
label_22:
    ushort num5;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
      sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar6));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num6 = (int) (^(int&) ((IntPtr) &stdAllocatorChar1 + 20) - (IntPtr) numPtr1 + (IntPtr) numPtr5);
      if (0 < num6)
      {
        do
        {
          --num6;
          \u003CModule\u003E.ungetc((int) *(sbyte*) (num6 + (IntPtr) numPtr1), (_iobuf*) *(int*) ((IntPtr) obj0 + 76));
        }
        while (num6 > 0);
      }
      num5 = num1;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num5;
label_27:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekoff(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    int _Off,
    int _Way,
    int __unnamed002)
  {
    if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) obj0 + 64 && _Way == 1 && *(int*) ((IntPtr) obj0 + 60) == 0)
      _Off -= 2;
    long num;
    if (*(int*) ((IntPtr) obj0 + 76) != 0 && \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Endwrite(obj0) && (_Off == 0 && _Way == 1 || \u003CModule\u003E.fseek((_iobuf*) *(int*) ((IntPtr) obj0 + 76), _Off, _Way) == 0) && \u003CModule\u003E.fgetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num) == 0)
    {
      if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) obj0 + 64)
      {
        ushort* numPtr = (ushort*) ((IntPtr) obj0 + 66);
        *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) ((IntPtr) obj0 + 64);
        *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) numPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) numPtr + 66 >> 1);
      }
      *(int*) obj1 = 0;
      *(long*) ((IntPtr) obj1 + 8) = num;
      *(int*) ((IntPtr) obj1 + 16) = *(int*) ((IntPtr) obj0 + 68);
      return obj1;
    }
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekpos(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    fpos\u003Cint\u003E _Pos,
    int __unnamed001)
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    long num1 = ^(long&) ((IntPtr) &_Pos + 8);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    int num2 = ^(int&) ref _Pos;
    if (*(int*) ((IntPtr) obj0 + 76) != 0 && \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Endwrite(obj0) && \u003CModule\u003E.fsetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num1) == 0 && (num2 == 0 || \u003CModule\u003E.fseek((_iobuf*) *(int*) ((IntPtr) obj0 + 76), num2, 1) == 0) && \u003CModule\u003E.fgetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num1) == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      *(int*) ((IntPtr) obj0 + 68) = ^(int&) ((IntPtr) &_Pos + 16);
      basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 64);
      if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) traitsUnsignedShortPtr)
      {
        ushort* numPtr = (ushort*) ((IntPtr) obj0 + 66);
        *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) traitsUnsignedShortPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) numPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) numPtr + 66 >> 1);
      }
      *(int*) obj1 = 0;
      *(long*) ((IntPtr) obj1 + 8) = num1;
      *(int*) ((IntPtr) obj1 + 16) = *(int*) ((IntPtr) obj0 + 68);
      return obj1;
    }
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esetbuf(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Buffer,
    int _Count)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (num1 != 0U)
    {
      int num2 = (IntPtr) _Buffer != IntPtr.Zero || _Count != 0 ? 0 : 4;
      if (\u003CModule\u003E.setvbuf((_iobuf*) num1, (sbyte*) _Buffer, num2, (uint) (_Count << 1)) == 0)
      {
        basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
        int _File = *(int*) ((IntPtr) traitsUnsignedShortPtr + 76);
        \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init(traitsUnsignedShortPtr, (_iobuf*) _File, (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E._Initfl) 1);
        return (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0;
      }
    }
    return (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esync(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    int num;
    if (*(int*) ((IntPtr) obj0 + 76) != 0)
    {
      basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      if (ushort.MaxValue != __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) traitsUnsignedShortPtr, new IntPtr(65535)) && 0 > \u003CModule\u003E.fflush((_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
      {
        num = -1;
        goto label_4;
      }
    }
    num = 0;
label_4:
    return num;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eimbue(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    locale* _Loc)
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Initcvt(obj0, \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u0020\u003E(_Loc));
  }

  internal static unsafe void* std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 80U, *(int*) traitsUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsUnsignedShortPtr);
      return (void*) traitsUnsignedShortPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Einit(
    [In] basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd)
  {
    \u003CModule\u003E.std\u002Eios_base\u002E_Init((ios_base*) obj0);
    *(int*) ((IntPtr) obj0 + 40) = (int) _Strbuf;
    *(int*) ((IntPtr) obj0 + 44) = 0;
    *(short*) ((IntPtr) obj0 + 48) = (short) \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ewiden(obj0, (sbyte) 32);
    if (*(int*) ((IntPtr) obj0 + 40) == 0)
    {
      basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
      int _State = *(int*) ((IntPtr) traitsUnsignedShortPtr + 8) | 4;
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eclear(traitsUnsignedShortPtr, _State, false);
    }
    if (_Isstd)
      \u003CModule\u003E.std\u002Eios_base\u002E_Addstd((ios_base*) obj0);
    else
      *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_ctor((_Mutex*) ((IntPtr) obj0 + 4));
    // ISSUE: fault handler
    try
    {
      locale* localePtr1 = (locale*) \u003CModule\u003E.@new(4U);
      locale* localePtr2 = (IntPtr) localePtr1 == IntPtr.Zero ? (locale*) 0 : \u003CModule\u003E.std\u002Elocale\u002E\u007Bctor\u007D(localePtr1);
      *(int*) ((IntPtr) obj0 + 56) = (int) localePtr2;
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mutex\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    return obj0;
  }

  internal static unsafe basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eclose(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
    if (*(int*) ((IntPtr) obj0 + 76) == 0)
    {
      traitsUnsignedShortPtr = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;
    }
    else
    {
      if (!\u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Endwrite(obj0))
        traitsUnsignedShortPtr = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;
      if (\u003CModule\u003E.fclose((_iobuf*) *(int*) ((IntPtr) obj0 + 76)) != 0)
        traitsUnsignedShortPtr = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;
    }
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init(obj0, (_iobuf*) 0, (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E._Initfl) 2);
    return traitsUnsignedShortPtr;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    _iobuf* _File,
    basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E._Initfl _Which)
  {
    int num = _Which == (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E._Initfl) 1 ? 1 : 0;
    *(sbyte*) ((IntPtr) obj0 + 72) = (sbyte) num;
    *(sbyte*) ((IntPtr) obj0 + 66) = (sbyte) 0;
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0);
    *(int*) ((IntPtr) obj0 + 76) = (int) _File;
    *(int*) ((IntPtr) obj0 + 68) = \u003CModule\u003E.\u003F_Stinit\u0040\u003F1\u003F\u003F_Init\u0040\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040IAMXPAU_iobuf\u0040\u0040W4_Initfl\u004023\u0040\u0040Z\u00404HA;
    *(int*) ((IntPtr) obj0 + 60) = 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Endwrite(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    if (*(int*) ((IntPtr) obj0 + 60) == 0 || *(byte*) ((IntPtr) obj0 + 66) == (byte) 0)
      return true;
    basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    if (ushort.MaxValue == __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) traitsUnsignedShortPtr1, new IntPtr(65535)))
      return false;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 8U, (sbyte) 0);
    // ISSUE: fault handler
    try
    {
      basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr2 = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 68);
      while (true)
      {
        uint num1;
        do
        {
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          sbyte* numPtr1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num2 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          sbyte* numPtr2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
          codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr1 = (codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60);
          codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr2 = unsignedShortCharIntPtr1;
          basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr3 = traitsUnsignedShortPtr2;
          sbyte* numPtr3 = numPtr2;
          IntPtr num3 = (int) num2 + (IntPtr) numPtr1;
          sbyte* numPtr4;
          ref sbyte* local = ref numPtr4;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          switch (__calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) unsignedShortCharIntPtr1 + 24))((sbyte**) unsignedShortCharIntPtr2, (sbyte*) traitsUnsignedShortPtr3, numPtr3, (int*) num3, (IntPtr) ref local))
          {
            case 0:
              *(sbyte*) ((IntPtr) obj0 + 66) = (sbyte) 0;
              goto case 1;
            case 1:
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
              num1 = (uint) ((IntPtr) numPtr4 - (IntPtr) numPtr5);
              if (0U < num1)
              {
                _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
                sbyte* numPtr6 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5));
                if ((int) num1 != (int) \u003CModule\u003E.fwrite((void*) numPtr6, 1U, num1, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
                  goto label_15;
              }
              if (*(byte*) ((IntPtr) obj0 + 66) != (byte) 0)
                continue;
              goto label_16;
            case 3:
              goto label_14;
            default:
              goto label_13;
          }
        }
        while (num1 != 0U);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 8U, (sbyte) 0);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
label_13:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return false;
label_14:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return true;
label_15:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return false;
label_16:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return true;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Initcvt(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* _Newpcvt)
  {
    codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr = _Newpcvt;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    if (__calli((__FnPtr<byte (IntPtr)>) *(int*) (*(int*) unsignedShortCharIntPtr + 4))((IntPtr) unsignedShortCharIntPtr) != (byte) 0)
    {
      *(int*) ((IntPtr) obj0 + 60) = 0;
    }
    else
    {
      *(int*) ((IntPtr) obj0 + 60) = (int) _Newpcvt;
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0);
    }
  }

  internal static unsafe ushort std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ewiden(
    [In] basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    sbyte _Byte)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc((ios_base*) obj0, &locale);
    ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr1;
    // ISSUE: fault handler
    try
    {
      ctypeUnsignedShortPtr1 = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cunsigned\u0020short\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr2 = ctypeUnsignedShortPtr1;
    int num = (int) _Byte;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<ushort (IntPtr, sbyte)>) *(int*) (*(int*) ctypeUnsignedShortPtr1 + 40))((sbyte) ctypeUnsignedShortPtr2, (IntPtr) num);
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 16) = (int) ((IntPtr) obj0 + 8);
    *(int*) ((IntPtr) obj0 + 20) = (int) ((IntPtr) obj0 + 12);
    *(int*) ((IntPtr) obj0 + 32) = (int) ((IntPtr) obj0 + 24);
    *(int*) ((IntPtr) obj0 + 36) = (int) ((IntPtr) obj0 + 28);
    *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 + 40);
    *(int*) ((IntPtr) obj0 + 52) = (int) ((IntPtr) obj0 + 44);
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esetp(obj0, (ushort*) 0, (ushort*) 0);
    *(int*) *(int*) ((IntPtr) obj0 + 16) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 32) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 48) = 0;
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esetp(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _First,
    ushort* _Last)
  {
    *(int*) *(int*) ((IntPtr) obj0 + 20) = (int) _First;
    *(int*) *(int*) ((IntPtr) obj0 + 36) = (int) _First;
    *(int*) *(int*) ((IntPtr) obj0 + 52) = (int) ((IntPtr) _Last - (IntPtr) _First >> 1);
  }

  internal static unsafe ctype\u003Cunsigned\u0020short\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cunsigned\u0020short\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Getcat(&pbVfacetLocale2B, _Loc) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (ctype\u003Cunsigned\u0020short\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E_Getcat(&pbVfacetLocale2B, _Loc) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe void \u003FA0xd48a97bf\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xd48a97bf\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eoverflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Epbackfail);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eshowmanyc);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eunderflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Euflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Exsgetn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Xsgetn_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Exsputn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekoff);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekpos);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esetbuf);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esync);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eimbue);
  }

  internal static unsafe void \u003FA0x58eb3bc8\u002E\u003F\u003F__E\u003FA0x58eb3bc8\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x58eb3bc8\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x58eb3bc8\u002E\u003F\u003F__F\u003FA0x58eb3bc8\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x58eb3bc8\u002E\u003F\u003F__F\u003FA0x58eb3bc8\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x58eb3bc8\u002Einitlocks);

  internal static unsafe void \u003FA0x58eb3bc8\u002E\u003F\u003F__E\u003FA0x58eb3bc8\u0040wfin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x58eb3bc8\u002Ewfin, \u003CModule\u003E.__iob_func());
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x58eb3bc8\u002E\u003F\u003F__F\u003FA0x58eb3bc8\u0040wfin\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x58eb3bc8\u002E\u003F\u003F__F\u003FA0x58eb3bc8\u0040wfin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x58eb3bc8\u002Ewfin);

  internal static unsafe void \u003FA0x58eb3bc8\u002E\u003F\u003F__Ewcin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewcin, (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x58eb3bc8\u002Ewfin, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x58eb3bc8\u002E\u003F\u003F__Fwcin\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x58eb3bc8\u002E\u003F\u003F__Fwcin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewcin);

  internal static unsafe basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Wcin_func() => &\u003CModule\u003E.std\u002Ewcin;

  internal static unsafe void \u003FA0x58eb3bc8\u002E\u003F\u003F__E\u003FA0x58eb3bc8\u0040init_ushcin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Ptr_wcin = &\u003CModule\u003E.std\u002Ewcin;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewcin + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ewcin + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
  }

  internal static unsafe basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd,
    [In] int obj3)
  {
    uint num1 = 0;
    if (obj3 != 0)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_8\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
      basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* pThis = (basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
      *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
      // ISSUE: fault handler
      try
      {
        *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
        }
      }
    }
    // ISSUE: fault handler
    try
    {
      *(int*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 4) = 0;
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Einit((basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _Strbuf, _Isstd);
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
      }
    }
    return obj0;
  }

  internal static unsafe void \u003FA0x9ed7e2b2\u002E\u003F\u003F__E\u003FA0x9ed7e2b2\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x9ed7e2b2\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x9ed7e2b2\u002E\u003F\u003F__F\u003FA0x9ed7e2b2\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x9ed7e2b2\u002E\u003F\u003F__F\u003FA0x9ed7e2b2\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x9ed7e2b2\u002Einitlocks);

  internal static unsafe void \u003FA0x9ed7e2b2\u002E\u003F\u003F__E\u003FA0x9ed7e2b2\u0040wflog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x9ed7e2b2\u002Ewflog, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x9ed7e2b2\u002E\u003F\u003F__F\u003FA0x9ed7e2b2\u0040wflog\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x9ed7e2b2\u002E\u003F\u003F__F\u003FA0x9ed7e2b2\u0040wflog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x9ed7e2b2\u002Ewflog);

  internal static unsafe void \u003FA0x9ed7e2b2\u002E\u003F\u003F__Ewclog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewclog, (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x9ed7e2b2\u002Ewflog, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x9ed7e2b2\u002E\u003F\u003F__Fwclog\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x9ed7e2b2\u002E\u003F\u003F__Fwclog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewclog);

  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Wclog_func() => &\u003CModule\u003E.std\u002Ewclog;

  internal static unsafe void \u003FA0x9ed7e2b2\u002E\u003F\u003F__E\u003FA0x9ed7e2b2\u0040init_ushclog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Ptr_wclog = &\u003CModule\u003E.std\u002Ewclog;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewclog + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ewclog + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
  }

  internal static unsafe void \u003FA0x56b456e4\u002E\u003F\u003F__E\u003FA0x56b456e4\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x56b456e4\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x56b456e4\u002E\u003F\u003F__F\u003FA0x56b456e4\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x56b456e4\u002E\u003F\u003F__F\u003FA0x56b456e4\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x56b456e4\u002Einitlocks);

  internal static unsafe void \u003FA0x56b456e4\u002E\u003F\u003F__E\u003FA0x56b456e4\u0040wfout\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x56b456e4\u002Ewfout, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 32));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x56b456e4\u002E\u003F\u003F__F\u003FA0x56b456e4\u0040wfout\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x56b456e4\u002E\u003F\u003F__F\u003FA0x56b456e4\u0040wfout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x56b456e4\u002Ewfout);

  internal static unsafe void \u003FA0x56b456e4\u002E\u003F\u003F__Ewcout\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewcout, (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x56b456e4\u002Ewfout, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x56b456e4\u002E\u003F\u003F__Fwcout\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x56b456e4\u002E\u003F\u003F__Fwcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewcout);

  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Wcout_func() => &\u003CModule\u003E.std\u002Ewcout;

  internal static unsafe _Init_ushcout* std\u002E_Init_ushcout\u002E\u007Bctor\u007D(
    [In] _Init_ushcout* obj0)
  {
    \u003CModule\u003E.std\u002E_Ptr_wcout = &\u003CModule\u003E.std\u002Ewcout;
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_wcin != IntPtr.Zero)
    {
      basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* stdPtrWcin = \u003CModule\u003E.std\u002E_Ptr_wcin;
      int num = *(int*) (*(int*) stdPtrWcin + 4);
      *(int*) ((IntPtr) stdPtrWcin + num + 44) = (int) &\u003CModule\u003E.std\u002Ewcout;
    }
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_wcerr != IntPtr.Zero)
    {
      basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* stdPtrWcerr = \u003CModule\u003E.std\u002E_Ptr_wcerr;
      int num = *(int*) (*(int*) stdPtrWcerr + 4);
      *(int*) ((IntPtr) stdPtrWcerr + num + 44) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
    }
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_wclog != IntPtr.Zero)
    {
      basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* stdPtrWclog = \u003CModule\u003E.std\u002E_Ptr_wclog;
      int num = *(int*) (*(int*) stdPtrWclog + 4);
      *(int*) ((IntPtr) stdPtrWclog + num + 44) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
    }
    return obj0;
  }

  internal static unsafe void \u003FA0x56b456e4\u002E\u003F\u003F__E\u003FA0x56b456e4\u0040init_ushcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_ushcout\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x56b456e4\u002Einit_ushcout);

  internal static unsafe ushort std\u002Echar_traits\u003Cwchar_t\u003E\u002Enot_eof(ushort* _Meta)
  {
    ushort num = *_Meta;
    return num == ushort.MaxValue ? (ushort) 0 : num;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Ein(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    sbyte** _Mid1,
    char* _First2,
    char* _Last2,
    char** _Mid2)
  {
    codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr = obj0;
    int* numPtr1 = _State;
    sbyte* numPtr2 = _First1;
    sbyte* numPtr3 = _Last1;
    sbyte** numPtr4 = _Mid1;
    char* chPtr1 = _First2;
    char* chPtr2 = _Last2;
    char** chPtr3 = _Mid2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**, char*, char*, char**)>) *(int*) (*(int*) obj0 + 16))((char**) codecvtWcharTCharIntPtr, (char*) numPtr1, (char*) numPtr2, (sbyte**) numPtr3, (sbyte*) numPtr4, (sbyte*) chPtr1, (int*) chPtr2, (IntPtr) chPtr3);
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Eout(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    char* _First1,
    char* _Last1,
    char** _Mid1,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr = obj0;
    int* numPtr1 = _State;
    char* chPtr1 = _First1;
    char* chPtr2 = _Last1;
    char** chPtr3 = _Mid1;
    sbyte* numPtr2 = _First2;
    sbyte* numPtr3 = _Last2;
    sbyte** numPtr4 = _Mid2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, int*, char*, char*, char**, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) obj0 + 20))((sbyte**) codecvtWcharTCharIntPtr, (sbyte*) numPtr1, (sbyte*) chPtr1, (char**) chPtr2, (char*) chPtr3, (char*) numPtr2, (int*) numPtr3, (IntPtr) numPtr4);
  }

  internal static unsafe codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E_Getcat(
    locale.facet** _Ppf,
    locale* _Ploc)
  {
    uint num1 = 0;
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr1 = (codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) \u003CModule\u003E.@new(16U);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
      _Locinfo locinfo;
      codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) codecvtWcharTCharIntPtr1 != IntPtr.Zero)
        {
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* locstr = \u003CModule\u003E.std\u002Elocale\u002Ename(_Ploc, &stdAllocatorChar);
          // ISSUE: fault handler
          try
          {
            num1 = 1U;
            _Locinfo* _Lobj = \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, locstr);
            // ISSUE: fault handler
            try
            {
              num1 = 3U;
              codecvtWcharTCharIntPtr2 = \u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(codecvtWcharTCharIntPtr1, _Lobj, 0U);
            }
            __fault
            {
              if (((int) num1 & 2) != 0)
              {
                num1 &= 4294967293U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
              }
            }
          }
          __fault
          {
            if (((int) num1 & 1) != 0)
            {
              num1 &= 4294967294U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
            }
          }
        }
        else
          codecvtWcharTCharIntPtr2 = (codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) 0;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) codecvtWcharTCharIntPtr1);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          *(int*) _Ppf = (int) codecvtWcharTCharIntPtr2;
        }
        __fault
        {
          if (((int) num1 & 2) != 0)
          {
            num1 &= 4294967293U;
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
          }
        }
        if (((int) num1 & 2) != 0)
        {
          num1 &= 4294967293U;
          \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
        }
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
        }
      }
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      }
    }
    return 2;
  }

  internal static unsafe ctype\u003Cwchar_t\u003E* std\u002Ectype\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
      _Ctypevec ctypevec = \u003CModule\u003E._Getctype();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref ctypevec, 16);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 24, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Ectype\u003Cwchar_t\u003E\u002E_Getcat(
    locale.facet** _Ppf,
    locale* _Ploc)
  {
    uint num1 = 0;
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      ctype\u003Cwchar_t\u003E* ctypeWcharTPtr1 = (ctype\u003Cwchar_t\u003E*) \u003CModule\u003E.@new(32U);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
      _Locinfo locinfo;
      ctype\u003Cwchar_t\u003E* ctypeWcharTPtr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) ctypeWcharTPtr1 != IntPtr.Zero)
        {
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* locstr = \u003CModule\u003E.std\u002Elocale\u002Ename(_Ploc, &stdAllocatorChar);
          // ISSUE: fault handler
          try
          {
            num1 = 1U;
            _Locinfo* _Lobj = \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, locstr);
            // ISSUE: fault handler
            try
            {
              num1 = 3U;
              ctypeWcharTPtr2 = \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(ctypeWcharTPtr1, _Lobj, 0U);
            }
            __fault
            {
              if (((int) num1 & 2) != 0)
              {
                num1 &= 4294967293U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
              }
            }
          }
          __fault
          {
            if (((int) num1 & 1) != 0)
            {
              num1 &= 4294967294U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
            }
          }
        }
        else
          ctypeWcharTPtr2 = (ctype\u003Cwchar_t\u003E*) 0;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) ctypeWcharTPtr1);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          *(int*) _Ppf = (int) ctypeWcharTPtr2;
        }
        __fault
        {
          if (((int) num1 & 2) != 0)
          {
            num1 &= 4294967293U;
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
          }
        }
        if (((int) num1 & 2) != 0)
        {
          num1 &= 4294967293U;
          \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
        }
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
        }
      }
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      }
    }
    return 2;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Fgetc\u003Cwchar_t\u003E(char* _Wchar, _iobuf* _File)
  {
    ushort num = \u003CModule\u003E.fgetwc(_File);
    if (num == ushort.MaxValue)
      return false;
    *_Wchar = (char) num;
    return true;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Fputc\u003Cwchar_t\u003E([MarshalAs(UnmanagedType.U2)] char _Wchar, _iobuf* _File) => \u003CModule\u003E.fputwc(_Wchar, _File) != ushort.MaxValue;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Ungetc\u003Cwchar_t\u003E(char* _Wchar, _iobuf* _File) => \u003CModule\u003E.ungetwc((ushort) *_Wchar, _File) != ushort.MaxValue;

  internal static unsafe void \u003FA0x67178f3e\u002E\u003F\u003F__E\u003FA0x67178f3e\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x67178f3e\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x67178f3e\u002E\u003F\u003F__F\u003FA0x67178f3e\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x67178f3e\u002E\u003F\u003F__F\u003FA0x67178f3e\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x67178f3e\u002Einitlocks);

  internal static unsafe void \u003FA0x67178f3e\u002E\u003F\u003F__E\u003FA0x67178f3e\u0040wferr\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x67178f3e\u002Ewferr, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x67178f3e\u002E\u003F\u003F__F\u003FA0x67178f3e\u0040wferr\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x67178f3e\u002E\u003F\u003F__F\u003FA0x67178f3e\u0040wferr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x67178f3e\u002Ewferr);

  internal static unsafe void \u003FA0x67178f3e\u002E\u003F\u003F__Ewcerr\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewcerr, (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x67178f3e\u002Ewferr, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x67178f3e\u002E\u003F\u003F__Fwcerr\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x67178f3e\u002E\u003F\u003F__Fwcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewcerr);

  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Wcerr_func() => &\u003CModule\u003E.std\u002Ewcerr;

  internal static unsafe _Init_wcerr* std\u002E_Init_wcerr\u002E\u007Bctor\u007D(
    [In] _Init_wcerr* obj0)
  {
    \u003CModule\u003E.std\u002E_Ptr_wcerr = &\u003CModule\u003E.std\u002Ewcerr;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewcerr + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ewcerr + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ios_base* iosBasePtr = (ios_base*) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewcerr + 4) + (IntPtr) &\u003CModule\u003E.std\u002Ewcerr);
    *(int*) ((IntPtr) iosBasePtr + 16) = *(int*) ((IntPtr) iosBasePtr + 16) | 2;
    return obj0;
  }

  internal static unsafe void \u003FA0x67178f3e\u002E\u003F\u003F__E\u003FA0x67178f3e\u0040init_wcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_wcerr\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x67178f3e\u002Einit_wcerr);

  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd,
    [In] int obj3)
  {
    uint num1 = 0;
    if (obj3 != 0)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_8\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
      basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* pThis = (basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
      *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
      // ISSUE: fault handler
      try
      {
        *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
        }
      }
    }
    // ISSUE: fault handler
    try
    {
      *(int*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Einit((basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _Strbuf, _Isstd);
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
      }
    }
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      if (*(byte*) ((IntPtr) obj0 + 72) != (byte) 0)
        \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eclose(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0);
  }

  internal static unsafe basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    _iobuf* _File)
  {
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init(obj0, _File, (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E._Initfl) 0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eoverflow(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    ushort _Meta)
  {
    if (ushort.MaxValue == _Meta)
      return \u003CModule\u003E.std\u002Echar_traits\u003Cwchar_t\u003E\u002Enot_eof(&_Meta);
    int num1 = *(int*) ((IntPtr) obj0 + 36);
    if (*(int*) num1 != 0)
    {
      int num2 = *(int*) num1;
      if ((uint) num2 < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 52) * 2 + num2))
      {
        *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Pninc((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0) = (char) _Meta;
        return _Meta;
      }
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U)
      return ushort.MaxValue;
    if (*(int*) ((IntPtr) obj0 + 60) == 0)
      return !\u003CModule\u003E.std\u002E_Fputc\u003Cwchar_t\u003E((char) _Meta, (_iobuf*) _File) ? ushort.MaxValue : _Meta;
    char _Wchar = (char) _Meta;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 8U, (sbyte) 0);
    ushort num3;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      sbyte* numPtr1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num4 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
      sbyte* _First2_1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
      char* chPtr;
      sbyte* numPtr2;
      int num5 = \u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Eout((codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) ((IntPtr) obj0 + 68), &_Wchar, &_Wchar + 1, &chPtr, _First2_1, (sbyte*) ((int) num4 + (IntPtr) numPtr1), &numPtr2);
      if (num5 >= 0)
      {
        do
        {
          if (num5 <= 1)
          {
            _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
            sbyte* numPtr3 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
            uint num6 = (uint) ((IntPtr) numPtr2 - (IntPtr) numPtr3);
            if (0U < num6)
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
              sbyte* numPtr4 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5));
              if ((int) num6 != (int) \u003CModule\u003E.fwrite((void*) numPtr4, 1U, num6, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
                goto label_23;
            }
            *(sbyte*) ((IntPtr) obj0 + 66) = (sbyte) 1;
            if ((IntPtr) chPtr == ref _Wchar)
            {
              if (0U >= num6)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if ((uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) < 32U)
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 8U, (sbyte) 0);
                else
                  goto label_25;
              }
              sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              uint num7 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
              sbyte* _First2_2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
              num5 = \u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Eout((codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) ((IntPtr) obj0 + 68), &_Wchar, &_Wchar + 1, &chPtr, _First2_2, (sbyte*) ((int) num7 + (IntPtr) numPtr5), &numPtr2);
            }
            else
              goto label_24;
          }
          else
            goto label_19;
        }
        while (num5 >= 0);
        goto label_26;
label_19:
        if (num5 == 3)
          num3 = !\u003CModule\u003E.std\u002E_Fputc\u003Cwchar_t\u003E(_Wchar, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)) ? ushort.MaxValue : _Meta;
        else
          goto label_26;
      }
      else
        goto label_26;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num3;
label_23:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
label_24:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return _Meta;
label_25:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
label_26:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Epbackfail(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    ushort _Meta)
  {
    int num1 = *(int*) *(int*) ((IntPtr) obj0 + 32);
    if (num1 != 0 && (uint) *(int*) *(int*) ((IntPtr) obj0 + 16) < (uint) num1 && (ushort.MaxValue == _Meta || (int) *(ushort*) (num1 - 2) == (int) _Meta))
    {
      int num2 = *(int*) ((IntPtr) obj0 + 48);
      *(int*) num2 = *(int*) num2 + 1;
      int num3 = *(int*) ((IntPtr) obj0 + 32);
      *(int*) num3 = *(int*) num3 - 2;
      return \u003CModule\u003E.std\u002Echar_traits\u003Cwchar_t\u003E\u002Enot_eof(&_Meta);
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U || ushort.MaxValue == _Meta)
      return ushort.MaxValue;
    if (*(int*) ((IntPtr) obj0 + 60) == 0 && \u003CModule\u003E.std\u002E_Ungetc\u003Cwchar_t\u003E(&(char) _Meta, (_iobuf*) _File))
      return _Meta;
    basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 64);
    if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) charTraitsWcharTPtr)
      return ushort.MaxValue;
    *(short*) charTraitsWcharTPtr = (short) _Meta;
    char* chPtr = (char*) charTraitsWcharTPtr;
    *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) charTraitsWcharTPtr;
    *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) chPtr;
    *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) chPtr + 66 >> 1);
    return _Meta;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eunderflow(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) *(int*) ((IntPtr) obj0 + 32);
    if (num1 != 0)
    {
      uint num2 = (uint) *(int*) *(int*) ((IntPtr) obj0 + 32);
      if (num2 < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 48) * 2) + num2)
        return *(ushort*) num1;
    }
    basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    ushort num3 = __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) charTraitsWcharTPtr1 + 20))((IntPtr) charTraitsWcharTPtr1);
    if (ushort.MaxValue == num3)
      return num3;
    basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr2 = obj0;
    int num4 = (int) num3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = (int) __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) charTraitsWcharTPtr2, (IntPtr) num4);
    return num3;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Euflow(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    if (*(int*) *(int*) ((IntPtr) obj0 + 32) != 0)
    {
      int num = *(int*) *(int*) ((IntPtr) obj0 + 32);
      if ((uint) num < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 48) * 2 + num))
        return (ushort) *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Gninc((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0);
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U)
      return ushort.MaxValue;
    if (*(int*) ((IntPtr) obj0 + 60) == 0)
    {
      char ch;
      return !\u003CModule\u003E.std\u002E_Fgetc\u003Cwchar_t\u003E(&ch, (_iobuf*) _File) ? ushort.MaxValue : (ushort) ch;
    }
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, false, 0U);
    sbyte* numPtr1;
    char ch1;
    // ISSUE: fault handler
    try
    {
      int _Ch = \u003CModule\u003E.fgetc((_iobuf*) *(int*) ((IntPtr) obj0 + 76));
      if (_Ch != -1)
      {
        basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _State = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 68);
        do
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 1U, (sbyte) _Ch);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          sbyte* numPtr2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num1 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          sbyte* _First1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
          char* chPtr;
          int num2 = \u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Ein((codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) _State, _First1, numPtr2 + (int) num1, &numPtr1, &ch1, &ch1 + 1, &chPtr);
          if (num2 >= 0)
          {
            if (num2 > 1)
            {
              if (num2 == 3)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if ((uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) >= 2U)
                  goto label_19;
              }
              else
                goto label_27;
            }
            else if ((IntPtr) chPtr == ref ch1)
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              sbyte* numPtr3 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(&stdAllocatorChar1, 0U, (uint) ((IntPtr) numPtr1 - (IntPtr) numPtr3));
            }
            else
              goto label_22;
            _Ch = \u003CModule\u003E.fgetc((_iobuf*) *(int*) ((IntPtr) obj0 + 76));
          }
          else
            goto label_27;
        }
        while (_Ch != -1);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
label_19:
    ushort num3;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5);
      \u003CModule\u003E.memcpy_s((void*) &ch1, 2U, (void*) \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) stdAllocatorCharPtr), 2U);
      num3 = (ushort) ch1;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num3;
label_22:
    ushort num4;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
      sbyte* numPtr4 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar6));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num5 = (int) (^(int&) ((IntPtr) &stdAllocatorChar1 + 20) - (IntPtr) numPtr1 + (IntPtr) numPtr4);
      if (0 < num5)
      {
        do
        {
          --num5;
          \u003CModule\u003E.ungetc((int) *(sbyte*) (num5 + (IntPtr) numPtr1), (_iobuf*) *(int*) ((IntPtr) obj0 + 76));
        }
        while (num5 > 0);
      }
      num4 = (ushort) ch1;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num4;
label_27:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekoff(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    int _Off,
    int _Way,
    int __unnamed002)
  {
    if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) obj0 + 64 && _Way == 1 && *(int*) ((IntPtr) obj0 + 60) == 0)
      _Off -= 2;
    long num;
    if (*(int*) ((IntPtr) obj0 + 76) != 0 && \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Endwrite(obj0) && (_Off == 0 && _Way == 1 || \u003CModule\u003E.fseek((_iobuf*) *(int*) ((IntPtr) obj0 + 76), _Off, _Way) == 0) && \u003CModule\u003E.fgetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num) == 0)
    {
      if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) obj0 + 64)
      {
        char* chPtr = (char*) ((IntPtr) obj0 + 66);
        *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) ((IntPtr) obj0 + 64);
        *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) chPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) chPtr + 66 >> 1);
      }
      *(int*) obj1 = 0;
      *(long*) ((IntPtr) obj1 + 8) = num;
      *(int*) ((IntPtr) obj1 + 16) = *(int*) ((IntPtr) obj0 + 68);
      return obj1;
    }
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekpos(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    fpos\u003Cint\u003E _Pos,
    int __unnamed001)
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    long num1 = ^(long&) ((IntPtr) &_Pos + 8);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    int num2 = ^(int&) ref _Pos;
    if (*(int*) ((IntPtr) obj0 + 76) != 0 && \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Endwrite(obj0) && \u003CModule\u003E.fsetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num1) == 0 && (num2 == 0 || \u003CModule\u003E.fseek((_iobuf*) *(int*) ((IntPtr) obj0 + 76), num2, 1) == 0) && \u003CModule\u003E.fgetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num1) == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      *(int*) ((IntPtr) obj0 + 68) = ^(int&) ((IntPtr) &_Pos + 16);
      basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 64);
      if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) charTraitsWcharTPtr)
      {
        char* chPtr = (char*) ((IntPtr) obj0 + 66);
        *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) charTraitsWcharTPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) chPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) chPtr + 66 >> 1);
      }
      *(int*) obj1 = 0;
      *(long*) ((IntPtr) obj1 + 8) = num1;
      *(int*) ((IntPtr) obj1 + 16) = *(int*) ((IntPtr) obj0 + 68);
      return obj1;
    }
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esetbuf(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Buffer,
    int _Count)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (num1 != 0U)
    {
      int num2 = (IntPtr) _Buffer != IntPtr.Zero || _Count != 0 ? 0 : 4;
      if (\u003CModule\u003E.setvbuf((_iobuf*) num1, (sbyte*) _Buffer, num2, (uint) (_Count << 1)) == 0)
      {
        basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
        int _File = *(int*) ((IntPtr) charTraitsWcharTPtr + 76);
        \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init(charTraitsWcharTPtr, (_iobuf*) _File, (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E._Initfl) 1);
        return (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0;
      }
    }
    return (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esync(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    int num;
    if (*(int*) ((IntPtr) obj0 + 76) != 0)
    {
      basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      if (ushort.MaxValue != __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) charTraitsWcharTPtr, new IntPtr(65535)) && 0 > \u003CModule\u003E.fflush((_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
      {
        num = -1;
        goto label_4;
      }
    }
    num = 0;
label_4:
    return num;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eimbue(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    locale* _Loc)
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Initcvt(obj0, \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u0020\u003E(_Loc));
  }

  internal static unsafe void* std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 80U, *(int*) charTraitsWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) charTraitsWcharTPtr);
      return (void*) charTraitsWcharTPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Einit(
    [In] basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd)
  {
    \u003CModule\u003E.std\u002Eios_base\u002E_Init((ios_base*) obj0);
    *(int*) ((IntPtr) obj0 + 40) = (int) _Strbuf;
    *(int*) ((IntPtr) obj0 + 44) = 0;
    *(short*) ((IntPtr) obj0 + 48) = (short) \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Ewiden(obj0, (sbyte) 32);
    if (*(int*) ((IntPtr) obj0 + 40) == 0)
    {
      basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
      int _State = *(int*) ((IntPtr) charTraitsWcharTPtr + 8) | 4;
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eclear(charTraitsWcharTPtr, _State, false);
    }
    if (_Isstd)
      \u003CModule\u003E.std\u002Eios_base\u002E_Addstd((ios_base*) obj0);
    else
      *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_ctor((_Mutex*) ((IntPtr) obj0 + 4));
    // ISSUE: fault handler
    try
    {
      locale* localePtr1 = (locale*) \u003CModule\u003E.@new(4U);
      locale* localePtr2 = (IntPtr) localePtr1 == IntPtr.Zero ? (locale*) 0 : \u003CModule\u003E.std\u002Elocale\u002E\u007Bctor\u007D(localePtr1);
      *(int*) ((IntPtr) obj0 + 56) = (int) localePtr2;
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mutex\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    return obj0;
  }

  internal static unsafe basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eclose(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
    if (*(int*) ((IntPtr) obj0 + 76) == 0)
    {
      charTraitsWcharTPtr = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;
    }
    else
    {
      if (!\u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Endwrite(obj0))
        charTraitsWcharTPtr = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;
      if (\u003CModule\u003E.fclose((_iobuf*) *(int*) ((IntPtr) obj0 + 76)) != 0)
        charTraitsWcharTPtr = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;
    }
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init(obj0, (_iobuf*) 0, (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E._Initfl) 2);
    return charTraitsWcharTPtr;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    _iobuf* _File,
    basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E._Initfl _Which)
  {
    int num = _Which == (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E._Initfl) 1 ? 1 : 0;
    *(sbyte*) ((IntPtr) obj0 + 72) = (sbyte) num;
    *(sbyte*) ((IntPtr) obj0 + 66) = (sbyte) 0;
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0);
    *(int*) ((IntPtr) obj0 + 76) = (int) _File;
    *(int*) ((IntPtr) obj0 + 68) = \u003CModule\u003E.\u003F_Stinit\u0040\u003F1\u003F\u003F_Init\u0040\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040IAMXPAU_iobuf\u0040\u0040W4_Initfl\u004023\u0040\u0040Z\u00404HA;
    *(int*) ((IntPtr) obj0 + 60) = 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Endwrite(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    if (*(int*) ((IntPtr) obj0 + 60) == 0 || *(byte*) ((IntPtr) obj0 + 66) == (byte) 0)
      return true;
    basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    if (ushort.MaxValue == __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) charTraitsWcharTPtr1, new IntPtr(65535)))
      return false;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 8U, (sbyte) 0);
    // ISSUE: fault handler
    try
    {
      basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr2 = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 68);
      while (true)
      {
        uint num1;
        do
        {
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          sbyte* numPtr1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num2 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          sbyte* numPtr2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
          codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr1 = (codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60);
          codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr2 = codecvtWcharTCharIntPtr1;
          basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr3 = charTraitsWcharTPtr2;
          sbyte* numPtr3 = numPtr2;
          IntPtr num3 = (int) num2 + (IntPtr) numPtr1;
          sbyte* numPtr4;
          ref sbyte* local = ref numPtr4;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          switch (__calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) codecvtWcharTCharIntPtr1 + 24))((sbyte**) codecvtWcharTCharIntPtr2, (sbyte*) charTraitsWcharTPtr3, numPtr3, (int*) num3, (IntPtr) ref local))
          {
            case 0:
              *(sbyte*) ((IntPtr) obj0 + 66) = (sbyte) 0;
              goto case 1;
            case 1:
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
              num1 = (uint) ((IntPtr) numPtr4 - (IntPtr) numPtr5);
              if (0U < num1)
              {
                _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
                sbyte* numPtr6 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5));
                if ((int) num1 != (int) \u003CModule\u003E.fwrite((void*) numPtr6, 1U, num1, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
                  goto label_15;
              }
              if (*(byte*) ((IntPtr) obj0 + 66) != (byte) 0)
                continue;
              goto label_16;
            case 3:
              goto label_14;
            default:
              goto label_13;
          }
        }
        while (num1 != 0U);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 8U, (sbyte) 0);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
label_13:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return false;
label_14:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return true;
label_15:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return false;
label_16:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return true;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Initcvt(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* _Newpcvt)
  {
    codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr = _Newpcvt;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    if (__calli((__FnPtr<byte (IntPtr)>) *(int*) (*(int*) codecvtWcharTCharIntPtr + 4))((IntPtr) codecvtWcharTCharIntPtr) != (byte) 0)
    {
      *(int*) ((IntPtr) obj0 + 60) = 0;
    }
    else
    {
      *(int*) ((IntPtr) obj0 + 60) = (int) _Newpcvt;
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0);
    }
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Ewiden(
    [In] basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    sbyte _Byte)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc((ios_base*) obj0, &locale);
    ctype\u003Cwchar_t\u003E* ctypeWcharTPtr1;
    // ISSUE: fault handler
    try
    {
      ctypeWcharTPtr1 = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cwchar_t\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    ctype\u003Cwchar_t\u003E* ctypeWcharTPtr2 = ctypeWcharTPtr1;
    int num = (int) _Byte;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (char) __calli((__FnPtr<ushort (IntPtr, sbyte)>) *(int*) (*(int*) ctypeWcharTPtr1 + 40))((sbyte) ctypeWcharTPtr2, (IntPtr) num);
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 16) = (int) ((IntPtr) obj0 + 8);
    *(int*) ((IntPtr) obj0 + 20) = (int) ((IntPtr) obj0 + 12);
    *(int*) ((IntPtr) obj0 + 32) = (int) ((IntPtr) obj0 + 24);
    *(int*) ((IntPtr) obj0 + 36) = (int) ((IntPtr) obj0 + 28);
    *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 + 40);
    *(int*) ((IntPtr) obj0 + 52) = (int) ((IntPtr) obj0 + 44);
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esetp(obj0, (char*) 0, (char*) 0);
    *(int*) *(int*) ((IntPtr) obj0 + 16) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 32) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 48) = 0;
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esetp(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _First,
    char* _Last)
  {
    *(int*) *(int*) ((IntPtr) obj0 + 20) = (int) _First;
    *(int*) *(int*) ((IntPtr) obj0 + 36) = (int) _First;
    *(int*) *(int*) ((IntPtr) obj0 + 52) = (int) ((IntPtr) _Last - (IntPtr) _First >> 1);
  }

  internal static unsafe ctype\u003Cwchar_t\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cwchar_t\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E_Getcat(&pbVfacetLocale2B, _Loc) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (ctype\u003Cwchar_t\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E_Getcat(&pbVfacetLocale2B, _Loc) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe void \u003FA0x67178f3e\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x67178f3e\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eoverflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Epbackfail);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eshowmanyc);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eunderflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Euflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Exsgetn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Xsgetn_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Exsputn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekoff);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekpos);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esetbuf);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esync);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eimbue);
  }

  internal static unsafe void \u003FA0xa3899430\u002E\u003F\u003F__E\u003FA0xa3899430\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0xa3899430\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0xa3899430\u002E\u003F\u003F__F\u003FA0xa3899430\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xa3899430\u002E\u003F\u003F__F\u003FA0xa3899430\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0xa3899430\u002Einitlocks);

  internal static unsafe void \u003FA0xa3899430\u002E\u003F\u003F__E\u003FA0xa3899430\u0040wfin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xa3899430\u002Ewfin, \u003CModule\u003E.__iob_func());
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xa3899430\u002E\u003F\u003F__F\u003FA0xa3899430\u0040wfin\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xa3899430\u002E\u003F\u003F__F\u003FA0xa3899430\u0040wfin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xa3899430\u002Ewfin);

  internal static unsafe void \u003FA0xa3899430\u002E\u003F\u003F__Ewcin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewcin, (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0xa3899430\u002Ewfin, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xa3899430\u002E\u003F\u003F__Fwcin\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xa3899430\u002E\u003F\u003F__Fwcin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewcin);

  internal static unsafe basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Wcin_func() => &\u003CModule\u003E.std\u002Ewcin;

  internal static unsafe void \u003FA0xa3899430\u002E\u003F\u003F__E\u003FA0xa3899430\u0040init_wcin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Ptr_wcin = &\u003CModule\u003E.std\u002Ewcin;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewcin + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ewcin + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
  }

  internal static unsafe basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd,
    [In] int obj3)
  {
    uint num1 = 0;
    if (obj3 != 0)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_8\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
      basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* pThis = (basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
      *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
      // ISSUE: fault handler
      try
      {
        *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
        }
      }
    }
    // ISSUE: fault handler
    try
    {
      *(int*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 4) = 0;
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Einit((basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _Strbuf, _Isstd);
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
      }
    }
    return obj0;
  }

  internal static unsafe void \u003FA0x2d4afa33\u002E\u003F\u003F__E\u003FA0x2d4afa33\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x2d4afa33\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x2d4afa33\u002E\u003F\u003F__F\u003FA0x2d4afa33\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x2d4afa33\u002E\u003F\u003F__F\u003FA0x2d4afa33\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x2d4afa33\u002Einitlocks);

  internal static unsafe void \u003FA0x2d4afa33\u002E\u003F\u003F__E\u003FA0x2d4afa33\u0040wflog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x2d4afa33\u002Ewflog, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x2d4afa33\u002E\u003F\u003F__F\u003FA0x2d4afa33\u0040wflog\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x2d4afa33\u002E\u003F\u003F__F\u003FA0x2d4afa33\u0040wflog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x2d4afa33\u002Ewflog);

  internal static unsafe void \u003FA0x2d4afa33\u002E\u003F\u003F__Ewclog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewclog, (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x2d4afa33\u002Ewflog, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x2d4afa33\u002E\u003F\u003F__Fwclog\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x2d4afa33\u002E\u003F\u003F__Fwclog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewclog);

  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Wclog_func() => &\u003CModule\u003E.std\u002Ewclog;

  internal static unsafe void \u003FA0x2d4afa33\u002E\u003F\u003F__E\u003FA0x2d4afa33\u0040init_wclog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Ptr_wclog = &\u003CModule\u003E.std\u002Ewclog;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewclog + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ewclog + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
  }

  internal static unsafe void \u003FA0xe5294e65\u002E\u003F\u003F__E\u003FA0xe5294e65\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0xe5294e65\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0xe5294e65\u002E\u003F\u003F__F\u003FA0xe5294e65\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xe5294e65\u002E\u003F\u003F__F\u003FA0xe5294e65\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0xe5294e65\u002Einitlocks);

  internal static unsafe void \u003FA0xe5294e65\u002E\u003F\u003F__E\u003FA0xe5294e65\u0040wfout\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xe5294e65\u002Ewfout, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 32));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xe5294e65\u002E\u003F\u003F__F\u003FA0xe5294e65\u0040wfout\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xe5294e65\u002E\u003F\u003F__F\u003FA0xe5294e65\u0040wfout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xe5294e65\u002Ewfout);

  internal static unsafe void \u003FA0xe5294e65\u002E\u003F\u003F__Ewcout\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewcout, (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0xe5294e65\u002Ewfout, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xe5294e65\u002E\u003F\u003F__Fwcout\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xe5294e65\u002E\u003F\u003F__Fwcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewcout);

  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Wcout_func() => &\u003CModule\u003E.std\u002Ewcout;

  internal static unsafe _Init_wcout* std\u002E_Init_wcout\u002E\u007Bctor\u007D(
    [In] _Init_wcout* obj0)
  {
    \u003CModule\u003E.std\u002E_Ptr_wcout = &\u003CModule\u003E.std\u002Ewcout;
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_wcin != IntPtr.Zero)
    {
      basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* stdPtrWcin = \u003CModule\u003E.std\u002E_Ptr_wcin;
      int num = *(int*) (*(int*) stdPtrWcin + 4);
      *(int*) ((IntPtr) stdPtrWcin + num + 44) = (int) &\u003CModule\u003E.std\u002Ewcout;
    }
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_wcerr != IntPtr.Zero)
    {
      basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* stdPtrWcerr = \u003CModule\u003E.std\u002E_Ptr_wcerr;
      int num = *(int*) (*(int*) stdPtrWcerr + 4);
      *(int*) ((IntPtr) stdPtrWcerr + num + 44) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
    }
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_wclog != IntPtr.Zero)
    {
      basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* stdPtrWclog = \u003CModule\u003E.std\u002E_Ptr_wclog;
      int num = *(int*) (*(int*) stdPtrWclog + 4);
      *(int*) ((IntPtr) stdPtrWclog + num + 44) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
    }
    return obj0;
  }

  internal static unsafe void \u003FA0xe5294e65\u002E\u003F\u003F__E\u003FA0xe5294e65\u0040init_wcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_wcout\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xe5294e65\u002Einit_wcout);

  internal static unsafe bad_alloc* std\u002Ebad_alloc\u002E\u007Bctor\u007D(
    [In] bad_alloc* obj0)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) obj0, &\u003CModule\u003E.std\u002E\u003FA0x484de624\u002E_bad_alloc_Message, 1);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe locale* std\u002Elocale\u002Eglobal([In] locale* obj0, locale* _param1)
  {
    uint num1;
    // ISSUE: fault handler
    try
    {
      num1 = 0U;
      \u003CModule\u003E.std\u002Elocale\u002E\u007Bctor\u007D(obj0);
      num1 = 1U;
      bool flag = false;
      int num2 = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num2);
          flag = true;
        }
        locale._Locimp* locimpPtr1 = \u003CModule\u003E.std\u002Elocale\u002E_Getgloballocale();
        if ((IntPtr) locimpPtr1 != (IntPtr) *(int*) _param1)
        {
          locale.facet* facetPtr1 = \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Decref((locale.facet*) locimpPtr1);
          void* voidPtr;
          if ((IntPtr) facetPtr1 != IntPtr.Zero)
          {
            locale.facet* facetPtr2 = facetPtr1;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(int*) *(int*) facetPtr1)((uint) facetPtr2, new IntPtr(1));
          }
          else
            voidPtr = (void*) 0;
          locale._Locimp* locimpPtr2 = (locale._Locimp*) *(int*) _param1;
          \u003CModule\u003E.std\u002Elocale\u002E_Setgloballocale((void*) locimpPtr2);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref((locale.facet*) locimpPtr2);
          int num3 = *(int*) ((IntPtr) locimpPtr2 + 16) & 63;
          if (num3 == 63)
          {
            \u003CModule\u003E.setlocale(0, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) locimpPtr2 + 24)));
          }
          else
          {
            for (int index = 0; index <= 5; ++index)
            {
              if ((1 << index >> 1 & num3) != 0)
                \u003CModule\u003E.setlocale(index, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) locimpPtr2 + 24)));
            }
          }
        }
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num2);
      }
      return obj0;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num4 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) obj0);
      }
    }
  }

  [SpecialName]
  internal static unsafe bad_alloc* std\u002Ebad_alloc\u002E\u007Bctor\u007D(
    [In] bad_alloc* obj0,
    bad_alloc* _param1)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) obj0, (exception*) _param1);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Elocale\u002E_Locimp\u002E_Locimp_Addfac(
    locale._Locimp* _param0,
    locale.facet* _param1,
    uint _param2)
  {
    bool flag = false;
    int num1 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num1);
        flag = true;
      }
      if ((uint) *(int*) ((IntPtr) _param0 + 12) <= _param2)
      {
        uint num2 = _param2 + 1U;
        if (num2 < 40U)
          num2 = 40U;
        locale.facet** facetPtr = (locale.facet**) \u003CModule\u003E.realloc((void*) *(int*) ((IntPtr) _param0 + 8), num2 << 2);
        if ((IntPtr) facetPtr == IntPtr.Zero)
        {
          if (((int) \u003CModule\u003E.\u003FA0x484de624\u002E\u003F\u0024S2\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404IA & 1) == 0)
          {
            \u003CModule\u003E.\u003FA0x484de624\u002E\u003F\u0024S2\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404IA |= 1U;
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x484de624\u002E\u003Fnomem\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404Vbad_alloc\u00404\u0040B);
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x484de624\u002E\u003F\u003F__Fnomem\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV123\u0040PAVfacet\u004023\u0040I\u0040Z\u0040YMXXZ));
            }
            __fault
            {
              \u003CModule\u003E.\u003FA0x484de624\u002E\u003F\u0024S2\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404IA &= 4294967294U;
            }
          }
          bad_alloc badAlloc;
          \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bctor\u007D(&badAlloc, &\u003CModule\u003E.\u003FA0x484de624\u002E\u003Fnomem\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404Vbad_alloc\u00404\u0040B);
          \u003CModule\u003E._CxxThrowException((void*) &badAlloc, &\u003CModule\u003E._TI2\u003FAVbad_alloc\u0040std\u0040\u0040);
        }
        *(int*) ((IntPtr) _param0 + 8) = (int) facetPtr;
        while (true)
        {
          uint num3 = (uint) *(int*) ((IntPtr) _param0 + 12);
          if (num3 < num2)
          {
            *(int*) ((int) num3 * 4 + *(int*) ((IntPtr) _param0 + 8)) = 0;
            *(int*) ((IntPtr) _param0 + 12) = *(int*) ((IntPtr) _param0 + 12) + 1;
          }
          else
            break;
        }
      }
      \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(_param1);
      int num4 = (int) _param2 * 4;
      int num5 = num4 + *(int*) ((IntPtr) _param0 + 8);
      if (*(int*) num5 != 0)
      {
        locale.facet* facetPtr1 = \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Decref((locale.facet*) *(int*) num5);
        if ((IntPtr) facetPtr1 != IntPtr.Zero)
        {
          locale.facet* facetPtr2 = facetPtr1;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(int*) *(int*) facetPtr1)((uint) facetPtr2, new IntPtr(1));
        }
      }
      *(int*) (*(int*) ((IntPtr) _param0 + 8) + num4) = (int) _param1;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num1);
    }
  }

  internal static unsafe void \u003FA0x484de624\u002E\u003F\u003F__Fnomem\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV123\u0040PAVfacet\u004023\u0040I\u0040Z\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x484de624\u002E\u003Fnomem\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404Vbad_alloc\u00404\u0040B);

  internal static unsafe void std\u002E_Locinfo\u002E_Locinfo_ctor(
    _Locinfo* _param0,
    int _param1,
    sbyte* _param2)
  {
    sbyte* numPtr = \u003CModule\u003E.setlocale(0, (sbyte*) 0);
    sbyte* _Ptr = (IntPtr) numPtr != IntPtr.Zero ? numPtr : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param0 + 60), _Ptr);
    \u003CModule\u003E.std\u002E_Locinfo\u002E_Locinfo_Addcats(_param0, _param1, _param2);
  }

  internal static unsafe _Locinfo* std\u002E_Locinfo\u002E_Locinfo_Addcats(
    _Locinfo* _param0,
    int _param1,
    sbyte* _param2)
  {
    if ((IntPtr) _param2 == IntPtr.Zero)
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    if (*_param2 != (sbyte) 42 || _param2[1] != (sbyte) 0)
    {
      sbyte* _Ptr;
      switch (_param1)
      {
        case 0:
          _Ptr = \u003CModule\u003E.setlocale(0, (sbyte*) 0);
          break;
        case 63:
          _Ptr = \u003CModule\u003E.setlocale(0, _param2);
          break;
        default:
          int num = 0;
          do
          {
            if ((1 << num >> 1 & _param1) != 0)
              \u003CModule\u003E.setlocale(num, _param2);
            ++num;
          }
          while (num <= 5);
          _Ptr = \u003CModule\u003E.setlocale(0, _param2);
          break;
      }
      if ((IntPtr) _Ptr != IntPtr.Zero)
      {
        _Locinfo* locinfoPtr = (_Locinfo*) ((IntPtr) _param0 + 88);
        if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ecompare((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) locinfoPtr, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01NBENCBCI\u0040\u003F\u0024CK\u003F\u0024AA\u0040) != 0)
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) locinfoPtr, _Ptr);
          goto label_15;
        }
        else
          goto label_15;
      }
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param0 + 88), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01NBENCBCI\u0040\u003F\u0024CK\u003F\u0024AA\u0040);
label_15:
    return _param0;
  }

  internal static void \u003FA0x484de624\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x484de624\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x484de624\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe void delete(void* _param0, void* _param1)
  {
  }

  internal static unsafe locale._Locimp* std\u002Elocale\u002E_Locimp\u002E\u007Bctor\u007D(
    [In] locale._Locimp* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _Transparent)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = 1;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 8) = 0;
      *(int*) ((IntPtr) obj0 + 12) = 0;
      *(int*) ((IntPtr) obj0 + 16) = 0;
      *(sbyte*) ((IntPtr) obj0 + 20) = (sbyte) _Transparent;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 24), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01NBENCBCI\u0040\u003F\u0024CK\u003F\u0024AA\u0040);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static void _AtModuleExit_m(__FnPtr<void ()> pf)
  {
    if (\u003CModule\u003E._atexit_m_appdomain(pf) == 0)
      return;
    \u003CModule\u003E.abort();
  }

  internal static unsafe void std\u002E_Fac_node\u002E\u007Bdtor\u007D([In] _Fac_node* obj0)
  {
    locale.facet* facetPtr1 = \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Decref((locale.facet*) *(int*) ((IntPtr) obj0 + 4));
    if ((IntPtr) facetPtr1 == IntPtr.Zero)
      return;
    locale.facet* facetPtr2 = facetPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(int*) *(int*) facetPtr1)((uint) facetPtr2, new IntPtr(1));
  }

  internal static unsafe void \u003FA0xc867d7a3\u002E\u003F\u003F__E\u003FA0xc867d7a3\u0040_Fac_head\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002E_Fac_head = (_Fac_node*) 0;

  internal static unsafe void _Fac_tidy_m()
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      while ((IntPtr) \u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002E_Fac_head != IntPtr.Zero)
      {
        _Fac_node* a0xc867d7a3FacHead = \u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002E_Fac_head;
        \u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002E_Fac_head = (_Fac_node*) *(int*) \u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002E_Fac_head;
        \u003CModule\u003E.std\u002E_Fac_node\u002E__delDtor(a0xc867d7a3FacHead, 1U);
      }
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe void* std\u002E_Fac_node\u002E__delDtor([In] _Fac_node* obj0, uint _param1)
  {
    \u003CModule\u003E.std\u002E_Fac_node\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Elocale\u002Efacet\u002Efacet_Register_m(locale.facet* _param0)
  {
    if ((IntPtr) \u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002E_Fac_head == IntPtr.Zero)
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._AtModuleExit_m((__FnPtr<void ()>) __methodptr(_Fac_tidy_m));
    }
    _Fac_node* facNodePtr1 = (_Fac_node*) \u003CModule\u003E.@new(8U);
    _Fac_node* facNodePtr2;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) facNodePtr1 != IntPtr.Zero)
      {
        *(int*) facNodePtr1 = (int) \u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002E_Fac_head;
        *(int*) ((IntPtr) facNodePtr1 + 4) = (int) _param0;
        facNodePtr2 = facNodePtr1;
      }
      else
        facNodePtr2 = (_Fac_node*) 0;
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) facNodePtr1);
    }
    \u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002E_Fac_head = facNodePtr2;
  }

  internal static unsafe void _Deletegloballocale(void* ptr)
  {
    locale._Locimp* locimpPtr = (locale._Locimp*) *(int*) ptr;
    if ((IntPtr) locimpPtr == IntPtr.Zero)
      return;
    locale.facet* facetPtr1 = \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Decref((locale.facet*) locimpPtr);
    if ((IntPtr) facetPtr1 == IntPtr.Zero)
      return;
    locale.facet* facetPtr2 = facetPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(int*) *(int*) facetPtr1)((uint) facetPtr2, new IntPtr(1));
  }

  internal static unsafe void \u003FA0xc867d7a3\u002E\u003F\u003F__E\u003FA0xc867d7a3\u0040global_locale\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0xc867d7a3\u002Eglobal_locale = (locale._Locimp*) 0;

  internal static unsafe void \u003FA0xc867d7a3\u002Etidy_global()
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      \u003CModule\u003E._Deletegloballocale((void*) &\u003CModule\u003E.\u003FA0xc867d7a3\u002Eglobal_locale);
      \u003CModule\u003E.\u003FA0xc867d7a3\u002Eglobal_locale = (locale._Locimp*) 0;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe locale._Locimp* std\u002Elocale\u002E_Getgloballocale() => \u003CModule\u003E.\u003FA0xc867d7a3\u002Eglobal_locale;

  internal static unsafe void std\u002Elocale\u002E_Setgloballocale(void* _param0)
  {
    if (((int) \u003CModule\u003E.\u003FA0xc867d7a3\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404IA & 1) == 0)
    {
      \u003CModule\u003E.\u003FA0xc867d7a3\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404IA |= 1U;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.\u003FA0xc867d7a3\u002E\u003Fregistered\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404_NA = false;
      }
      __fault
      {
        \u003CModule\u003E.\u003FA0xc867d7a3\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404IA &= 4294967294U;
      }
    }
    if (!\u003CModule\u003E.\u003FA0xc867d7a3\u002E\u003Fregistered\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404_NA)
    {
      \u003CModule\u003E.\u003FA0xc867d7a3\u002E\u003Fregistered\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404_NA = true;
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._Atexit((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003Ftidy_global\u0040\u003FA0xc867d7a3\u0040\u0040\u0024\u0024J0YAXXZ);
    }
    \u003CModule\u003E.\u003FA0xc867d7a3\u002Eglobal_locale = (locale._Locimp*) _param0;
  }

  internal static void \u003FA0xc867d7a3\u002E\u003F\u003F__E\u003FA0xc867d7a3\u0040classic_locale\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xc867d7a3\u002E\u003F\u003F__F\u003FA0xc867d7a3\u0040classic_locale\u0040std\u0040\u0040YMXXZ));

  internal static unsafe void \u003FA0xc867d7a3\u002E\u003F\u003F__F\u003FA0xc867d7a3\u0040classic_locale\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002Eclassic_locale);

  internal static unsafe void \u003FA0xc867d7a3\u002E\u003F\u003F__E\u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A = (locale._Locimp*) 0;

  internal static unsafe locale._Locimp** std\u002Elocale\u002E_Locimp\u002E_Clocptr_func() => &\u003CModule\u003E.\u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A;

  internal static void \u003FA0xc867d7a3\u002E\u003F\u003F__E\u003F_Id_cnt\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Id_cnt\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0HA = 0;

  internal static unsafe int* std\u002Elocale\u002Eid\u002E_Id_cnt_func() => &\u003CModule\u003E.\u003F_Id_cnt\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0HA;

  internal static void \u003FA0xc867d7a3\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe locale.id* std\u002Ectype\u003Cchar\u003E\u002E_Id_func() => &\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;

  internal static void \u003FA0xc867d7a3\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe locale.id* std\u002Ectype\u003Cwchar_t\u003E\u002E_Id_func() => &\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;

  internal static void \u003FA0xc867d7a3\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe locale.id* std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E_Id_func() => &\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;

  internal static void \u003FA0xc867d7a3\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe locale.id* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Id_func() => &\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;

  internal static void \u003FA0xc867d7a3\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe locale.id* std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E_Id_func() => &\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;

  internal static unsafe locale* std\u002Elocale\u002Eclassic()
  {
    \u003CModule\u003E.std\u002Elocale\u002E_Init();
    return &\u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002Eclassic_locale;
  }

  internal static unsafe locale* std\u002Elocale\u002Eempty([In] locale* obj0)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Elocale\u002E_Init();
    locale._Locimp* locimpPtr1 = (locale._Locimp*) \u003CModule\u003E.@new(52U);
    // ISSUE: fault handler
    try
    {
      locale._Locimp* locimpPtr2;
      // ISSUE: fault handler
      try
      {
        locimpPtr2 = (IntPtr) locimpPtr1 == IntPtr.Zero ? (locale._Locimp*) 0 : \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E\u007Bctor\u007D(locimpPtr1, true);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) locimpPtr1);
      }
      *(int*) obj0 = (int) locimpPtr2;
      num1 = 1U;
      return obj0;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) obj0);
      }
    }
  }

  internal static unsafe locale._Locimp* std\u002Elocale\u002E_Init()
  {
    locale._Locimp* locimpPtr1 = \u003CModule\u003E.\u003FA0xc867d7a3\u002Eglobal_locale;
    if ((IntPtr) \u003CModule\u003E.\u003FA0xc867d7a3\u002Eglobal_locale == IntPtr.Zero)
    {
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        locimpPtr1 = \u003CModule\u003E.\u003FA0xc867d7a3\u002Eglobal_locale;
        if ((IntPtr) \u003CModule\u003E.\u003FA0xc867d7a3\u002Eglobal_locale == IntPtr.Zero)
        {
          locale._Locimp* locimpPtr2 = (locale._Locimp*) \u003CModule\u003E.@new(52U);
          locale._Locimp* locimpPtr3;
          // ISSUE: fault handler
          try
          {
            locimpPtr3 = (IntPtr) locimpPtr2 == IntPtr.Zero ? (locale._Locimp*) 0 : \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E\u007Bctor\u007D(locimpPtr2, false);
          }
          __fault
          {
            \u003CModule\u003E.delete((void*) locimpPtr2);
          }
          locimpPtr1 = locimpPtr3;
          \u003CModule\u003E.std\u002Elocale\u002E_Setgloballocale((void*) locimpPtr3);
          *(int*) ((IntPtr) locimpPtr3 + 16) = 63;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) locimpPtr3 + 24), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
          \u003CModule\u003E.\u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A = locimpPtr3;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref((locale.facet*) locimpPtr3);
          locale* localePtr1 = &\u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002Eclassic_locale;
          // ISSUE: fault handler
          try
          {
            locale._Locimp* localeStdQ0PaV123A = \u003CModule\u003E.\u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ref \u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002Eclassic_locale = (int) \u003CModule\u003E.\u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A;
            locale* localePtr2 = &\u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002Eclassic_locale;
            locale* localePtr3 = &\u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002Eclassic_locale;
          }
          __fault
          {
            \u003CModule\u003E.delete((void*) localePtr1, (void*) &\u003CModule\u003E.std\u002E\u003FA0xc867d7a3\u002Eclassic_locale);
          }
        }
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    return locimpPtr1;
  }

  internal static unsafe void std\u002Elocale\u002E_Locimp\u002E_Locimp_dtor(locale._Locimp* _param0)
  {
    bool flag = false;
    int num1 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num1);
        flag = true;
      }
      uint num2 = (uint) *(int*) ((IntPtr) _param0 + 12);
      while (0U < num2)
      {
        --num2;
        int num3 = (int) num2 * 4 + *(int*) ((IntPtr) _param0 + 8);
        if (*(int*) num3 != 0)
        {
          locale.facet* facetPtr1 = \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Decref((locale.facet*) *(int*) num3);
          if ((IntPtr) facetPtr1 != IntPtr.Zero)
          {
            locale.facet* facetPtr2 = facetPtr1;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(int*) *(int*) facetPtr1)((uint) facetPtr2, new IntPtr(1));
          }
        }
      }
      \u003CModule\u003E.free((void*) *(int*) ((IntPtr) _param0 + 8));
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num1);
    }
  }

  internal static unsafe void std\u002E_Locinfo\u002E_Locinfo_ctor(
    _Locinfo* _param0,
    sbyte* _param1)
  {
    sbyte* numPtr = \u003CModule\u003E.setlocale(0, (sbyte*) 0);
    sbyte* _Ptr1 = (IntPtr) numPtr != IntPtr.Zero ? numPtr : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param0 + 60), _Ptr1);
    sbyte* _Ptr2;
    if ((IntPtr) _param1 != IntPtr.Zero)
    {
      _param1 = \u003CModule\u003E.setlocale(0, _param1);
      if ((IntPtr) _param1 != IntPtr.Zero)
      {
        _Ptr2 = _param1;
        goto label_4;
      }
    }
    _Ptr2 = (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01NBENCBCI\u0040\u003F\u0024CK\u003F\u0024AA\u0040;
label_4:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param0 + 88), _Ptr2);
  }

  internal static unsafe void std\u002E_Locinfo\u002E_Locinfo_ctor(
    _Locinfo* _param0,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _param1)
  {
    sbyte* numPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(_param1);
    sbyte* numPtr2 = \u003CModule\u003E.setlocale(0, (sbyte*) 0);
    sbyte* _Ptr1 = (IntPtr) numPtr2 != IntPtr.Zero ? numPtr2 : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param0 + 60), _Ptr1);
    sbyte* _Ptr2;
    if ((IntPtr) numPtr1 != IntPtr.Zero)
    {
      sbyte* numPtr3 = \u003CModule\u003E.setlocale(0, numPtr1);
      if ((IntPtr) numPtr3 != IntPtr.Zero)
      {
        _Ptr2 = numPtr3;
        goto label_4;
      }
    }
    _Ptr2 = (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01NBENCBCI\u0040\u003F\u0024CK\u003F\u0024AA\u0040;
label_4:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param0 + 88), _Ptr2);
  }

  internal static unsafe void std\u002E_Locinfo\u002E_Locinfo_dtor(_Locinfo* _param0)
  {
    if (0U >= (uint) *(int*) ((IntPtr) _param0 + 80))
      return;
    \u003CModule\u003E.setlocale(0, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param0 + 60)));
  }

  internal static void \u003FA0x388f666f\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x388f666f\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x388f666f\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x388f666f\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x388f666f\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x388f666f\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x388f666f\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x388f666f\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  [SpecialName]
  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(obj0, _Right, 0U, uint.MaxValue);
    return obj0;
  }

  [SpecialName]
  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(obj0, _Right, 0U, uint.MaxValue);
    return obj0;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right,
    uint _Roff,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) _Right + 20) < _Roff)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num = (uint) *(int*) ((IntPtr) _Right + 20) - _Roff;
    if (_Count < num)
      num = _Count;
    if (obj0 == _Right)
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eerase(obj0, num + _Roff, uint.MaxValue);
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eerase(obj0, 0U, _Roff);
    }
    else if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Grow(obj0, num, false))
    {
      \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0), (uint) *(int*) ((IntPtr) obj0 + 24), (char*) ((int) _Roff * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(_Right)), num);
      *(int*) ((IntPtr) obj0 + 20) = (int) num;
      *(short*) ((int) num * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eerase(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) obj0 + 20) < _Off)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 20) - _Off;
    if (num1 < _Count)
      _Count = num1;
    if (0U < _Count)
    {
      \u003CModule\u003E.std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E((char*) ((int) _Off * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)), (uint) *(int*) ((IntPtr) obj0 + 24) - _Off, (char*) (((int) _Off + (int) _Count) * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)), num1 - _Count);
      uint num2 = (uint) *(int*) ((IntPtr) obj0 + 20) - _Count;
      *(int*) ((IntPtr) obj0 + 20) = (int) num2;
      *(short*) ((int) num2 * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
    }
    return obj0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Grow(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Newsize,
    [MarshalAs(UnmanagedType.U1)] bool _Trim)
  {
    if (2147483646U < _Newsize)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if ((uint) *(int*) ((IntPtr) obj0 + 24) < _Newsize)
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Copy(obj0, _Newsize, (uint) *(int*) ((IntPtr) obj0 + 20));
    else if (_Trim && _Newsize < 8U)
    {
      uint num = (uint) *(int*) ((IntPtr) obj0 + 20);
      uint _Newsize1 = _Newsize >= num ? num : _Newsize;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, true, _Newsize1);
    }
    else if (_Newsize == 0U)
    {
      *(int*) ((IntPtr) obj0 + 20) = 0;
      *\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0) = char.MinValue;
    }
    return 0U < _Newsize;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _Built,
    uint _Newsize)
  {
    if (_Built && 8U <= (uint) *(int*) ((IntPtr) obj0 + 24))
    {
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _First1 = (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
      char* _First2 = (char*) *(int*) _First1;
      if (0U < _Newsize)
        \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E((char*) _First1, 8U, _First2, _Newsize);
      \u003CModule\u003E.delete((void*) _First2);
    }
    *(int*) ((IntPtr) obj0 + 24) = 7;
    *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
    *(short*) ((int) _Newsize * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
  }

  internal static unsafe char* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return 8U <= (uint) *(int*) ((IntPtr) obj0 + 24) ? (char*) *(int*) ((IntPtr) obj0 + 4) : (char*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe char* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return 8U <= (uint) *(int*) ((IntPtr) obj0 + 24) ? (char*) *(int*) ((IntPtr) obj0 + 4) : (char*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right,
    uint _Roff,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) _Right + 20) < _Roff)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num = (uint) *(int*) ((IntPtr) _Right + 20) - _Roff;
    if (_Count < num)
      num = _Count;
    if (obj0 == _Right)
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eerase(obj0, num + _Roff, uint.MaxValue);
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eerase(obj0, 0U, _Roff);
    }
    else if (\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Grow(obj0, num, false))
    {
      \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0), (uint) *(int*) ((IntPtr) obj0 + 24), (ushort*) ((int) _Roff * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(_Right)), num);
      *(int*) ((IntPtr) obj0 + 20) = (int) num;
      *(short*) ((int) num * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eerase(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) obj0 + 20) < _Off)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 20) - _Off;
    if (num1 < _Count)
      _Count = num1;
    if (0U < _Count)
    {
      \u003CModule\u003E.std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E((ushort*) ((int) _Off * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)), (uint) *(int*) ((IntPtr) obj0 + 24) - _Off, (ushort*) (((int) _Off + (int) _Count) * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)), num1 - _Count);
      uint num2 = (uint) *(int*) ((IntPtr) obj0 + 20) - _Count;
      *(int*) ((IntPtr) obj0 + 20) = (int) num2;
      *(short*) ((int) num2 * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
    }
    return obj0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Grow(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _Newsize,
    [MarshalAs(UnmanagedType.U1)] bool _Trim)
  {
    if (2147483646U < _Newsize)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if ((uint) *(int*) ((IntPtr) obj0 + 24) < _Newsize)
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Copy(obj0, _Newsize, (uint) *(int*) ((IntPtr) obj0 + 20));
    else if (_Trim && _Newsize < 8U)
    {
      uint num = (uint) *(int*) ((IntPtr) obj0 + 20);
      uint _Newsize1 = _Newsize >= num ? num : _Newsize;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(obj0, true, _Newsize1);
    }
    else if (_Newsize == 0U)
    {
      *(int*) ((IntPtr) obj0 + 20) = 0;
      *\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0) = (ushort) 0;
    }
    return 0U < _Newsize;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _Built,
    uint _Newsize)
  {
    if (_Built && 8U <= (uint) *(int*) ((IntPtr) obj0 + 24))
    {
      basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _First1 = (basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
      ushort* _First2 = (ushort*) *(int*) _First1;
      if (0U < _Newsize)
        \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E((ushort*) _First1, 8U, _First2, _Newsize);
      \u003CModule\u003E.delete((void*) _First2);
    }
    *(int*) ((IntPtr) obj0 + 24) = 7;
    *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
    *(short*) ((int) _Newsize * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
  }

  internal static unsafe ushort* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return 8U <= (uint) *(int*) ((IntPtr) obj0 + 24) ? (ushort*) *(int*) ((IntPtr) obj0 + 4) : (ushort*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe ushort* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return 8U <= (uint) *(int*) ((IntPtr) obj0 + 24) ? (ushort*) *(int*) ((IntPtr) obj0 + 4) : (ushort*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe void std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Copy(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Newsize,
    uint _Oldlen)
  {
    uint num1 = (uint) \u003CModule\u003E.__CxxQueryExceptionSize();
    // ISSUE: untyped stack allocation
    int num2 = (int) __untypedstackalloc((int) num1 << 1);
    uint num3 = _Newsize | 7U;
    if (2147483646U < num3)
    {
      num3 = _Newsize;
    }
    else
    {
      uint num4 = (uint) *(int*) ((IntPtr) obj0 + 24);
      uint num5 = num4 >> 1;
      if (num3 / 3U < num5 && num4 <= 2147483646U - num5)
        num3 = num5 + num4;
    }
    char* _First1 = (char*) 0;
    int num6;
    try
    {
      num6 = (int) num1 + num2;
      _First1 = \u003CModule\u003E.std\u002E_Allocate\u003Cwchar_t\u003E(num3 + 1U, (char*) 0);
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode1 = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num7 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num6);
      try
      {
        try
        {
          num3 = _Newsize;
          try
          {
            _First1 = \u003CModule\u003E.std\u002E_Allocate\u003Cwchar_t\u003E(_Newsize + 1U, (char*) 0);
            goto label_23;
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            uint exceptionCode2 = (uint) Marshal.GetExceptionCode();
            if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
            uint num8 = 0;
            \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num2);
            try
            {
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
                \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
              }
              catch (Exception ex3) when (
              {
                // ISSUE: unable to correctly present filter
                num8 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
                if (num8 != 0U)
                {
                  SuccessfulFiltering;
                }
                else
                  throw;
              }
              )
              {
              }
              if (num8 != 0U)
                throw;
              else
                goto label_23;
            }
            finally
            {
              \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num2, (int) num8);
            }
          }
        }
        catch (Exception ex4) when (
        {
          // ISSUE: unable to correctly present filter
          num7 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num7 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num7 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num6, (int) num7);
      }
    }
label_23:
    if (0U < _Oldlen)
      \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First1, num3 + 1U, \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0), _Oldlen);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
    *(int*) ((IntPtr) obj0 + 4) = (int) _First1;
    *(int*) ((IntPtr) obj0 + 24) = (int) num3;
    *(int*) ((IntPtr) obj0 + 20) = (int) _Oldlen;
    *(short*) ((int) _Oldlen * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Copy(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _Newsize,
    uint _Oldlen)
  {
    uint num1 = (uint) \u003CModule\u003E.__CxxQueryExceptionSize();
    // ISSUE: untyped stack allocation
    int num2 = (int) __untypedstackalloc((int) num1 << 1);
    uint num3 = _Newsize | 7U;
    if (2147483646U < num3)
    {
      num3 = _Newsize;
    }
    else
    {
      uint num4 = (uint) *(int*) ((IntPtr) obj0 + 24);
      uint num5 = num4 >> 1;
      if (num3 / 3U < num5 && num4 <= 2147483646U - num5)
        num3 = num5 + num4;
    }
    ushort* _First1 = (ushort*) 0;
    int num6;
    try
    {
      num6 = (int) num1 + num2;
      _First1 = \u003CModule\u003E.std\u002E_Allocate\u003Cunsigned\u0020short\u003E(num3 + 1U, (ushort*) 0);
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode1 = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num7 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num6);
      try
      {
        try
        {
          num3 = _Newsize;
          try
          {
            _First1 = \u003CModule\u003E.std\u002E_Allocate\u003Cunsigned\u0020short\u003E(_Newsize + 1U, (ushort*) 0);
            goto label_23;
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            uint exceptionCode2 = (uint) Marshal.GetExceptionCode();
            if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
            uint num8 = 0;
            \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num2);
            try
            {
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
                \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
              }
              catch (Exception ex3) when (
              {
                // ISSUE: unable to correctly present filter
                num8 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
                if (num8 != 0U)
                {
                  SuccessfulFiltering;
                }
                else
                  throw;
              }
              )
              {
              }
              if (num8 != 0U)
                throw;
              else
                goto label_23;
            }
            finally
            {
              \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num2, (int) num8);
            }
          }
        }
        catch (Exception ex4) when (
        {
          // ISSUE: unable to correctly present filter
          num7 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num7 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num7 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num6, (int) num7);
      }
    }
label_23:
    if (0U < _Oldlen)
      \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First1, num3 + 1U, \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0), _Oldlen);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
    *(int*) ((IntPtr) obj0 + 4) = (int) _First1;
    *(int*) ((IntPtr) obj0 + 24) = (int) num3;
    *(int*) ((IntPtr) obj0 + 20) = (int) _Oldlen;
    *(short*) ((int) _Oldlen * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
  }

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static void \u003FA0x4a1bf91e\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe char* std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(
    char* _First1,
    uint _Size,
    char* _First2,
    uint _Count)
  {
    \u003CModule\u003E.memmove_s((void*) _First1, _Size << 1, (void*) _First2, _Count << 1);
    return _First1;
  }

  internal static unsafe ushort* std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(
    ushort* _First1,
    uint _Size,
    ushort* _First2,
    uint _Count)
  {
    \u003CModule\u003E.memmove_s((void*) _First1, _Size << 1, (void*) _First2, _Count << 1);
    return _First1;
  }

  internal static unsafe char* std\u002E_Allocate\u003Cwchar_t\u003E(
    uint _Count,
    char* __unnamed001)
  {
    if (_Count <= 0U)
      _Count = 0U;
    else if (uint.MaxValue / _Count < 2U)
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    return (char*) \u003CModule\u003E.@new(_Count << 1);
  }

  internal static unsafe ushort* std\u002E_Allocate\u003Cunsigned\u0020short\u003E(
    uint _Count,
    ushort* __unnamed001)
  {
    if (_Count <= 0U)
      _Count = 0U;
    else if (uint.MaxValue / _Count < 2U)
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    return (ushort*) \u003CModule\u003E.@new(_Count << 1);
  }

  internal static unsafe short _Getwctype([MarshalAs(UnmanagedType.U2)] char _Ch, _Ctypevec* _Ctype)
  {
    short num;
    return \u003CModule\u003E.__crtGetStringTypeW((localeinfo_struct*) 0, 1U, &_Ch, 1, (ushort*) &num, *(int*) ((IntPtr) _Ctype + 4), *(int*) _Ctype) != 0 ? num : (short) 0;
  }

  internal static unsafe char* _Getwctypes(
    char* _First,
    char* _Last,
    short* _Dest,
    _Ctypevec* _Ctype)
  {
    \u003CModule\u003E.__crtGetStringTypeW((localeinfo_struct*) 0, 1U, _First, (int) ((IntPtr) _Last - (IntPtr) _First >> 1), (ushort*) _Dest, *(int*) ((IntPtr) _Ctype + 4), *(int*) _Ctype);
    return _Last;
  }

  internal static unsafe void* __InlineInterlockedCompareExchangePointer(
    void** Destination,
    void* ExChange,
    void* Comperand)
  {
    return (void*) \u003CModule\u003E.InterlockedCompareExchange((int*) Destination, (int) ExChange, (int) Comperand);
  }

  internal static unsafe int _Mbrtowc(char* pwc, sbyte* s, uint n, int* pst, _Cvtvec* ploc)
  {
    if ((IntPtr) s == IntPtr.Zero || n == 0U)
      return 0;
    if (*s == (sbyte) 0)
    {
      if ((IntPtr) pwc != IntPtr.Zero)
        *pwc = char.MinValue;
      return 0;
    }
    uint num1;
    int num2;
    if ((IntPtr) ploc == IntPtr.Zero)
    {
      int num3 = (int) \u003CModule\u003E.___lc_handle_func()[2];
      num1 = \u003CModule\u003E.___lc_codepage_func();
      num2 = num3;
    }
    else
    {
      num2 = *(int*) ploc;
      num1 = (uint) *(int*) ((IntPtr) ploc + 4);
    }
    if (num2 == 0)
    {
      if ((IntPtr) pwc != IntPtr.Zero)
        *pwc = (char) (byte) *s;
      return 1;
    }
    localeinfo_struct* localeForCp = \u003CModule\u003E._GetLocaleForCP(num1);
    if (*pst != 0)
    {
      ((byte*) pst)[1] = (byte) *s;
      if (\u003CModule\u003E.___mb_cur_max_l_func(localeForCp) > 1)
      {
        int num4 = (IntPtr) pwc != IntPtr.Zero ? 1 : 0;
        if (\u003CModule\u003E.MultiByteToWideChar(num1, 9U, (sbyte*) pst, 2, pwc, num4) != 0)
        {
          *pst = 0;
          return \u003CModule\u003E.___mb_cur_max_l_func(localeForCp);
        }
      }
      *pst = 0;
      *\u003CModule\u003E._errno() = 42;
      return -1;
    }
    if (((IntPtr) localeForCp != IntPtr.Zero ? (int) *(byte*) ((int) (byte) *s + *(int*) ((IntPtr) localeForCp + 4) + 29) & 4 : (int) *(ushort*) ((int) (byte) *s * 2 + (IntPtr) \u003CModule\u003E.__pctype_func()) & 32768) != 0)
    {
      if (n < (uint) \u003CModule\u003E.___mb_cur_max_l_func(localeForCp))
      {
        *(sbyte*) pst = *s;
        return -2;
      }
      if (\u003CModule\u003E.___mb_cur_max_l_func(localeForCp) > 1)
      {
        int num5 = (IntPtr) pwc != IntPtr.Zero ? 1 : 0;
        if (\u003CModule\u003E.MultiByteToWideChar(num1, 9U, s, \u003CModule\u003E.___mb_cur_max_l_func(localeForCp), pwc, num5) != 0)
          goto label_24;
      }
      if (s[1] == (sbyte) 0)
      {
        *pst = 0;
        *\u003CModule\u003E._errno() = 42;
        return -1;
      }
label_24:
      return \u003CModule\u003E.___mb_cur_max_l_func(localeForCp);
    }
    int num6 = (IntPtr) pwc != IntPtr.Zero ? 1 : 0;
    if (\u003CModule\u003E.MultiByteToWideChar(num1, 9U, s, 1, pwc, num6) != 0)
      return 1;
    *\u003CModule\u003E._errno() = 42;
    return -1;
  }

  internal static unsafe int _Mbrtowc(ushort* pwc, sbyte* s, uint n, int* pst, _Cvtvec* ploc) => \u003CModule\u003E._Mbrtowc((char*) pwc, s, n, pst, ploc);

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char _Towlower([MarshalAs(UnmanagedType.U2)] char _Ch, _Ctypevec* _Ctype)
  {
    char ch = _Ch;
    if (_Ch != char.MaxValue)
    {
      uint num = (uint) *(int*) _Ctype;
      if (num == 0U && _Ch < 'Ā')
      {
        if ((ushort) ((uint) _Ch + 65471U) <= (ushort) 25)
          ch = (char) ((int) _Ch + 32);
      }
      else if (\u003CModule\u003E.__crtLCMapStringW((localeinfo_struct*) 0, num, 256U, &_Ch, 1, &ch, 1, *(int*) ((IntPtr) _Ctype + 4)) == 0)
        ch = _Ch;
    }
    return ch;
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char _Towupper([MarshalAs(UnmanagedType.U2)] char _Ch, _Ctypevec* _Ctype)
  {
    char ch = _Ch;
    if (_Ch != char.MaxValue)
    {
      uint num = (uint) *(int*) _Ctype;
      if (num == 0U && _Ch < 'Ā')
      {
        if ((ushort) ((uint) _Ch + 65439U) <= (ushort) 25)
          ch = (char) ((int) _Ch - 32);
      }
      else if (\u003CModule\u003E.__crtLCMapStringW((localeinfo_struct*) 0, num, 512U, &_Ch, 1, &ch, 1, *(int*) ((IntPtr) _Ctype + 4)) == 0)
        ch = _Ch;
    }
    return ch;
  }

  internal static unsafe int __Wcrtomb_lk(sbyte* s, [MarshalAs(UnmanagedType.U2)] char wchar, int* pst, _Cvtvec* ploc) => \u003CModule\u003E._Wcrtomb(s, wchar, pst, ploc);

  internal static unsafe int _Wcrtomb(sbyte* s, [MarshalAs(UnmanagedType.U2)] char wchar, int* pst, _Cvtvec* ploc)
  {
    uint num1;
    int num2;
    if ((IntPtr) ploc == IntPtr.Zero)
    {
      int num3 = (int) \u003CModule\u003E.___lc_handle_func()[2];
      num1 = \u003CModule\u003E.___lc_codepage_func();
      num2 = num3;
    }
    else
    {
      num2 = *(int*) ploc;
      num1 = (uint) *(int*) ((IntPtr) ploc + 4);
    }
    if (num2 == 0)
    {
      if (wchar > 'ÿ')
      {
        *\u003CModule\u003E._errno() = 42;
        return -1;
      }
      *s = (sbyte) wchar;
      return 1;
    }
    int num4 = 0;
    localeinfo_struct* localeForCp = \u003CModule\u003E._GetLocaleForCP(num1);
    int multiByte = \u003CModule\u003E.WideCharToMultiByte(num1, 0U, &wchar, 1, s, \u003CModule\u003E.___mb_cur_max_l_func(localeForCp), (sbyte*) 0, &num4);
    if (multiByte != 0 && num4 == 0)
      return multiByte;
    *\u003CModule\u003E._errno() = 42;
    return -1;
  }

  internal static unsafe int _Wcrtomb(sbyte* s, ushort wchar, int* pst, _Cvtvec* ploc) => \u003CModule\u003E._Wcrtomb(s, (char) wchar, pst, ploc);

  internal static unsafe _Cvtvec _Getcvt()
  {
    _Cvtvec cvtvec;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref cvtvec = (int) \u003CModule\u003E.___lc_handle_func()[2];
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &cvtvec + 4) = (int) \u003CModule\u003E.___lc_codepage_func();
    return cvtvec;
  }

  internal static unsafe void std\u002E_Mutex\u002E_Mutex_ctor(_Mutex* _param0)
  {
    void* _Mtx = \u003CModule\u003E.@new(24U);
    *(int*) _param0 = (int) _Mtx;
    \u003CModule\u003E._Mtxinit((_RTL_CRITICAL_SECTION*) _Mtx);
  }

  internal static unsafe void std\u002E_Mutex\u002E_Mutex_dtor(_Mutex* _param0)
  {
    \u003CModule\u003E._Mtxdst((_RTL_CRITICAL_SECTION*) *(int*) _param0);
    \u003CModule\u003E.delete((void*) *(int*) _param0);
  }

  internal static unsafe void std\u002E_Mutex\u002E_Mutex_Lock(_Mutex* _param0) => \u003CModule\u003E._Mtxlock((_RTL_CRITICAL_SECTION*) *(int*) _param0);

  internal static unsafe void std\u002E_Mutex\u002E_Mutex_Unlock(_Mutex* _param0) => \u003CModule\u003E._Mtxunlock((_RTL_CRITICAL_SECTION*) *(int*) _param0);

  internal static unsafe void std\u002E_Init_locks\u002E_Init_locks_ctor(_Init_locks* _param0)
  {
    if (\u003CModule\u003E.InterlockedIncrement(&\u003CModule\u003E.std\u002E\u003FA0x3d15c383\u002Einit) != 0)
      return;
    _RTL_CRITICAL_SECTION* _Mtx = (_RTL_CRITICAL_SECTION*) &\u003CModule\u003E.std\u002E\u003FA0x3d15c383\u002Emtx;
    // ISSUE: cast to a reference type
    do
    {
      \u003CModule\u003E._Mtxinit(_Mtx);
      _Mtx += 24;
    }
    while ((IntPtr) _Mtx < (\u0024ArrayType\u0024\u0024\u0024BY03U_RTL_CRITICAL_SECTION\u0040\u0040&) ((IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x3d15c383\u002Emtx + 96));
  }

  internal static unsafe void std\u002E_Init_locks\u002E_Init_locks_dtor(_Init_locks* _param0)
  {
    if (\u003CModule\u003E.InterlockedDecrement(&\u003CModule\u003E.std\u002E\u003FA0x3d15c383\u002Einit) >= 0)
      return;
    _RTL_CRITICAL_SECTION* _Mtx = (_RTL_CRITICAL_SECTION*) &\u003CModule\u003E.std\u002E\u003FA0x3d15c383\u002Emtx;
    // ISSUE: cast to a reference type
    do
    {
      \u003CModule\u003E._Mtxdst(_Mtx);
      _Mtx += 24;
    }
    while ((IntPtr) _Mtx < (\u0024ArrayType\u0024\u0024\u0024BY03U_RTL_CRITICAL_SECTION\u0040\u0040&) ((IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x3d15c383\u002Emtx + 96));
  }

  internal static unsafe void \u003FA0x3d15c383\u002E\u003F\u003F__E\u003FA0x3d15c383\u0040initlocks\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.std\u002E\u003FA0x3d15c383\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3d15c383\u002E\u003F\u003F__F\u003FA0x3d15c383\u0040initlocks\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3d15c383\u002E\u003F\u003F__F\u003FA0x3d15c383\u0040initlocks\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.std\u002E\u003FA0x3d15c383\u002Einitlocks);

  internal static unsafe void std\u002E_Lockit\u002E_Lockit_ctor(_Lockit* _param0) => \u003CModule\u003E._Mtxlock((_RTL_CRITICAL_SECTION*) &\u003CModule\u003E.std\u002E\u003FA0x3d15c383\u002Emtx);

  internal static unsafe void std\u002E_Lockit\u002E_Lockit_ctor(_Lockit* _param0, int _param1)
  {
    int num = _param1 & 3;
    *(int*) _param0 = num;
    \u003CModule\u003E._Mtxlock((_RTL_CRITICAL_SECTION*) (num * 24 + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x3d15c383\u002Emtx));
  }

  internal static unsafe void std\u002E_Lockit\u002E_Lockit_dtor(_Lockit* _param0) => \u003CModule\u003E._Mtxunlock((_RTL_CRITICAL_SECTION*) (*(int*) _param0 * 24 + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x3d15c383\u002Emtx));

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void std\u002E_Lockit\u002E_Lockit_ctor(int _param0) => \u003CModule\u003E._Mtxlock((_RTL_CRITICAL_SECTION*) ((_param0 & 3) * 24 + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x3d15c383\u002Emtx));

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void std\u002E_Lockit\u002E_Lockit_dtor(int _param0) => \u003CModule\u003E._Mtxunlock((_RTL_CRITICAL_SECTION*) ((_param0 & 3) * 24 + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x3d15c383\u002Emtx));

  internal static unsafe void _Once(int* _Cntrl, __FnPtr<void ()> _Func)
  {
    if (*_Cntrl == 2)
      return;
    switch (\u003CModule\u003E.InterlockedExchange(_Cntrl, 1))
    {
      case 0:
        // ISSUE: function pointer call
        __calli(_Func)();
        *_Cntrl = 2;
        break;
      case 2:
        *_Cntrl = 2;
        break;
      default:
        if (*_Cntrl == 2)
          break;
        do
        {
          \u003CModule\u003E.Sleep(1U);
        }
        while (*_Cntrl != 2);
        break;
    }
  }

  internal static unsafe void _Mtxinit(_RTL_CRITICAL_SECTION* _Mtx) => \u003CModule\u003E.InitializeCriticalSection(_Mtx);

  internal static unsafe void _Mtxdst(_RTL_CRITICAL_SECTION* _Mtx) => \u003CModule\u003E.DeleteCriticalSection(_Mtx);

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void _Mtxlock(_RTL_CRITICAL_SECTION* _Mtx)
  {
    Thread.BeginThreadAffinity();
    \u003CModule\u003E.EnterCriticalSection(_Mtx);
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void _Mtxunlock(_RTL_CRITICAL_SECTION* _Mtx)
  {
    \u003CModule\u003E.LeaveCriticalSection(_Mtx);
    Thread.EndThreadAffinity();
  }

  [SuppressUnmanagedCodeSecurity]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DllImport("kernel32.dll")]
  public static extern unsafe void EnterCriticalSection(_RTL_CRITICAL_SECTION* lpCriticalSection);

  [SuppressUnmanagedCodeSecurity]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DllImport("kernel32.dll")]
  public static extern unsafe void LeaveCriticalSection(_RTL_CRITICAL_SECTION* lpCriticalSection);

  internal static unsafe _iobuf* std\u002E_Fiopen(sbyte* filename, int mode, int prot)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0BAE\u0040_W arrayTypeBy0BaeW;
    return \u003CModule\u003E.mbstowcs_s((uint*) 0, (char*) &arrayTypeBy0BaeW, 260U, filename, 259U) != 0 ? (_iobuf*) 0 : \u003CModule\u003E.std\u002E_Fiopen((char*) &arrayTypeBy0BaeW, mode, prot);
  }

  internal static unsafe _iobuf* std\u002E_Fiopen(char* filename, int mode, int prot)
  {
    int num1 = mode & 4;
    int num2 = mode & 128;
    if ((mode & 64) != 0)
      mode |= 1;
    if ((mode & 8) != 0)
      mode |= 2;
    mode &= -197;
    int num3 = 0;
    int num4 = 1;
    while (num4 != mode)
    {
      ++num3;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      num4 = ^(int&) (num3 * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x0e86b956\u002E\u003Fvalid\u0040\u003F1\u003F\u003F_Fiopen\u0040std\u0040\u0040YAPAU_iobuf\u0040\u0040PB_WHH\u0040Z\u00404QBHB);
      if (num4 == 0)
        break;
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) (num3 * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x0e86b956\u002E\u003Fvalid\u0040\u003F1\u003F\u003F_Fiopen\u0040std\u0040\u0040YAPAU_iobuf\u0040\u0040PB_WHH\u0040Z\u00404QBHB) == 0)
      return (_iobuf*) 0;
    if (num2 != 0 && (mode & 1) != 0)
    {
      _iobuf* iobufPtr = \u003CModule\u003E._wfsopen(filename, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_13BPINEIPE\u0040\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040, prot);
      if ((IntPtr) iobufPtr != IntPtr.Zero)
      {
        \u003CModule\u003E.fclose(iobufPtr);
        return (_iobuf*) 0;
      }
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    char* chPtr = (char*) ^(int&) (num3 * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x0e86b956\u002E\u003Fmods\u0040\u003F1\u003F\u003F_Fiopen\u0040std\u0040\u0040YAPAU_iobuf\u0040\u0040PB_WHH\u0040Z\u00404PAPB_WA);
    _iobuf* iobufPtr1 = \u003CModule\u003E._wfsopen(filename, chPtr, prot);
    if ((IntPtr) iobufPtr1 == IntPtr.Zero)
      return (_iobuf*) 0;
    if (num1 == 0 || \u003CModule\u003E.fseek(iobufPtr1, 0, 2) == 0)
      return iobufPtr1;
    \u003CModule\u003E.fclose(iobufPtr1);
    return (_iobuf*) 0;
  }

  internal static unsafe _iobuf* std\u002E_Fiopen(ushort* _Filename, int _Mode, int _Prot) => \u003CModule\u003E.std\u002E_Fiopen((char*) _Filename, _Mode, _Prot);

  internal static unsafe void std\u002E_String_base\u002E_Xlen() => \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);

  internal static unsafe void std\u002E_String_base\u002E_Xran() => \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);

  internal static unsafe void std\u002E_String_base\u002E_Xinvarg() => \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);

  internal static unsafe void std\u002E_Nomemory()
  {
    if (((int) \u003CModule\u003E.\u003FA0xfd82e259\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404IA & 1) == 0)
    {
      \u003CModule\u003E.\u003FA0xfd82e259\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404IA |= 1U;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0xfd82e259\u002E\u003Fnomem\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404Vbad_alloc\u00402\u0040B);
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0xfd82e259\u002E\u003F\u003F__Fnomem\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u0040YMXXZ));
      }
      __fault
      {
        \u003CModule\u003E.\u003FA0xfd82e259\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404IA &= 4294967294U;
      }
    }
    bad_alloc badAlloc;
    \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bctor\u007D(&badAlloc, &\u003CModule\u003E.\u003FA0xfd82e259\u002E\u003Fnomem\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404Vbad_alloc\u00402\u0040B);
    \u003CModule\u003E._CxxThrowException((void*) &badAlloc, &\u003CModule\u003E._TI2\u003FAVbad_alloc\u0040std\u0040\u0040);
  }

  internal static unsafe void \u003FA0xfd82e259\u002E\u003F\u003F__Fnomem\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0xfd82e259\u002E\u003Fnomem\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404Vbad_alloc\u00402\u0040B);

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool std\u002E_uncaught_exception_m() => \u003CModule\u003E.__uncaught_exception();

  internal static unsafe int _Tolower(int c, _Ctypevec* ploc)
  {
    uint num1;
    uint num2;
    if ((IntPtr) ploc == IntPtr.Zero)
    {
      num1 = \u003CModule\u003E.___lc_handle_func()[2];
      num2 = \u003CModule\u003E.___lc_codepage_func();
    }
    else
    {
      num1 = (uint) *(int*) ploc;
      num2 = (uint) *(int*) ((IntPtr) ploc + 4);
    }
    if (num1 == 0U)
    {
      if ((uint) (c - 65) <= 25U)
        c += 32;
      return c;
    }
    if ((uint) c < 256U)
    {
      if ((IntPtr) ploc == IntPtr.Zero)
      {
        if (\u003CModule\u003E.isupper(c) == 0)
          return c;
        goto label_14;
      }
      else if ((short) ((int) *(short*) (c * 2 + *(int*) ((IntPtr) ploc + 8)) & 1) == (short) 0)
        return c;
    }
    int num3;
    int num4;
    if ((IntPtr) ploc != IntPtr.Zero)
    {
      num3 = c >> 8;
      if ((ushort) ((uint) *(short*) ((num3 & (int) byte.MaxValue) * 2 + *(int*) ((IntPtr) ploc + 8)) & 32768U) == (ushort) 0)
      {
        num4 = 0;
        goto label_17;
      }
      else
        goto label_18;
    }
label_14:
    num3 = c >> 8;
    num4 = (int) *(ushort*) ((int) (byte) num3 * 2 + (IntPtr) \u003CModule\u003E.__pctype_func()) & 32768;
label_17:
    \u0024ArrayType\u0024\u0024\u0024BY02E arrayTypeBy02E1;
    int num5;
    if (num4 == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ref arrayTypeBy02E1 = (sbyte) (byte) c;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ((IntPtr) &arrayTypeBy02E1 + 1) = (sbyte) 0;
      num5 = 1;
      goto label_20;
    }
label_18:
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ref arrayTypeBy02E1 = (sbyte) (byte) num3;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ((IntPtr) &arrayTypeBy02E1 + 1) = (sbyte) (byte) c;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ((IntPtr) &arrayTypeBy02E1 + 2) = (sbyte) 0;
    num5 = 2;
label_20:
    \u0024ArrayType\u0024\u0024\u0024BY02E arrayTypeBy02E2;
    int num6 = \u003CModule\u003E.__crtLCMapStringA((localeinfo_struct*) 0, num1, 256U, (sbyte*) &arrayTypeBy02E1, num5, (sbyte*) &arrayTypeBy02E2, 3, (int) num2, 1);
    if (0 == num6)
      return c;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    return num6 == 1 ? (int) ^(byte&) ref arrayTypeBy02E2 : (int) ^(byte&) ref arrayTypeBy02E2 << 8 | (int) ^(byte&) ((IntPtr) &arrayTypeBy02E2 + 1);
  }

  internal static unsafe _Ctypevec _Getctype()
  {
    _Ctypevec ctypevec;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref ctypevec = (int) \u003CModule\u003E.___lc_handle_func()[1];
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &ctypevec + 4) = (int) \u003CModule\u003E.___lc_codepage_func();
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &ctypevec + 8) = (int) \u003CModule\u003E.calloc(256U, 2U);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ((IntPtr) &ctypevec + 8) != 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      \u003CModule\u003E.memcpy((void*) ^(int&) ((IntPtr) &ctypevec + 8), (void*) \u003CModule\u003E.__pctype_func(), 512U);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &ctypevec + 12) = 1;
    }
    else
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &ctypevec + 8) = (int) \u003CModule\u003E.__pctype_func();
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &ctypevec + 12) = 0;
    }
    return ctypevec;
  }

  internal static unsafe int _Toupper(int c, _Ctypevec* ploc)
  {
    uint num1;
    uint num2;
    if ((IntPtr) ploc == IntPtr.Zero)
    {
      num1 = \u003CModule\u003E.___lc_handle_func()[2];
      num2 = \u003CModule\u003E.___lc_codepage_func();
    }
    else
    {
      num1 = (uint) *(int*) ploc;
      num2 = (uint) *(int*) ((IntPtr) ploc + 4);
    }
    if (num1 == 0U)
    {
      if ((uint) (c - 97) <= 25U)
        c -= 32;
      return c;
    }
    if ((uint) c < 256U)
    {
      if ((IntPtr) ploc == IntPtr.Zero)
      {
        if (\u003CModule\u003E.islower(c) == 0)
          return c;
        goto label_14;
      }
      else if ((short) ((int) *(short*) (c * 2 + *(int*) ((IntPtr) ploc + 8)) & 2) == (short) 0)
        return c;
    }
    int num3;
    int num4;
    if ((IntPtr) ploc != IntPtr.Zero)
    {
      num3 = c >> 8;
      if ((ushort) ((uint) *(short*) ((num3 & (int) byte.MaxValue) * 2 + *(int*) ((IntPtr) ploc + 8)) & 32768U) == (ushort) 0)
      {
        num4 = 0;
        goto label_17;
      }
      else
        goto label_18;
    }
label_14:
    num3 = c >> 8;
    num4 = (int) *(ushort*) ((int) (byte) num3 * 2 + (IntPtr) \u003CModule\u003E.__pctype_func()) & 32768;
label_17:
    \u0024ArrayType\u0024\u0024\u0024BY02E arrayTypeBy02E1;
    int num5;
    if (num4 == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ref arrayTypeBy02E1 = (sbyte) (byte) c;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ((IntPtr) &arrayTypeBy02E1 + 1) = (sbyte) 0;
      num5 = 1;
      goto label_20;
    }
label_18:
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ref arrayTypeBy02E1 = (sbyte) (byte) num3;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ((IntPtr) &arrayTypeBy02E1 + 1) = (sbyte) (byte) c;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ((IntPtr) &arrayTypeBy02E1 + 2) = (sbyte) 0;
    num5 = 2;
label_20:
    \u0024ArrayType\u0024\u0024\u0024BY02E arrayTypeBy02E2;
    int num6 = \u003CModule\u003E.__crtLCMapStringA((localeinfo_struct*) 0, num1, 512U, (sbyte*) &arrayTypeBy02E1, num5, (sbyte*) &arrayTypeBy02E2, 3, (int) num2, 1);
    if (0 == num6)
      return c;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    return num6 == 1 ? (int) ^(byte&) ref arrayTypeBy02E2 : (int) ^(byte&) ref arrayTypeBy02E2 << 8 | (int) ^(byte&) ((IntPtr) &arrayTypeBy02E2 + 1);
  }

  internal static ushort towctrans(ushort c, [MarshalAs(UnmanagedType.U2)] char val) => val != '\u0001' ? \u003CModule\u003E.towlower(c) : \u003CModule\u003E.towupper(c);

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char wctrans(sbyte* name)
  {
    int num = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ref \u003CModule\u003E.\u003FA0x5d638340\u002Etab != 0)
    {
      wctab* wctabPtr = (wctab*) &\u003CModule\u003E.\u003FA0x5d638340\u002Etab;
      while (\u003CModule\u003E.strcmp((sbyte*) *(int*) wctabPtr, name) != 0)
      {
        ++num;
        wctabPtr = (wctab*) (num * 8 + (IntPtr) &\u003CModule\u003E.\u003FA0x5d638340\u002Etab);
        if (*(int*) wctabPtr == 0)
          goto label_5;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      return (char) ^(ushort&) (num * 8 + ((IntPtr) &\u003CModule\u003E.\u003FA0x5d638340\u002Etab + 4));
    }
label_5:
    return char.MinValue;
  }

  internal static unsafe ushort wctype(sbyte* name)
  {
    int num = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ref \u003CModule\u003E.\u003FA0x1ed63743\u002Etab != 0)
    {
      wctab* wctabPtr = (wctab*) &\u003CModule\u003E.\u003FA0x1ed63743\u002Etab;
      while (\u003CModule\u003E.strcmp((sbyte*) *(int*) wctabPtr, name) != 0)
      {
        ++num;
        wctabPtr = (wctab*) (num * 8 + (IntPtr) &\u003CModule\u003E.\u003FA0x1ed63743\u002Etab);
        if (*(int*) wctabPtr == 0)
          goto label_5;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      return ^(ushort&) (num * 8 + ((IntPtr) &\u003CModule\u003E.\u003FA0x1ed63743\u002Etab + 4));
    }
label_5:
    return 0;
  }

  [DebuggerStepThrough]
  internal static unsafe ValueType \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle() => (IntPtr) \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA != IntPtr.Zero ? (ValueType) GCHandle.FromIntPtr(new IntPtr(\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA)) : (ValueType) null;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(
    object value)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = GCHandle.ToIntPtr(GCHandle.Alloc(value)).ToPointer();
    else
      ((GCHandle) valueType).Target = value;
  }

  [DebuggerStepThrough]
  internal static object \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    return valueType != null ? ((GCHandle) valueType).Target : (object) null;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      return;
    ((GCHandle) valueType).Free();
    \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = (void*) 0;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get() != null;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef()
  {
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      object obj = new object();
      \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = (void*) 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(obj);
      \u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA = 0;
    }
    ++\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x11773762\u002E__global_lock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      Monitor.Enter(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x11773762\u002E__global_unlock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      Monitor.Exit(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x11773762\u002E__alloc_global_lock()
  {
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef();
    return \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized();
  }

  [DebuggerStepThrough]
  internal static void \u003FA0x11773762\u002E__dealloc_global_lock()
  {
    --\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
    if (\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA != 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct();
  }

  internal static unsafe int _atexit_helper(
    __FnPtr<void ()> func,
    uint* __pexit_list_size,
    __FnPtr<void ()>** __ponexitend_e,
    __FnPtr<void ()>** __ponexitbegin_e)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0;
    if (func == null)
      return -1;
    int num1;
    if (\u003CModule\u003E.\u003FA0x11773762\u002E__global_lock())
    {
      try
      {
        __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) *(int*) __ponexitbegin_e);
        __FnPtr<void ()>* local3 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) *(int*) __ponexitend_e);
        __FnPtr<void ()>* local4 = (__FnPtr<void ()>*) ((IntPtr) local3 - (IntPtr) local2);
        if ((UIntPtr) ((int) *__pexit_list_size - 1) < (UIntPtr) local4 >> 2)
        {
          try
          {
            uint num2 = *__pexit_list_size * 4U;
            uint num3 = num2 >= 2048U ? 2048U : num2;
            IntPtr cb = new IntPtr((int) num2 + (int) num3);
            IntPtr num4 = Marshal.ReAllocHGlobal(new IntPtr((void*) local2), cb);
            local3 = (__FnPtr<void ()>*) ((IntPtr) num4.ToPointer() + (IntPtr) local4);
            local2 = (__FnPtr<void ()>*) num4.ToPointer();
            uint num5 = *__pexit_list_size;
            uint num6 = 512U >= num5 ? num5 : 512U;
            *__pexit_list_size = num5 + num6;
          }
          catch (OutOfMemoryException ex)
          {
            IntPtr cb = new IntPtr((int) *__pexit_list_size * 4 + 8);
            IntPtr num7 = Marshal.ReAllocHGlobal(new IntPtr((void*) local2), cb);
            local3 = (__FnPtr<void ()>*) ((IntPtr) num7.ToPointer() - (IntPtr) local2 + (IntPtr) local3);
            local2 = (__FnPtr<void ()>*) num7.ToPointer();
            uint* numPtr = __pexit_list_size;
            int num8 = (int) *numPtr + 4;
            *numPtr = (uint) num8;
          }
        }
        *(int*) local3 = (int) func;
        __FnPtr<void ()>* local5 = (__FnPtr<void ()>*) ((IntPtr) local3 + 4);
        local1 = func;
        *(int*) __ponexitbegin_e = (int) \u003CModule\u003E._encode_pointer((void*) local2);
        *(int*) __ponexitend_e = (int) \u003CModule\u003E._encode_pointer((void*) local5);
      }
      catch (OutOfMemoryException ex)
      {
      }
      finally
      {
        \u003CModule\u003E.\u003FA0x11773762\u002E__global_unlock();
      }
      if (local1 != null)
      {
        num1 = 0;
        goto label_12;
      }
    }
    num1 = -1;
label_12:
    return num1;
  }

  internal static unsafe void _exit_callback()
  {
    if (\u003CModule\u003E.\u003FA0x11773762\u002E__exit_list_size == 0U)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x11773762\u002E__onexitend_m);
    if ((IntPtr) local1 != new IntPtr(-1) && (IntPtr) local1 != IntPtr.Zero && (IntPtr) local2 != IntPtr.Zero)
    {
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 4;
            if (local2 < local1)
              goto label_7;
          }
          while ((IntPtr) *(int*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          void* voidPtr = \u003CModule\u003E._decode_pointer((void*) *(int*) local2);
          *(int*) local2 = (int) \u003CModule\u003E._encoded_null();
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) (IntPtr) voidPtr)();
          local5 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m);
          local6 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x11773762\u002E__onexitend_m);
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_7:
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
    }
    \u003CModule\u003E.\u003FA0x11773762\u002E__dealloc_global_lock();
  }

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_m()
  {
    if (!\u003CModule\u003E.\u003FA0x11773762\u002E__alloc_global_lock())
      return 0;
    \u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer(Marshal.AllocHGlobal(128).ToPointer());
    \u003CModule\u003E.\u003FA0x11773762\u002E__onexitend_m = \u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m;
    \u003CModule\u003E.\u003FA0x11773762\u002E__exit_list_size = 32U;
    return 1;
  }

  internal static unsafe int _atexit_m(__FnPtr<void ()> func) => \u003CModule\u003E._atexit_helper((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) func), &\u003CModule\u003E.\u003FA0x11773762\u002E__exit_list_size, &\u003CModule\u003E.\u003FA0x11773762\u002E__onexitend_m, &\u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m);

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_app_domain()
  {
    if (\u003CModule\u003E.\u003FA0x11773762\u002E__alloc_global_lock())
    {
      \u003CModule\u003E.__onexitbegin_app_domain = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer(Marshal.AllocHGlobal(128).ToPointer());
      \u003CModule\u003E.__onexitend_app_domain = \u003CModule\u003E.__onexitbegin_app_domain;
      \u003CModule\u003E.__exit_list_size_app_domain = 32U;
    }
    return 1;
  }

  internal static unsafe void _app_exit_callback()
  {
    if (\u003CModule\u003E.__exit_list_size_app_domain == 0U)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitend_app_domain);
    try
    {
      if ((IntPtr) local1 == new IntPtr(-1) || (IntPtr) local1 == IntPtr.Zero || (IntPtr) local2 == IntPtr.Zero)
        return;
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 4;
          }
          while (local2 >= local1 && (IntPtr) *(int*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          if (local2 >= local1)
          {
            // ISSUE: cast to a function pointer type
            __FnPtr<void ()> local7 = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) *(int*) local2);
            *(int*) local2 = (int) \u003CModule\u003E._encoded_null();
            // ISSUE: function pointer call
            __calli(local7)();
            local5 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
            local6 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitend_app_domain);
          }
          else
            goto label_12;
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_12:;
    }
    finally
    {
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
      \u003CModule\u003E.\u003FA0x11773762\u002E__dealloc_global_lock();
    }
  }

  [DebuggerStepThrough]
  internal static unsafe int _atexit_m_appdomain(__FnPtr<void ()> func) => \u003CModule\u003E._atexit_helper((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) func), &\u003CModule\u003E.__exit_list_size_app_domain, &\u003CModule\u003E.__onexitend_app_domain, &\u003CModule\u003E.__onexitbegin_app_domain);

  [DebuggerStepThrough]
  internal static unsafe int _initterm_e(__FnPtr<int ()>* pfbegin, __FnPtr<int ()>* pfend)
  {
    int num1 = 0;
    if (pfbegin < pfend)
    {
      while (num1 == 0)
      {
        uint num2 = (uint) *(int*) pfbegin;
        if (num2 != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          num1 = __calli((__FnPtr<int ()>) (int) num2)();
        }
        pfbegin += 4;
        if (pfbegin >= pfend)
          break;
      }
    }
    return num1;
  }

  [DebuggerStepThrough]
  internal static unsafe void _initterm(__FnPtr<void ()>* pfbegin, __FnPtr<void ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint num = (uint) *(int*) pfbegin;
      if (num != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) (int) num)();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static ModuleHandle \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle() => typeof (ThisModule).Module.ModuleHandle;

  [DebuggerStepThrough]
  internal static unsafe void _initterm_m(__FnPtr<void* ()>* pfbegin, __FnPtr<void* ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint methodToken = (uint) *(int*) pfbegin;
      if (methodToken != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        void* voidPtr = __calli(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E((__FnPtr<void* ()>) (int) methodToken))();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static unsafe __FnPtr<void* ()> \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E(
    __FnPtr<void* ()> methodToken)
  {
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void* ()>) (IntPtr) \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle().ResolveMethodHandle((int) methodToken).GetFunctionPointer().ToPointer();
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ehvec_dtor(
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    int num = 0;
    ptr = (void*) ((int) size * count + (IntPtr) ptr);
    try
    {
      while (true)
      {
        --count;
        if (count >= 0)
        {
          ptr -= (int) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
      num = 1;
    }
    finally
    {
      if (num == 0)
        \u003CModule\u003E.__ArrayUnwind(ptr, size, count, pDtor);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe int \u003FA0x644ad69d\u002EArrayUnwindFilter(_EXCEPTION_POINTERS* pExPtrs)
  {
    if (*(int*) *(int*) pExPtrs != -529697949)
      return 0;
    \u003CModule\u003E.terminate();
    return 0;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ArrayUnwind(
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    try
    {
      while (true)
      {
        --count;
        if (count >= 0)
        {
          ptr -= (int) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
    }
    catch (Exception ex) when (\u003CModule\u003E.\u003FA0x644ad69d\u002EArrayUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _encode_pointer([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _decode_pointer([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _encoded_null();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void __setusermatherr([In] __FnPtr<int (_exception*)> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<int (uint)> _query_new_handler();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe __FnPtr<int ()> GetProcAddress([In] HINSTANCE__* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<int (uint)> _set_new_handler([In] __FnPtr<int (uint)> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int* _errno();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CorBindToRuntimeEx(
    [In] char* obj0,
    [In] char* obj1,
    [In] uint obj2,
    [In] _GUID* obj3,
    [In] _GUID* obj4,
    [In] void** obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void (int)> signal([In] int obj0, [In] __FnPtr<void (int)> obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe HINSTANCE__* GetModuleHandleW([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void _invalid_parameter(
    [In] char* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] uint obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CoCreateInstance(
    [In] _GUID* obj0,
    [In] IUnknown* obj1,
    [In] uint obj2,
    [In] _GUID* obj3,
    [In] void** obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void ()> _get_purecall_handler();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void (char*, char*, char*, uint, uint)> _set_invalid_parameter_handler(
    [In] __FnPtr<void (char*, char*, char*, uint, uint)> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void ()> _get_unexpected();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void ()> set_unexpected([In] __FnPtr<void ()> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void ()> _get_terminate();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void ()> _set_purecall_handler([In] __FnPtr<void ()> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void ()> set_terminate([In] __FnPtr<void ()> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void (char*, char*, char*, uint, uint)> _get_invalid_parameter_handler();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int _fpieee_flt(
    [In] uint obj0,
    [In] _EXCEPTION_POINTERS* obj1,
    [In] __FnPtr<int (_FPIEEE_RECORD*)> obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _getFiberPtrId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _amsg_exit([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern void __security_init_cookie();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void Sleep([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _cexit();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void delete([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int strcpy_s([In] sbyte* obj0, [In] uint obj1, [In] sbyte* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint strlen([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* malloc([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void free([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* CreateThread(
    [In] _SECURITY_ATTRIBUTES* obj0,
    [In] uint obj1,
    [In] __FnPtr<uint (void*)> obj2,
    [In] void* obj3,
    [In] uint obj4,
    [In] uint* obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint ResumeThread([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _dosmaperr([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int _XcptFilter([In] uint obj0, [In] _EXCEPTION_POINTERS* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void* (uint)> __set_flsgetvalue();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _tiddata* _getptd();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint GetLastError();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __fls_setvalue([In] uint obj0, [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void ExitThread([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void _initptd([In] _tiddata* obj0, [In] threadlocaleinfostruct* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _exit([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* __fls_getvalue([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void _freefls([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* calloc([In] uint obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _endthread();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint __get_flsindex();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint GetCurrentThreadId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _endthreadex([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* @new([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int __CxxQueryExceptionSize();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxDetectRethrow([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void _CxxThrowException([In] void* obj0, [In] _s__ThrowInfo* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int memcpy_s([In] void* obj0, [In] uint obj1, [In] void* obj2, [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void __CxxUnregisterExceptionObject([In] void* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxExceptionFilter(
    [In] void* obj0,
    [In] void* obj1,
    [In] int obj2,
    [In] void* obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void delete\u005B\u005D([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* memset([In] void* obj0, [In] int obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int ___mb_cur_max_func();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _invalid_parameter_noinfo();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxRegisterExceptionObject([In] void* obj0, [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int memcmp([In] void* obj0, [In] void* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int memmove_s([In] void* obj0, [In] uint obj1, [In] void* obj2, [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void _invoke_watson(
    [In] char* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] uint obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void abort();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fclose([In] _iobuf* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fseek([In] _iobuf* obj0, [In] int obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint fwrite([In] void* obj0, [In] uint obj1, [In] uint obj2, [In] _iobuf* obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int setvbuf([In] _iobuf* obj0, [In] sbyte* obj1, [In] int obj2, [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fsetpos([In] _iobuf* obj0, [In] long* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fgetc([In] _iobuf* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fflush([In] _iobuf* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fgetpos([In] _iobuf* obj0, [In] long* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _iobuf* __iob_func();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int ungetc([In] int obj0, [In] _iobuf* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fputc([In] int obj0, [In] _iobuf* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe ushort fgetwc([In] _iobuf* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe ushort ungetwc([In] ushort obj0, [In] _iobuf* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe ushort fputwc([MarshalAs(UnmanagedType.U2)] char _param0, [In] _iobuf* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* setlocale([In] int obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* realloc([In] void* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int sprintf_s([In] sbyte* obj0, [In] uint obj1, [In] sbyte* obj2, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* memcpy([In] void* obj0, [In] void* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint* ___lc_handle_func();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __crtGetStringTypeW(
    [In] localeinfo_struct* obj0,
    [In] uint obj1,
    [In] char* obj2,
    [In] int obj3,
    [In] ushort* obj4,
    [In] int obj5,
    [In] int obj6);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe localeinfo_struct* _GetLocaleForCP([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern int \u003FA0xba4dcdd5\u002E_InitCPLocHash();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint ___lc_codepage_func();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe ushort* __pctype_func();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int MultiByteToWideChar(
    [In] uint obj0,
    [In] uint obj1,
    [In] sbyte* obj2,
    [In] int obj3,
    [In] char* obj4,
    [In] int obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int ___mb_cur_max_l_func([In] localeinfo_struct* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int InterlockedCompareExchange([In] int* obj0, [In] int obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __crtLCMapStringW(
    [In] localeinfo_struct* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] char* obj3,
    [In] int obj4,
    [In] char* obj5,
    [In] int obj6,
    [In] int obj7);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __crtLCMapStringA(
    [In] localeinfo_struct* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] sbyte* obj3,
    [In] int obj4,
    [In] sbyte* obj5,
    [In] int obj6,
    [In] int obj7,
    [In] int obj8);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int WideCharToMultiByte(
    [In] uint obj0,
    [In] uint obj1,
    [In] char* obj2,
    [In] int obj3,
    [In] sbyte* obj4,
    [In] int obj5,
    [In] sbyte* obj6,
    [In] int* obj7);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int InterlockedDecrement([In] int* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int InterlockedIncrement([In] int* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void DeleteCriticalSection([In] _RTL_CRITICAL_SECTION* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int InterlockedExchange([In] int* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void InitializeCriticalSection([In] _RTL_CRITICAL_SECTION* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int mbstowcs_s(
    [In] uint* obj0,
    [In] char* obj1,
    [In] uint obj2,
    [In] sbyte* obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _iobuf* _wfsopen([In] char* obj0, [In] char* obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  public static extern bool __uncaught_exception();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int isupper([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int islower([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern ushort towupper([In] ushort obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int strcmp([In] sbyte* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern ushort towlower([In] ushort obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __FrameUnwindFilter([In] _EXCEPTION_POINTERS* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void terminate();
}
