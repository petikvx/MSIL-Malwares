// Decompiled with JetBrains decompiler
// Type: Mooreming.MergeSort
// Assembly: EventListe, Version=1.0.2.0, Culture=neutral, PublicKeyToken=null
// MVID: 17402B6D-E2A2-428E-97AD-7F2170B297A3
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.06\Backdoor.Win32.Buterat.frsq-f1c24055722dc6f94c4b223ed4a7bce8ffb5c5bb3030bca735d6ceab513d8d31.exe

using System;

namespace Mooreming
{
  internal class MergeSort
  {
    private int arraySize;
    private IComparable[] array;

    public MergeSort(IComparable[] array, int length)
    {
      this.arraySize = length;
      this.array = array;
      this.MergeSort_Recursive(this.array, 0, this.arraySize - 1);
    }

    public void DoMerge(IComparable[] numbers, int left, int mid, int right)
    {
      IComparable[] comparableArray = new IComparable[this.arraySize];
      int num1 = mid - 1;
      int num2 = left;
      int num3 = right - left + 1;
      while (left <= num1 && mid <= right)
        comparableArray[num2++] = numbers[left].CompareTo((object) numbers[mid]) > 0 ? numbers[mid++] : numbers[left++];
      while (left <= num1)
        comparableArray[num2++] = numbers[left++];
      while (mid <= right)
        comparableArray[num2++] = numbers[mid++];
      for (int index = 0; index < num3; ++index)
      {
        numbers[right] = comparableArray[right];
        --right;
      }
    }

    public void MergeSort_Recursive(IComparable[] numbers, int left, int right)
    {
      if (right <= left)
        return;
      int right1 = (right + left) / 2;
      this.MergeSort_Recursive(numbers, left, right1);
      this.MergeSort_Recursive(numbers, right1 + 1, right);
      this.DoMerge(numbers, left, right1 + 1, right);
    }
  }
}
