// Decompiled with JetBrains decompiler
// Type: AjScript.ObjectUtilities
// Assembly: FUNCD, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 38B3918C-7BBD-4048-BF6D-F5A856A1A18A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-Ransom.Win32.Convagent.gen-2f81e8b71640e7b5770deccc56c23d75240c34a5914dcb138ec2972e624a0f03.exe

using AjScript.Language;
using System;
using System.Collections;
using System.Reflection;

namespace AjScript
{
  public class ObjectUtilities
  {
    public static void SetValue(object obj, string name, object value)
    {
      if (obj is IObject)
        ((IObject) obj).SetValue(name, value);
      else
        obj.GetType().InvokeMember(name, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.SetField | BindingFlags.SetProperty, (Binder) null, obj, new object[1]
        {
          value
        });
    }

    public static object GetValue(object obj, string name) => obj is IObject ? ((IObject) obj).GetValue(name) : obj.GetType().InvokeMember(name, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.InvokeMethod | BindingFlags.GetField | BindingFlags.GetProperty, (Binder) null, obj, (object[]) null);

    public static object GetValue(object obj, string name, object[] parameters)
    {
      if (!(obj is IObject))
        return ObjectUtilities.GetNativeValue(obj, name, parameters);
      return parameters == null ? ((IObject) obj).GetValue(name) : ((IObject) obj).Invoke(name, parameters);
    }

    public static object GetNativeValue(object obj, string name, object[] parameters) => obj.GetType().InvokeMember(name, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.InvokeMethod | BindingFlags.GetField | BindingFlags.GetProperty, (Binder) null, obj, parameters);

    public static bool IsNumber(object obj)
    {
      switch (obj)
      {
        case int _:
        case short _:
        case long _:
        case Decimal _:
        case double _:
        case float _:
          return true;
        default:
          return obj is byte;
      }
    }

    public static object GetIndexedValue(object obj, object[] indexes)
    {
      switch (obj)
      {
        case Array _:
          return ObjectUtilities.GetIndexedValue((Array) obj, indexes);
        case IList _:
          return ObjectUtilities.GetIndexedValue((IList) obj, indexes);
        case IDictionary _:
          return ObjectUtilities.GetIndexedValue((IDictionary) obj, indexes);
        case DynamicObject _:
          if (indexes != null && indexes.Length == 1)
            return ((DynamicObject) obj).GetValue((string) indexes[0]);
          break;
      }
      return ObjectUtilities.GetValue(obj, "", indexes);
    }

    public static void SetIndexedValue(object obj, object[] indexes, object value)
    {
      switch (obj)
      {
        case Array _:
          ObjectUtilities.SetIndexedValue((Array) obj, indexes, value);
          break;
        case IList _:
          int index = indexes.Length == 1 ? (int) indexes[0] : throw new InvalidOperationException("Invalid number of subindices");
          IList list = (IList) obj;
          if (list.Count == index)
          {
            list.Add(value);
            break;
          }
          list[index] = value;
          break;
        case IDictionary _:
          if (indexes.Length != 1)
            throw new InvalidOperationException("Invalid number of subindices");
          ((IDictionary) obj)[indexes[0]] = value;
          break;
        default:
          throw new InvalidOperationException(string.Format("Not indexed value of type {0}", (object) obj.GetType().ToString()));
      }
    }

    public static void SetIndexedValue(Array array, object[] indexes, object value)
    {
      switch (indexes.Length)
      {
        case 1:
          array.SetValue(value, (int) indexes[0]);
          break;
        case 2:
          array.SetValue(value, (int) indexes[0], (int) indexes[1]);
          break;
        case 3:
          array.SetValue(value, (int) indexes[0], (int) indexes[1], (int) indexes[2]);
          break;
        default:
          throw new InvalidOperationException("Invalid number of subindices");
      }
    }

    private static object GetIndexedValue(Array array, object[] indexes)
    {
      switch (indexes.Length)
      {
        case 1:
          return array.GetValue((int) indexes[0]);
        case 2:
          return array.GetValue((int) indexes[0], (int) indexes[1]);
        case 3:
          return array.GetValue((int) indexes[0], (int) indexes[1], (int) indexes[2]);
        default:
          throw new InvalidOperationException("Invalid number of subindices");
      }
    }

    private static object GetIndexedValue(IList list, object[] indexes) => indexes.Length == 1 ? list[(int) indexes[0]] : throw new InvalidOperationException("Invalid number of subindices");

    private static object GetIndexedValue(IDictionary dictionary, object[] indexes) => indexes.Length == 1 ? dictionary[indexes[0]] : throw new InvalidOperationException("Invalid number of subindices");
  }
}
