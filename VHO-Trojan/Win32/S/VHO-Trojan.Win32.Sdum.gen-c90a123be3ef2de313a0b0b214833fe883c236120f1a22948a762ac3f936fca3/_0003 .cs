// Decompiled with JetBrains decompiler
// Type:  
// Assembly: Egoebwgfjtvapr, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 1CC6CB3C-932E-4FDA-6A81-0D2F63757017
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\VHO-Trojan.Win32.Sdum.gen-c90a123be3ef2de313a0b0b214833fe883c236120f1a22948a762ac3f936fca3.exe

using System;
using System.Security.Cryptography;

internal sealed class \u0003\u2000 : DeriveBytes
{
  private byte[] \u0002;
  private byte[] \u0003;
  private int \u0005;
  private readonly \u0003\u2000\u2000 \u0008;
  private readonly byte[] \u0006;

  public \u0003\u2000(byte[] _param1, byte[] _param2, int _param3)
  {
    \u0003\u2000\u2000 obj = new \u0003\u2000\u2000();
    if (true)
      goto label_2;
label_1:
    // ISSUE: explicit constructor call
    base.\u002Ector();
    if (_param1 == null)
      throw new ArgumentNullException(\u0008\u2008\u2000.\u0002(-1485703172));
    if (_param2 == null)
      throw new ArgumentNullException(\u0008\u2008\u2000.\u0002(-1485703415));
    if (_param3 < 1)
      throw new ArgumentException(\u0008\u2008\u2000.\u0002(-1485703418));
    byte[] numArray1 = (byte[]) _param1.Clone();
    if (true)
      goto label_11;
label_9:
    byte[] numArray2 = (byte[]) _param2.Clone();
    if (true)
      goto label_12;
label_10:
    this.\u0005 = _param3;
    this.\u0006 = new byte[this.\u0008.\u0002()];
    return;
label_12:
    this.\u0003 = numArray2;
    goto label_10;
label_11:
    this.\u0002 = numArray1;
    goto label_9;
label_2:
    this.\u0008 = obj;
    goto label_1;
  }

  private void \u0002(byte[] _param1, int _param2, byte[] _param3, byte[] _param4, int _param5)
  {
    if (_param1 != null)
      this.\u0008.\u0002(_param1, 0, _param1.Length);
    this.\u0008.\u0002(_param3, 0, _param3.Length);
    this.\u0008.\u0002(this.\u0006, 0);
    byte[] src = this.\u0006;
    byte[] dst = _param4;
    int dstOffset = _param5;
    int length = this.\u0006.Length;
    if (true)
      goto label_4;
label_3:
    int num;
    if (true)
      num = 1;
    for (; num < _param2; ++num)
    {
      this.\u0008.\u0002(this.\u0006, 0, this.\u0006.Length);
      this.\u0008.\u0002(this.\u0006, 0);
      int index;
      if (true)
        index = 0;
      for (; index < this.\u0006.Length; ++index)
        _param4[_param5 + index] ^= this.\u0006[index];
    }
    return;
label_4:
    Buffer.BlockCopy((Array) src, 0, (Array) dst, dstOffset, length);
    goto label_3;
  }

  public override byte[] GetBytes(int _param1)
  {
    int num1 = this.\u0008.\u0002();
    if (true)
      goto label_4;
label_1:
    int num2;
    int num3 = (_param1 + num2 - 1) / num2;
    if (true)
      goto label_5;
label_2:
    byte[] numArray1 = new byte[4];
    if (true)
      goto label_6;
label_3:
    int num4;
    byte[] src = new byte[num4 * num2];
    int num5 = 0;
    this.\u0008.\u0002(this.\u0002);
    byte[] numArray2;
    for (int index1 = 1; index1 <= num4; ++index1)
    {
      int index2 = 3;
      while (++numArray2[index2] == (byte) 0)
        --index2;
      this.\u0002(this.\u0003, this.\u0005, numArray2, src, num5);
      num5 += num2;
    }
    if (_param1 < src.Length)
    {
      byte[] dst = new byte[_param1];
      Buffer.BlockCopy((Array) src, 0, (Array) dst, 0, _param1);
      src = dst;
    }
    return src;
label_6:
    numArray2 = numArray1;
    goto label_3;
label_5:
    num4 = num3;
    goto label_2;
label_4:
    num2 = num1;
    goto label_1;
  }

  public override void Reset() => throw new NotSupportedException();
}
