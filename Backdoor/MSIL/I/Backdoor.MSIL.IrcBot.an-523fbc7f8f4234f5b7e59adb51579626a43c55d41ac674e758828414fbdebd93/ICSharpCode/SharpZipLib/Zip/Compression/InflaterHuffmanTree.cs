// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree
// Assembly: TheBot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E6D888C-8D83-46CE-907A-18F99381A0FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Backdoor.MSIL.IrcBot.an-523fbc7f8f4234f5b7e59adb51579626a43c55d41ac674e758828414fbdebd93.exe

using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
using System;

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
  public class InflaterHuffmanTree
  {
    private const int \uE001 = 15;
    private short[] \uE000;
    public static InflaterHuffmanTree defLitLenTree;
    public static InflaterHuffmanTree defDistTree;

    static InflaterHuffmanTree()
    {
      try
      {
        byte[] codeLengths1 = new byte[288];
        int num1 = 0;
        while (num1 < 144)
          codeLengths1[num1++] = (byte) 8;
        while (num1 < 256)
          codeLengths1[num1++] = (byte) 9;
        while (num1 < 280)
          codeLengths1[num1++] = (byte) 7;
        while (num1 < 288)
          codeLengths1[num1++] = (byte) 8;
        InflaterHuffmanTree.defLitLenTree = new InflaterHuffmanTree(codeLengths1);
        byte[] codeLengths2 = new byte[32];
        int num2 = 0;
        while (num2 < 32)
          codeLengths2[num2++] = (byte) 5;
        InflaterHuffmanTree.defDistTree = new InflaterHuffmanTree(codeLengths2);
      }
      catch (Exception ex)
      {
        throw new SharpZipBaseException(\uE01B.\uE000("\uF6F5\uF6D2\uF6DA\uF6D0\uF6DD\uF6C8\uF6D9\uF6CE\uF6F4\uF6C9\uF6DA\uF6DA\uF6D1\uF6DD\uF6D2\uF6E8\uF6CE\uF6D9\uF6D9\uF686\uF69C\uF6CF\uF6C8\uF6DD\uF6C8\uF6D5\uF6DF\uF69C\uF6C8\uF6CE\uF6D9\uF6D9\uF69C\uF6D0\uF6D9\uF6D2\uF6DB\uF6C8\uF6D4\uF69C\uF6D5\uF6D0\uF6D0\uF6D9\uF6DB\uF6DD\uF6D0", 63164));
      }
    }

    public InflaterHuffmanTree(byte[] codeLengths) => this.\uE000(codeLengths);

    private void \uE000(byte[] _param1)
    {
      int[] numArray1 = new int[16];
      int[] numArray2 = new int[16];
      for (int index1 = 0; index1 < _param1.Length; ++index1)
      {
        int index2 = (int) _param1[index1];
        if (index2 > 0)
          ++numArray1[index2];
      }
      int num1 = 0;
      int length = 512;
      for (int index = 1; index <= 15; ++index)
      {
        numArray2[index] = num1;
        num1 += numArray1[index] << 16 - index;
        if (index >= 10)
        {
          int num2 = numArray2[index] & 130944;
          int num3 = num1 & 130944;
          length += num3 - num2 >> 16 - index;
        }
      }
      this.\uE000 = new short[length];
      int num4 = 512;
      for (int index = 15; index >= 10; --index)
      {
        int num5 = num1 & 130944;
        num1 -= numArray1[index] << 16 - index;
        for (int toReverse = num1 & 130944; toReverse < num5; toReverse += 128)
        {
          this.\uE000[(int) DeflaterHuffman.BitReverse(toReverse)] = (short) (-num4 << 4 | index);
          num4 += 1 << index - 9;
        }
      }
      for (int index3 = 0; index3 < _param1.Length; ++index3)
      {
        int index4 = (int) _param1[index3];
        if (index4 != 0)
        {
          int toReverse = numArray2[index4];
          int index5 = (int) DeflaterHuffman.BitReverse(toReverse);
          if (index4 <= 9)
          {
            do
            {
              this.\uE000[index5] = (short) (index3 << 4 | index4);
              index5 += 1 << index4;
            }
            while (index5 < 512);
          }
          else
          {
            int num6 = (int) this.\uE000[index5 & 511];
            int num7 = 1 << (num6 & 15);
            int num8 = -(num6 >> 4);
            do
            {
              this.\uE000[num8 | index5 >> 9] = (short) (index3 << 4 | index4);
              index5 += 1 << index4;
            }
            while (index5 < num7);
          }
          numArray2[index4] = toReverse + (1 << 16 - index4);
        }
      }
    }

    public int GetSymbol(StreamManipulator input)
    {
      StreamManipulator streamManipulator = input;
      int num1;
      if ((num1 = streamManipulator.PeekBits(9)) >= 0)
      {
        short[] numArray = this.\uE000;
        int index = num1;
        int num2;
        if ((num2 = (int) numArray[index]) >= 0)
        {
          input.DropBits(num2 & 15);
          return num2 >> 4;
        }
        int num3 = -(num2 >> 4);
        int bitCount = num2 & 15;
        int num4;
        if ((num4 = input.PeekBits(bitCount)) >= 0)
        {
          int num5 = (int) this.\uE000[num3 | num4 >> 9];
          input.DropBits(num5 & 15);
          return num5 >> 4;
        }
        int availableBits = input.AvailableBits;
        int num6 = input.PeekBits(availableBits);
        int num7 = (int) this.\uE000[num3 | num6 >> 9];
        if ((num7 & 15) > availableBits)
          return -1;
        input.DropBits(num7 & 15);
        return num7 >> 4;
      }
      int availableBits1 = input.AvailableBits;
      int num8 = (int) this.\uE000[input.PeekBits(availableBits1)];
      if (num8 < 0 || (num8 & 15) > availableBits1)
        return -1;
      input.DropBits(num8 & 15);
      return num8 >> 4;
    }
  }
}
