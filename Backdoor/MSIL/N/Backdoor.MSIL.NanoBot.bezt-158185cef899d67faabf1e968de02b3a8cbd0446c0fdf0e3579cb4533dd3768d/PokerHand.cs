// Decompiled with JetBrains decompiler
// Type: TexasHoldem.PokerHand
// Assembly: EventComm, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 230F04B0-E761-4388-A1F3-FE85FC156328
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.05\Backdoor.MSIL.NanoBot.bezt-158185cef899d67faabf1e968de02b3a8cbd0446c0fdf0e3579cb4533dd3768d.exe

using System;
using System.Collections.Generic;

namespace TexasHoldem
{
  public class PokerHand : IComparable<PokerHand>
  {
    public const int HAND_SIZE = 5;
    private List<Card> cards;
    private PokerHandRank rank = PokerHandRank.Invalid;

    public PokerHand() => this.cards = new List<Card>(5);

    public void Add(Card card)
    {
      if (card == null || this.cards.Count >= 5)
        return;
      this.cards.Add(card);
      this.cards.Sort();
    }

    public void Add(PokerHand hand)
    {
      if (this.cards.Count + hand.Cards.Count > 5)
        return;
      foreach (Card card in hand.Cards)
        this.Add(card);
      this.cards.Sort();
    }

    public PokerHandRank Rank
    {
      get
      {
        if (this.rank == PokerHandRank.Invalid)
          this.rank = this.CalculatePokerHandRank();
        return this.rank;
      }
    }

    public List<Card> Cards => this.cards;

    public CardFace GetHighestFace()
    {
      CardFace highestFace = CardFace.Back;
      foreach (Card card in this.cards)
      {
        if (card.Face > highestFace)
          highestFace = card.Face;
      }
      return highestFace;
    }

    public PokerHandRank CalculatePokerHandRank()
    {
      if (this.cards.Count != 5)
        return PokerHandRank.Invalid;
      if (this.IsStraightFlush())
        return PokerHandRank.StraightFlush;
      if (this.IsFourOfAKind())
        return PokerHandRank.FourOfAKind;
      if (this.IsFullHouse())
        return PokerHandRank.FullHouse;
      if (this.IsFlush())
        return PokerHandRank.Flush;
      if (this.IsStraight())
        return PokerHandRank.Straight;
      if (this.IsThreeOfAKind())
        return PokerHandRank.ThreeOfAKind;
      if (this.IsTwoPair())
        return PokerHandRank.TwoPair;
      return this.IsOnePair() ? PokerHandRank.OnePair : PokerHandRank.HighCard;
    }

    public bool AreSequential() => this.cards[1].Face == this.cards[0].Face + 1 && this.cards[2].Face == this.cards[1].Face + 1 && this.cards[3].Face == this.cards[2].Face + 1 && this.cards[4].Face == this.cards[3].Face + 1 || this.HasAce() && this.cards[2].Face == this.cards[1].Face + 1 && this.cards[3].Face == this.cards[2].Face + 1 && this.cards[4].Face == this.cards[3].Face + 1 && this.cards[4].Face == CardFace.King;

    public bool HasAce()
    {
      foreach (Card card in this.cards)
      {
        if (card.Face == CardFace.Ace)
          return true;
      }
      return false;
    }

    public bool AreSameSuit()
    {
      CardSuit suit = this.cards[0].Suit;
      foreach (Card card in this.cards)
      {
        if (card.Suit != suit)
          return false;
      }
      return true;
    }

    public bool IsStraightFlush() => this.AreSameSuit() && this.AreSequential();

    public bool IsFourOfAKind() => this.HasMultipleOfAKind(4);

    public bool HasMultipleOfAKind(int multiple)
    {
      if (multiple > 5 || multiple <= 0)
        return false;
      for (int index1 = 0; index1 < 5; ++index1)
      {
        int num = 0;
        CardFace face = this.cards[index1].Face;
        for (int index2 = 0; index2 < 5; ++index2)
        {
          if (this.cards[index1].Face == this.cards[index2].Face)
            ++num;
        }
        if (num == multiple)
          return true;
      }
      return false;
    }

    public bool IsFullHouse()
    {
      CardFace cardFace1 = CardFace.Back;
      int num1 = 0;
      CardFace cardFace2 = CardFace.Back;
      int num2 = 0;
      foreach (Card card in this.cards)
      {
        if (card.Face == cardFace1)
          ++num1;
        else if (card.Face == cardFace2)
          ++num2;
        else if (cardFace1 == CardFace.Back)
        {
          cardFace1 = card.Face;
          ++num1;
        }
        else
        {
          if (cardFace2 != CardFace.Back)
            return false;
          cardFace2 = card.Face;
          ++num2;
        }
      }
      return num1 == 2 && num2 == 3 || num1 == 3 && num2 == 2;
    }

    public bool IsFlush() => this.AreSameSuit();

    public bool IsStraight() => this.AreSequential();

    public bool IsThreeOfAKind() => this.HasMultipleOfAKind(3);

    public bool IsTwoPair()
    {
      CardFace cardFace1 = CardFace.Back;
      CardFace cardFace2 = CardFace.Back;
      for (int index1 = 0; index1 < 4; ++index1)
      {
        for (int index2 = index1 + 1; index2 < 5; ++index2)
        {
          if (this.cards[index1].Face == this.cards[index2].Face && cardFace1 != this.cards[index1].Face && cardFace2 != this.cards[index1].Face)
          {
            if (cardFace1 == CardFace.Back)
              cardFace1 = this.cards[index1].Face;
            else if (cardFace2 == CardFace.Back)
              cardFace2 = this.cards[index1].Face;
          }
        }
      }
      return cardFace1 != CardFace.Back && cardFace2 != 0;
    }

    public bool IsOnePair()
    {
      for (int index1 = 0; index1 < 5; ++index1)
      {
        for (int index2 = 0; index2 < 5; ++index2)
        {
          if (index1 != index2 && this.cards[index1].Face == this.cards[index2].Face)
            return true;
        }
      }
      return false;
    }

    public int CompareTo(PokerHand other)
    {
      if (this.Rank > other.Rank)
        return 1;
      if (this.Rank < other.Rank)
        return -1;
      switch (this.Rank)
      {
        case PokerHandRank.HighCard:
          if (this.HasAce() && !other.HasAce())
            return 1;
          if (!this.HasAce() && other.HasAce())
            return -1;
          List<CardFace> sortedListOfCardFaces1 = this.GetSortedListOfCardFaces();
          List<CardFace> sortedListOfCardFaces2 = other.GetSortedListOfCardFaces();
          for (int index = 0; index < sortedListOfCardFaces1.Count; ++index)
          {
            if (sortedListOfCardFaces1[index] > sortedListOfCardFaces2[index])
              return 1;
            if (sortedListOfCardFaces1[index] < sortedListOfCardFaces2[index])
              return -1;
          }
          break;
        case PokerHandRank.OnePair:
          List<CardFace> onePairRanks1 = this.GetOnePairRanks();
          List<CardFace> onePairRanks2 = other.GetOnePairRanks();
          for (int index = 0; index < onePairRanks1.Count; ++index)
          {
            if (onePairRanks1[index] > onePairRanks2[index])
              return 1;
            if (onePairRanks1[index] < onePairRanks2[index])
              return -1;
          }
          break;
        case PokerHandRank.TwoPair:
          List<CardFace> twoPairRanks1 = this.GetTwoPairRanks();
          List<CardFace> twoPairRanks2 = other.GetTwoPairRanks();
          for (int index = 0; index < twoPairRanks1.Count; ++index)
          {
            if (twoPairRanks1[index] > twoPairRanks2[index])
              return 1;
            if (twoPairRanks1[index] < twoPairRanks2[index])
              return -1;
          }
          break;
        case PokerHandRank.ThreeOfAKind:
          List<CardFace> threeOfAkindRanks1 = this.GetThreeOfAKindRanks();
          List<CardFace> threeOfAkindRanks2 = other.GetThreeOfAKindRanks();
          for (int index = 0; index < threeOfAkindRanks1.Count; ++index)
          {
            if (threeOfAkindRanks1[index] > threeOfAkindRanks2[index])
              return 1;
            if (threeOfAkindRanks1[index] < threeOfAkindRanks2[index])
              return -1;
          }
          break;
        case PokerHandRank.Straight:
          if (this.HasAce() && !other.HasAce())
            return 1;
          if (!this.HasAce() && other.HasAce())
            return -1;
          if (this.GetHighestFace() > other.GetHighestFace())
            return 1;
          if (this.GetHighestFace() < other.GetHighestFace())
            return -1;
          break;
        case PokerHandRank.Flush:
          List<CardFace> sortedListOfCardFaces3 = this.GetSortedListOfCardFaces();
          List<CardFace> sortedListOfCardFaces4 = other.GetSortedListOfCardFaces();
          for (int index = 0; index < sortedListOfCardFaces3.Count; ++index)
          {
            if (sortedListOfCardFaces3[index] > sortedListOfCardFaces4[index])
              return 1;
            if (sortedListOfCardFaces3[index] < sortedListOfCardFaces4[index])
              return -1;
          }
          break;
        case PokerHandRank.FullHouse:
          if (this.GetFaceOfMultiple(3) > other.GetFaceOfMultiple(3))
            return 1;
          if (this.GetFaceOfMultiple(3) < other.GetFaceOfMultiple(3))
            return -1;
          if (this.GetFaceOfMultiple(2) > other.GetFaceOfMultiple(2))
            return 1;
          if (this.GetFaceOfMultiple(2) < other.GetFaceOfMultiple(2))
            return -1;
          break;
        case PokerHandRank.FourOfAKind:
          if (this.GetFaceOfMultiple(4) > other.GetFaceOfMultiple(4))
            return 1;
          if (this.GetFaceOfMultiple(4) < other.GetFaceOfMultiple(4))
            return -1;
          if (this.GetFaceOfMultiple(1) > other.GetFaceOfMultiple(1))
            return 1;
          if (this.GetFaceOfMultiple(1) < other.GetFaceOfMultiple(1))
            return -1;
          break;
        case PokerHandRank.StraightFlush:
          if (this.GetHighestFace() > other.GetHighestFace())
            return 1;
          if (this.GetHighestFace() < other.GetHighestFace())
            return -1;
          break;
      }
      return 0;
    }

    public CardFace GetFaceOfMultiple(int multiple)
    {
      for (int index1 = 0; index1 < 5; ++index1)
      {
        int num = 0;
        CardFace face = this.cards[index1].Face;
        for (int index2 = 0; index2 < 5; ++index2)
        {
          if (this.cards[index1].Face == this.cards[index2].Face)
            ++num;
        }
        if (num == multiple)
          return face;
      }
      return CardFace.Back;
    }

    public List<CardFace> GetSortedListOfCardFaces()
    {
      List<CardFace> sortedListOfCardFaces = new List<CardFace>();
      foreach (Card card in this.cards)
        sortedListOfCardFaces.Add(card.Face);
      sortedListOfCardFaces.Sort();
      sortedListOfCardFaces.Reverse();
      return sortedListOfCardFaces;
    }

    public List<CardFace> GetThreeOfAKindRanks()
    {
      List<CardFace> threeOfAkindRanks = new List<CardFace>();
      threeOfAkindRanks.Add(this.GetFaceOfMultiple(3));
      List<CardFace> sortedListOfCardFaces = this.GetSortedListOfCardFaces();
      sortedListOfCardFaces.Reverse();
      for (int index = 4; index >= 0; --index)
      {
        if (sortedListOfCardFaces[index] != threeOfAkindRanks[0])
          threeOfAkindRanks.Add((CardFace) index);
      }
      return threeOfAkindRanks;
    }

    public List<CardFace> GetTwoPairRanks()
    {
      List<CardFace> twoPairRanks = new List<CardFace>();
      CardFace cardFace1 = CardFace.Back;
      CardFace cardFace2 = CardFace.Back;
      CardFace cardFace3 = CardFace.Back;
      for (int index1 = 0; index1 < 5; ++index1)
      {
        for (int index2 = 0; index2 < 5; ++index2)
        {
          if (index1 != index2 && this.cards[index1].Face == this.cards[index2].Face && cardFace1 != this.cards[index1].Face && cardFace2 != this.cards[index1].Face)
          {
            if (cardFace1 == CardFace.Back)
              cardFace1 = this.cards[index1].Face;
            if (cardFace2 == CardFace.Back)
              cardFace2 = this.cards[index1].Face;
          }
        }
      }
      foreach (Card card in this.cards)
      {
        if (card.Face != cardFace1 && card.Face != cardFace2)
          cardFace3 = card.Face;
      }
      twoPairRanks.Add(cardFace1);
      twoPairRanks.Add(cardFace2);
      twoPairRanks.Sort();
      if (twoPairRanks[0] != 0)
        twoPairRanks.Reverse();
      twoPairRanks.Add(cardFace3);
      return twoPairRanks;
    }

    public List<CardFace> GetOnePairRanks()
    {
      CardFace faceOfMultiple = this.GetFaceOfMultiple(2);
      List<CardFace> onePairRanks = new List<CardFace>();
      foreach (Card card in this.cards)
      {
        if (card.Face != faceOfMultiple)
          onePairRanks.Add(card.Face);
      }
      onePairRanks.Sort();
      onePairRanks.Reverse();
      if (onePairRanks[onePairRanks.Count - 1] == CardFace.Ace)
      {
        onePairRanks.RemoveAt(onePairRanks.Count - 1);
        onePairRanks.Insert(0, CardFace.Ace);
      }
      onePairRanks.Insert(0, faceOfMultiple);
      return onePairRanks;
    }
  }
}
