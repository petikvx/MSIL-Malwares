// Decompiled with JetBrains decompiler
// Type: Aura.Services.InjectHelper
// Assembly: Kudeta Crypter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 16F9F4AC-EE0C-4DE1-A1E6-B297F2D4338B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-VirTool.MSIL.Crypto.gen-a09f476c823deb3aadbd99b5e979f18689723f0ab3b5690e0b9a42cf2007f2a8.exe

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.Utils;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Aura.Services
{
  public static class InjectHelper
  {
    private static TypeDefUser Clone(TypeDef origin)
    {
      TypeDefUser typeDefUser1 = new TypeDefUser(origin.Namespace, origin.Name);
      ((TypeDef) typeDefUser1).Attributes = origin.Attributes;
      TypeDefUser typeDefUser2 = typeDefUser1;
      if (origin.ClassLayout != null)
        ((TypeDef) typeDefUser2).ClassLayout = (ClassLayout) new ClassLayoutUser(origin.ClassLayout.PackingSize, origin.ClassSize);
      foreach (GenericParam genericParameter in (IEnumerable<GenericParam>) origin.GenericParameters)
        ((ICollection<GenericParam>) ((TypeDef) typeDefUser2).GenericParameters).Add((GenericParam) new GenericParamUser(genericParameter.Number, genericParameter.Flags, UTF8String.op_Implicit("-")));
      return typeDefUser2;
    }

    private static MethodDefUser Clone(MethodDef origin)
    {
      MethodDefUser methodDefUser = new MethodDefUser(origin.Name, (MethodSig) null, origin.ImplAttributes, origin.Attributes);
      foreach (GenericParam genericParameter in (IEnumerable<GenericParam>) origin.GenericParameters)
        ((ICollection<GenericParam>) ((MethodDef) methodDefUser).GenericParameters).Add((GenericParam) new GenericParamUser(genericParameter.Number, genericParameter.Flags, UTF8String.op_Implicit("-")));
      return methodDefUser;
    }

    private static FieldDefUser Clone(FieldDef origin) => new FieldDefUser(origin.Name, (FieldSig) null, origin.Attributes);

    private static TypeDef PopulateContext(TypeDef typeDef, InjectHelper.InjectContext ctx)
    {
      IDnlibDef idnlibDef;
      TypeDef typeDef1;
      if (!ctx.map.TryGetValue((IDnlibDef) typeDef, out idnlibDef))
      {
        typeDef1 = (TypeDef) InjectHelper.Clone(typeDef);
        ctx.map[(IDnlibDef) typeDef] = (IDnlibDef) typeDef1;
      }
      else
        typeDef1 = (TypeDef) idnlibDef;
      foreach (TypeDef nestedType in (IEnumerable<TypeDef>) typeDef.NestedTypes)
        ((ICollection<TypeDef>) typeDef1.NestedTypes).Add(InjectHelper.PopulateContext(nestedType, ctx));
      foreach (MethodDef method in (IEnumerable<MethodDef>) typeDef.Methods)
        ((ICollection<MethodDef>) typeDef1.Methods).Add((MethodDef) (ctx.map[(IDnlibDef) method] = (IDnlibDef) InjectHelper.Clone(method)));
      foreach (FieldDef field in (IEnumerable<FieldDef>) typeDef.Fields)
        ((ICollection<FieldDef>) typeDef1.Fields).Add((FieldDef) (ctx.map[(IDnlibDef) field] = (IDnlibDef) InjectHelper.Clone(field)));
      return typeDef1;
    }

    private static void CopyTypeDef(TypeDef typeDef, InjectHelper.InjectContext ctx)
    {
      TypeDef typeDef1 = (TypeDef) ctx.map[(IDnlibDef) typeDef];
      TypeDef typeDef2 = typeDef1;
      Importer importer1 = ctx.Importer;
      ITypeDefOrRef itypeDefOrRef = ((Importer) ref importer1).Import(typeDef.BaseType);
      typeDef2.BaseType = itypeDefOrRef;
      foreach (InterfaceImpl interfaceImpl in (IEnumerable<InterfaceImpl>) typeDef.Interfaces)
      {
        IList<InterfaceImpl> interfaces = typeDef1.Interfaces;
        Importer importer2 = ctx.Importer;
        InterfaceImplUser interfaceImplUser = new InterfaceImplUser(((Importer) ref importer2).Import(interfaceImpl.Interface));
        ((ICollection<InterfaceImpl>) interfaces).Add((InterfaceImpl) interfaceImplUser);
      }
    }

    private static void CopyMethodDef(MethodDef methodDef, InjectHelper.InjectContext ctx)
    {
      MethodDef methodDef1 = (MethodDef) ctx.map[(IDnlibDef) methodDef];
      MethodDef methodDef2 = methodDef1;
      Importer importer1 = ctx.Importer;
      CallingConventionSig callingConventionSig = ((Importer) ref importer1).Import(methodDef.Signature);
      methodDef2.Signature = callingConventionSig;
      methodDef1.Parameters.UpdateParameterTypes();
      if (methodDef.ImplMap != null)
        methodDef1.ImplMap = (ImplMap) new ImplMapUser((ModuleRef) new ModuleRefUser(ctx.TargetModule, methodDef.ImplMap.Module.Name), methodDef.ImplMap.Name, methodDef.ImplMap.Attributes);
      foreach (CustomAttribute customAttribute1 in (LazyList<CustomAttribute>) methodDef.CustomAttributes)
      {
        CustomAttributeCollection customAttributes = methodDef1.CustomAttributes;
        Importer importer2 = ctx.Importer;
        CustomAttribute customAttribute2 = new CustomAttribute((ICustomAttributeType) ((Importer) ref importer2).Import((IMethod) customAttribute1.Constructor));
        ((LazyList<CustomAttribute>) customAttributes).Add(customAttribute2);
      }
      if (!methodDef.HasBody)
        return;
      methodDef1.Body = new CilBody(methodDef.Body.InitLocals, (IList<Instruction>) new List<Instruction>(), (IList<ExceptionHandler>) new List<ExceptionHandler>(), (IList<Local>) new List<Local>())
      {
        MaxStack = methodDef.Body.MaxStack
      };
      Dictionary<object, object> bodyMap = new Dictionary<object, object>();
      foreach (Local variable in methodDef.Body.Variables)
      {
        Importer importer3 = ctx.Importer;
        Local local = new Local(((Importer) ref importer3).Import(variable.Type));
        methodDef1.Body.Variables.Add(local);
        local.Name = variable.Name;
        local.Attributes = variable.Attributes;
        bodyMap[(object) variable] = (object) local;
      }
      foreach (Instruction instruction1 in (IEnumerable<Instruction>) methodDef.Body.Instructions)
      {
        Instruction instruction2 = new Instruction(instruction1.OpCode, instruction1.Operand)
        {
          SequencePoint = instruction1.SequencePoint
        };
        switch (instruction2.Operand)
        {
          case IType itype2:
            Instruction instruction3 = instruction2;
            Importer importer4 = ctx.Importer;
            IType itype1 = ((Importer) ref importer4).Import(itype2);
            instruction3.Operand = (object) itype1;
            break;
          case IMethod imethod2:
            Instruction instruction4 = instruction2;
            Importer importer5 = ctx.Importer;
            IMethod imethod1 = ((Importer) ref importer5).Import(imethod2);
            instruction4.Operand = (object) imethod1;
            break;
          case IField ifield2:
            Instruction instruction5 = instruction2;
            Importer importer6 = ctx.Importer;
            IField ifield1 = ((Importer) ref importer6).Import(ifield2);
            instruction5.Operand = (object) ifield1;
            break;
        }
        ((ICollection<Instruction>) methodDef1.Body.Instructions).Add(instruction2);
        bodyMap[(object) instruction1] = (object) instruction2;
      }
      foreach (Instruction instruction6 in (IEnumerable<Instruction>) methodDef1.Body.Instructions)
      {
        if (instruction6.Operand != null && bodyMap.ContainsKey(instruction6.Operand))
          instruction6.Operand = bodyMap[instruction6.Operand];
        else if (instruction6.Operand is Instruction[] operand)
        {
          Instruction instruction7 = instruction6;
          Func<Instruction, Instruction> selector = (Func<Instruction, Instruction>) (target => (Instruction) bodyMap[(object) target]);
          Instruction[] array = ((IEnumerable<Instruction>) operand).Select<Instruction, Instruction>(selector).ToArray<Instruction>();
          instruction7.Operand = (object) array;
        }
      }
      foreach (ExceptionHandler exceptionHandler1 in (IEnumerable<ExceptionHandler>) methodDef.Body.ExceptionHandlers)
      {
        IList<ExceptionHandler> exceptionHandlers = methodDef1.Body.ExceptionHandlers;
        ExceptionHandler exceptionHandler2 = new ExceptionHandler(exceptionHandler1.HandlerType);
        ITypeDefOrRef itypeDefOrRef;
        if (exceptionHandler1.CatchType != null)
        {
          Importer importer7 = ctx.Importer;
          itypeDefOrRef = ((Importer) ref importer7).Import(exceptionHandler1.CatchType);
        }
        else
          itypeDefOrRef = (ITypeDefOrRef) null;
        exceptionHandler2.CatchType = itypeDefOrRef;
        exceptionHandler2.TryStart = (Instruction) bodyMap[(object) exceptionHandler1.TryStart];
        exceptionHandler2.TryEnd = (Instruction) bodyMap[(object) exceptionHandler1.TryEnd];
        exceptionHandler2.HandlerStart = (Instruction) bodyMap[(object) exceptionHandler1.HandlerStart];
        exceptionHandler2.HandlerEnd = (Instruction) bodyMap[(object) exceptionHandler1.HandlerEnd];
        exceptionHandler2.FilterStart = exceptionHandler1.FilterStart == null ? (Instruction) null : (Instruction) bodyMap[(object) exceptionHandler1.FilterStart];
        ((ICollection<ExceptionHandler>) exceptionHandlers).Add(exceptionHandler2);
      }
      methodDef1.Body.SimplifyMacros((IList<Parameter>) methodDef1.Parameters);
    }

    private static void CopyFieldDef(FieldDef fieldDef, InjectHelper.InjectContext ctx)
    {
      FieldDef fieldDef1 = (FieldDef) ctx.map[(IDnlibDef) fieldDef];
      Importer importer = ctx.Importer;
      CallingConventionSig callingConventionSig = ((Importer) ref importer).Import(fieldDef.Signature);
      fieldDef1.Signature = callingConventionSig;
    }

    private static void Copy(TypeDef typeDef, InjectHelper.InjectContext ctx, bool copySelf)
    {
      if (copySelf)
        InjectHelper.CopyTypeDef(typeDef, ctx);
      foreach (TypeDef nestedType in (IEnumerable<TypeDef>) typeDef.NestedTypes)
        InjectHelper.Copy(nestedType, ctx, true);
      foreach (MethodDef method in (IEnumerable<MethodDef>) typeDef.Methods)
        InjectHelper.CopyMethodDef(method, ctx);
      foreach (FieldDef field in (IEnumerable<FieldDef>) typeDef.Fields)
        InjectHelper.CopyFieldDef(field, ctx);
    }

    public static TypeDef Inject(TypeDef typeDef, ModuleDef target)
    {
      InjectHelper.InjectContext ctx = new InjectHelper.InjectContext(typeDef.Module, target);
      InjectHelper.PopulateContext(typeDef, ctx);
      InjectHelper.Copy(typeDef, ctx, true);
      return (TypeDef) ctx.map[(IDnlibDef) typeDef];
    }

    public static MethodDef Inject(MethodDef methodDef, ModuleDef target)
    {
      InjectHelper.InjectContext ctx = new InjectHelper.InjectContext(methodDef.Module, target);
      ctx.map[(IDnlibDef) methodDef] = (IDnlibDef) InjectHelper.Clone(methodDef);
      InjectHelper.CopyMethodDef(methodDef, ctx);
      return (MethodDef) ctx.map[(IDnlibDef) methodDef];
    }

    public static IEnumerable<IDnlibDef> Inject(
      TypeDef typeDef,
      TypeDef newType,
      ModuleDef target)
    {
      InjectHelper.InjectContext ctx = new InjectHelper.InjectContext(typeDef.Module, target);
      ctx.map[(IDnlibDef) typeDef] = (IDnlibDef) newType;
      InjectHelper.PopulateContext(typeDef, ctx);
      InjectHelper.Copy(typeDef, ctx, false);
      return ((IEnumerable<IDnlibDef>) ctx.map.Values).Except<IDnlibDef>((IEnumerable<IDnlibDef>) new TypeDef[1]
      {
        newType
      });
    }

    private class InjectContext : ImportMapper
    {
      public readonly Dictionary<IDnlibDef, IDnlibDef> map = new Dictionary<IDnlibDef, IDnlibDef>();
      public readonly ModuleDef OriginModule;
      public readonly ModuleDef TargetModule;
      public readonly Importer importer;

      public InjectContext(ModuleDef module, ModuleDef target)
      {
        this.OriginModule = module;
        this.TargetModule = target;
        this.importer = new Importer(target, (ImporterOptions) 1, new GenericParamContext(), (ImportMapper) this);
      }

      public Importer Importer => this.importer;

      public virtual ITypeDefOrRef Map(ITypeDefOrRef typeDefOrRef) => !(typeDefOrRef is TypeDef key) || !this.map.ContainsKey((IDnlibDef) key) ? (ITypeDefOrRef) null : (ITypeDefOrRef) this.map[(IDnlibDef) key];

      public virtual IMethod Map(MethodDef methodDef) => !this.map.ContainsKey((IDnlibDef) methodDef) ? (IMethod) null : (IMethod) this.map[(IDnlibDef) methodDef];

      public virtual IField Map(FieldDef fieldDef) => !this.map.ContainsKey((IDnlibDef) fieldDef) ? (IField) null : (IField) this.map[(IDnlibDef) fieldDef];
    }
  }
}
