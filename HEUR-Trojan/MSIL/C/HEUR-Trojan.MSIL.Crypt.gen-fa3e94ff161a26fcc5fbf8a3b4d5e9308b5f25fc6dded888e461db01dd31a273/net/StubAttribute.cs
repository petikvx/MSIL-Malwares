// Decompiled with JetBrains decompiler
// Type: net.StubAttribute
// Assembly: net, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F6242565-25BF-4452-B4C5-DC4E00930466
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-fa3e94ff161a26fcc5fbf8a3b4d5e9308b5f25fc6dded888e461db01dd31a273.exe

using System;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Security.Cryptography;

namespace net
{
  internal class StubAttribute
  {
    private static readonly object valuesHandle;
    private static readonly int nextMessage;
    private static readonly int previousLine;
    private static readonly MemoryStream dataInstance = (MemoryStream) null;
    private static readonly MemoryStream fontSet = (MemoryStream) null;
    private static readonly byte activeAddress;

    static StubAttribute()
    {
      StubAttribute.nextMessage = int.MaxValue;
      StubAttribute.previousLine = int.MinValue;
      StubAttribute.dataInstance = new MemoryStream(0);
      StubAttribute.fontSet = new MemoryStream(0);
      StubAttribute.valuesHandle = new object();
    }

    private static string ClearComponent(Assembly valuesHandle)
    {
      string str = valuesHandle.FullName;
      int length = str.IndexOf(',');
      if (length >= 0)
        str = str.Substring(0, length);
      return str;
    }

    private static byte[] FindSolution(Assembly valuesHandle)
    {
      try
      {
        string fullName = valuesHandle.FullName;
        int num1 = fullName.IndexOf("PublicKeyToken=");
        if (num1 < 0)
          num1 = fullName.IndexOf("publickeytoken=");
        if (num1 < 0)
          return (byte[]) null;
        int num2 = num1 + 15;
        if (fullName[num2] == 'n' || fullName[num2] == 'N')
          return (byte[]) null;
        byte[] bytes = BitConverter.GetBytes(long.Parse(fullName.Substring(num2, 16), NumberStyles.HexNumber));
        Array.Reverse((Array) bytes);
        return bytes;
      }
      catch
      {
      }
      return (byte[]) null;
    }

    internal static byte[] AddAspect(Stream valuesHandle)
    {
      lock (StubAttribute.valuesHandle)
        return StubAttribute.RebuildTreeNode(97L, (object) valuesHandle);
    }

    internal static byte[] LoadXmlFile(long valuesHandle, Stream nextMessage)
    {
      try
      {
        return StubAttribute.AddAspect(nextMessage);
      }
      catch
      {
        return StubAttribute.RebuildTreeNode(97L, (object) nextMessage);
      }
    }

    internal static byte[] RebuildTreeNode(long valuesHandle, object nextMessage)
    {
      Stream stream1 = nextMessage as Stream;
      Stream stream2 = stream1;
      MemoryStream memoryStream = (MemoryStream) null;
      for (int index = 1; index < 4; ++index)
        stream1.ReadByte();
      ushort num1 = ~(ushort) stream1.ReadByte();
      if (((int) num1 & 2) != 0)
      {
        DESCryptoServiceProvider cryptoServiceProvider = new DESCryptoServiceProvider();
        byte[] buffer1 = new byte[8];
        stream1.Read(buffer1, 0, 8);
        cryptoServiceProvider.IV = buffer1;
        byte[] buffer2 = new byte[8];
        stream1.Read(buffer2, 0, 8);
        bool flag = true;
        foreach (byte num2 in buffer2)
        {
          if (num2 != (byte) 0)
          {
            flag = false;
            break;
          }
        }
        if (flag)
          buffer2 = StubAttribute.FindSolution(Assembly.GetExecutingAssembly());
        cryptoServiceProvider.Key = buffer2;
        if (StubAttribute.dataInstance == null)
          StubAttribute.dataInstance.Capacity = StubAttribute.nextMessage != int.MaxValue ? StubAttribute.nextMessage : (int) stream1.Length;
        StubAttribute.dataInstance.Position = 0L;
        ICryptoTransform decryptor = cryptoServiceProvider.CreateDecryptor();
        int inputBlockSize = decryptor.InputBlockSize;
        int outputBlockSize = decryptor.OutputBlockSize;
        byte[] numArray1 = new byte[decryptor.OutputBlockSize];
        byte[] numArray2 = new byte[decryptor.InputBlockSize];
        int position;
        for (position = (int) stream1.Position; (long) (position + inputBlockSize) < stream1.Length; position += inputBlockSize)
        {
          stream1.Read(numArray2, 0, inputBlockSize);
          int count = decryptor.TransformBlock(numArray2, 0, inputBlockSize, numArray1, 0);
          StubAttribute.dataInstance.Write(numArray1, 0, count);
        }
        stream1.Read(numArray2, 0, (int) (stream1.Length - (long) position));
        byte[] buffer3 = decryptor.TransformFinalBlock(numArray2, 0, (int) (stream1.Length - (long) position));
        StubAttribute.dataInstance.Write(buffer3, 0, buffer3.Length);
        stream2 = (Stream) StubAttribute.dataInstance;
        stream2.Position = 0L;
        memoryStream = StubAttribute.dataInstance;
      }
      if (((int) num1 & 8) != 0)
      {
        if (StubAttribute.fontSet == null)
          StubAttribute.fontSet.Capacity = StubAttribute.previousLine != int.MinValue ? StubAttribute.previousLine : (int) stream2.Length * 2;
        StubAttribute.fontSet.Position = 0L;
        DeflateStream deflateStream = new DeflateStream(stream2, CompressionMode.Decompress);
        int count1 = 1000;
        byte[] buffer = new byte[count1];
        int count2;
        do
        {
          count2 = deflateStream.Read(buffer, 0, count1);
          if (count2 > 0)
            StubAttribute.fontSet.Write(buffer, 0, count2);
        }
        while (count2 >= count1);
        memoryStream = StubAttribute.fontSet;
      }
      if (memoryStream != null)
        return memoryStream.ToArray();
      byte[] buffer4 = new byte[stream1.Length - stream1.Position];
      stream1.Read(buffer4, 0, buffer4.Length);
      return buffer4;
    }
  }
}
