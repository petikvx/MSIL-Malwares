// Decompiled with JetBrains decompiler
// Type: org.lb.lbvm.scheme.Compiler
// Assembly: GCCollectionMo, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3A5CAC9E-800C-431E-83D8-5129C6781923
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\Trojan-PSW.Win32.Stealer.aezg-0c850189152813ace3063af65fad784dace09ebd9778423c04aa0881b0d0cc09.exe

using org.lb.lbvm.exceptions;
using org.lb.lbvm.runtime;
using System;
using System.Collections.Generic;
using System.Globalization;

namespace org.lb.lbvm.scheme
{
  internal sealed class Compiler
  {
    private readonly List<string> CompiledSource = new List<string>();
    private readonly NameGenerator NameGenerator = new NameGenerator();

    public static IEnumerable<string> Compile(string source) => (IEnumerable<string>) null;

    private Compiler(string source)
    {
    }

    private void CompileStatement(object o, bool tailCall, bool quoting = false)
    {
      switch (o)
      {
        case bool flag:
          this.Emit(flag ? "PUSHTRUE" : "PUSHFALSE");
          break;
        case int num1:
          this.Emit("PUSHINT " + num1.ToString());
          break;
        case double num2:
          this.Emit("PUSHDBL " + num2.ToString((IFormatProvider) CultureInfo.InvariantCulture));
          break;
        case string _:
          this.Emit("PUSHSTR " + StringObject.Escape((string) o));
          break;
        default:
          if (Symbols.NilSymbol.Equals(o))
          {
            this.Emit("PUSHNIL");
            break;
          }
          switch (o)
          {
            case char ch:
              this.Emit("PUSHCHR " + ((byte) ch).ToString());
              return;
            case Symbol _:
              this.Emit((quoting ? "PUSHSYM " : "PUSHVAR ") + o?.ToString());
              return;
            case List<object> _:
              if (quoting)
              {
                this.CompileQuotedList((List<object>) o);
                return;
              }
              this.CompileList((List<object>) o, tailCall);
              return;
            default:
              throw new CompilerException("Internal error: I don't know how to compile " + (quoting ? "quoted " : "") + "object of type " + o.GetType()?.ToString());
          }
      }
    }

    private void Emit(string line) => this.CompiledSource.Add(line);

    private void CompileList(List<object> value, bool tailCall)
    {
      object obj = value.Count != 0 ? value[0] : throw new CompilerException("Empty list cannot be called as a function");
      if (obj is Symbol)
      {
        FunctionDefinition function = Symbols.GetFunction(obj.ToString());
        if (function != null)
        {
          this.AssertParameterCount(function.Arity, value.Count - 1, function.Opcode);
          for (int index = 1; index <= function.Arity; ++index)
            this.CompileStatement(value[index], false);
          this.Emit(function.Opcode);
          return;
        }
      }
      if (Symbols.DefineSymbol.Equals(obj))
        this.CompileDefine(value);
      else if (Symbols.LambdaSymbol.Equals(obj))
        this.CompileLambda(value);
      else if (Symbols.SetSymbol.Equals(obj))
        this.CompileSet(value);
      else if (Symbols.QuoteSymbol.Equals(obj))
        this.CompileQuote(value);
      else if (Symbols.IfSymbol.Equals(obj))
        this.CompileIf(value, tailCall);
      else if (Symbols.BeginSymbol.Equals(obj))
        this.CompileBegin((IEnumerable<object>) value, tailCall);
      else if (Symbols.CondSymbol.Equals(obj))
        this.CompileCond((IEnumerable<object>) value, tailCall);
      else
        this.CompileFunctionCall(value, tailCall);
    }

    private void AssertParameterCount(int expected, int got, string function)
    {
      if (expected != got)
        throw new CompilerException(function + ": Expected " + expected.ToString() + " parameter(s), got " + got.ToString());
    }

    private void CompileLambda(List<object> value)
    {
      if (!(value[1] is List<object>))
        throw new CompilerException("Invalid lambda form");
      new List<object>()
      {
        (object) this.NameGenerator.NextLambdaName()
      }.AddRange((IEnumerable<object>) value[1]);
    }

    private void CompileDefine(List<object> value)
    {
    }

    private void CompileFunctionDefinition(
      List<object> functionNameAndParameters,
      List<object> body)
    {
    }

    private void CompileVariableDefinition(List<object> value)
    {
      this.AssertParameterCount(2, value.Count - 1, "define variable");
      Symbol symbol = value[1] is Symbol ? (Symbol) value[1] : throw new CompilerException("Target of define is not a symbol");
      this.CompileStatement(value[2], false);
      this.Emit("DEFINE " + symbol?.ToString());
      this.Emit("PUSHVAR " + symbol?.ToString());
    }

    private void CompileSet(List<object> value)
    {
      this.AssertParameterCount(2, value.Count - 1, "set!");
      Symbol symbol = value[1] is Symbol ? (Symbol) value[1] : throw new CompilerException("Target of set! is not a symbol");
      this.CompileStatement(value[2], false);
      this.Emit("SET " + symbol?.ToString());
      this.Emit("PUSHVAR " + symbol?.ToString());
    }

    private void CompileQuote(List<object> value)
    {
      this.AssertParameterCount(1, value.Count - 1, "quote");
      this.CompileStatement(value[1], false, true);
    }

    private void CompileQuotedList(List<object> value)
    {
      this.Emit("PUSHVAR list");
      foreach (object o in value)
        this.CompileStatement(o, false, true);
      this.Emit("CALL " + value.Count.ToString());
    }

    private void CompileIf(List<object> value, bool tailCall)
    {
      this.CompileStatement(value[1], false);
      string str1 = this.NameGenerator.NextLabel();
      string str2 = this.NameGenerator.NextLabel();
      this.Emit("BFALSE " + str1);
      this.CompileStatement(value[2], tailCall);
      this.Emit("JMP " + str2);
      this.Emit(str1 + ":");
      this.CompileStatement(value[3], tailCall);
      this.Emit(str2 + ":");
    }

    private void CompileBegin(IEnumerable<object> value, bool tailCall)
    {
    }

    private void CompileCond(IEnumerable<object> value, bool tailCall) => this.Emit(this.NameGenerator.NextLabel() + ":");

    private void CompileBlock(List<object> statements, bool tailCall)
    {
      for (int index = 0; index < statements.Count; ++index)
      {
        bool flag = index == statements.Count - 1;
        this.CompileStatement(statements[index], tailCall & flag);
        if (!flag)
          this.Emit("POP");
      }
    }

    private void CompileFunctionCall(List<object> value, bool tailCall)
    {
      foreach (object o in value)
        this.CompileStatement(o, false);
      this.Emit((tailCall ? "TAILCALL " : "CALL ") + (value.Count - 1).ToString());
    }
  }
}
