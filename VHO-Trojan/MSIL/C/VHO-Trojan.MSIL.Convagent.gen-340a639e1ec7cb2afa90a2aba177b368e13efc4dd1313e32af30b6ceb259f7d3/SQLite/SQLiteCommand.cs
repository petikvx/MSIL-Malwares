// Decompiled with JetBrains decompiler
// Type: SQLite.SQLiteCommand
// Assembly: SharpChrome, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D938FA4A-3611-4CA7-B3BE-AF9F6D845B7B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\VHO-Trojan.MSIL.Convagent.gen-340a639e1ec7cb2afa90a2aba177b368e13efc4dd1313e32af30b6ceb259f7d3.exe

using Community.CsharpSqlite;
using System;
using System.Collections.Generic;
using System.Linq;

namespace SQLite
{
  public class SQLiteCommand
  {
    private SQLiteConnection _conn;
    private List<SQLiteCommand.Binding> _bindings;
    internal static IntPtr NegativePointer = new IntPtr(-1);

    public string CommandText { get; set; }

    internal SQLiteCommand(SQLiteConnection conn)
    {
      this._conn = conn;
      this._bindings = new List<SQLiteCommand.Binding>();
      this.CommandText = "";
    }

    public int ExecuteNonQuery()
    {
      int num = this._conn.Trace ? 1 : 0;
      Sqlite3.Vdbe stmt = this.Prepare();
      SQLite3.Result r = SQLite3.Step(stmt);
      this.Finalize(stmt);
      if (r == SQLite3.Result.Done)
        return SQLite3.Changes(this._conn.Handle);
      if (r == SQLite3.Result.Error)
      {
        string errmsg = SQLite3.GetErrmsg(this._conn.Handle);
        throw SQLiteException.New(r, errmsg);
      }
      throw SQLiteException.New(r, r.ToString());
    }

    public List<SQLiteQueryRow> ExecuteQuery() => this.ExecuteDeferredQuery().ToList<SQLiteQueryRow>();

    public IEnumerable<SQLiteQueryRow> ExecuteDeferredQuery()
    {
      int num1 = this._conn.Trace ? 1 : 0;
      Sqlite3.Vdbe stmt = this.Prepare();
      try
      {
        string[] cols = new string[SQLite3.ColumnCount(stmt)];
        for (int index = 0; index < cols.Length; ++index)
        {
          string str = SQLite3.ColumnName16(stmt, index);
          cols[index] = str;
        }
        while (SQLite3.Step(stmt) == SQLite3.Result.Row)
        {
          SQLiteQueryRow sqLiteQueryRow = new SQLiteQueryRow();
          for (int index = 0; index < cols.Length; ++index)
          {
            SQLite3.ColType type = SQLite3.ColumnType(stmt, index);
            Type targetType;
            switch (type)
            {
              case SQLite3.ColType.Integer:
                targetType = typeof (int);
                break;
              case SQLite3.ColType.Float:
                targetType = typeof (double);
                break;
              case SQLite3.ColType.Text:
                targetType = typeof (string);
                break;
              default:
                targetType = typeof (object);
                break;
            }
            object obj = this.ReadCol(stmt, index, type, targetType);
            SQLiteQueryColumn sqLiteQueryColumn = new SQLiteQueryColumn();
            sqLiteQueryColumn.Key = cols[index];
            sqLiteQueryColumn.Value = obj;
            if (sqLiteQueryRow.column == null)
              sqLiteQueryRow.column = new List<SQLiteQueryColumn>();
            sqLiteQueryRow.column.Add(sqLiteQueryColumn);
            targetType = (Type) null;
          }
          this.OnInstanceCreated((object) sqLiteQueryRow);
          yield return sqLiteQueryRow;
        }
        cols = (string[]) null;
      }
      finally
      {
        int num2 = (int) SQLite3.Finalize(stmt);
      }
    }

    public IEnumerable<T> ExecuteDeferredQuery<T>() => this.ExecuteDeferredQuery<T>(this._conn.GetMapping(typeof (T)));

    public List<T> ExecuteQuery<T>() => this.ExecuteDeferredQuery<T>(this._conn.GetMapping(typeof (T))).ToList<T>();

    public List<T> ExecuteQuery<T>(TableMapping map) => this.ExecuteDeferredQuery<T>(map).ToList<T>();

    protected virtual void OnInstanceCreated(object obj)
    {
    }

    public IEnumerable<T> ExecuteDeferredQuery<T>(TableMapping map)
    {
      int num1 = this._conn.Trace ? 1 : 0;
      Sqlite3.Vdbe stmt = this.Prepare();
      try
      {
        TableMapping.Column[] cols = new TableMapping.Column[SQLite3.ColumnCount(stmt)];
        for (int index = 0; index < cols.Length; ++index)
        {
          string columnName = SQLite3.ColumnName16(stmt, index);
          cols[index] = map.FindColumn(columnName);
        }
        while (SQLite3.Step(stmt) == SQLite3.Result.Row)
        {
          object instance = Activator.CreateInstance(map.MappedType);
          for (int index = 0; index < cols.Length; ++index)
          {
            if (cols[index] != null)
            {
              SQLite3.ColType type = SQLite3.ColumnType(stmt, index);
              object val = this.ReadCol(stmt, index, type, cols[index].ColumnType);
              cols[index].SetValue(instance, val);
            }
          }
          this.OnInstanceCreated(instance);
          yield return (T) instance;
        }
        cols = (TableMapping.Column[]) null;
      }
      finally
      {
        int num2 = (int) SQLite3.Finalize(stmt);
      }
    }

    public T ExecuteScalar<T>()
    {
      int num = this._conn.Trace ? 1 : 0;
      T obj = default (T);
      Sqlite3.Vdbe stmt = this.Prepare();
      try
      {
        SQLite3.Result r = SQLite3.Step(stmt);
        switch (r)
        {
          case SQLite3.Result.Row:
            SQLite3.ColType type = SQLite3.ColumnType(stmt, 0);
            obj = (T) this.ReadCol(stmt, 0, type, typeof (T));
            break;
          case SQLite3.Result.Done:
            break;
          default:
            throw SQLiteException.New(r, SQLite3.GetErrmsg(this._conn.Handle));
        }
      }
      finally
      {
        this.Finalize(stmt);
      }
      return obj;
    }

    public void Bind(string name, object val) => this._bindings.Add(new SQLiteCommand.Binding()
    {
      Name = name,
      Value = val
    });

    public void Bind(object val) => this.Bind((string) null, val);

    public override string ToString()
    {
      string[] strArray = new string[1 + this._bindings.Count];
      strArray[0] = this.CommandText;
      int index = 1;
      foreach (SQLiteCommand.Binding binding in this._bindings)
      {
        strArray[index] = string.Format("  {0}: {1}", (object) (index - 1), binding.Value);
        ++index;
      }
      return string.Join(Environment.NewLine, strArray);
    }

    private Sqlite3.Vdbe Prepare()
    {
      Sqlite3.Vdbe stmt = SQLite3.Prepare2(this._conn.Handle, this.CommandText);
      this.BindAll(stmt);
      return stmt;
    }

    private void Finalize(Sqlite3.Vdbe stmt)
    {
      int num = (int) SQLite3.Finalize(stmt);
    }

    private void BindAll(Sqlite3.Vdbe stmt)
    {
      int num = 1;
      foreach (SQLiteCommand.Binding binding in this._bindings)
      {
        binding.Index = binding.Name == null ? num++ : SQLite3.BindParameterIndex(stmt, binding.Name);
        SQLiteCommand.BindParameter(stmt, binding.Index, binding.Value, this._conn.StoreDateTimeAsTicks);
      }
    }

    internal static void BindParameter(
      Sqlite3.Vdbe stmt,
      int index,
      object value,
      bool storeDateTimeAsTicks)
    {
      switch (value)
      {
        case null:
          SQLite3.BindNull(stmt, index);
          break;
        case int val:
          SQLite3.BindInt(stmt, index, val);
          break;
        case string _:
          SQLite3.BindText(stmt, index, (string) value, -1, SQLiteCommand.NegativePointer);
          break;
        case byte _:
        case ushort _:
        case sbyte _:
        case short _:
          SQLite3.BindInt(stmt, index, Convert.ToInt32(value));
          break;
        case bool flag:
          SQLite3.BindInt(stmt, index, flag ? 1 : 0);
          break;
        case uint _:
        case long _:
          SQLite3.BindInt64(stmt, index, Convert.ToInt64(value));
          break;
        case float _:
        case double _:
        case Decimal _:
          SQLite3.BindDouble(stmt, index, Convert.ToDouble(value));
          break;
        case System.DateTime _:
          if (storeDateTimeAsTicks)
          {
            SQLite3.BindInt64(stmt, index, ((System.DateTime) value).Ticks);
            break;
          }
          SQLite3.BindText(stmt, index, ((System.DateTime) value).ToString("yyyy-MM-dd HH:mm:ss"), -1, SQLiteCommand.NegativePointer);
          break;
        default:
          if (value.GetType().IsEnum)
          {
            SQLite3.BindInt(stmt, index, Convert.ToInt32(value));
            break;
          }
          switch (value)
          {
            case byte[] _:
              SQLite3.BindBlob(stmt, index, (byte[]) value, ((byte[]) value).Length, SQLiteCommand.NegativePointer);
              return;
            case Guid guid:
              SQLite3.BindText(stmt, index, guid.ToString(), 72, SQLiteCommand.NegativePointer);
              return;
            default:
              throw new NotSupportedException("Cannot store type: " + (object) value.GetType());
          }
      }
    }

    private object ReadCol(Sqlite3.Vdbe stmt, int index, SQLite3.ColType type, Type clrType)
    {
      if (type == SQLite3.ColType.Null)
        return (object) null;
      if ((object) clrType == (object) typeof (string))
        return (object) SQLite3.ColumnString(stmt, index);
      if ((object) clrType == (object) typeof (int))
        return (object) SQLite3.ColumnInt(stmt, index);
      if ((object) clrType == (object) typeof (bool))
        return (object) (SQLite3.ColumnInt(stmt, index) == 1);
      if ((object) clrType == (object) typeof (double))
        return (object) SQLite3.ColumnDouble(stmt, index);
      if ((object) clrType == (object) typeof (float))
        return (object) (float) SQLite3.ColumnDouble(stmt, index);
      if ((object) clrType == (object) typeof (System.DateTime))
        return this._conn.StoreDateTimeAsTicks ? (object) new System.DateTime(SQLite3.ColumnInt64(stmt, index)) : (object) System.DateTime.Parse(SQLite3.ColumnString(stmt, index));
      if (clrType.IsEnum)
        return (object) SQLite3.ColumnInt(stmt, index);
      if ((object) clrType == (object) typeof (long))
        return (object) SQLite3.ColumnInt64(stmt, index);
      if ((object) clrType == (object) typeof (uint))
        return (object) (uint) SQLite3.ColumnInt64(stmt, index);
      if ((object) clrType == (object) typeof (Decimal))
        return (object) (Decimal) SQLite3.ColumnDouble(stmt, index);
      if ((object) clrType == (object) typeof (byte))
        return (object) (byte) SQLite3.ColumnInt(stmt, index);
      if ((object) clrType == (object) typeof (ushort))
        return (object) (ushort) SQLite3.ColumnInt(stmt, index);
      if ((object) clrType == (object) typeof (short))
        return (object) (short) SQLite3.ColumnInt(stmt, index);
      if ((object) clrType == (object) typeof (sbyte))
        return (object) (sbyte) SQLite3.ColumnInt(stmt, index);
      if ((object) clrType == (object) typeof (byte[]))
        return (object) SQLite3.ColumnByteArray(stmt, index);
      if ((object) clrType == (object) typeof (object))
        return (object) SQLite3.ColumnByteArray(stmt, index);
      if ((object) clrType == (object) typeof (Guid))
        return (object) new Guid(SQLite3.ColumnString(stmt, index));
      throw new NotSupportedException("Don't know how to read " + (object) clrType);
    }

    private class Binding
    {
      public string Name { get; set; }

      public object Value { get; set; }

      public int Index { get; set; }
    }
  }
}
