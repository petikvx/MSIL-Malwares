// Decompiled with JetBrains decompiler
// Type: TGL.Polices.Identifier
// Assembly: InvalidOleVariantTypeExcept, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 9E82E8E9-C8CD-41F7-BA61-2A9379AE4148
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Backdoor.MSIL.Androm.gen-02b77b24d467552510c0f56dbde53c82e4e932dcaeb0e08fcfec00d4c359a9b9.exe

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using TGL.Consumers;
using TGL.Licensing;

namespace TGL.Polices
{
  [Serializable]
  public class Identifier
  {
    private ItemValues m_Callback;
    private Dictionary<ItemValues, object> _Status;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public Identifier(ItemValues res)
    {
      int num1 = 5;
      while (true)
      {
        int num2 = num1;
        while (true)
        {
          switch (num2)
          {
            case 0:
            case 3:
              this._Status = new Dictionary<ItemValues, object>();
              if (Identifier.FlushInfo())
              {
                num2 = 6;
                continue;
              }
              goto label_6;
            case 1:
            case 2:
              goto label_6;
            case 4:
              this.m_Callback = res;
              goto case 0;
            case 5:
              UtilsContextLicense.ListWorker();
              num2 = 2;
              continue;
            case 6:
              goto label_9;
            default:
              goto label_4;
          }
        }
label_4:
        num1 = 0;
        continue;
label_6:
        // ISSUE: explicit constructor call
        base.\u002Ector();
        num1 = 4;
      }
label_9:;
    }

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public ItemValues CreateRecord() => this.m_Callback;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void CalculateRecord(ItemValues value) => this.m_Callback = value;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public Identifier ComputeRecord(ItemValues var1, object result)
    {
      this._Status[var1] = result;
      return this;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public object DeleteRecord(ItemValues config)
    {
      object obj;
      this._Status.TryGetValue(config, out obj);
      return obj;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public int PatchRecord() => this._Status.Count;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public List<object> PopRecord() => this._Status.Values.ToList<object>();

    [MethodImpl(MethodImplOptions.NoInlining)]
    public void ForgotRecord(ItemValues init) => this._Status.Remove(init);

    [MethodImpl(MethodImplOptions.NoInlining)]
    public void UpdateRecord() => this._Status.Clear();

    internal static bool FlushInfo() => true;

    internal static bool RemoveInfo() => false;
  }
}
