// Decompiled with JetBrains decompiler
// Type: ChessBoard.Chessmens.Pawn
// Assembly: IArraySortHel, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B08900B5-C53F-4995-B311-D7E8DC4113C6
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcrg-fe8d5c5d892bac95b940a26cf50aacf262dd40e3394fc1ba8444ab3842a16fda.exe

using System.Collections.Generic;

namespace ChessBoard.Chessmens
{
  public class Pawn : BaseChessman
  {
    private List<Cell> acceptableCells;

    public override ChessmenType Type => ChessmenType.Pawn;

    public Pawn()
    {
    }

    public Pawn(Colorz color)
      : base(color)
    {
label_1:
      int num1 = -44857874;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -54406266)) % 3U)
        {
          case 0:
            goto label_1;
          case 1:
            num1 = (int) num2 * 1339741000 ^ 1742662033;
            continue;
          case 2:
            goto label_3;
          default:
            goto label_5;
        }
      }
label_3:
      return;
label_5:;
    }

    public bool IsLastRow(int row)
    {
label_1:
      int num1 = 1747204034;
      bool flag;
      while (true)
      {
        uint num2;
        int num3;
        int num4;
        switch ((num2 = (uint) (num1 ^ 1521835139)) % 9U)
        {
          case 0:
            num3 = row == 7 ? 1 : 0;
            break;
          case 1:
            if (this.Color != Colorz.White)
            {
              num4 = 0;
              goto label_8;
            }
            else
            {
              num1 = (int) num2 * -1529552888 ^ 915939268;
              continue;
            }
          case 3:
            flag = true;
            num1 = (int) num2 * 160777588 ^ -355750807;
            continue;
          case 4:
            if (this.Color != Colorz.Black)
            {
              num3 = 0;
              break;
            }
            num1 = 1096732555;
            continue;
          case 5:
            num1 = (int) num2 * -831641952 ^ -1011181183;
            continue;
          case 6:
            goto label_1;
          case 7:
            num1 = (int) num2 * 1210114765 ^ 1880245667;
            continue;
          case 8:
            num4 = row == 0 ? 1 : 0;
            goto label_8;
          default:
            goto label_16;
        }
        flag = num3 != 0;
        num1 = 503347561;
        continue;
label_8:
        int num5;
        num1 = num5 = num4 == 0 ? 852407861 : (num5 = 2097139567);
      }
label_16:
      return flag;
    }

    public override bool Equals(object obj)
    {
label_1:
      int num1 = -1030928412;
      bool flag;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -1586931548)) % 6U)
        {
          case 0:
            goto label_1;
          case 1:
            flag = false;
            num1 = (int) num2 * -1640315131 ^ 1297416319;
            continue;
          case 2:
            int num3 = obj is Pawn ? 97679387 : (num3 = 1375712483);
            num1 = num3 ^ (int) num2 * 1259752560;
            continue;
          case 3:
            flag = base.Equals(obj);
            num1 = -509944515;
            continue;
          case 4:
            num1 = (int) num2 * -722194804 ^ 1666101661;
            continue;
          default:
            goto label_7;
        }
      }
label_7:
      return flag;
    }

    public override int GetHashCode()
    {
label_1:
      int num1 = 713850878;
      int hashCode;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 447954379)) % 4U)
        {
          case 0:
            goto label_1;
          case 1:
            hashCode = base.GetHashCode();
            num1 = (int) num2 * 1898268843 ^ -1207263221;
            continue;
          case 3:
            num1 = (int) num2 * 751059146 ^ -2032641529;
            continue;
          default:
            goto label_5;
        }
      }
label_5:
      return hashCode;
    }

    public override List<Cell> GetAcceptableCells(
      BoardCell[,] boardCells,
      Cell currentCell,
      bool needToCheckShah = true)
    {
label_1:
      int num1 = -813438029;
      bool flag;
      List<Cell> acceptableCells;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -767882668)) % 11U)
        {
          case 0:
            flag = needToCheckShah;
            num1 = (int) num2 * -761848543 ^ -960356207;
            continue;
          case 1:
            this.acceptableCells = new List<Cell>();
            num1 = (int) num2 * 2120658273 ^ 437222572;
            continue;
          case 2:
            this.AddPositionsIfCanKillEnemy(boardCells, currentCell);
            num1 = (int) num2 * 387208450 ^ -1405017158;
            continue;
          case 3:
            this.AddFrontCellsIfPossible(boardCells, currentCell);
            num1 = (int) num2 * -627308211 ^ 1222770382;
            continue;
          case 4:
            int num3 = !flag ? -59611109 : (num3 = -1980444971);
            num1 = num3 ^ (int) num2 * -646647493;
            continue;
          case 5:
            num1 = (int) num2 * 2018538115 ^ -612864596;
            continue;
          case 6:
            this.AdjustAcceptableCellsInCaseShah(boardCells, this.acceptableCells, currentCell);
            num1 = (int) num2 * 473430659 ^ -1476299922;
            continue;
          case 7:
            acceptableCells = this.acceptableCells;
            num1 = -1948035887;
            continue;
          case 9:
            goto label_1;
          case 10:
            num1 = (int) num2 * 720118150 ^ 1255233957;
            continue;
          default:
            goto label_12;
        }
      }
label_12:
      return acceptableCells;
    }

    private void AddFrontCellsIfPossible(BoardCell[,] boardCells, Cell currentCell)
    {
label_1:
      int num1 = 922952290;
      while (true)
      {
        uint num2;
        int count;
        int num3;
        switch ((num2 = (uint) (num1 ^ 1533221659)) % 6U)
        {
          case 0:
            this.AddNextFrontCellIfPossible(boardCells, currentCell, 2);
            num1 = (int) num2 * 1492670722 ^ -1697035962;
            continue;
          case 1:
            count = this.acceptableCells.Count;
            num1 = (int) num2 * -824066159 ^ 1002043782;
            continue;
          case 2:
            num3 = this.acceptableCells.Count > count ? 1 : 0;
            break;
          case 3:
            goto label_3;
          case 4:
            this.AddNextFrontCellIfPossible(boardCells, currentCell, 1);
            if (this.NeedToCheckNextFrontCell(currentCell.Row))
            {
              num1 = (int) num2 * 1032114951 ^ -1638279125;
              continue;
            }
            num3 = 0;
            break;
          case 5:
            goto label_1;
          default:
            goto label_11;
        }
        int num4;
        num1 = num4 = num3 == 0 ? 454129694 : (num4 = 1160128951);
      }
label_3:
      return;
label_11:;
    }

    private bool NeedToCheckNextFrontCell(int currentRow)
    {
      if (this.Color == Colorz.White)
        goto label_4;
label_1:
      int num1 = -374292278;
label_2:
      int num2;
      bool checkNextFrontCell;
      while (true)
      {
        uint num3;
        switch ((num3 = (uint) (num1 ^ -1024155115)) % 4U)
        {
          case 0:
            goto label_1;
          case 1:
            checkNextFrontCell = currentRow == num2;
            num1 = (int) num3 * 1184680497 ^ 294813918;
            continue;
          case 3:
            goto label_3;
          default:
            goto label_7;
        }
      }
label_3:
      int num4 = 1;
      goto label_5;
label_7:
      return checkNextFrontCell;
label_4:
      num4 = 6;
label_5:
      num2 = num4;
      num1 = -317762404;
      goto label_2;
    }

    private void AddNextFrontCellIfPossible(
      BoardCell[,] boardCells,
      Cell currentCell,
      int nextRowCount)
    {
label_1:
      int num1 = -994800843;
      int row;
      Cell cell;
      int nextRowToTest;
      int column;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -486285808)) % 8U)
        {
          case 0:
            column = currentCell.Column;
            num1 = (int) num2 * -1765449907 ^ 575386143;
            continue;
          case 1:
            this.acceptableCells.Add(cell);
            num1 = (int) num2 * -869057222 ^ -1750952087;
            continue;
          case 2:
            goto label_1;
          case 3:
            goto label_3;
          case 4:
            cell = new Cell(nextRowToTest, column);
            num1 = (int) num2 * -949704496 ^ -38456514;
            continue;
          case 5:
            row = currentCell.Row;
            num1 = (int) num2 * 2044525437 ^ 231523313;
            continue;
          case 6:
            int num3 = !this.IsCellEmptyAndInBounds(boardCells, cell) ? 767280669 : (num3 = 1318411351);
            num1 = num3 ^ (int) num2 * 1603123465;
            continue;
          case 7:
            nextRowToTest = this.GetNextRowToTest(nextRowCount, row);
            num1 = (int) num2 * -192050990 ^ 347784490;
            continue;
          default:
            goto label_10;
        }
      }
label_3:
      return;
label_10:;
    }

    private int GetNextRowToTest(int nextRowCount, int currentRow)
    {
label_1:
      int num1 = 527447412;
      int nextRowToTest;
      while (true)
      {
        uint num2;
        int num3;
        switch ((num2 = (uint) (num1 ^ 1525236527)) % 5U)
        {
          case 0:
            goto label_1;
          case 1:
            if (this.Color != Colorz.White)
            {
              num1 = (int) num2 * 36834909 ^ -66673068;
              continue;
            }
            num3 = currentRow - nextRowCount;
            break;
          case 3:
            num1 = (int) num2 * 2106959641 ^ -478142958;
            continue;
          case 4:
            num3 = currentRow + nextRowCount;
            break;
          default:
            goto label_9;
        }
        nextRowToTest = num3;
        num1 = 35862299;
      }
label_9:
      return nextRowToTest;
    }

    private bool IsCellEmptyAndInBounds(BoardCell[,] boardCells, Cell cell)
    {
label_1:
      int num1 = -383149131;
      bool flag;
      while (true)
      {
        uint num2;
        int num3;
        switch ((num2 = (uint) (num1 ^ -573322328)) % 5U)
        {
          case 1:
            if (this.IsCellInBounds(cell))
            {
              num1 = (int) num2 * -779475865 ^ -631964820;
              continue;
            }
            num3 = 0;
            break;
          case 2:
            goto label_1;
          case 3:
            num3 = boardCells[cell.Row, cell.Column].IsEmpty() ? 1 : 0;
            break;
          case 4:
            num1 = (int) num2 * 352694863 ^ -1575166469;
            continue;
          default:
            goto label_9;
        }
        flag = num3 != 0;
        num1 = -1662583893;
      }
label_9:
      return flag;
    }

    private void AddPositionsIfCanKillEnemy(BoardCell[,] chessboard, Cell currentCell)
    {
      int nextRowToTest = this.GetNextRowToTest(1, currentCell.Row);
      int collumn = currentCell.Column - 1;
label_1:
      int num1 = 1724207394;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 492370247)) % 4U)
        {
          case 0:
            this.AddIfEnemyExistAndIfInBounds(chessboard, nextRowToTest, collumn);
            num1 = (int) num2 * 2140963992 ^ -1656934471;
            continue;
          case 1:
            this.AddIfEnemyExistAndIfInBounds(chessboard, nextRowToTest, collumn);
            collumn = currentCell.Column + 1;
            num1 = (int) num2 * 978750617 ^ -1378915706;
            continue;
          case 2:
            goto label_3;
          case 3:
            goto label_1;
          default:
            goto label_6;
        }
      }
label_3:
      return;
label_6:;
    }

    private void AddIfEnemyExistAndIfInBounds(BoardCell[,] board, int row, int collumn)
    {
label_1:
      int num1 = -1976405102;
      while (true)
      {
        uint num2;
        Cell cell;
        bool flag1;
        bool flag2;
        int num3;
        switch ((num2 = (uint) (num1 ^ -1988975263)) % 9U)
        {
          case 0:
            int num4 = !flag2 ? 590588708 : (num4 = 238615874);
            num1 = num4 ^ (int) num2 * -1417275873;
            continue;
          case 1:
            int num5 = !flag1 ? -1150116361 : (num5 = -787413347);
            num1 = num5 ^ (int) num2 * -908147152;
            continue;
          case 2:
            cell = new Cell(row, collumn);
            flag1 = !this.IsCellInBounds(cell);
            num1 = (int) num2 * 1657674065 ^ -1720080550;
            continue;
          case 3:
            this.acceptableCells.Add(cell);
            num1 = (int) num2 * -1574474985 ^ 1721875435;
            continue;
          case 4:
            goto label_3;
          case 5:
            if (board[row, collumn].IsEmpty())
            {
              num3 = 0;
              break;
            }
            num1 = -834754476;
            continue;
          case 6:
            num3 = board[row, collumn].Chessman.Color != this.Color ? 1 : 0;
            break;
          case 7:
            num1 = (int) num2 * 1277016882 ^ -1725530955;
            continue;
          case 8:
            goto label_1;
          default:
            goto label_14;
        }
        flag2 = num3 != 0;
        num1 = -414056874;
      }
label_3:
      return;
label_14:;
    }
  }
}
