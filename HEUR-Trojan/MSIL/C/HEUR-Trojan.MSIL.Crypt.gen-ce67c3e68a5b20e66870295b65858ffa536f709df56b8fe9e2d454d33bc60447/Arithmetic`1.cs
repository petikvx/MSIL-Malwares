// Decompiled with JetBrains decompiler
// Type: GenericMath.Arithmetic`1
// Assembly: NDp6, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 1E52A124-4038-410B-8375-93D4A037FA1F
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.Crypt.gen-ce67c3e68a5b20e66870295b65858ffa536f709df56b8fe9e2d454d33bc60447.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Runtime.CompilerServices;

namespace GenericMath
{
  public struct Arithmetic<T>
  {
    public static Func<T, T> UnaryPlus;
    public static Func<T, T> UnaryMinus;
    public static Func<T, T, T> Add;
    public static Func<T, T, T> Subtract;
    public static Func<T, T, T> Multiply;
    public static Func<T, T, T> Divide;
    public static Func<T, T, T> IntegerDivide;
    public static Func<T, T, T> Modulus;
    public static Func<T, T, T> Power;
    public static Func<T, T, bool> Equal;
    public static Func<T, T, bool> NotEqual;
    public static Func<T, T, bool> LessThan;
    public static Func<T, T, bool> LessThanEqual;
    public static Func<T, T, bool> MoreThan;
    public static Func<T, T, bool> MoreThanEqual;
    public T Value;

    public Arithmetic(T _Value)
      : this()
    {
      this.Value = _Value;
    }

    public static implicit operator Arithmetic<T>(T Value)
    {
      Arithmetic<T> arithmetic;
      arithmetic.Value = Value;
      return arithmetic;
    }

    public static implicit operator T(Arithmetic<T> obj) => obj.Value;

    public static Arithmetic<T> operator +(Arithmetic<T> V) => (Arithmetic<T>) Arithmetic<T>.UnaryPlus(V.Value);

    public static Arithmetic<T> operator -(Arithmetic<T> V) => (Arithmetic<T>) Arithmetic<T>.UnaryMinus(V.Value);

    public static Arithmetic<T> operator +(Arithmetic<T> L, Arithmetic<T> R) => (Arithmetic<T>) Arithmetic<T>.Add(L.Value, R.Value);

    public static Arithmetic<T> operator -(Arithmetic<T> L, Arithmetic<T> R) => (Arithmetic<T>) Arithmetic<T>.Subtract(L.Value, R.Value);

    public static Arithmetic<T> operator *(Arithmetic<T> L, Arithmetic<T> R) => (Arithmetic<T>) Arithmetic<T>.Multiply(L.Value, R.Value);

    public static Arithmetic<T> operator /(Arithmetic<T> L, Arithmetic<T> R) => (Arithmetic<T>) Arithmetic<T>.Divide(L.Value, R.Value);

    [SpecialName]
    public static Arithmetic<T> op_IntegerDivision(Arithmetic<T> L, Arithmetic<T> R) => (Arithmetic<T>) Arithmetic<T>.IntegerDivide(L.Value, R.Value);

    public static Arithmetic<T> operator %(Arithmetic<T> L, Arithmetic<T> R) => (Arithmetic<T>) Arithmetic<T>.Modulus(L.Value, R.Value);

    [SpecialName]
    public static Arithmetic<T> op_Exponent(Arithmetic<T> L, Arithmetic<T> R) => (Arithmetic<T>) Arithmetic<T>.Power(L.Value, R.Value);

    public static bool operator ==(Arithmetic<T> L, Arithmetic<T> R) => Arithmetic<T>.Equal(L.Value, R.Value);

    public static bool operator !=(Arithmetic<T> L, Arithmetic<T> R) => Arithmetic<T>.NotEqual(L.Value, R.Value);

    public static bool operator <(Arithmetic<T> L, Arithmetic<T> R) => Arithmetic<T>.LessThan(L.Value, R.Value);

    public static bool operator <=(Arithmetic<T> L, Arithmetic<T> R) => Arithmetic<T>.LessThanEqual(L.Value, R.Value);

    public static bool operator >(Arithmetic<T> L, Arithmetic<T> R) => Arithmetic<T>.MoreThan(L.Value, R.Value);

    public static bool operator >=(Arithmetic<T> L, Arithmetic<T> R) => Arithmetic<T>.MoreThanEqual(L.Value, R.Value);

    public _T ValueGet<_T>() => Conversions.ToGenericParameter<_T>((object) this.Value);

    public void ValueSet<_T>(_T V) => this.Value = Conversions.ToGenericParameter<T>((object) V);
  }
}
