// Decompiled with JetBrains decompiler
// Type: TinHatURandom
// Assembly: wacYTAgLgQAjexermaa, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8B2A0664-5AE5-48FF-9B05-FC8D65B8BF2C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-31211fd1239d9e0de50a1af9ad1e71a55be0dac1e55e06444d2537caa96bd0c6.exe

using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Digests;
using Org.BouncyCastle.Crypto.Prng;
using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Threading;

public sealed class TinHatURandom : RandomNumberGenerator
{
  private const int TrueInt = 1;
  private const int FalseInt = 0;
  private const int RESEED_LOCKED = 1;
  private const int RESEED_UNLOCKED = 0;
  private const int MaxBytesPerSeedSoft = 65536;
  private const int MaxStateCounterHard = 1048576;
  private int disposed;
  private static TinHatURandom _StaticInstance = new TinHatURandom(TinHatRandom.StaticInstance);
  private EventHandler TinHatRandom_EntropyIncreased_Handler;
  private DigestRandomGenerator myPrng;
  private TinHatRandom myTinHatRandom;
  private bool myTinHatRandom_IsMineExclusively;
  private object stateCounterLockObj = new object();
  private int reseedLockInt;
  private int digestSize;
  private int stateCounter = 1048576;
  public int SeedSize;

  public static TinHatURandom StaticInstance => TinHatURandom._StaticInstance;

  public TinHatURandom()
  {
    this.myTinHatRandom = new TinHatRandom();
    this.myTinHatRandom_IsMineExclusively = true;
    IDigest idigest = (IDigest) new Sha256Digest();
    this.myPrng = new DigestRandomGenerator(idigest);
    this.digestSize = idigest.GetDigestSize();
    this.SeedSize = this.digestSize;
    this.TinHatRandom_EntropyIncreased_Handler = new EventHandler(this.LogAddGroupset_Headline);
    this.myTinHatRandom.EntropyIncreased += this.TinHatRandom_EntropyIncreased_Handler;
    this.LoadPluginget_Syntaxget_Syntax();
  }

  public TinHatURandom(IDigest digest)
  {
    this.myTinHatRandom = new TinHatRandom();
    this.myTinHatRandom_IsMineExclusively = true;
    this.myPrng = new DigestRandomGenerator(digest);
    this.digestSize = digest.GetDigestSize();
    this.SeedSize = this.digestSize;
    this.TinHatRandom_EntropyIncreased_Handler = new EventHandler(this.LogAddGroupset_Headline);
    this.myTinHatRandom.EntropyIncreased += this.TinHatRandom_EntropyIncreased_Handler;
    this.LoadPluginget_Syntaxget_Syntax();
  }

  public TinHatURandom(List<EntropyHasher> EntropyHashers, IDigest digest)
  {
    this.myTinHatRandom = new TinHatRandom(EntropyHashers);
    this.myTinHatRandom_IsMineExclusively = true;
    this.myPrng = new DigestRandomGenerator(digest);
    this.digestSize = digest.GetDigestSize();
    this.SeedSize = this.digestSize;
    this.TinHatRandom_EntropyIncreased_Handler = new EventHandler(this.LogAddGroupset_Headline);
    this.myTinHatRandom.EntropyIncreased += this.TinHatRandom_EntropyIncreased_Handler;
    this.LoadPluginget_Syntaxget_Syntax();
  }

  public TinHatURandom(TinHatRandom myTinHatRandom)
  {
    this.myTinHatRandom = myTinHatRandom;
    this.myTinHatRandom_IsMineExclusively = false;
    IDigest idigest = (IDigest) new Sha256Digest();
    this.myPrng = new DigestRandomGenerator(idigest);
    this.digestSize = idigest.GetDigestSize();
    this.SeedSize = this.digestSize;
    this.TinHatRandom_EntropyIncreased_Handler = new EventHandler(this.LogAddGroupset_Headline);
    this.myTinHatRandom.EntropyIncreased += this.TinHatRandom_EntropyIncreased_Handler;
    this.LoadPluginget_Syntaxget_Syntax();
  }

  public TinHatURandom(TinHatRandom myTinHatRandom, IDigest digest)
  {
    this.myTinHatRandom = myTinHatRandom;
    this.myTinHatRandom_IsMineExclusively = false;
    this.myPrng = new DigestRandomGenerator(digest);
    this.digestSize = digest.GetDigestSize();
    this.SeedSize = this.digestSize;
    this.TinHatRandom_EntropyIncreased_Handler = new EventHandler(this.LogAddGroupset_Headline);
    this.myTinHatRandom.EntropyIncreased += this.TinHatRandom_EntropyIncreased_Handler;
    this.LoadPluginget_Syntaxget_Syntax();
  }

  private void LogAddGroupset_Headline(object sender, EventArgs e) => this.LoadPluginget_Syntaxget_Syntax();

  public override void GetBytes(byte[] data)
  {
    if (data == null)
      throw new ArgumentNullException(nameof (data));
    if (data.Length == 0)
      return;
    lock (this.stateCounterLockObj)
    {
      int num = this.stateCounter + 1 + data.Length / this.digestSize;
      if (num > 1048576)
        this.LoadPluginget_Syntaxget_Syntax();
      else if (num > 65536 && Interlocked.Exchange(ref this.reseedLockInt, 1) == 0)
        ThreadPool.QueueUserWorkItem(new WaitCallback(this.set_DirectoryLogStart));
      this.stateCounter += 1 + data.Length / this.digestSize;
      this.myPrng.NextBytes(data);
    }
  }

  public override void GetNonZeroBytes(byte[] data)
  {
    if (data == null)
      throw new ArgumentNullException(nameof (data));
    if (data.Length == 0)
      return;
    int index1 = 0;
label_4:
    byte[] data1 = new byte[(int) (1.05 * (double) (data.Length - index1))];
    this.GetBytes(data1);
    for (int index2 = 0; index2 < data1.Length; ++index2)
    {
      if (data1[index2] != (byte) 0)
      {
        data[index1] = data1[index2];
        ++index1;
        if (index1 == data.Length)
        {
          Array.Clear((Array) data1, 0, data1.Length);
          return;
        }
      }
    }
    goto label_4;
  }

  private void set_DirectoryLogStart(object state) => this.LoadPluginget_Syntaxget_Syntax();

  private void LoadPluginget_Syntaxget_Syntax()
  {
    if (this.disposed == 1)
      return;
    try
    {
      byte[] data = new byte[this.SeedSize];
      this.myTinHatRandom.GetBytes(data);
      lock (this.stateCounterLockObj)
      {
        this.myPrng.AddSeedMaterial(data);
        this.stateCounter = 0;
        this.reseedLockInt = 0;
      }
    }
    catch
    {
      if (this.disposed != 0)
        return;
      throw;
    }
  }

  protected override void Dispose(bool disposing)
  {
    if (Interlocked.Exchange(ref this.disposed, 1) == 1)
      return;
    if (this.myTinHatRandom_IsMineExclusively)
      this.myTinHatRandom.Dispose();
    else
      this.myTinHatRandom.EntropyIncreased -= this.TinHatRandom_EntropyIncreased_Handler;
    base.Dispose(disposing);
  }

  ~TinHatURandom() => this.Dispose(false);
}
