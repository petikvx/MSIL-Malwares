// Decompiled with JetBrains decompiler
// Type: s980438210111899.s900448252129696
// Assembly: s968508024776124, Version=2.0.47.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: E3596912-35E7-405B-A05A-F5F12AB5E292
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.PowerShell.gen-b1729c7ae8423cc844b16aa10ca8ddd2b2331adbfb6646d80d73381fbc73a109.exe

using s065175910567653;
using s719272214711671;
using System;
using System.Runtime.CompilerServices;

namespace s980438210111899
{
  internal class s900448252129696<K, T>
    where K : IEquatable<K>
    where T : class
  {
    private const ushort s423230444063577 = 65535;
    private const int s214887206782444 = 13;
    private const int s995141024182674 = 8191;
    private const int s798978620873424 = 7;
    private ushort[] s947519820469302;
    private s900448252129696<K, T>.s328498310551794[] s795772480990493;
    private ushort s662244756044289;
    private int s754248883722529;
    private byte s258848445172295;
    private ushort s347816219403251;

    public s900448252129696(int maxEntries)
    {
      if (maxEntries > 65534)
        maxEntries = 65534;
      this.m_hashTable = new ushort[maxEntries * 2 + 1];
      this.m_entries = new s900448252129696<K, T>.s328498310551794[maxEntries];
      this.m_curAge = (byte) 2;
      this.Clear();
    }

    public T s742401936510528(K s032931135936685)
    {
      T obj;
      this.TryGet(s032931135936685, ref obj);
      return obj;
    }

    public bool s153613180684606(K s568150465494123, out T s240089872244748)
    {
      int hashCode = s568150465494123.GetHashCode();
      int next = (int) this.m_hashTable[(int) ((uint) hashCode % (uint) this.m_hashTable.Length)];
      int num = (hashCode ^ hashCode >> 16) & 8191;
      s900448252129696<K, T>.s328498310551794 entry;
      for (; next != (int) ushort.MaxValue; next = (int) entry.Next)
      {
        entry = this.m_entries[next];
        if (entry.Hash == num && entry.Key.Equals(s568150465494123))
        {
          if (entry.s464394924195323 != (int) this.m_curAge)
            this.UpdateAge(ref this.m_entries[next]);
          s240089872244748 = entry.Value;
          return true;
        }
      }
      s240089872244748 = default (T);
      return false;
    }

    public void s218150251565465(K s125081187281739, T s864636446098805)
    {
      int hashCode = s125081187281739.GetHashCode();
      uint index = (uint) hashCode % (uint) this.m_hashTable.Length;
      int num = (hashCode ^ hashCode >> 16) & 8191;
      ushort freeEntry = this.GetFreeEntry();
      this.m_entries[(int) freeEntry] = new s900448252129696<K, T>.s328498310551794()
      {
        s693794942628943 = num,
        Key = s125081187281739,
        Value = s864636446098805,
        Next = this.m_hashTable[(int) index]
      };
      this.UpdateAge(ref this.m_entries[(int) freeEntry]);
      this.m_hashTable[(int) index] = freeEntry;
    }

    public void s617912726742504()
    {
      for (int index = 0; index < this.m_hashTable.Length; ++index)
        this.m_hashTable[index] = ushort.MaxValue;
      for (int index = 0; index < this.m_entries.Length; ++index)
      {
        this.m_entries[index].Key = default (K);
        if ((object) this.m_entries[index].Value != null && this.m_entries[index].Value is IDisposable disposable)
          disposable.Dispose();
        this.m_entries[index].Value = default (T);
      }
      this.m_freeEntries = (ushort) this.m_entries.Length;
    }

    public int s225918559417718 => this.m_entries.Length;

    private void s078874765198342(
      ref s900448252129696<K, T>.s328498310551794 s839321323790140)
    {
      s839321323790140.s464394924195323 = (int) this.m_curAge;
      ++this.m_entriesInCurAge;
      if ((int) this.m_entriesInCurAge * 2 < this.m_entries.Length)
        return;
      this.m_entriesInCurAge = (ushort) 0;
      this.m_curAge = (byte) ((int) this.m_curAge + 1 & 7);
    }

    private ushort s786259141110212()
    {
      if ((ushort) 0 < this.m_freeEntries)
        return --this.m_freeEntries;
      int num = 0;
      while (true)
      {
        do
        {
          ushort next = this.m_hashTable[this.m_freeScan];
          ushort index = ushort.MaxValue;
          for (; next != ushort.MaxValue; next = this.m_entries[(int) next].Next)
          {
            if (((int) this.m_curAge - this.m_entries[(int) next].s464394924195323 & 7) > 1 || num >= 5)
            {
              if (index == ushort.MaxValue)
                this.m_hashTable[this.m_freeScan] = this.m_entries[(int) next].Next;
              else
                this.m_entries[(int) index].Next = this.m_entries[(int) next].Next;
              return next;
            }
            ++num;
            index = next;
          }
          ++this.m_freeScan;
        }
        while (this.m_freeScan < this.m_hashTable.Length);
        this.m_freeScan = 0;
      }
    }

    private struct s328498310551794
    {
      public T s958377245240637;
      public ushort s931674083475463;
      private ushort s107301281794657;
      internal uint s860496709350033;

      public int s693794942628943
      {
        [SpecialName] get => (int) ((s900448252129696<T0, T1>.s328498310551794) this).HashAge & 8191;
        set => this.HashAge = (ushort) (value | (int) this.HashAge & -8192);
      }

      public int s464394924195323
      {
        get => (int) ((uint) this.HashAge >> 13);
        set => this.HashAge = (ushort) (value << 13 | (int) this.HashAge & 8191);
      }

      internal s328498310551794(string[] names)
      {
        // ISSUE: explicit constructor call
        ((s293547439506271) ref this).\u002Ector();
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        (^(s752892378058130.s399364223577823&) ref this).s400203591150675 = new string[names.Length - 1];
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        Array.Copy((Array) names, 1, (Array) (^(s752892378058130.s399364223577823&) ref this).s400203591150675, 0, (^(s752892378058130.s399364223577823&) ref this).s400203591150675.Length);
      }
    }
  }
}
