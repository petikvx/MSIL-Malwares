// Decompiled with JetBrains decompiler
// Type: insomnia.Class38
// Assembly: insomnia, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 848092D5-5192-4B4F-B8F0-07AD40D025FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Blocker.exyo-803dbe7f976d166aef05102db1219065c8b0bb78e3cf85095fc361f891e6a4e0.exe

using System;
using System.Net;
using System.Net.Sockets;
using System.Text;

namespace insomnia
{
  internal class Class38
  {
    private static string[] Field1 = new string[10]
    {
      "Operation completed successfully.",
      "General SOCKS server failure.",
      "Connection not allowed by ruleset.",
      "Network unreachable.",
      "Host unreachable.",
      "Connection refused.",
      "TTL expired.",
      "Command not supported.",
      "Address type not supported.",
      "Unknown error."
    };

    private Class38()
    {
    }

    public static Socket Method1(
      string A_0,
      int A_1,
      string A_2,
      ushort A_3,
      string A_4,
      string A_5)
    {
      IPAddress ipAddress = (IPAddress) null;
      byte[] buffer1 = new byte[257];
      byte[] buffer2 = new byte[257];
      IPAddress address;
      try
      {
        address = IPAddress.Parse(A_0);
      }
      catch (FormatException ex)
      {
        address = Dns.GetHostByAddress(A_0).AddressList[0];
      }
      try
      {
        ipAddress = IPAddress.Parse(A_2);
      }
      catch (FormatException ex)
      {
      }
      IPEndPoint remoteEP = new IPEndPoint(address, A_1);
      Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
      socket.Connect((EndPoint) remoteEP);
      ushort num1 = 0;
      byte[] numArray1 = buffer1;
      int index1 = (int) num1;
      ushort num2 = (ushort) (index1 + 1);
      numArray1[index1] = (byte) 5;
      byte[] numArray2 = buffer1;
      int index2 = (int) num2;
      ushort num3 = (ushort) (index2 + 1);
      numArray2[index2] = (byte) 2;
      byte[] numArray3 = buffer1;
      int index3 = (int) num3;
      ushort num4 = (ushort) (index3 + 1);
      numArray3[index3] = (byte) 0;
      byte[] numArray4 = buffer1;
      int index4 = (int) num4;
      ushort size1 = (ushort) (index4 + 1);
      numArray4[index4] = (byte) 2;
      socket.Send(buffer1, (int) size1, SocketFlags.None);
      if (socket.Receive(buffer2, 2, SocketFlags.None) != 2)
        throw new ApplicationException1("Bad response received from proxy server.");
      if (buffer2[1] == byte.MaxValue)
      {
        socket.Close();
        throw new ApplicationException1("None of the authentication method was accepted by proxy server.");
      }
      ushort num5 = 0;
      byte[] numArray5 = buffer1;
      int index5 = (int) num5;
      ushort num6 = (ushort) (index5 + 1);
      numArray5[index5] = (byte) 5;
      byte[] numArray6 = buffer1;
      int index6 = (int) num6;
      ushort index7 = (ushort) (index6 + 1);
      int length1 = (int) (byte) A_4.Length;
      numArray6[index6] = (byte) length1;
      byte[] bytes1 = Encoding.Default.GetBytes(A_4);
      bytes1.CopyTo((Array) buffer1, (int) index7);
      ushort num7 = (ushort) ((uint) index7 + (uint) (ushort) bytes1.Length);
      byte[] numArray7 = buffer1;
      int index8 = (int) num7;
      ushort index9 = (ushort) (index8 + 1);
      int length2 = (int) (byte) A_5.Length;
      numArray7[index8] = (byte) length2;
      byte[] bytes2 = Encoding.Default.GetBytes(A_5);
      bytes2.CopyTo((Array) buffer1, (int) index9);
      ushort size2 = (ushort) ((uint) index9 + (uint) (ushort) bytes2.Length);
      socket.Send(buffer1, (int) size2, SocketFlags.None);
      if (socket.Receive(buffer2, 2, SocketFlags.None) != 2)
        throw new ApplicationException1("Bad response received from proxy server.");
      if (buffer2[1] != (byte) 0)
        throw new ApplicationException1("Bad Usernaem/Password.");
      ushort num8 = 0;
      byte[] numArray8 = buffer1;
      int index10 = (int) num8;
      ushort num9 = (ushort) (index10 + 1);
      numArray8[index10] = (byte) 5;
      byte[] numArray9 = buffer1;
      int index11 = (int) num9;
      ushort num10 = (ushort) (index11 + 1);
      numArray9[index11] = (byte) 1;
      byte[] numArray10 = buffer1;
      int index12 = (int) num10;
      ushort size3 = (ushort) (index12 + 1);
      numArray10[index12] = (byte) 0;
      if (ipAddress == null)
      {
        byte[] numArray11 = buffer1;
        int index13 = (int) size3;
        ushort num11 = (ushort) (index13 + 1);
        numArray11[index13] = (byte) 3;
        byte[] numArray12 = buffer1;
        int index14 = (int) num11;
        ushort index15 = (ushort) (index14 + 1);
        int num12 = (int) Convert.ToByte(A_2.Length);
        numArray12[index14] = (byte) num12;
        byte[] bytes3 = Encoding.Default.GetBytes(A_2);
        bytes3.CopyTo((Array) buffer1, (int) index15);
        size3 = (ushort) ((uint) index15 + (uint) (ushort) bytes3.Length);
      }
      else
        goto label_18;
label_16:
      byte[] bytes4 = BitConverter.GetBytes(A_3);
      for (int index16 = bytes4.Length - 1; index16 >= 0; --index16)
        buffer1[(int) size3++] = bytes4[index16];
      socket.Send(buffer1, (int) size3, SocketFlags.None);
      socket.Receive(buffer2);
      if (buffer2[1] != (byte) 0)
        throw new ApplicationException1(Class38.Field1[(int) buffer2[1]]);
      return socket;
label_18:
      switch (ipAddress.AddressFamily)
      {
        case AddressFamily.InterNetwork:
          byte[] numArray13 = buffer1;
          int index17 = (int) size3;
          ushort index18 = (ushort) (index17 + 1);
          numArray13[index17] = (byte) 1;
          byte[] addressBytes1 = ipAddress.GetAddressBytes();
          addressBytes1.CopyTo((Array) buffer1, (int) index18);
          size3 = (ushort) ((uint) index18 + (uint) (ushort) addressBytes1.Length);
          goto label_16;
        case AddressFamily.InterNetworkV6:
          byte[] numArray14 = buffer1;
          int index19 = (int) size3;
          ushort index20 = (ushort) (index19 + 1);
          numArray14[index19] = (byte) 4;
          byte[] addressBytes2 = ipAddress.GetAddressBytes();
          addressBytes2.CopyTo((Array) buffer1, (int) index20);
          size3 = (ushort) ((uint) index20 + (uint) (ushort) addressBytes2.Length);
          goto label_16;
        default:
          goto label_16;
      }
    }
  }
}
