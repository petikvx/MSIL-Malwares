// Decompiled with JetBrains decompiler
// Type: ChessBoard.Chessmens.BaseChessman
// Assembly: IArraySortHel, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B08900B5-C53F-4995-B311-D7E8DC4113C6
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcrg-fe8d5c5d892bac95b940a26cf50aacf262dd40e3394fc1ba8444ab3842a16fda.exe

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace ChessBoard.Chessmens
{
  public class BaseChessman
  {
    protected Direction[] AnyDirections;

    public Colorz Color { get; set; }

    public virtual ChessmenType Type { get; set; }

    public bool Moved { get; set; }

    public BaseChessman()
    {
      Direction[] directionArray = new Direction[8];
      Direction direction1 = new Direction();
      direction1.Row = -1;
      direction1.Column = -1;
      directionArray[0] = direction1;
      Direction direction2 = new Direction();
      direction2.Row = -1;
      direction2.Column = 1;
      directionArray[1] = direction2;
      Direction direction3 = new Direction();
      direction3.Row = 1;
      direction3.Column = -1;
      directionArray[2] = direction3;
      Direction direction4 = new Direction();
      direction4.Row = 1;
      direction4.Column = 1;
      directionArray[3] = direction4;
      Direction direction5 = new Direction();
      direction5.Row = -1;
      direction5.Column = 0;
      directionArray[4] = direction5;
      Direction direction6 = new Direction();
      direction6.Row = 1;
      direction6.Column = 0;
      directionArray[5] = direction6;
      Direction direction7 = new Direction();
      direction7.Row = 0;
      direction7.Column = -1;
      directionArray[6] = direction7;
      Direction direction8 = new Direction();
      direction8.Row = 0;
      direction8.Column = 1;
      directionArray[7] = direction8;
      this.AnyDirections = directionArray;
      // ISSUE: explicit constructor call
      base.\u002Ector();
label_1:
      int num1 = -301388387;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -631626929)) % 4U)
        {
          case 0:
            goto label_3;
          case 1:
            num1 = (int) num2 * 517000566 ^ 1385106253;
            continue;
          case 2:
            num1 = (int) num2 * 694244939 ^ -908367164;
            continue;
          case 3:
            goto label_1;
          default:
            goto label_6;
        }
      }
label_3:
      return;
label_6:;
    }

    public BaseChessman(Colorz color)
    {
      Direction[] directionArray = new Direction[8];
      Direction direction1 = new Direction();
      direction1.Row = -1;
      direction1.Column = -1;
      directionArray[0] = direction1;
      Direction direction2 = new Direction();
      direction2.Row = -1;
      direction2.Column = 1;
      directionArray[1] = direction2;
      Direction direction3 = new Direction();
      direction3.Row = 1;
      direction3.Column = -1;
      directionArray[2] = direction3;
      Direction direction4 = new Direction();
      direction4.Row = 1;
      direction4.Column = 1;
      directionArray[3] = direction4;
      Direction direction5 = new Direction();
      direction5.Row = -1;
      direction5.Column = 0;
      directionArray[4] = direction5;
      Direction direction6 = new Direction();
      direction6.Row = 1;
      direction6.Column = 0;
      directionArray[5] = direction6;
      Direction direction7 = new Direction();
      direction7.Row = 0;
      direction7.Column = -1;
      directionArray[6] = direction7;
      Direction direction8 = new Direction();
      direction8.Row = 0;
      direction8.Column = 1;
      directionArray[7] = direction8;
      this.AnyDirections = directionArray;
      // ISSUE: explicit constructor call
      base.\u002Ector();
label_1:
      int num1 = -998706609;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -1403485902)) % 5U)
        {
          case 0:
            num1 = (int) num2 * 893290816 ^ 249173319;
            continue;
          case 1:
            num1 = (int) num2 * -28020611 ^ 1449269719;
            continue;
          case 2:
            goto label_3;
          case 3:
            goto label_1;
          case 4:
            this.Color = color;
            num1 = (int) num2 * -1203375161 ^ -1832080563;
            continue;
          default:
            goto label_7;
        }
      }
label_3:
      return;
label_7:;
    }

    public override bool Equals(object obj)
    {
label_1:
      int num1 = -1437723185;
      bool flag;
      while (true)
      {
        uint num2;
        BaseChessman baseChessman;
        int num3;
        switch ((num2 = (uint) (num1 ^ -1062406164)) % 9U)
        {
          case 0:
            num3 = baseChessman.Moved == this.Moved ? 1 : 0;
            goto label_13;
          case 2:
            flag = false;
            num1 = (int) num2 * -1058850173 ^ 199259345;
            continue;
          case 3:
            goto label_1;
          case 4:
            baseChessman = (BaseChessman) obj;
            num1 = -233799935;
            continue;
          case 5:
            if (baseChessman.Color == this.Color)
            {
              num1 = (int) num2 * 2003712826 ^ 265911092;
              continue;
            }
            break;
          case 6:
            num1 = (int) num2 * 2012650622 ^ 438531841;
            continue;
          case 7:
            if (baseChessman.Type == this.Type)
            {
              num1 = (int) num2 * 200902679 ^ 573671507;
              continue;
            }
            break;
          case 8:
            int num4 = obj == null ? -1408288925 : (num4 = -1277147859);
            num1 = num4 ^ (int) num2 * -934316226;
            continue;
          default:
            goto label_14;
        }
        num3 = 0;
label_13:
        flag = num3 != 0;
        num1 = -175587011;
      }
label_14:
      return flag;
    }

    public override int GetHashCode()
    {
label_1:
      int num1 = 1245723205;
      int num2;
      int hashCode;
      while (true)
      {
        uint num3;
        switch ((num3 = (uint) (num1 ^ 1704160647)) % 5U)
        {
          case 0:
            goto label_1;
          case 2:
            num1 = (int) num3 * 462508684 ^ 797700254;
            continue;
          case 3:
            hashCode = num2;
            num1 = (int) num3 * 609925201 ^ -43710347;
            continue;
          case 4:
            num2 = (int) ((int) (17 * 23 + this.Color) * 23 + this.Type);
            num1 = (int) num3 * -1315285123 ^ 2041992968;
            continue;
          default:
            goto label_6;
        }
      }
label_6:
      return hashCode;
    }

    public virtual List<Cell> GetAcceptableCells(
      BoardCell[,] boardCells,
      Cell currentCell,
      bool needToCheckShah = true)
    {
      throw BaseChessman.\u202B⁬‏‏⁬‬⁯⁯⁪⁮‫‪‭​⁫⁪‪⁫⁯⁫‪⁪‍⁪‌​‮​‮‭​​⁯⁭⁭‍‍​‫⁪‮();
    }

    protected bool IsCellInBounds(Cell cell)
    {
label_1:
      int num1 = 2075755066;
      bool flag;
      while (true)
      {
        uint num2;
        int num3;
        switch ((num2 = (uint) (num1 ^ 1557757346)) % 7U)
        {
          case 0:
            num3 = cell.Column <= 7 ? 1 : 0;
            goto label_8;
          case 1:
            if (cell.Column >= 0)
            {
              num1 = (int) num2 * 1826830728 ^ 1517719302;
              continue;
            }
            break;
          case 3:
            if (cell.Row >= 0)
            {
              num1 = (int) num2 * 836028260 ^ -56295800;
              continue;
            }
            break;
          case 4:
            num1 = (int) num2 * 457851827 ^ 1019544233;
            continue;
          case 5:
            if (cell.Row <= 7)
            {
              num1 = (int) num2 * -436352681 ^ 1898250125;
              continue;
            }
            break;
          case 6:
            goto label_1;
          default:
            goto label_13;
        }
        num3 = 0;
label_8:
        flag = num3 != 0;
        num1 = 2091682035;
      }
label_13:
      return flag;
    }

    protected List<Cell> GetAcceptableCellsForDirections(
      BoardCell[,] boardCells,
      Direction[] possibleDirections,
      Cell currentCell,
      int stepsCount = 8)
    {
      List<Cell> cellList = new List<Cell>();
label_1:
      int num1 = -1635795247;
      bool flag1;
      List<Cell> cellsForDirections;
      bool flag2;
      int movementSteps;
      Cell cell;
      BaseChessman chessman;
      bool flag3;
      bool flag4;
      int index;
      Direction[] directionArray;
      BoardCell boardCell;
      Direction direction;
      int row;
      int column;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -2069942438)) % 30U)
        {
          case 0:
            int num3;
            num1 = num3 = index < directionArray.Length ? -690662519 : (num3 = -1732110126);
            continue;
          case 1:
            num1 = (int) num2 * 755910526 ^ -985172413;
            continue;
          case 2:
            chessman = boardCell.Chessman;
            num1 = (int) num2 * 125264894 ^ -628601935;
            continue;
          case 3:
            flag2 = movementSteps < stepsCount;
            num1 = -440977665;
            continue;
          case 4:
            boardCell = boardCells[row, column];
            num1 = -886741564;
            continue;
          case 5:
            cell = new Cell(boardCell.Row, boardCell.Column);
            num1 = (int) num2 * -96658243 ^ 1143990459;
            continue;
          case 6:
            int num4 = !flag4 ? 299095794 : (num4 = 231042966);
            num1 = num4 ^ (int) num2 * -1650048228;
            continue;
          case 7:
            num1 = (int) num2 * -141175587 ^ 1890544423;
            continue;
          case 8:
            int num5 = !flag1 ? -1550991445 : (num5 = -1479527873);
            num1 = num5 ^ (int) num2 * -98205148;
            continue;
          case 9:
            num1 = (int) num2 * 666585846 ^ -1042917392;
            continue;
          case 10:
            int num6 = flag3 ? -752665911 : (num6 = -1670614109);
            num1 = num6 ^ (int) num2 * -1559962969;
            continue;
          case 11:
            direction = directionArray[index];
            num1 = -837702369;
            continue;
          case 12:
            cellsForDirections = cellList;
            num1 = (int) num2 * -651926463 ^ 462535794;
            continue;
          case 13:
            cellList.Add(cell);
            num1 = (int) num2 * 530879276 ^ 290649819;
            continue;
          case 14:
            num1 = -498507367;
            continue;
          case 15:
            ++movementSteps;
            num1 = (int) num2 * -1051788802 ^ 5425101;
            continue;
          case 16:
            goto label_1;
          case 17:
            flag3 = chessman.Color != this.Color;
            num1 = (int) num2 * -2039234269 ^ 1764686079;
            continue;
          case 18:
          case 29:
            ++index;
            num1 = -1709055460;
            continue;
          case 19:
            row = currentCell.Row + this.GetStepsCoutForMovement(direction.Row, movementSteps);
            column = currentCell.Column + this.GetStepsCoutForMovement(direction.Column, movementSteps);
            flag4 = !this.IsCellInBounds(new Cell(row, column));
            num1 = (int) num2 * -804072257 ^ -1133559909;
            continue;
          case 20:
            flag1 = chessman != null;
            num1 = (int) num2 * 631991016 ^ 307984106;
            continue;
          case 21:
            cellList.Add(cell);
            num1 = -1312323431;
            continue;
          case 23:
            num1 = (int) num2 * -90572873 ^ -1810460060;
            continue;
          case 24:
            num1 = (int) num2 * 903527615 ^ 705018415;
            continue;
          case 25:
            movementSteps = 0;
            num1 = (int) num2 * 877502839 ^ -1375111919;
            continue;
          case 26:
            directionArray = possibleDirections;
            index = 0;
            num1 = (int) num2 * 836294927 ^ -1831961115;
            continue;
          case 27:
            int num7 = flag2 ? -1386209986 : (num7 = -190942178);
            num1 = num7 ^ (int) num2 * -1491890574;
            continue;
          case 28:
            num1 = (int) num2 * 1124659440 ^ -1186835676;
            continue;
          default:
            goto label_30;
        }
      }
label_30:
      return cellsForDirections;
    }

    protected void AdjustAcceptableCellsInCaseShah(
      BoardCell[,] boardCells,
      List<Cell> acceptableCells,
      Cell currentCell)
    {
label_1:
      int num1 = 1817673829;
      List<Cell> cellList;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 33866640)) % 3U)
        {
          case 1:
            cellList = new List<Cell>();
            num1 = (int) num2 * 607280594 ^ 1416189691;
            continue;
          case 2:
            goto label_1;
          default:
            goto label_4;
        }
      }
label_4:
      using (List<Cell>.Enumerator enumerator = acceptableCells.GetEnumerator())
      {
label_11:
        int num3 = enumerator.MoveNext() ? 194841361 : (num3 = 1981160617);
        Cell current;
        while (true)
        {
          uint num4;
          switch ((num4 = (uint) (num3 ^ 33866640)) % 6U)
          {
            case 0:
              goto label_11;
            case 1:
              int num5 = this.IsKingUnderShah(boardCells, current, currentCell) ? 1540539597 : (num5 = 1273865035);
              num3 = num5 ^ (int) num4 * -15370639;
              continue;
            case 2:
              cellList.Add(current);
              num3 = (int) num4 * 409249247 ^ -1989475610;
              continue;
            case 4:
              num3 = 194841361;
              continue;
            case 5:
              current = enumerator.Current;
              num3 = 252553253;
              continue;
            default:
              goto label_13;
          }
        }
      }
label_13:
      using (List<Cell>.Enumerator enumerator = cellList.GetEnumerator())
      {
label_19:
        int num6 = enumerator.MoveNext() ? 1063989703 : (num6 = 963276652);
        Cell current;
        while (true)
        {
          uint num7;
          switch ((num7 = (uint) (num6 ^ 33866640)) % 5U)
          {
            case 0:
              goto label_19;
            case 1:
              current = enumerator.Current;
              num6 = 1576191196;
              continue;
            case 2:
              num6 = 1063989703;
              continue;
            case 3:
              goto label_21;
            case 4:
              acceptableCells.Remove(current);
              num6 = (int) num7 * 1690419801 ^ -939959561;
              continue;
            default:
              goto label_17;
          }
        }
label_21:
        return;
label_17:;
      }
    }

    protected bool IsKingUnderShah(BoardCell[,] boardCells, Cell cellToCheck, Cell currentCell)
    {
label_1:
      int num1 = -847628741;
      BoardCell[,] copyOfBoardCells;
      bool flag;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -1774731596)) % 6U)
        {
          case 0:
            goto label_1;
          case 1:
            Cell kingCell = this.FindKingCell(copyOfBoardCells);
            flag = BaseChessman.IsCellUnderShah(copyOfBoardCells, kingCell, this.Color);
            num1 = (int) num2 * 1606961252 ^ 1001974260;
            continue;
          case 2:
            num1 = (int) num2 * -1729160099 ^ -404842949;
            continue;
          case 3:
            copyOfBoardCells = this.GetDeepCopyOfBoardCells(boardCells);
            num1 = (int) num2 * 433755573 ^ 916133457;
            continue;
          case 4:
            this.TestMoveChessman(copyOfBoardCells, currentCell, cellToCheck);
            num1 = (int) num2 * 1335838931 ^ 2109992617;
            continue;
          default:
            goto label_7;
        }
      }
label_7:
      return flag;
    }

    internal static bool IsCellUnderShah(BoardCell[,] boardCells, Cell cellToCheck, Colorz color)
    {
label_1:
      int num1 = -758004241;
      List<Cell> enemyAcceptableCells;
      bool flag;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -544750899)) % 4U)
        {
          case 0:
            goto label_1;
          case 2:
            enemyAcceptableCells = BaseChessman.FindEnemyAcceptableCells(boardCells, color);
            num1 = (int) num2 * -447608035 ^ 233846036;
            continue;
          case 3:
            flag = enemyAcceptableCells.Any<Cell>((Func<Cell, bool>) (enemyCell => enemyCell.Row == cellToCheck.Row && enemyCell.Column == cellToCheck.Column));
            num1 = (int) num2 * -2144198678 ^ 1793939530;
            continue;
          default:
            goto label_5;
        }
      }
label_5:
      return flag;
    }

    protected bool IfEmptyOrEnemy(BoardCell[,] boardCells, int testRow, int testColumn)
    {
label_1:
      int num1 = 1067186636;
      bool flag;
      while (true)
      {
        uint num2;
        int num3;
        switch ((num2 = (uint) (num1 ^ 1271715003)) % 5U)
        {
          case 0:
            goto label_1;
          case 1:
            num1 = (int) num2 * -1541800579 ^ -1662724995;
            continue;
          case 2:
            if (!boardCells[testRow, testColumn].IsEmpty())
            {
              num1 = (int) num2 * 1947459600 ^ -41613614;
              continue;
            }
            num3 = 1;
            break;
          case 3:
            num3 = boardCells[testRow, testColumn].Chessman.Color != this.Color ? 1 : 0;
            break;
          default:
            goto label_9;
        }
        flag = num3 != 0;
        num1 = 1374841439;
      }
label_9:
      return flag;
    }

    private Cell FindKingCell(BoardCell[,] boardCells)
    {
label_1:
      int num1 = -1505382064;
      Cell kingCell;
      while (true)
      {
        uint num2;
        int row;
        int column;
        bool flag1;
        bool flag2;
        bool flag3;
        BaseChessman chessman;
        int num3;
        switch ((num2 = (uint) (num1 ^ -828594351)) % 18U)
        {
          case 0:
            flag3 = row < 8;
            num1 = -732152817;
            continue;
          case 1:
            int num4 = !flag1 ? 48823000 : (num4 = 1639176913);
            num1 = num4 ^ (int) num2 * -1312483874;
            continue;
          case 2:
            kingCell = new Cell(row, column);
            num1 = (int) num2 * 901160747 ^ -1564603750;
            continue;
          case 3:
            num1 = -505695264;
            continue;
          case 4:
            flag2 = column < 8;
            num1 = -1119699726;
            continue;
          case 5:
            int num5 = !flag2 ? -412123414 : (num5 = -168432443);
            num1 = num5 ^ (int) num2 * 1317861969;
            continue;
          case 6:
            num1 = (int) num2 * -1813155914 ^ -869659651;
            continue;
          case 8:
            ++column;
            num1 = (int) num2 * 1854158861 ^ -322892831;
            continue;
          case 9:
            column = 0;
            num1 = (int) num2 * -941248190 ^ -209008963;
            continue;
          case 10:
            ++row;
            num1 = (int) num2 * -596942414 ^ 700254281;
            continue;
          case 11:
            row = 0;
            num1 = (int) num2 * -1715689037 ^ -1973871062;
            continue;
          case 12:
            num3 = chessman.Color == this.Color ? 1 : 0;
            break;
          case 13:
            goto label_1;
          case 14:
            int num6 = flag3 ? 340236742 : (num6 = 641019817);
            num1 = num6 ^ (int) num2 * 1452587889;
            continue;
          case 15:
            num1 = -828553127;
            continue;
          case 16:
            goto label_7;
          case 17:
            chessman = boardCells[row, column].Chessman;
            if (chessman is King)
            {
              num1 = -2123789981;
              continue;
            }
            num3 = 0;
            break;
          default:
            goto label_22;
        }
        flag1 = num3 != 0;
        num1 = -1349670170;
      }
label_7:
      throw BaseChessman.\u206C‬‎‍‎⁪‫‮‬⁮​‍‪⁭​⁫⁬⁬‬‪‭‫‫‏‪‮⁬‍‬⁬‮​‎‫⁮‌⁫‪‌‎‮(\u003CModule\u003E.\u206A⁪‍‌‪⁫‎⁮‫⁮⁭‎‍‌⁪⁪⁯⁫‪⁪‌‮‍⁬⁮‭​⁮⁭⁪⁮⁯​⁮⁭‬‫‎‫‏‮<string>(2944499542U));
label_22:
      return kingCell;
    }

    private static List<Cell> FindEnemyAcceptableCells(
      BoardCell[,] boardCells,
      Colorz color)
    {
label_1:
      int num1 = 527949564;
      List<Cell> enemyAcceptableCells;
      while (true)
      {
        uint num2;
        BaseChessman chessman;
        int column;
        int row;
        List<Cell> cellList;
        Cell currentCell;
        bool flag;
        int num3;
        switch ((num2 = (uint) (num1 ^ 1166241583)) % 22U)
        {
          case 0:
            cellList.AddRange((IEnumerable<Cell>) chessman.GetAcceptableCells(boardCells, currentCell, false));
            num1 = (int) num2 * 1408336866 ^ 1175244084;
            continue;
          case 1:
            enemyAcceptableCells = cellList;
            num1 = (int) num2 * 2132176758 ^ 624816985;
            continue;
          case 2:
            column = 0;
            num1 = 1241953390;
            continue;
          case 3:
            num1 = (int) num2 * 2087496681 ^ -1482167913;
            continue;
          case 4:
            chessman = boardCells[row, column].Chessman;
            num1 = (int) num2 * -1195189626 ^ -1163058573;
            continue;
          case 5:
            flag = column < 8;
            num1 = 1331334709;
            continue;
          case 7:
            if (chessman.Color != color)
            {
              num1 = (int) num2 * 312773772 ^ 1550485254;
              continue;
            }
            break;
          case 8:
            num1 = 1642247159;
            continue;
          case 9:
            num1 = (int) num2 * -466933257 ^ 537413305;
            continue;
          case 10:
            currentCell = new Cell(row, column);
            num1 = 1138970263;
            continue;
          case 11:
            cellList = new List<Cell>();
            row = 0;
            num1 = (int) num2 * 1932550807 ^ 869889364;
            continue;
          case 12:
            ++row;
            num1 = (int) num2 * -120662072 ^ 1755033228;
            continue;
          case 13:
            ++column;
            num1 = 571674814;
            continue;
          case 14:
            goto label_1;
          case 15:
            num1 = (int) num2 * -1819747234 ^ -2075563912;
            continue;
          case 16:
            num1 = (int) num2 * 46285881 ^ -2078323934;
            continue;
          case 17:
            num3 = chessman is King ? 1 : 0;
            goto label_24;
          case 18:
            if (chessman != null)
            {
              num1 = (int) num2 * -1491028993 ^ -1474758418;
              continue;
            }
            break;
          case 19:
            int num4;
            num1 = num4 = row < 8 ? 37630339 : (num4 = 1061580152);
            continue;
          case 20:
            int num5 = !flag ? -1264083633 : (num5 = -35890037);
            num1 = num5 ^ (int) num2 * -1334354897;
            continue;
          case 21:
            num1 = (int) num2 * -1698038153 ^ -1116506765;
            continue;
          default:
            goto label_27;
        }
        num3 = 1;
label_24:
        int num6;
        num1 = num6 = num3 != 0 ? 889452472 : (num6 = 1146235725);
      }
label_27:
      return enemyAcceptableCells;
    }

    private void TestMoveChessman(BoardCell[,] chessboard, Cell oldCell, Cell newCell)
    {
      chessboard[newCell.Row, newCell.Column].Chessman = chessboard[oldCell.Row, oldCell.Column].Chessman;
label_1:
      int num1 = 190236598;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 1598278271)) % 3U)
        {
          case 0:
            goto label_1;
          case 1:
            chessboard[oldCell.Row, oldCell.Column].Chessman = (BaseChessman) null;
            num1 = (int) num2 * -1560318730 ^ -1649879656;
            continue;
          case 2:
            goto label_3;
          default:
            goto label_5;
        }
      }
label_3:
      return;
label_5:;
    }

    private BoardCell[,] GetDeepCopyOfBoardCells(BoardCell[,] boardCells)
    {
      BoardCell[,] copyOfBoardCells = (BoardCell[,]) null;
label_1:
      int num1 = 1098795780;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 504320502)) % 3U)
        {
          case 0:
            goto label_1;
          case 2:
            num1 = (int) num2 * 634852719 ^ 1942299022;
            continue;
          default:
            goto label_4;
        }
      }
label_4:
      return copyOfBoardCells;
    }

    private int GetStepsCoutForMovement(int direction, int movementSteps)
    {
label_1:
      int num1 = 766666397;
      int stepsCoutForMovement;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 1595306485)) % 7U)
        {
          case 0:
            num1 = (int) num2 * -913394798 ^ -1379075964;
            continue;
          case 1:
            int num3 = direction != 0 ? -1837580243 : (num3 = -694360769);
            num1 = num3 ^ (int) num2 * 1746668274;
            continue;
          case 3:
            goto label_1;
          case 4:
            stepsCoutForMovement = 0;
            num1 = (int) num2 * -125710989 ^ 1864623647;
            continue;
          case 5:
            stepsCoutForMovement = direction + (direction == -1 ? movementSteps * -1 : movementSteps);
            num1 = 627839345;
            continue;
          case 6:
            num1 = (int) num2 * 565274910 ^ -738525900;
            continue;
          default:
            goto label_8;
        }
      }
label_8:
      return stepsCoutForMovement;
    }

    static NotImplementedException \u202B⁬‏‏⁬‬⁯⁯⁪⁮‫‪‭​⁫⁪‪⁫⁯⁫‪⁪‍⁪‌​‮​‮‭​​⁯⁭⁭‍‍​‫⁪‮() => new NotImplementedException();

    static ArgumentException \u206C‬‎‍‎⁪‫‮‬⁮​‍‪⁭​⁫⁬⁬‬‪‭‫‫‏‪‮⁬‍‬⁬‮​‎‫⁮‌⁫‪‌‎‮(
      [In] string obj0)
    {
      return new ArgumentException(obj0);
    }
  }
}
