// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Ressource, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7A61D5AB-B799-4526-BF58-A6DA1297213F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan.Win32.Inject.ancbn-87991063fbeea430cdbe9586022ccd45abc0d3ca50af32983044f034c3072515.exe

using System;
using System.Collections;

internal sealed class \uE00D
{
  internal const int \uE000 = 32768;
  internal const int \uE001 = 258;
  internal const int \uE002 = 285;
  internal const int \uE003 = 287;
  internal const int \uE004 = 29;
  internal const int \uE005 = 31;
  internal const int \uE006 = 15;
  internal const int \uE007 = 256;
  internal const int \uE008 = 0;
  internal const int \uE009 = 1;
  internal const int \uE00A = 2;
  internal const int \uE00B = 16;
  internal const int \uE00C = 18;
  internal const int \uE00D = 16;
  internal const int \uE00E = 17;
  internal const int \uE00F = 18;
  private const int \uE010 = 257;
  internal static \uE00F[] \uE011 = new \uE00F[288];
  internal static \uE00F[] \uE012 = new \uE00F[32];
  internal static \uE011 \uE013;
  internal static readonly int[] \uE014 = new int[19];
  private static readonly int[] \uE015;
  private static readonly int[] \uE016;
  private static readonly int[] \uE017;
  private static readonly int[] \uE018;

  static \uE00D()
  {
    \uE00D.\uE014[0] = 16;
    \uE00D.\uE014[1] = 17;
    \uE00D.\uE014[2] = 18;
    \uE00D.\uE014[4] = 8;
    \uE00D.\uE014[5] = 7;
    \uE00D.\uE014[6] = 9;
    \uE00D.\uE014[7] = 6;
    \uE00D.\uE014[8] = 10;
    \uE00D.\uE014[9] = 5;
    \uE00D.\uE014[10] = 11;
    \uE00D.\uE014[11] = 4;
    \uE00D.\uE014[12] = 12;
    \uE00D.\uE014[13] = 3;
    \uE00D.\uE014[14] = 13;
    \uE00D.\uE014[15] = 2;
    \uE00D.\uE014[16] = 14;
    \uE00D.\uE014[17] = 1;
    \uE00D.\uE014[18] = 15;
    \uE00D.\uE015 = new int[29];
    \uE00D.\uE015[0] = 3;
    \uE00D.\uE015[1] = 4;
    \uE00D.\uE015[2] = 5;
    \uE00D.\uE015[3] = 6;
    \uE00D.\uE015[4] = 7;
    \uE00D.\uE015[5] = 8;
    \uE00D.\uE015[6] = 9;
    \uE00D.\uE015[7] = 10;
    \uE00D.\uE015[8] = 11;
    \uE00D.\uE015[9] = 13;
    \uE00D.\uE015[10] = 15;
    \uE00D.\uE015[11] = 17;
    \uE00D.\uE015[12] = 19;
    \uE00D.\uE015[13] = 23;
    \uE00D.\uE015[14] = 27;
    \uE00D.\uE015[15] = 31;
    \uE00D.\uE015[16] = 35;
    \uE00D.\uE015[17] = 43;
    \uE00D.\uE015[18] = 51;
    \uE00D.\uE015[19] = 59;
    \uE00D.\uE015[20] = 67;
    \uE00D.\uE015[21] = 83;
    \uE00D.\uE015[22] = 99;
    \uE00D.\uE015[23] = 115;
    \uE00D.\uE015[24] = 131;
    \uE00D.\uE015[25] = 163;
    \uE00D.\uE015[26] = 195;
    \uE00D.\uE015[27] = 227;
    \uE00D.\uE015[28] = 258;
    \uE00D.\uE016 = new int[29];
    int index1 = 8;
    int num1 = 0;
    for (; index1 < 28; ++index1)
    {
      if (index1 % 4 == 0)
        ++num1;
      \uE00D.\uE016[index1] = num1;
    }
    \uE00D.\uE017 = new int[30];
    \uE00D.\uE017[0] = 1;
    \uE00D.\uE017[1] = 2;
    \uE00D.\uE017[2] = 3;
    \uE00D.\uE017[3] = 4;
    \uE00D.\uE017[4] = 5;
    \uE00D.\uE017[5] = 7;
    \uE00D.\uE017[6] = 9;
    \uE00D.\uE017[7] = 13;
    \uE00D.\uE017[8] = 17;
    \uE00D.\uE017[9] = 25;
    \uE00D.\uE017[10] = 33;
    \uE00D.\uE017[11] = 49;
    \uE00D.\uE017[12] = 65;
    \uE00D.\uE017[13] = 97;
    \uE00D.\uE017[14] = 129;
    \uE00D.\uE017[15] = 193;
    \uE00D.\uE017[16] = 257;
    \uE00D.\uE017[17] = 385;
    \uE00D.\uE017[18] = 513;
    \uE00D.\uE017[19] = 769;
    \uE00D.\uE017[20] = 1025;
    \uE00D.\uE017[21] = 1537;
    \uE00D.\uE017[22] = 2049;
    \uE00D.\uE017[23] = 3073;
    \uE00D.\uE017[24] = 4097;
    \uE00D.\uE017[25] = 6145;
    \uE00D.\uE017[26] = 8193;
    \uE00D.\uE017[27] = 12289;
    \uE00D.\uE017[28] = 16385;
    \uE00D.\uE017[29] = 24577;
    \uE00D.\uE018 = new int[30];
    int index2 = 4;
    int num2 = 0;
    for (; index2 < 30; ++index2)
    {
      if (index2 % 2 == 0)
        ++num2;
      \uE00D.\uE018[index2] = num2;
    }
    for (int index3 = 0; index3 <= 143; ++index3)
    {
      \uE00D.\uE011[index3].\uE000 = 48 + index3;
      \uE00D.\uE011[index3].\uE001 = 8;
    }
    for (int index4 = 144; index4 <= (int) byte.MaxValue; ++index4)
    {
      \uE00D.\uE011[index4].\uE000 = 400 + index4 - 144;
      \uE00D.\uE011[index4].\uE001 = 9;
    }
    for (int index5 = 256; index5 <= 279; ++index5)
    {
      \uE00D.\uE011[index5].\uE000 = index5 - 256;
      \uE00D.\uE011[index5].\uE001 = 7;
    }
    for (int index6 = 280; index6 <= 287; ++index6)
    {
      \uE00D.\uE011[index6].\uE000 = 192 + index6 - 280;
      \uE00D.\uE011[index6].\uE001 = 8;
    }
    for (int index7 = 0; index7 <= 31; ++index7)
    {
      \uE00D.\uE012[index7].\uE000 = index7;
      \uE00D.\uE012[index7].\uE001 = 5;
    }
    \uE00D.\uE013 = \uE00D.\uE000(\uE00D.\uE011, \uE00D.\uE012);
  }

  internal static int \uE002(int[] _param0, int[] _param1)
  {
    int num = 0;
    for (int index = 0; index < _param0.Length; ++index)
      num += _param0[index] * _param1[index];
    return num;
  }

  internal static int \uE003(int[] _param0, int[] _param1)
  {
    int num = 0;
    for (int index = 0; index < _param0.Length; ++index)
      num += _param0[index] * \uE00D.\uE011[index].\uE001;
    for (int index = 0; index < _param1.Length; ++index)
      num += _param1[index] * \uE00D.\uE012[index].\uE001;
    return num;
  }

  internal static \uE00F[] \uE000(int[] _param0)
  {
    \uE00F[] objArray = new \uE00F[_param0.Length];
    for (int index = 0; index < _param0.Length; ++index)
      objArray[index].\uE001 = _param0[index];
    \uE00D.\uE000(objArray);
    return objArray;
  }

  internal static void \uE000(\uE00F[] _param0)
  {
    int num1 = _param0[0].\uE001;
    for (int index = 1; index < _param0.Length; ++index)
    {
      if (num1 < _param0[index].\uE001)
        num1 = _param0[index].\uE001;
    }
    int[] numArray1 = new int[num1 + 1];
    for (int index = 0; index < _param0.Length; ++index)
      ++numArray1[_param0[index].\uE001];
    int[] numArray2 = new int[num1 + 1];
    int num2 = 0;
    numArray1[0] = 0;
    for (int index = 1; index <= num1; ++index)
    {
      num2 = num2 + numArray1[index - 1] << 1;
      numArray2[index] = num2;
    }
    for (int index1 = 0; index1 < _param0.Length; ++index1)
    {
      int index2 = _param0[index1].\uE001;
      if (index2 != 0)
      {
        _param0[index1].\uE000 = numArray2[index2];
        ++numArray2[index2];
      }
    }
  }

  internal static \uE011 \uE000(\uE00F[] _param0, \uE00F[] _param1) => new \uE011()
  {
    \uE000 = \uE00D.\uE000(_param0),
    \uE001 = \uE00D.\uE000(_param1)
  };

  internal static \uE010 \uE000(\uE00F[] _param0)
  {
    \uE00D.\uE009[] objArray = new \uE00D.\uE009[_param0.Length];
    int num = 0;
    for (int index = 0; index < _param0.Length; ++index)
    {
      if (_param0[index].\uE001 > 0)
      {
        \uE00D.\uE009 obj = new \uE00D.\uE009();
        ref \uE00D.\uE009 local = ref obj;
        obj.\uE000 = _param0[index];
        obj.\uE001 = (ushort) index;
        objArray[num++] = obj;
      }
    }
    if (_param0.Length < 1)
      throw new InvalidOperationException();
    return \uE00D.\uE000(objArray, num, 0, 0);
  }

  private static \uE010 \uE000(
    \uE00D.\uE009[] _param0,
    int _param1,
    int _param2,
    int _param3)
  {
    \uE00D.\uE009[] objArray1 = new \uE00D.\uE009[_param1];
    \uE00D.\uE009[] objArray2 = new \uE00D.\uE009[_param1];
    \uE010 obj1 = new \uE010();
    obj1.\uE000 = false;
    int num1;
    int num2 = num1 = 0;
    for (int index = 0; index < _param1; ++index)
    {
      \uE00D.\uE009 obj2 = _param0[index];
      if (obj2.\uE000.\uE001 == _param3 && obj2.\uE000.\uE000 == _param2)
      {
        obj1.\uE000 = true;
        obj1.\uE001 = obj2.\uE001;
      }
      else if ((obj2.\uE000.\uE000 >> obj2.\uE000.\uE001 - _param3 - 1 & 1) != 0)
        objArray2[num2++] = obj2;
      else
        objArray1[num1++] = obj2;
    }
    if (obj1.\uE000)
    {
      if (num2 > 0 || num1 > 0)
        throw new InvalidOperationException();
    }
    else
    {
      if (num1 > 0)
        obj1.\uE002 = \uE00D.\uE000(objArray1, num1, _param2 << 1, _param3 + 1);
      if (num2 > 0)
        obj1.\uE003 = \uE00D.\uE000(objArray2, num2, _param2 << 1 | 1, _param3 + 1);
    }
    return obj1;
  }

  internal static void \uE00A(int _param0, out int _param1, out int _param2)
  {
    _param1 = \uE00D.\uE015[_param0 - 257];
    _param2 = \uE00D.\uE016[_param0 - 257];
  }

  internal static void \uE00B(int _param0, out int _param1, out int _param2, out int _param3)
  {
    int index = Array.BinarySearch<int>(\uE00D.\uE015, _param0);
    if (index < 0)
      index = ~index - 1;
    _param1 = index + 257;
    _param2 = _param0 - \uE00D.\uE015[index];
    _param3 = \uE00D.\uE016[index];
  }

  internal static void \uE00B(int _param0, out int _param1, out int _param2)
  {
    _param1 = \uE00D.\uE017[_param0];
    _param2 = \uE00D.\uE018[_param0];
  }

  internal static void \uE00C(int _param0, out int _param1, out int _param2, out int _param3)
  {
    int index = Array.BinarySearch<int>(\uE00D.\uE017, _param0);
    if (index < 0)
      index = ~index - 1;
    _param1 = index;
    _param2 = _param0 - \uE00D.\uE017[index];
    _param3 = \uE00D.\uE018[index];
  }

  internal static int[] \uE000(int[] _param0, int _param1) => \uE00E.\uE002(_param0, _param1);

  internal static int[] \uE000(int[] _param0) => \uE00E.\uE002(_param0, 15);

  internal static int \uE000(int _param0)
  {
    switch (_param0)
    {
      case 16:
        return 2;
      case 17:
        return 3;
      case 18:
        return 7;
      default:
        return 0;
    }
  }

  internal static int[] \uE000(int[] _param0, int _param1, int _param2)
  {
    ArrayList arrayList = new ArrayList();
    int num1 = 0;
    while (num1 < _param2)
    {
      if (_param0[_param1 + num1] == 0)
      {
        int num2 = 0;
        do
        {
          ++num2;
        }
        while (num1 + num2 < _param2 && num2 < 138 && _param0[_param1 + num1 + num2] == 0);
        if (num2 < 3)
        {
          if (num2 >= 1)
            arrayList.Add((object) 0);
          if (num2 >= 2)
            arrayList.Add((object) 0);
        }
        else if (num2 < 11)
        {
          arrayList.Add((object) 17);
          arrayList.Add((object) (num2 - 3));
        }
        else
        {
          arrayList.Add((object) 18);
          arrayList.Add((object) (num2 - 11));
        }
        num1 += num2;
      }
      else
      {
        int num3 = _param0[_param1 + num1++];
        arrayList.Add((object) num3);
        int num4 = 0;
        while (num1 + num4 < _param2 && num4 < 6 && _param0[_param1 + num1 + num4] == num3)
          ++num4;
        if (num4 >= 3)
        {
          arrayList.Add((object) 16);
          arrayList.Add((object) (num4 - 3));
          num1 += num4;
        }
      }
    }
    return (int[]) arrayList.ToArray(typeof (int));
  }

  private struct \uE009
  {
    internal \uE00F \uE000;
    internal ushort \uE001;
  }
}
