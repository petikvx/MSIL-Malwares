// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteFunction
// Assembly: sysrt, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F2102D52-57B0-4622-A1CB-9DE0B00E107F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Blocker.hehh-e9e3600777f319c90d3c06bee4af8f501eba42a876d1d5ed7d3de045ff7cba31.exe

using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Permissions;

namespace System.Data.SQLite
{
  public abstract class SQLiteFunction : IDisposable
  {
    internal SQLiteBase _base;
    private Dictionary<long, SQLiteFunction.AggregateData> _contextDataList;
    private SQLiteCallback _InvokeFunc;
    private SQLiteCallback _StepFunc;
    private SQLiteFinalCallback _FinalFunc;
    private SQLiteCollation _CompareFunc;
    private SQLiteCollation _CompareFunc16;
    internal IntPtr _context;
    private static List<SQLiteFunctionAttribute> _registeredFunctions = new List<SQLiteFunctionAttribute>();

    protected SQLiteFunction() => this._contextDataList = new Dictionary<long, SQLiteFunction.AggregateData>();

    public SQLiteConvert SQLiteConvert => (SQLiteConvert) this._base;

    public virtual object Invoke(object[] args) => (object) null;

    public virtual void Step(object[] args, int stepNumber, ref object contextData)
    {
    }

    public virtual object Final(object contextData) => (object) null;

    public virtual int Compare(string param1, string param2) => 0;

    internal object[] ConvertParams(int nArgs, IntPtr argsptr)
    {
      object[] objArray = new object[nArgs];
      IntPtr[] destination = new IntPtr[nArgs];
      Marshal.Copy(argsptr, destination, 0, nArgs);
      for (int index = 0; index < nArgs; ++index)
      {
        switch (this._base.GetParamValueType(destination[index]))
        {
          case TypeAffinity.Int64:
            objArray[index] = (object) this._base.GetParamValueInt64(destination[index]);
            break;
          case TypeAffinity.Double:
            objArray[index] = (object) this._base.GetParamValueDouble(destination[index]);
            break;
          case TypeAffinity.Text:
            objArray[index] = (object) this._base.GetParamValueText(destination[index]);
            break;
          case TypeAffinity.Blob:
            int paramValueBytes = (int) this._base.GetParamValueBytes(destination[index], 0, (byte[]) null, 0, 0);
            byte[] bDest = new byte[paramValueBytes];
            this._base.GetParamValueBytes(destination[index], 0, bDest, 0, paramValueBytes);
            objArray[index] = (object) bDest;
            break;
          case TypeAffinity.Null:
            objArray[index] = (object) DBNull.Value;
            break;
          case TypeAffinity.DateTime:
            objArray[index] = (object) this._base.ToDateTime(this._base.GetParamValueText(destination[index]));
            break;
        }
      }
      return objArray;
    }

    private void SetReturnValue(IntPtr context, object returnValue)
    {
      if (returnValue == null || returnValue == DBNull.Value)
      {
        this._base.ReturnNull(context);
      }
      else
      {
        Type type = returnValue.GetType();
        if ((object) type == (object) typeof (DateTime))
          this._base.ReturnText(context, this._base.ToString((DateTime) returnValue));
        else if (returnValue is Exception exception)
        {
          this._base.ReturnError(context, exception.Message);
        }
        else
        {
          switch (SQLiteConvert.TypeToAffinity(type))
          {
            case TypeAffinity.Int64:
              this._base.ReturnInt64(context, Convert.ToInt64(returnValue, (IFormatProvider) CultureInfo.CurrentCulture));
              break;
            case TypeAffinity.Double:
              this._base.ReturnDouble(context, Convert.ToDouble(returnValue, (IFormatProvider) CultureInfo.CurrentCulture));
              break;
            case TypeAffinity.Text:
              this._base.ReturnText(context, returnValue.ToString());
              break;
            case TypeAffinity.Blob:
              this._base.ReturnBlob(context, (byte[]) returnValue);
              break;
            case TypeAffinity.Null:
              this._base.ReturnNull(context);
              break;
          }
        }
      }
    }

    internal void ScalarCallback(IntPtr context, int nArgs, IntPtr argsptr)
    {
      this._context = context;
      this.SetReturnValue(context, this.Invoke(this.ConvertParams(nArgs, argsptr)));
    }

    internal int CompareCallback(IntPtr ptr, int len1, IntPtr ptr1, int len2, IntPtr ptr2) => this.Compare(SQLiteConvert.UTF8ToString(ptr1, len1), SQLiteConvert.UTF8ToString(ptr2, len2));

    internal int CompareCallback16(IntPtr ptr, int len1, IntPtr ptr1, int len2, IntPtr ptr2) => this.Compare(SQLite3_UTF16.UTF16ToString(ptr1, len1), SQLite3_UTF16.UTF16ToString(ptr2, len2));

    internal void StepCallback(IntPtr context, int nArgs, IntPtr argsptr)
    {
      long key = (long) this._base.AggregateContext(context);
      SQLiteFunction.AggregateData aggregateData;
      if (!this._contextDataList.TryGetValue(key, out aggregateData))
      {
        aggregateData = new SQLiteFunction.AggregateData();
        this._contextDataList[key] = aggregateData;
      }
      try
      {
        this._context = context;
        this.Step(this.ConvertParams(nArgs, argsptr), aggregateData._count, ref aggregateData._data);
      }
      finally
      {
        ++aggregateData._count;
      }
    }

    internal void FinalCallback(IntPtr context)
    {
      long key = (long) this._base.AggregateContext(context);
      object contextData = (object) null;
      if (this._contextDataList.ContainsKey(key))
      {
        contextData = this._contextDataList[key]._data;
        this._contextDataList.Remove(key);
      }
      this._context = context;
      this.SetReturnValue(context, this.Final(contextData));
      if (!(contextData is IDisposable disposable))
        return;
      disposable.Dispose();
    }

    protected virtual void Dispose(bool disposing)
    {
      if (!disposing)
        return;
      foreach (KeyValuePair<long, SQLiteFunction.AggregateData> contextData in this._contextDataList)
      {
        if (contextData.Value._data is IDisposable data)
          data.Dispose();
      }
      this._contextDataList.Clear();
      this._InvokeFunc = (SQLiteCallback) null;
      this._StepFunc = (SQLiteCallback) null;
      this._FinalFunc = (SQLiteFinalCallback) null;
      this._CompareFunc = (SQLiteCollation) null;
      this._base = (SQLiteBase) null;
      this._contextDataList = (Dictionary<long, SQLiteFunction.AggregateData>) null;
    }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    [FileIOPermission(SecurityAction.Assert, AllFiles = FileIOPermissionAccess.PathDiscovery)]
    static SQLiteFunction()
    {
      try
      {
        Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
        int length1 = assemblies.Length;
        AssemblyName name = Assembly.GetCallingAssembly().GetName();
        for (int index1 = 0; index1 < length1; ++index1)
        {
          bool flag = false;
          Type[] types;
          try
          {
            AssemblyName[] referencedAssemblies = assemblies[index1].GetReferencedAssemblies();
            int length2 = referencedAssemblies.Length;
            for (int index2 = 0; index2 < length2; ++index2)
            {
              if (referencedAssemblies[index2].Name == name.Name)
              {
                flag = true;
                break;
              }
            }
            if (flag)
              types = assemblies[index1].GetTypes();
            else
              continue;
          }
          catch (ReflectionTypeLoadException ex)
          {
            types = ex.Types;
          }
          int length3 = types.Length;
          for (int index3 = 0; index3 < length3; ++index3)
          {
            if ((object) types[index3] != null)
            {
              object[] customAttributes = types[index3].GetCustomAttributes(typeof (SQLiteFunctionAttribute), false);
              int length4 = customAttributes.Length;
              for (int index4 = 0; index4 < length4; ++index4)
              {
                if (customAttributes[index4] is SQLiteFunctionAttribute functionAttribute)
                {
                  functionAttribute._instanceType = types[index3];
                  SQLiteFunction._registeredFunctions.Add(functionAttribute);
                }
              }
            }
          }
        }
      }
      catch
      {
      }
    }

    public static void RegisterFunction(Type typ)
    {
      object[] customAttributes = typ.GetCustomAttributes(typeof (SQLiteFunctionAttribute), false);
      int length = customAttributes.Length;
      for (int index = 0; index < length; ++index)
      {
        if (customAttributes[index] is SQLiteFunctionAttribute functionAttribute)
        {
          functionAttribute._instanceType = typ;
          SQLiteFunction._registeredFunctions.Add(functionAttribute);
        }
      }
    }

    internal static SQLiteFunction[] BindFunctions(SQLiteBase sqlbase)
    {
      List<SQLiteFunction> sqLiteFunctionList = new List<SQLiteFunction>();
      foreach (SQLiteFunctionAttribute registeredFunction in SQLiteFunction._registeredFunctions)
      {
        SQLiteFunction instance = (SQLiteFunction) Activator.CreateInstance(registeredFunction._instanceType);
        instance._base = sqlbase;
        instance._InvokeFunc = registeredFunction.FuncType == FunctionType.Scalar ? new SQLiteCallback(instance.ScalarCallback) : (SQLiteCallback) null;
        instance._StepFunc = registeredFunction.FuncType == FunctionType.Aggregate ? new SQLiteCallback(instance.StepCallback) : (SQLiteCallback) null;
        instance._FinalFunc = registeredFunction.FuncType == FunctionType.Aggregate ? new SQLiteFinalCallback(instance.FinalCallback) : (SQLiteFinalCallback) null;
        instance._CompareFunc = registeredFunction.FuncType == FunctionType.Collation ? new SQLiteCollation(instance.CompareCallback) : (SQLiteCollation) null;
        instance._CompareFunc16 = registeredFunction.FuncType == FunctionType.Collation ? new SQLiteCollation(instance.CompareCallback16) : (SQLiteCollation) null;
        if (registeredFunction.FuncType != FunctionType.Collation)
          sqlbase.CreateFunction(registeredFunction.Name, registeredFunction.Arguments, instance is SQLiteFunctionEx, instance._InvokeFunc, instance._StepFunc, instance._FinalFunc);
        else
          sqlbase.CreateCollation(registeredFunction.Name, instance._CompareFunc, instance._CompareFunc16);
        sqLiteFunctionList.Add(instance);
      }
      SQLiteFunction[] array = new SQLiteFunction[sqLiteFunctionList.Count];
      sqLiteFunctionList.CopyTo(array, 0);
      return array;
    }

    private class AggregateData
    {
      internal int _count = 1;
      internal object _data;
    }
  }
}
