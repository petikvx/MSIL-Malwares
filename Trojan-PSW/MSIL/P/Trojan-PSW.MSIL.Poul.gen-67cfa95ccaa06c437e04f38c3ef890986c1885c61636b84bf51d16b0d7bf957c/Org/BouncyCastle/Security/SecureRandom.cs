// Decompiled with JetBrains decompiler
// Type: Org.BouncyCastle.Security.SecureRandom
// Assembly: Poullight, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A9555FC6-4E86-4D22-9A29-AD3955B2BC52
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\Trojan-PSW.MSIL.Poul.gen-67cfa95ccaa06c437e04f38c3ef890986c1885c61636b84bf51d16b0d7bf957c.exe

using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Prng;
using System;
using System.Threading;

namespace Org.BouncyCastle.Security
{
  public class SecureRandom : Random
  {
    private static long counter = DateTime.UtcNow.Ticks * 100L;
    private static readonly double DoubleScale = Math.Pow(2.0, 64.0);
    protected readonly IRandomGenerator generator;

    public SecureRandom()
      : this((IRandomGenerator) SecureRandom.CreatePrng("SHA256", true))
    {
    }

    public SecureRandom(IRandomGenerator generator)
      : base(0)
    {
      this.generator = generator;
    }

    private static SecureRandom Master { get; } = new SecureRandom((IRandomGenerator) new CryptoApiRandomGenerator());

    private static long NextCounterValue() => Interlocked.Increment(ref SecureRandom.counter);

    private static DigestRandomGenerator CreatePrng(
      string digestName,
      bool autoSeed)
    {
      IDigest digest = DigestUtilities.GetDigest(digestName);
      if (digest == null)
        return (DigestRandomGenerator) null;
      DigestRandomGenerator prng = new DigestRandomGenerator(digest);
      if (autoSeed)
      {
        prng.AddSeedMaterial(SecureRandom.NextCounterValue());
        prng.AddSeedMaterial(SecureRandom.GetNextBytes(SecureRandom.Master, digest.GetDigestSize()));
      }
      return prng;
    }

    public static byte[] GetNextBytes(SecureRandom secureRandom, int length)
    {
      byte[] buffer = new byte[length];
      secureRandom.NextBytes(buffer);
      return buffer;
    }

    public override int Next() => this.NextInt() & int.MaxValue;

    public override int Next(int maxValue)
    {
      if (maxValue < 2)
      {
        if (maxValue < 0)
          throw new ArgumentOutOfRangeException(nameof (maxValue), "cannot be negative");
        return 0;
      }
      if ((maxValue & maxValue - 1) == 0)
        return (int) ((long) (this.NextInt() & int.MaxValue) * (long) maxValue >> 31);
      int num1;
      int num2;
      do
      {
        num1 = this.NextInt() & int.MaxValue;
        num2 = num1 % maxValue;
      }
      while (num1 - num2 + (maxValue - 1) < 0);
      return num2;
    }

    public override int Next(int minValue, int maxValue)
    {
      if (maxValue <= minValue)
        return maxValue == minValue ? minValue : throw new ArgumentException("maxValue cannot be less than minValue");
      int maxValue1 = maxValue - minValue;
      if (maxValue1 > 0)
        return minValue + this.Next(maxValue1);
      int num;
      do
      {
        num = this.NextInt();
      }
      while (num < minValue || num >= maxValue);
      return num;
    }

    public override void NextBytes(byte[] buf) => this.generator.NextBytes(buf);

    public override double NextDouble() => Convert.ToDouble((ulong) this.NextLong()) / SecureRandom.DoubleScale;

    public virtual int NextInt()
    {
      byte[] buffer = new byte[4];
      this.NextBytes(buffer);
      return (((int) buffer[0] << 8 | (int) buffer[1]) << 8 | (int) buffer[2]) << 8 | (int) buffer[3];
    }

    public virtual long NextLong() => (long) (uint) this.NextInt() << 32 | (long) (uint) this.NextInt();
  }
}
