// Decompiled with JetBrains decompiler
// Type: System.ServiceModel.Dispatcher.SingleBodyParameterDataContractMessageFormatter
// Assembly: Microsoft.Transactions.Bridge, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 51116F84-6FE2-4BD6-A908-2C88E06F45BB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Trojan.MSIL.Picsys.gen-d64123468b2dcb11e9205288e0a6cb144a448944457a708807b7345a8a766675.exe

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;
using System.ServiceModel.Channels;
using System.ServiceModel.Description;

namespace System.ServiceModel.Dispatcher
{
  internal class SingleBodyParameterDataContractMessageFormatter : 
    SingleBodyParameterMessageFormatter
  {
    private static readonly System.Type TypeOfNullable = typeof (Nullable<>);
    private static readonly System.Type[] CollectionDataContractInterfaces = new System.Type[4]
    {
      typeof (IEnumerable),
      typeof (IList),
      typeof (ICollection),
      typeof (IDictionary)
    };
    private static readonly System.Type[] GenericCollectionDataContractInterfaces = new System.Type[4]
    {
      typeof (IEnumerable<>),
      typeof (IList<>),
      typeof (ICollection<>),
      typeof (IDictionary<,>)
    };
    private XmlObjectSerializer cachedOutputSerializer;
    private System.Type cachedOutputSerializerType;
    private bool ignoreExtensionData;
    private XmlObjectSerializer[] inputSerializers;
    private IList<System.Type> knownTypes;
    private int maxItemsInObjectGraph;
    private System.Type parameterDataContractType;
    private IDataContractSurrogate surrogate;
    private object thisLock;
    private bool useJsonFormat;
    private bool isParameterCollectionInterfaceDataContract;
    private bool isQueryable;

    public SingleBodyParameterDataContractMessageFormatter(
      OperationDescription operation,
      System.Type parameterType,
      bool isRequestFormatter,
      bool useJsonFormat,
      DataContractSerializerOperationBehavior dcsob)
      : base(operation, isRequestFormatter, "DataContractSerializer")
    {
      if (operation == null)
        throw System.ServiceModel.DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (operation));
      if (parameterType == (System.Type) null)
        throw System.ServiceModel.DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (parameterType));
      if (dcsob == null)
        throw System.ServiceModel.DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (dcsob));
      this.parameterDataContractType = DataContractSerializerOperationFormatter.GetSubstituteDataContractType(parameterType, out this.isQueryable);
      this.isParameterCollectionInterfaceDataContract = SingleBodyParameterDataContractMessageFormatter.IsTypeCollectionInterface(this.parameterDataContractType);
      List<System.Type> typeList = new List<System.Type>();
      if (operation.KnownTypes != null)
      {
        foreach (System.Type knownType in operation.KnownTypes)
          typeList.Add(knownType);
      }
      System.Type type = SingleBodyParameterDataContractMessageFormatter.UnwrapNullableType(this.parameterDataContractType);
      if (type != this.parameterDataContractType)
        typeList.Add(type);
      this.surrogate = dcsob.DataContractSurrogate;
      this.ignoreExtensionData = dcsob.IgnoreExtensionDataObject;
      this.maxItemsInObjectGraph = dcsob.MaxItemsInObjectGraph;
      this.knownTypes = (IList<System.Type>) typeList.AsReadOnly();
      SingleBodyParameterDataContractMessageFormatter.ValidateType(this.parameterDataContractType, this.surrogate, (IEnumerable<System.Type>) this.knownTypes);
      this.useJsonFormat = useJsonFormat;
      this.CreateInputSerializers(this.parameterDataContractType);
      this.thisLock = new object();
    }

    internal static System.Type UnwrapNullableType(System.Type type)
    {
      while (type.IsGenericType && type.GetGenericTypeDefinition() == SingleBodyParameterDataContractMessageFormatter.TypeOfNullable)
        type = type.GetGenericArguments()[0];
      return type;
    }

    protected override object ReadObject(Message message)
    {
      object source = base.ReadObject(message);
      return this.isQueryable && source != null ? (object) ((IEnumerable) source).AsQueryable() : source;
    }

    protected override void AttachMessageProperties(Message message, bool isRequest)
    {
      if (!this.useJsonFormat)
        return;
      message.Properties.Add("WebBodyFormatMessageProperty", (object) WebBodyFormatMessageProperty.JsonProperty);
    }

    protected override XmlObjectSerializer[] GetInputSerializers() => this.inputSerializers;

    protected override XmlObjectSerializer GetOutputSerializer(System.Type type)
    {
      lock (this.thisLock)
      {
        if (this.cachedOutputSerializerType != type)
        {
          System.Type type1;
          if (this.isParameterCollectionInterfaceDataContract)
          {
            // ISSUE: reference to a compiler-generated method
            type1 = this.parameterDataContractType.IsAssignableFrom(type) ? this.parameterDataContractType : throw System.ServiceModel.DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new SerializationException(SR2.GetString(SR2.TypeIsNotParameterTypeAndIsNotPresentInKnownTypes, (object) type, (object) this.OperationName, (object) this.ContractName, (object) this.parameterDataContractType)));
          }
          else
            type1 = this.GetTypeForSerializer(type, this.parameterDataContractType, this.knownTypes);
          this.cachedOutputSerializer = this.CreateSerializer(type1);
          this.cachedOutputSerializerType = type;
        }
        return this.cachedOutputSerializer;
      }
    }

    private static bool IsTypeCollectionInterface(System.Type parameterType)
    {
      if (parameterType.IsGenericType && parameterType.IsInterface)
      {
        System.Type genericTypeDefinition = parameterType.GetGenericTypeDefinition();
        foreach (System.Type contractInterface in SingleBodyParameterDataContractMessageFormatter.GenericCollectionDataContractInterfaces)
        {
          if (genericTypeDefinition == contractInterface)
            return true;
        }
      }
      foreach (System.Type contractInterface in SingleBodyParameterDataContractMessageFormatter.CollectionDataContractInterfaces)
      {
        if (parameterType == contractInterface)
          return true;
      }
      return false;
    }

    protected override void ValidateMessageFormatProperty(Message message)
    {
      if (this.useJsonFormat)
      {
        object obj;
        message.Properties.TryGetValue("WebBodyFormatMessageProperty", out obj);
        if (!(obj is WebBodyFormatMessageProperty formatMessageProperty))
        {
          // ISSUE: reference to a compiler-generated method
          throw System.ServiceModel.DiagnosticUtility.ExceptionUtility.ThrowHelperWarning((Exception) new InvalidOperationException(SR2.GetString(SR2.MessageFormatPropertyNotFound, (object) this.OperationName, (object) this.ContractName, (object) this.ContractNs)));
        }
        if (formatMessageProperty.Format != WebContentFormat.Json)
        {
          // ISSUE: reference to a compiler-generated method
          throw System.ServiceModel.DiagnosticUtility.ExceptionUtility.ThrowHelperWarning((Exception) new InvalidOperationException(SR2.GetString(SR2.InvalidHttpMessageFormat, (object) this.OperationName, (object) this.ContractName, (object) this.ContractNs, (object) formatMessageProperty.Format, (object) WebContentFormat.Json)));
        }
      }
      else
        base.ValidateMessageFormatProperty(message);
    }

    private static void ValidateType(
      System.Type parameterType,
      IDataContractSurrogate surrogate,
      IEnumerable<System.Type> knownTypes)
    {
      XsdDataContractExporter contractExporter = new XsdDataContractExporter();
      if (surrogate != null || knownTypes != null)
      {
        ExportOptions exportOptions = new ExportOptions();
        exportOptions.DataContractSurrogate = surrogate;
        if (knownTypes != null)
        {
          foreach (System.Type knownType in knownTypes)
            exportOptions.KnownTypes.Add(knownType);
        }
        contractExporter.Options = exportOptions;
      }
      contractExporter.GetSchemaTypeName(parameterType);
    }

    private void CreateInputSerializers(System.Type type)
    {
      List<XmlObjectSerializer> objectSerializerList = new List<XmlObjectSerializer>();
      objectSerializerList.Add(this.CreateSerializer(type));
      foreach (System.Type knownType in (IEnumerable<System.Type>) this.knownTypes)
        objectSerializerList.Add(this.CreateSerializer(knownType));
      this.inputSerializers = objectSerializerList.ToArray();
    }

    private XmlObjectSerializer CreateSerializer(System.Type type) => this.useJsonFormat ? (XmlObjectSerializer) new DataContractJsonSerializer(type, (IEnumerable<System.Type>) this.knownTypes, this.maxItemsInObjectGraph, this.ignoreExtensionData, this.surrogate, false) : (XmlObjectSerializer) new DataContractSerializer(type, (IEnumerable<System.Type>) this.knownTypes, this.maxItemsInObjectGraph, this.ignoreExtensionData, false, this.surrogate);
  }
}
