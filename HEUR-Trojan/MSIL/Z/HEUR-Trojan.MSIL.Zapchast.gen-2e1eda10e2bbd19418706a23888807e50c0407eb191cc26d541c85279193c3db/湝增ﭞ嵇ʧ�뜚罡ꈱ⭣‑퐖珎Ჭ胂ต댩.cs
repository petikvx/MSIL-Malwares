// Decompiled with JetBrains decompiler
// Type: 湝增ﭞ嵇ʧ�뜚罡ꈱ⭣‑퐖珎Ჭ胂ต댩
// Assembly: $77-Venom, Version=2.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC8E8704-647D-4CA7-99AB-BB7BE936B486
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\HEUR-Trojan.MSIL.Zapchast.gen-2e1eda10e2bbd19418706a23888807e50c0407eb191cc26d541c85279193c3db.exe

using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

public static class 湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37
{
  private const int 魠\u2EA3㗈\uAB07瓝䣞\uA495踿鼄\u20A5ꄿ昭䟲顆\u1738钙\u2AA7\u25FB䗒\uA838 = 16;
  private const int \uE16F\u2394稏ጏ\u303E䧇\u294E落\uF442\uEF4C뭹샒\u33D8\u2949ꅿ篺暥\uEFF2덚翈 = 32;
  private static byte[] \uF7C6骶\uF500ロᒉ䬳쿷\uFFFD\uEE30섆㙫\u1756ࣲ搶ﳏ\u0CD0东䍜섡\u3192;
  private static byte[] 㺫㭜\u264B\uF789ἴ蓑즰\u204E薧鰑ᴹ\uFFFD\uE21D\u086A蟞诈㩀ﶆᤛ麋;
  public static readonly byte[] 됐忱톧錚\u1775\uFFFD쎀괐ﰹ錘\u2F0C㪧憼ꃺ\u0A34\uF277䘆ﺉ絪\uFFFD = new byte[32]
  {
    (byte) 191,
    (byte) 235,
    (byte) 30,
    (byte) 86,
    (byte) 251,
    (byte) 205,
    (byte) 151,
    (byte) 59,
    (byte) 178,
    (byte) 25,
    (byte) 2,
    (byte) 36,
    (byte) 48,
    (byte) 165,
    (byte) 120,
    (byte) 67,
    (byte) 0,
    (byte) 61,
    (byte) 86,
    (byte) 68,
    (byte) 210,
    (byte) 30,
    (byte) 98,
    (byte) 185,
    (byte) 212,
    (byte) 241,
    (byte) 128,
    (byte) 231,
    (byte) 230,
    (byte) 195,
    (byte) 57,
    (byte) 65
  };

  public static void 䢧闭ᚥꊅ䍒\uEF01᠐\u2B73\u070A宛螂螔䨦푁顮㒛吓촰\u2527耡(string key)
  {
    using (Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(key, 湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.됐忱톧錚\u1775\uFFFD쎀괐ﰹ錘\u2F0C㪧憼ꃺ\u0A34\uF277䘆ﺉ絪\uFFFD, 50000))
    {
      湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.\uF7C6骶\uF500ロᒉ䬳쿷\uFFFD\uEE30섆㙫\u1756ࣲ搶ﳏ\u0CD0东䍜섡\u3192 = rfc2898DeriveBytes.GetBytes(16);
      湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.㺫㭜\u264B\uF789ἴ蓑즰\u204E薧鰑ᴹ\uFFFD\uE21D\u086A蟞诈㩀ﶆᤛ麋 = rfc2898DeriveBytes.GetBytes(64);
    }
  }

  public static void 㑙\uFFFD\u3037캔ﲭᢦ药놰鵉ੁ啡늳泛靟\uEE56硤\uF025䣎엿ꫦ(string key, string authKey)
  {
    湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.\uF7C6骶\uF500ロᒉ䬳쿷\uFFFD\uEE30섆㙫\u1756ࣲ搶ﳏ\u0CD0东䍜섡\u3192 = Convert.FromBase64String(key);
    湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.㺫㭜\u264B\uF789ἴ蓑즰\u204E薧鰑ᴹ\uFFFD\uE21D\u086A蟞诈㩀ﶆᤛ麋 = Convert.FromBase64String(authKey);
  }

  public static string \uF2D3ꔃ执喾틆駫鸅俳\uF3FD钾㙋ꫩ吏慰쭆ٿأ\uFFFD庒굓(string input, string key) => Convert.ToBase64String(湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.舴뇓囆漯Ǐṟ쬵䰚祩듭큎洘뛔䳻푤鼫睩\uFFFDᰚ쥓(Encoding.UTF8.GetBytes(input), Encoding.UTF8.GetBytes(key)));

  public static string 婋ﰢ\uE496裗ꂺ캝㗄몪䞣羣蘝膒\uFFFD塸쬢\u23F8昙\u087C糈\u29D9(string input) => Convert.ToBase64String(湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.\u2D72\uD7FF塻颿ጚﬄᕌ쯮\uAA4F鞞\uF6CDꦪ뺩玼ሱ쁔爢좨辷\uE3C0(Encoding.UTF8.GetBytes(input)));

  public static byte[] \u2D72\uD7FF塻颿ጚﬄᕌ쯮\uAA4F鞞\uF6CDꦪ뺩玼ሱ쁔爢좨辷\uE3C0(byte[] input)
  {
    if (湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.\uF7C6骶\uF500ロᒉ䬳쿷\uFFFD\uEE30섆㙫\u1756ࣲ搶ﳏ\u0CD0东䍜섡\u3192 == null || 湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.\uF7C6骶\uF500ロᒉ䬳쿷\uFFFD\uEE30섆㙫\u1756ࣲ搶ﳏ\u0CD0东䍜섡\u3192.Length == 0)
      throw new Exception("Key can not be empty.");
    byte[] buffer = input != null && input.Length != 0 ? input : throw new ArgumentException("Input can not be empty.");
    byte[] numArray = new byte[0];
    try
    {
      using (MemoryStream memoryStream = new MemoryStream())
      {
        memoryStream.Position = 32L;
        using (AesCryptoServiceProvider cryptoServiceProvider = new AesCryptoServiceProvider())
        {
          cryptoServiceProvider.KeySize = 128;
          cryptoServiceProvider.BlockSize = 128;
          cryptoServiceProvider.Mode = CipherMode.CBC;
          cryptoServiceProvider.Padding = PaddingMode.PKCS7;
          cryptoServiceProvider.Key = 湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.\uF7C6骶\uF500ロᒉ䬳쿷\uFFFD\uEE30섆㙫\u1756ࣲ搶ﳏ\u0CD0东䍜섡\u3192;
          cryptoServiceProvider.GenerateIV();
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, cryptoServiceProvider.CreateEncryptor(), CryptoStreamMode.Write))
          {
            memoryStream.Write(cryptoServiceProvider.IV, 0, cryptoServiceProvider.IV.Length);
            cryptoStream.Write(buffer, 0, buffer.Length);
            cryptoStream.FlushFinalBlock();
            using (HMACSHA256 hmacshA256 = new HMACSHA256(湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.㺫㭜\u264B\uF789ἴ蓑즰\u204E薧鰑ᴹ\uFFFD\uE21D\u086A蟞诈㩀ﶆᤛ麋))
            {
              byte[] hash = hmacshA256.ComputeHash(memoryStream.ToArray(), 32, memoryStream.ToArray().Length - 32);
              memoryStream.Position = 0L;
              memoryStream.Write(hash, 0, hash.Length);
            }
          }
        }
        numArray = memoryStream.ToArray();
      }
    }
    catch
    {
    }
    return numArray;
  }

  public static byte[] 舴뇓囆漯Ǐṟ쬵䰚祩듭큎洘뛔䳻푤鼫睩\uFFFDᰚ쥓(byte[] input, byte[] key)
  {
    if (key == null || key.Length == 0)
      throw new Exception("Key can not be empty.");
    byte[] bytes;
    using (Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(key, 湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.됐忱톧錚\u1775\uFFFD쎀괐ﰹ錘\u2F0C㪧憼ꃺ\u0A34\uF277䘆ﺉ絪\uFFFD, 50000))
    {
      key = rfc2898DeriveBytes.GetBytes(16);
      bytes = rfc2898DeriveBytes.GetBytes(64);
    }
    byte[] buffer = input;
    byte[] numArray = new byte[0];
    try
    {
      using (MemoryStream memoryStream = new MemoryStream())
      {
        memoryStream.Position = 32L;
        using (AesCryptoServiceProvider cryptoServiceProvider = new AesCryptoServiceProvider())
        {
          cryptoServiceProvider.KeySize = 128;
          cryptoServiceProvider.BlockSize = 128;
          cryptoServiceProvider.Mode = CipherMode.CBC;
          cryptoServiceProvider.Padding = PaddingMode.PKCS7;
          cryptoServiceProvider.Key = key;
          cryptoServiceProvider.GenerateIV();
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, cryptoServiceProvider.CreateEncryptor(), CryptoStreamMode.Write))
          {
            memoryStream.Write(cryptoServiceProvider.IV, 0, cryptoServiceProvider.IV.Length);
            cryptoStream.Write(buffer, 0, buffer.Length);
            cryptoStream.FlushFinalBlock();
            using (HMACSHA256 hmacshA256 = new HMACSHA256(bytes))
            {
              byte[] hash = hmacshA256.ComputeHash(memoryStream.ToArray(), 32, memoryStream.ToArray().Length - 32);
              memoryStream.Position = 0L;
              memoryStream.Write(hash, 0, hash.Length);
            }
          }
        }
        numArray = memoryStream.ToArray();
      }
    }
    catch
    {
    }
    return numArray;
  }

  public static string ᡝ懥瑜\uE014執䫎\uF748ᘖ̴妪뤰쉿\u20C5\u0EFE읷吓聨狼芅\uE8F2(string input) => Encoding.UTF8.GetString(湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.憲\uF525イ귉鏴䖹좍࿆제廰揆頻Ἳ棝᭫혍첀\uFFFD떣未(Convert.FromBase64String(input)));

  public static byte[] 憲\uF525イ귉鏴䖹좍࿆제廰揆頻Ἳ棝᭫혍첀\uFFFD떣未(byte[] input)
  {
    if (湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.\uF7C6骶\uF500ロᒉ䬳쿷\uFFFD\uEE30섆㙫\u1756ࣲ搶ﳏ\u0CD0东䍜섡\u3192 == null || 湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.\uF7C6骶\uF500ロᒉ䬳쿷\uFFFD\uEE30섆㙫\u1756ࣲ搶ﳏ\u0CD0东䍜섡\u3192.Length == 0)
      throw new Exception("Key can not be empty.");
    if (input == null || input.Length == 0)
      throw new ArgumentException("Input can not be empty.");
    byte[] dst = new byte[0];
    try
    {
      using (MemoryStream memoryStream = new MemoryStream(input))
      {
        using (AesCryptoServiceProvider cryptoServiceProvider = new AesCryptoServiceProvider())
        {
          cryptoServiceProvider.KeySize = 128;
          cryptoServiceProvider.BlockSize = 128;
          cryptoServiceProvider.Mode = CipherMode.CBC;
          cryptoServiceProvider.Padding = PaddingMode.PKCS7;
          cryptoServiceProvider.Key = 湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.\uF7C6骶\uF500ロᒉ䬳쿷\uFFFD\uEE30섆㙫\u1756ࣲ搶ﳏ\u0CD0东䍜섡\u3192;
          using (HMACSHA256 hmacshA256 = new HMACSHA256(湝增ﭞ嵇ʧ\uF2CD\uFFFD뜚罡ꈱ\u2B63\u2011퐖珎\u1CAD胂\uEF70ต댩\uEB37.㺫㭜\u264B\uF789ἴ蓑즰\u204E薧鰑ᴹ\uFFFD\uE21D\u086A蟞诈㩀ﶆᤛ麋))
          {
            byte[] hash = hmacshA256.ComputeHash(memoryStream.ToArray(), 32, memoryStream.ToArray().Length - 32);
            byte[] buffer = new byte[32];
            memoryStream.Read(buffer, 0, buffer.Length);
            byte[] a2 = buffer;
            if (!㹱Ý疻欁頎虿\uF466ힻ\uF7A0ɜﴃ\uFFFD탳ꆂ\u2F82儷垂熈\u221C㕉.砰\uF653尡吷龻わ暉\u2848\uF0F1耮\u088B䢨ﶙ했Ⲯ丏봢ᚩꤴ\uFFFD(hash, a2))
              return dst;
          }
          byte[] buffer1 = new byte[16];
          memoryStream.Read(buffer1, 0, 16);
          cryptoServiceProvider.IV = buffer1;
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, cryptoServiceProvider.CreateDecryptor(), CryptoStreamMode.Read))
          {
            byte[] numArray = new byte[memoryStream.Length - 16L + 1L];
            dst = new byte[cryptoStream.Read(numArray, 0, numArray.Length)];
            Buffer.BlockCopy((Array) numArray, 0, (Array) dst, 0, dst.Length);
          }
        }
      }
    }
    catch
    {
    }
    return dst;
  }
}
