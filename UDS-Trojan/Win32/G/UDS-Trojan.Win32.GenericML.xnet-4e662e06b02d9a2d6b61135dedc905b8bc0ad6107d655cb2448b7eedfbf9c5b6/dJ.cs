// Decompiled with JetBrains decompiler
// Type: jd.dJ
// Assembly: RuntimeFieldI, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3177D6BF-0678-437F-AD25-445C5521A270
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4e662e06b02d9a2d6b61135dedc905b8bc0ad6107d655cb2448b7eedfbf9c5b6.exe

using System;
using System.Runtime.InteropServices;

namespace jd
{
  internal class dJ
  {
    private static double z4c;
    private static dJ GYv;

    public static Tuple<double, Wl> g4H(Pm _param0, SY _param1)
    {
      Console.Write("\n\t\t\t  ~~~ МЕТОД РУНГЕ КУТТЫ ПРИ ");
      dJ.z4c = _param0.K4V / (double) _param1.N;
      Console.WriteLine(_param0.ToString() ?? "");
      Console.Write("\t\t\t  ~~~ n={0} h={1} ", (object) _param1.N, (object) dJ.z4c);
      Wl wl1 = _param1.TJq();
      Wl wl2 = new Wl(_param0.V4m);
      Wl wl3 = new Wl();
      for (int index = 0; index < _param1.N; ++index)
      {
        wl3.A42(0, 0.0);
        double num1 = 0.5 * (0.0 - wl2.e4L(0) * wl1.e4L(1) + wl2.e4L(1) * wl1.e4L(0) + wl2.e4L(2) * wl1.e4L(3) - wl2.e4L(3) * wl1.e4L(2));
        wl3.A42(1, num1 >= 0.0 ? _param1.GJE() : _param1.pJs());
        double num2 = 0.5 * (0.0 - wl2.e4L(0) * wl1.e4L(2) + wl2.e4L(2) * wl1.e4L(0) + wl2.e4L(3) * wl1.e4L(1) - wl2.e4L(1) * wl1.e4L(3));
        wl3.A42(2, num2 >= 0.0 ? _param1.GJE() : _param1.pJs());
        double num3 = 0.5 * (0.0 - wl2.e4L(0) * wl1.e4L(3) + wl2.e4L(1) * wl1.e4L(2) + wl2.e4L(3) * wl1.e4L(0) - wl2.e4L(2) * wl1.e4L(1));
        wl3.A42(3, num3 >= 0.0 ? _param1.GJE() : _param1.pJs());
        Wl wl4 = dJ.g4a(wl2, wl3, index);
        Wl wl5 = dJ.g4a(wl1, wl3, index);
        wl2 = wl4;
        wl1 = wl5;
      }
      Console.WriteLine("\n\t\t\t  ~~~ РЕЗУЛЬТАТЫ:\n\t\t\t  ~~~ НОРМА ПОСЛЕ: {0} НОРМА ДО: {1}", (object) wl1.R4W(), (object) _param1.TJq().R4W());
      Console.WriteLine("\t\t\t  ~~~ ПОЛУЧЕНО lambda(T) = {0}\n\t\t\t  ~~~ ЗАДАЧА lambda(T) = {1}", (object) wl1.ToString(), (object) _param1.uJK().ToString());
      return new Tuple<double, Wl>(dJ.R4e(wl2, wl3, wl1), wl1);
    }

    private static Wl C4r(Wl _param0, Wl _param1)
    {
      Wl wl = (Wl) dJ.XYB(0.5, (object) (_param0 % _param1));
      int num = 0;
      if (dJ.sYJ() == null)
        goto label_3;
label_1:
      switch (num)
      {
        default:
          return wl;
      }
label_3:
      num = 0;
      goto label_1;
    }

    private static double R4e(Wl _param0, Wl _param1, Wl _param2) => _param0 / (Wl) dJ.XYB(0.5, (object) (_param2 % _param1)) - 1.0;

    private static Wl g4a(Wl _param0, Wl _param1, int _param2)
    {
      Wl wl1 = dJ.z4c * (Wl) dJ.LY5((object) _param0, (object) _param1);
      Wl wl2 = dJ.z4c * dJ.C4r(_param0 + 0.5 * wl1, _param1);
      int num1 = 0;
      if (dJ.sYJ() != null)
        goto label_4;
label_1:
      Wl wl3;
      switch (num1)
      {
        case 1:
          return wl3;
        default:
          Wl wl4 = dJ.z4c * dJ.C4r(_param0 + 0.5 * wl2, _param1);
          Wl wl5 = dJ.z4c * dJ.C4r(_param0 + wl4, _param1);
          wl3 = _param0 + 1.0 / 6.0 * (Wl) dJ.AYd((object) (wl1 + 2.0 * wl2 + 2.0 * wl4), (object) wl5);
          goto case 1;
      }
label_4:
      int num2;
      num1 = num2;
      goto label_1;
    }

    public dJ()
    {
      dJ.FYW();
      // ISSUE: explicit constructor call
      base.\u002Ector();
    }

    internal static object XYB(double _param0, [In] object obj1) => (object) (_param0 * (Wl) obj1);

    internal static bool PY9() => dJ.GYv == null;

    internal static dJ sYJ() => dJ.GYv;

    internal static object LY5([In] object obj0, [In] object obj1) => (object) dJ.C4r((Wl) obj0, (Wl) obj1);

    internal static object AYd([In] object obj0, [In] object obj1) => (object) ((Wl) obj0 + (Wl) obj1);

    internal static void FYW() => gs.JD3Ei4();
  }
}
