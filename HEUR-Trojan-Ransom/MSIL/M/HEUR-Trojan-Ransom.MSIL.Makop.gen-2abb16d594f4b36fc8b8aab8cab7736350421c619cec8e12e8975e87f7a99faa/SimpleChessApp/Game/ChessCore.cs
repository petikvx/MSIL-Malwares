// Decompiled with JetBrains decompiler
// Type: SimpleChessApp.Game.ChessCore
// Assembly: طv, Version=2.159.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8DDF840D-AD0E-4D2F-A03C-7E334C2C97A3
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.01-msil\HEUR-Trojan-Ransom.MSIL.Makop.gen-2abb16d594f4b36fc8b8aab8cab7736350421c619cec8e12e8975e87f7a99faa.exe

namespace SimpleChessApp.Game
{
  public class ChessCore
  {
    public Board ChessBoard;
    public PieceColor WhosPlaying;
    public bool DisableTurn;
    public int TurnId = 1;
    public Square lastCheckPiece;
    public Square ghostCheckPiece;
    public Square LastMove;
    public NotationManager Turns = new NotationManager();
    public bool firstClick = true;
    public Square lastSquare;

    public ChessCore(Board b)
    {
label_1:
      int num1 = -1903264842;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -1806317145)) % 6U)
        {
          case 0:
            num1 = (int) num2 * -1135516386 ^ -21947894;
            continue;
          case 1:
            goto label_3;
          case 2:
            goto label_1;
          case 3:
            this.ChessBoard = b;
            this.resetFlags();
            num1 = (int) num2 * 1310067929 ^ 2019407096;
            continue;
          case 4:
            num1 = (int) num2 * -2083406242 ^ -1489157192;
            continue;
          case 5:
            num1 = (int) num2 * -1855817981 ^ -1576047282;
            continue;
          default:
            goto label_8;
        }
      }
label_3:
      return;
label_8:;
    }

    public ChessCore()
    {
label_1:
      int num1 = -122118039;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -1789832854)) % 3U)
        {
          case 0:
            goto label_1;
          case 1:
            num1 = (int) num2 * -15377259 ^ 1935158504;
            continue;
          case 2:
            goto label_3;
          default:
            goto label_5;
        }
      }
label_3:
      return;
label_5:;
    }

    public void RestartGame()
    {
label_1:
      int num1 = -1133562686;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -119257661)) % 4U)
        {
          case 0:
            goto label_1;
          case 1:
            this.resetFlags();
            num1 = (int) num2 * -14874602 ^ -903117757;
            continue;
          case 2:
            this.ChessBoard.Restart();
            num1 = (int) num2 * -1045262230 ^ -2052243136;
            continue;
          case 3:
            goto label_3;
          default:
            goto label_6;
        }
      }
label_3:
      return;
label_6:;
    }

    private void resetFlags(bool turn = false)
    {
label_1:
      int num1 = 229358255;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 679012065)) % 4U)
        {
          case 1:
            this.TurnId = 1;
            this.lastCheckPiece = (Square) null;
            num1 = (int) num2 * -1308972657 ^ 1623570994;
            continue;
          case 2:
            this.DisableTurn = turn;
            this.WhosPlaying = PieceColor.White;
            num1 = (int) num2 * -242216325 ^ 1869068382;
            continue;
          case 3:
            goto label_1;
          default:
            goto label_5;
        }
      }
label_5:
      this.Turns.Clear();
    }

    internal void TestPassant()
    {
      new DebugChess(this.ChessBoard).TestPassant();
label_1:
      int num1 = -1551233622;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -10928867)) % 5U)
        {
          case 0:
            goto label_1;
          case 1:
            this.resetFlags(true);
            num1 = (int) num2 * -1639311793 ^ -487755938;
            continue;
          case 2:
            num1 = (int) num2 * 912085152 ^ 4169260;
            continue;
          case 3:
            goto label_3;
          case 4:
            num1 = (int) num2 * -799235033 ^ 1963981509;
            continue;
          default:
            goto label_7;
        }
      }
label_3:
      return;
label_7:;
    }

    internal void TestSinglePiece(Pieces x)
    {
label_1:
      int num1 = 1437696364;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 1958879192)) % 5U)
        {
          case 0:
            this.resetFlags(true);
            num1 = (int) num2 * -2008469689 ^ -1619824734;
            continue;
          case 1:
            new DebugChess(this.ChessBoard).TestSinglePiece(x);
            num1 = (int) num2 * -425470410 ^ 1519773141;
            continue;
          case 2:
            num1 = (int) num2 * -1606547480 ^ -2032260535;
            continue;
          case 3:
            goto label_3;
          case 4:
            goto label_1;
          default:
            goto label_7;
        }
      }
label_3:
      return;
label_7:;
    }

    internal void TestCastling()
    {
      new DebugChess(this.ChessBoard).TestCastling();
      this.resetFlags(true);
    }

    internal void TestCheck()
    {
      new DebugChess(this.ChessBoard).TestCheck();
label_1:
      int num1 = -697856655;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -655420729)) % 3U)
        {
          case 0:
            goto label_1;
          case 1:
            goto label_3;
          case 2:
            this.resetFlags(true);
            num1 = (int) num2 * -105226452 ^ -1492163822;
            continue;
          default:
            goto label_5;
        }
      }
label_3:
      return;
label_5:;
    }

    internal void TestDiscoverCheck()
    {
label_1:
      int num1 = -1197740154;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -268896447)) % 5U)
        {
          case 0:
            goto label_1;
          case 1:
            num1 = (int) num2 * 1903039553 ^ -1893423369;
            continue;
          case 2:
            this.resetFlags(true);
            num1 = (int) num2 * -716201095 ^ -246683382;
            continue;
          case 3:
            goto label_3;
          case 4:
            new DebugChess(this.ChessBoard).TestDiscoverCheck();
            num1 = (int) num2 * -261603076 ^ -1199226710;
            continue;
          default:
            goto label_7;
        }
      }
label_3:
      return;
label_7:;
    }

    internal void TestPromotion()
    {
label_1:
      int num1 = -774788824;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -1866105901)) % 4U)
        {
          case 0:
            goto label_1;
          case 1:
            this.resetFlags(true);
            num1 = (int) num2 * -440177772 ^ 1915401749;
            continue;
          case 2:
            goto label_3;
          case 3:
            new DebugChess(this.ChessBoard).TestPromotion();
            num1 = (int) num2 * 617754651 ^ -1904192089;
            continue;
          default:
            goto label_6;
        }
      }
label_3:
      return;
label_6:;
    }

    internal void CheckOnCastling()
    {
      new DebugChess(this.ChessBoard).CheckOnCastling();
label_1:
      int num1 = 2084003731;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 2135674301)) % 3U)
        {
          case 0:
            goto label_3;
          case 1:
            this.resetFlags(true);
            num1 = (int) num2 * -395771714 ^ 1270506428;
            continue;
          case 2:
            goto label_1;
          default:
            goto label_5;
        }
      }
label_3:
      return;
label_5:;
    }
  }
}
