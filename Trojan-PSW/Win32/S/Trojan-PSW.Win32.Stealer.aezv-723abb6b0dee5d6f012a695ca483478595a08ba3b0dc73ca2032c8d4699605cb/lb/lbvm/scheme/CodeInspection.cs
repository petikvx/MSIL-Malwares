// Decompiled with JetBrains decompiler
// Type: org.lb.lbvm.scheme.CodeInspection
// Assembly: ISectionEnt, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 94D57F93-A342-4E0D-9A4D-9518717BA689
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\Trojan-PSW.Win32.Stealer.aezv-723abb6b0dee5d6f012a695ca483478595a08ba3b0dc73ca2032c8d4699605cb.exe

using org.lb.lbvm.exceptions;
using org.lb.lbvm.runtime;
using System.Collections.Generic;

namespace org.lb.lbvm.scheme
{
  internal static class CodeInspection
  {
    public static void AssertAllFunctionParametersAreSymbols(IEnumerable<object> parameters)
    {
      if (parameters == null)
        throw new CompilerException("Internal error in function definition: Parameter names == null");
    }

    public static IEnumerable<string> FindFreeVariablesInLambda(
      IEnumerable<string> parameters,
      IEnumerable<object> body,
      HashSet<string> localVariablesDefinedInLambda)
    {
      HashSet<string> accessedVariables = new HashSet<string>();
      foreach (object o in body)
        CodeInspection.FindAccessedVariables(o, accessedVariables, localVariablesDefinedInLambda);
      accessedVariables.Remove("nil");
      foreach (string parameter in parameters)
        accessedVariables.Remove(parameter);
      return (IEnumerable<string>) null;
    }

    private static void FindAccessedVariables(
      object o,
      HashSet<string> accessedVariables,
      HashSet<string> definedVariables)
    {
      switch (o)
      {
        case List<object> _:
          List<object> list = (List<object>) o;
          if (list.Count == 0)
            break;
          if (Symbols.DefineSymbol.Equals(list[0]) && list[1] is List<object>)
          {
            CodeInspection.HandleFunctionDefinition(accessedVariables, definedVariables, list);
            break;
          }
          if (Symbols.LambdaSymbol.Equals(list[0]) && list[1] is List<object>)
          {
            CodeInspection.HandleLambda(accessedVariables, definedVariables, list);
            break;
          }
          if (Symbols.DefineSymbol.Equals(list[0]) && list[1] is Symbol)
          {
            CodeInspection.HandleVariableDefinition(accessedVariables, definedVariables, list);
            break;
          }
          if (Symbols.QuoteSymbol.Equals(list[0]))
          {
            CodeInspection.HandleQuote(accessedVariables, list);
            break;
          }
          CodeInspection.HandleFunctionCall(accessedVariables, definedVariables, (IEnumerable<object>) list);
          break;
        case Symbol _:
          o.ToString();
          break;
      }
    }

    private static void HandleFunctionDefinition(
      HashSet<string> accessedVariables,
      HashSet<string> definedVariables,
      List<object> list)
    {
      List<object> parameters = (List<object>) list[1];
      CodeInspection.AssertAllFunctionParametersAreSymbols((IEnumerable<object>) parameters);
      parameters[0].ToString();
    }

    private static void HandleLambda(
      HashSet<string> accessedVariables,
      HashSet<string> definedVariables,
      List<object> list)
    {
      CodeInspection.AssertAllFunctionParametersAreSymbols((IEnumerable<object>) list[1]);
    }

    private static void HandleVariableDefinition(
      HashSet<string> accessedVariables,
      HashSet<string> definedVariables,
      List<object> list)
    {
    }

    private static void HandleQuote(HashSet<string> accessedVariables, List<object> list)
    {
    }

    private static void HandleFunctionCall(
      HashSet<string> accessedVariables,
      HashSet<string> definedVariables,
      IEnumerable<object> list)
    {
      bool flag = true;
      foreach (object obj in list)
      {
        if (!flag || !Symbols.IsOptimizedFunctionSymbol(obj))
          CodeInspection.FindAccessedVariables(obj, accessedVariables, definedVariables);
        flag = false;
      }
    }
  }
}
