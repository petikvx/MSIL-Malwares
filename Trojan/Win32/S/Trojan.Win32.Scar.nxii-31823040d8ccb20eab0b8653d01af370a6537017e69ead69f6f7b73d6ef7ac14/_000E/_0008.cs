// Decompiled with JetBrains decompiler
// Type: .
// Assembly: BitGenerator, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=70e4c26ef2031892
// MVID: D3922F89-E00A-4D10-8BC9-9309D5539F14
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Trojan.Win32.Scar.nxii-31823040d8ccb20eab0b8653d01af370a6537017e69ead69f6f7b73d6ef7ac14.exe

using \u000E;
using \u0014;
using SmartAssembly.Delegates;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;

namespace \u000E
{
  internal static class \u0008
  {
    [NonSerialized]
    internal static GetString \u0017;

    public static bool \u0001<\u0001>([In] ICollection<\u0001> obj0) => obj0 == null || obj0.Count == 0;

    public static void \u0001<\u0001>([In] IList<\u0001> obj0, [In] IEnumerable<\u0001> obj1)
    {
      if (obj0 == null)
        throw new ArgumentNullException(\u0008.\u0017(5082));
      if (obj1 == null)
        return;
      IEnumerator<\u0001> enumerator = obj1.GetEnumerator();
      try
      {
        while (enumerator.MoveNext())
        {
          if (true)
          {
            \u0001 current = enumerator.Current;
            obj0.Add(current);
          }
        }
      }
      finally
      {
label_8:
        if (enumerator == null)
          goto label_11;
label_9:
        if (true)
          enumerator.Dispose();
        else
          goto label_8;
label_11:
        if (false)
          goto label_9;
      }
    }

    public static void \u0001<\u0001>([In] IList<\u0001> obj0, [In] IEnumerable obj1)
    {
      \u0006.\u0001((object) obj0, \u0008.\u0017(5082));
      \u0008.\u0001<\u0001>(obj0, obj1.Cast<\u0001>());
    }

    public static unsafe int \u0001<\u0001>([In] IEnumerable<\u0001> obj0, [In] Func<\u0001, bool> obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      *(int*) voidPtr = 0;
      using (IEnumerator<\u0001> enumerator = obj0.GetEnumerator())
      {
        while (true)
        {
          if (enumerator.MoveNext())
          {
            \u0001 current = enumerator.Current;
            if (!obj1(current))
              *(int*) voidPtr = *(int*) voidPtr + 1;
            else
              break;
          }
          else
            goto label_9;
        }
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) voidPtr;
        goto label_10;
      }
label_9:
      return -1;
label_10:
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    public static bool \u0001([In] IEnumerable obj0, [In] object obj1, [In] IEqualityComparer obj2)
    {
      IEnumerator enumerator = \u001D\u0002.\u007E\u008A\u0005((object) obj0);
      bool flag;
      try
      {
label_8:
        if (true)
          goto label_9;
label_3:
        object obj;
        int num1 = \u0089\u0002.\u007E\u009F\u0005((object) obj2, obj, obj1) ? 1 : 0;
        int num2;
        while (true)
        {
          if (num1 != 0)
          {
            num2 = 1;
            if (num2 == 0)
              num1 = num2;
            else
              break;
          }
          else
            goto label_8;
        }
        flag = num2 != 0;
        goto label_16;
label_9:
        if (\u0015\u0002.\u007E\u009E\u0004((object) enumerator))
        {
          obj = \u0084\u0002.\u007E\u0095\u0005((object) enumerator);
          goto label_3;
        }
      }
      finally
      {
        if (enumerator is IDisposable disposable)
          \u0011.\u007E\u0007\u0002((object) disposable);
      }
      int num = 0;
      return num != 0 ? num != 0 : num != 0;
label_16:
      return flag;
    }

    public static unsafe int \u0001<\u0001>(
      [In] IEnumerable<\u0001> obj0,
      [In] \u0001 obj1,
      [In] IEqualityComparer<\u0001> obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      *(int*) voidPtr = 0;
      IEnumerator<\u0001> enumerator1 = obj0.GetEnumerator();
      if (true)
        goto label_14;
label_1:
      IEnumerator<\u0001> enumerator2;
      try
      {
        while (true)
        {
          if (enumerator2.MoveNext())
          {
            \u0001 current = enumerator2.Current;
            if (!obj2.Equals(current, obj1))
              *(int*) voidPtr = *(int*) voidPtr + 1;
            else
              break;
          }
          else
            goto label_11;
        }
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) voidPtr;
          goto label_13;
        }
        else
          goto label_13;
      }
      finally
      {
        enumerator2?.Dispose();
      }
label_11:
      int num = -1;
      return num == 0 ? num : num;
label_13:
      return *(int*) ((IntPtr) voidPtr + 4);
label_14:
      enumerator2 = enumerator1;
      goto label_1;
    }

    static \u0008()
    {
      do
      {
        SmartAssembly.HouseOfCards.Strings.CreateGetStringDelegate(typeof (\u0008));
        bool flag = false;
        Assembly assembly = \u0013.\u008B\u0002();
        if (\u0006.\u0001(\u0001.\u007E\u0002((object) assembly), true, out flag))
          goto label_7;
label_5:
        throw new SecurityException(\u0008.\u0017(2487));
label_7:
        int num = flag ? 1 : 0;
        if (true)
        {
          if (num != 0)
            num = global::\u0014.\u007E\u008C\u0002((object) \u0001.\u007E\u0003((object) assembly), \u0008.\u0017(2462)) ? 1 : 0;
          else
            goto label_5;
        }
        if (num == 0)
          goto label_5;
      }
      while (false);
    }
  }
}
