// Decompiled with JetBrains decompiler
// Type: ᠟ዱↂ突꬏廠⑔륫⛹㠂䒖࿫慥䡋磺扩썜ﺤ梘
// Assembly: $77-Venom, Version=2.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC8E8704-647D-4CA7-99AB-BB7BE936B486
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Zapchast.gen-815b2bf1ddadfb46a27001e08246e8f82f629eb793963bef856d17e1ef9c4085.exe

using System;
using System.IO;

public class \u181Fዱↂ突\uAB0F廠\u2454륫\u26F9㠂䒖\u0FEB慥䡋\uEC55磺扩썜ﺤ梘
{
  private int 蠐猘덿釃졺緊ࠀ䖿ꝃﹲ駹ᴩ칳\uF050Ը\uF2AB㣨겾監霊;
  private readonly object ꝰ詜䜸듨썞\uEF80䱌\uE11A㽭ᗔ\u2888歭끰\uE6C9菕帚䒟ሓv齰 = new object();
  private const int \uE366큂鉘\uE513ᓃ䊰ן婠\uF2B3ꃉ\uEDF7罃\u2201㻰\uFFFD\uE13E剁첦㐼ී = 65535;

  public string Path { get; private set; }

  public string LastError { get; private set; }

  public int MaxBlocks
  {
    get
    {
      if (this.蠐猘덿釃졺緊ࠀ䖿ꝃﹲ駹ᴩ칳\uF050Ը\uF2AB㣨겾監霊 <= 0)
      {
        if (this.蠐猘덿釃졺緊ࠀ䖿ꝃﹲ駹ᴩ칳\uF050Ը\uF2AB㣨겾監霊 != -1)
        {
          try
          {
            FileInfo fileInfo = new FileInfo(this.Path);
            this.蠐猘덿釃졺緊ࠀ䖿ꝃﹲ駹ᴩ칳\uF050Ը\uF2AB㣨겾監霊 = fileInfo.Exists ? (int) Math.Ceiling((double) fileInfo.Length / (double) ushort.MaxValue) : throw new FileNotFoundException();
          }
          catch (UnauthorizedAccessException ex)
          {
            this.蠐猘덿釃졺緊ࠀ䖿ꝃﹲ駹ᴩ칳\uF050Ը\uF2AB㣨겾監霊 = -1;
            this.LastError = "Access denied";
          }
          catch (IOException ex)
          {
            this.蠐猘덿釃졺緊ࠀ䖿ꝃﹲ駹ᴩ칳\uF050Ը\uF2AB㣨겾監霊 = -1;
            if (ex is FileNotFoundException)
              this.LastError = "File not found";
            if (ex is PathTooLongException)
              this.LastError = "Path is too long";
          }
          return this.蠐猘덿釃졺緊ࠀ䖿ꝃﹲ駹ᴩ칳\uF050Ը\uF2AB㣨겾監霊;
        }
      }
      return this.蠐猘덿釃졺緊ࠀ䖿ꝃﹲ駹ᴩ칳\uF050Ը\uF2AB㣨겾監霊;
    }
  }

  public \u181Fዱↂ突\uAB0F廠\u2454륫\u26F9㠂䒖\u0FEB慥䡋\uEC55磺扩썜ﺤ梘(string path) => this.Path = path;

  private int 겖\u0BD3ᳯ啳趶ㄝ\u0DFCꛅㇰ擕䇖歓췑輾얚얙Ꙓ\uF0B7\uE63D\uFFFD(long length) => length >= (long) ushort.MaxValue ? (int) ushort.MaxValue : (int) length;

  public bool \u28B1\uE060唸艥鏖ꡥ\uF66C\uFFFD虠眚鷳\u3280㯅咅忭宨䢭묉\uE9EB\u33A8(
    int blockNumber,
    out byte[] readBytes)
  {
    try
    {
      if (blockNumber > this.MaxBlocks)
        throw new ArgumentOutOfRangeException();
      lock (this.ꝰ詜䜸듨썞\uEF80䱌\uE11A㽭ᗔ\u2888歭끰\uE6C9菕帚䒟ሓv齰)
      {
        using (FileStream fileStream = File.OpenRead(this.Path))
        {
          if (blockNumber == 0)
          {
            fileStream.Seek(0L, SeekOrigin.Begin);
            long length = fileStream.Length - fileStream.Position;
            readBytes = length >= 0L ? new byte[this.겖\u0BD3ᳯ啳趶ㄝ\u0DFCꛅㇰ擕䇖歓췑輾얚얙Ꙓ\uF0B7\uE63D\uFFFD(length)] : throw new IOException("negative length");
            fileStream.Read(readBytes, 0, readBytes.Length);
          }
          else
          {
            fileStream.Seek((long) (blockNumber * (int) ushort.MaxValue), SeekOrigin.Begin);
            long length = fileStream.Length - fileStream.Position;
            readBytes = length >= 0L ? new byte[this.겖\u0BD3ᳯ啳趶ㄝ\u0DFCꛅㇰ擕䇖歓췑輾얚얙Ꙓ\uF0B7\uE63D\uFFFD(length)] : throw new IOException("negative length");
            fileStream.Read(readBytes, 0, readBytes.Length);
          }
        }
      }
      return true;
    }
    catch (ArgumentOutOfRangeException ex)
    {
      readBytes = new byte[0];
      this.LastError = "BlockNumber bigger than MaxBlocks";
    }
    catch (UnauthorizedAccessException ex)
    {
      readBytes = new byte[0];
      this.LastError = "Access denied";
    }
    catch (IOException ex)
    {
      readBytes = new byte[0];
      switch (ex)
      {
        case FileNotFoundException _:
          this.LastError = "File not found";
          break;
        case DirectoryNotFoundException _:
          this.LastError = "Directory not found";
          break;
        case PathTooLongException _:
          this.LastError = "Path is too long";
          break;
        default:
          this.LastError = "Unable to read from File Stream";
          break;
      }
    }
    return false;
  }

  public bool 먯熚䀍\uE766ᖌ㜰垺ƛ䋽㟎ꝷ\uF2AE탛Ї复샆\uE763ষ䤌랶(byte[] block, int blockNumber)
  {
    try
    {
      if (!File.Exists(this.Path) && blockNumber > 0)
        throw new FileNotFoundException();
      lock (this.ꝰ詜䜸듨썞\uEF80䱌\uE11A㽭ᗔ\u2888歭끰\uE6C9菕帚䒟ሓv齰)
      {
        if (blockNumber == 0)
        {
          using (FileStream fileStream = File.Open(this.Path, FileMode.Create, FileAccess.Write))
          {
            fileStream.Seek(0L, SeekOrigin.Begin);
            fileStream.Write(block, 0, block.Length);
          }
          return true;
        }
        using (FileStream fileStream = File.Open(this.Path, FileMode.Append, FileAccess.Write))
        {
          fileStream.Seek((long) (blockNumber * (int) ushort.MaxValue), SeekOrigin.Begin);
          fileStream.Write(block, 0, block.Length);
        }
      }
      return true;
    }
    catch (UnauthorizedAccessException ex)
    {
      this.LastError = "Access denied";
    }
    catch (IOException ex)
    {
      switch (ex)
      {
        case FileNotFoundException _:
          this.LastError = "File not found";
          break;
        case DirectoryNotFoundException _:
          this.LastError = "Directory not found";
          break;
        case PathTooLongException _:
          this.LastError = "Path is too long";
          break;
        default:
          this.LastError = "Unable to write to File Stream";
          break;
      }
    }
    return false;
  }
}
