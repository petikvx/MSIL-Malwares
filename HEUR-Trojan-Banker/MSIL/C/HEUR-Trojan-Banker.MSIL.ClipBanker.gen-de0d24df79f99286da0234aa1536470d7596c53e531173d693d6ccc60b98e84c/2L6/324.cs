// Decompiled with JetBrains decompiler
// Type: 2L6.324
// Assembly: uc5uTlQKZwvBJeUwoIoxWYL1o3uBI8gaMfnT9AO, Version=9.8.6.0, Culture=neutral, PublicKeyToken=null
// MVID: 66B519F9-803D-46C9-8343-EC24850CA08A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-de0d24df79f99286da0234aa1536470d7596c53e531173d693d6ccc60b98e84c.exe

using \u0032L6;
using \u0034i2;
using \u0034ke;
using \u0035H3;
using \u0038Gu;
using A6y;
using g5V;
using Qlv;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using t28;

namespace \u0032L6
{
  internal static class \u003324
  {
    public static bool ZB7(
      [In] Stream obj0,
      [In] ICollection<q14> obj1,
      [In] uint obj2,
      [In] \u0033RZ obj3,
      [In] string obj4,
      [In] \u0033rn obj5)
    {
      if (obj0 is \u0035yQ obj6)
        obj6.u61(true);
      long num1 = 0;
      using (MemoryStream memoryStream = new MemoryStream())
      {
        foreach (q14 q14 in (IEnumerable<q14>) obj1)
        {
          if (q14.\u0032vs)
            q14.\u0036Jb((Stream) memoryStream);
        }
        byte[] array = memoryStream.ToArray();
        obj0.Write(array, 0, array.Length);
        num1 = (long) array.Length;
      }
      long num2 = obj0 is \u0036IA obj7 ? obj7.Kpw() : obj0.Position;
      long num3 = num2 - num1;
      uint num4 = obj6 != null ? obj6.\u0031pq() : 0U;
      long num5 = num2 - num3;
      int num6 = \u003324.\u00325U(obj1);
      int num7 = obj3 == \u0033RZ.\u0023d || num6 >= (int) ushort.MaxValue || num5 > (long) uint.MaxValue ? 1 : (num3 > (long) uint.MaxValue ? 1 : 0);
      byte[] numArray1;
      if (num7 != 0)
      {
        if (obj3 == \u0033RZ.\u0023a)
        {
          if (new StackFrame(1).GetMethod().DeclaringType == typeof (\u0032f3))
            throw new xZi("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property.");
          throw new xZi("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property.");
        }
        byte[] numArray2 = \u003324.\u0036D4(num3, num2, num6, obj2);
        numArray1 = \u003324.t72(num3, num2, obj3, num6, obj4, obj5);
        if (num4 != 0U)
        {
          int num8 = (int) obj6.\u003763(numArray2.Length + numArray1.Length);
          int destinationIndex1 = 16;
          Array.Copy((Array) BitConverter.GetBytes((uint) num8), 0, (Array) numArray2, destinationIndex1, 4);
          int destinationIndex2 = destinationIndex1 + 4;
          Array.Copy((Array) BitConverter.GetBytes((uint) num8), 0, (Array) numArray2, destinationIndex2, 4);
          int destinationIndex3 = 60;
          Array.Copy((Array) BitConverter.GetBytes((uint) num8), 0, (Array) numArray2, destinationIndex3, 4);
          int destinationIndex4 = destinationIndex3 + 4 + 8;
          Array.Copy((Array) BitConverter.GetBytes((uint) num8), 0, (Array) numArray2, destinationIndex4, 4);
        }
        obj0.Write(numArray2, 0, numArray2.Length);
      }
      else
        numArray1 = \u003324.t72(num3, num2, obj3, num6, obj4, obj5);
      if (num4 != 0U)
      {
        int num9 = (int) (ushort) obj6.\u003763(numArray1.Length);
        int destinationIndex5 = 4;
        Array.Copy((Array) BitConverter.GetBytes((ushort) num9), 0, (Array) numArray1, destinationIndex5, 2);
        int destinationIndex6 = destinationIndex5 + 2;
        Array.Copy((Array) BitConverter.GetBytes((ushort) num9), 0, (Array) numArray1, destinationIndex6, 2);
        int num10 = destinationIndex6 + 2;
      }
      obj0.Write(numArray1, 0, numArray1.Length);
      if (obj6 == null)
        return num7 != 0;
      obj6.u61(false);
      return num7 != 0;
    }

    private static Encoding \u003553([In] \u0033rn obj0, [In] string obj1)
    {
      switch (obj0.tN9())
      {
        case VR4.\u0023a:
          return obj0.\u003778();
        case VR4.\u0023d:
          return obj0.q3M();
        default:
          Encoding encoding = obj0.\u003778();
          if (obj1 == null)
            return encoding;
          byte[] bytes = encoding.GetBytes(obj1);
          return encoding.GetString(bytes, 0, bytes.Length).Equals(obj1) ? encoding : obj0.q3M();
      }
    }

    private static byte[] t72(
      [In] long obj0,
      [In] long obj1,
      [In] \u0033RZ obj2,
      [In] int obj3,
      [In] string obj4,
      [In] \u0033rn obj5)
    {
      Encoding encoding = \u003324.\u003553(obj5, obj4);
      byte[] numArray1 = (byte[]) null;
      short num1 = 0;
      switch (obj4)
      {
        case "":
        case null:
          byte[] destinationArray = new byte[22 + (int) num1];
          int destinationIndex = 0;
          Array.Copy((Array) BitConverter.GetBytes(101010256U), 0, (Array) destinationArray, destinationIndex, 4);
          int num2 = destinationIndex + 4;
          byte[] numArray2 = destinationArray;
          int index1 = num2;
          int num3 = index1 + 1;
          numArray2[index1] = (byte) 0;
          byte[] numArray3 = destinationArray;
          int index2 = num3;
          int num4 = index2 + 1;
          numArray3[index2] = (byte) 0;
          byte[] numArray4 = destinationArray;
          int index3 = num4;
          int num5 = index3 + 1;
          numArray4[index3] = (byte) 0;
          byte[] numArray5 = destinationArray;
          int index4 = num5;
          int num6 = index4 + 1;
          numArray5[index4] = (byte) 0;
          if (obj3 >= (int) ushort.MaxValue || obj2 == \u0033RZ.\u0023d)
          {
            for (int index5 = 0; index5 < 4; ++index5)
              destinationArray[num6++] = byte.MaxValue;
          }
          else
          {
            byte[] numArray6 = destinationArray;
            int index6 = num6;
            int num7 = index6 + 1;
            int num8 = (int) (byte) (obj3 & (int) byte.MaxValue);
            numArray6[index6] = (byte) num8;
            byte[] numArray7 = destinationArray;
            int index7 = num7;
            int num9 = index7 + 1;
            int num10 = (int) (byte) ((obj3 & 65280) >> 8);
            numArray7[index7] = (byte) num10;
            byte[] numArray8 = destinationArray;
            int index8 = num9;
            int num11 = index8 + 1;
            int num12 = (int) (byte) (obj3 & (int) byte.MaxValue);
            numArray8[index8] = (byte) num12;
            byte[] numArray9 = destinationArray;
            int index9 = num11;
            num6 = index9 + 1;
            int num13 = (int) (byte) ((obj3 & 65280) >> 8);
            numArray9[index9] = (byte) num13;
          }
          long num14 = obj1 - obj0;
          if (num14 >= (long) uint.MaxValue || obj0 >= (long) uint.MaxValue)
          {
            for (int index10 = 0; index10 < 8; ++index10)
              destinationArray[num6++] = byte.MaxValue;
          }
          else
          {
            byte[] numArray10 = destinationArray;
            int index11 = num6;
            int num15 = index11 + 1;
            int num16 = (int) (byte) ((ulong) num14 & (ulong) byte.MaxValue);
            numArray10[index11] = (byte) num16;
            byte[] numArray11 = destinationArray;
            int index12 = num15;
            int num17 = index12 + 1;
            int num18 = (int) (byte) ((num14 & 65280L) >> 8);
            numArray11[index12] = (byte) num18;
            byte[] numArray12 = destinationArray;
            int index13 = num17;
            int num19 = index13 + 1;
            int num20 = (int) (byte) ((num14 & 16711680L) >> 16);
            numArray12[index13] = (byte) num20;
            byte[] numArray13 = destinationArray;
            int index14 = num19;
            int num21 = index14 + 1;
            int num22 = (int) (byte) ((num14 & 4278190080L) >> 24);
            numArray13[index14] = (byte) num22;
            byte[] numArray14 = destinationArray;
            int index15 = num21;
            int num23 = index15 + 1;
            int num24 = (int) (byte) ((ulong) obj0 & (ulong) byte.MaxValue);
            numArray14[index15] = (byte) num24;
            byte[] numArray15 = destinationArray;
            int index16 = num23;
            int num25 = index16 + 1;
            int num26 = (int) (byte) ((obj0 & 65280L) >> 8);
            numArray15[index16] = (byte) num26;
            byte[] numArray16 = destinationArray;
            int index17 = num25;
            int num27 = index17 + 1;
            int num28 = (int) (byte) ((obj0 & 16711680L) >> 16);
            numArray16[index17] = (byte) num28;
            byte[] numArray17 = destinationArray;
            int index18 = num27;
            num6 = index18 + 1;
            int num29 = (int) (byte) ((obj0 & 4278190080L) >> 24);
            numArray17[index18] = (byte) num29;
          }
          int num30;
          switch (obj4)
          {
            case "":
            case null:
              byte[] numArray18 = destinationArray;
              int index19 = num6;
              int num31 = index19 + 1;
              numArray18[index19] = (byte) 0;
              byte[] numArray19 = destinationArray;
              int index20 = num31;
              num30 = index20 + 1;
              numArray19[index20] = (byte) 0;
              break;
            default:
              if ((int) num1 + num6 + 2 > destinationArray.Length)
                num1 = (short) (destinationArray.Length - num6 - 2);
              byte[] numArray20 = destinationArray;
              int index21 = num6;
              int num32 = index21 + 1;
              int num33 = (int) (byte) ((uint) num1 & (uint) byte.MaxValue);
              numArray20[index21] = (byte) num33;
              byte[] numArray21 = destinationArray;
              int index22 = num32;
              int num34 = index22 + 1;
              int num35 = (int) (byte) (((int) num1 & 65280) >> 8);
              numArray21[index22] = (byte) num35;
              if (num1 != (short) 0)
              {
                int index23;
                for (index23 = 0; index23 < (int) num1 && num34 + index23 < destinationArray.Length; ++index23)
                  destinationArray[num34 + index23] = numArray1[index23];
                num30 = num34 + index23;
                break;
              }
              break;
          }
          return destinationArray;
        default:
          numArray1 = encoding.GetBytes(obj4);
          num1 = (short) numArray1.Length;
          goto case "";
      }
    }

    private static byte[] \u0036D4([In] long obj0, [In] long obj1, [In] int obj2, [In] uint obj3)
    {
      byte[] destinationArray = new byte[76];
      int destinationIndex1 = 0;
      Array.Copy((Array) BitConverter.GetBytes(101075792U), 0, (Array) destinationArray, destinationIndex1, 4);
      int destinationIndex2 = destinationIndex1 + 4;
      Array.Copy((Array) BitConverter.GetBytes(44L), 0, (Array) destinationArray, destinationIndex2, 8);
      int num1 = destinationIndex2 + 8;
      byte[] numArray1 = destinationArray;
      int index1 = num1;
      int num2 = index1 + 1;
      numArray1[index1] = (byte) 45;
      byte[] numArray2 = destinationArray;
      int index2 = num2;
      int num3 = index2 + 1;
      numArray2[index2] = (byte) 0;
      byte[] numArray3 = destinationArray;
      int index3 = num3;
      int num4 = index3 + 1;
      numArray3[index3] = (byte) 45;
      byte[] numArray4 = destinationArray;
      int index4 = num4;
      int destinationIndex3 = index4 + 1;
      numArray4[index4] = (byte) 0;
      for (int index5 = 0; index5 < 8; ++index5)
        destinationArray[destinationIndex3++] = (byte) 0;
      long num5 = (long) obj2;
      Array.Copy((Array) BitConverter.GetBytes(num5), 0, (Array) destinationArray, destinationIndex3, 8);
      int destinationIndex4 = destinationIndex3 + 8;
      Array.Copy((Array) BitConverter.GetBytes(num5), 0, (Array) destinationArray, destinationIndex4, 8);
      int destinationIndex5 = destinationIndex4 + 8;
      Array.Copy((Array) BitConverter.GetBytes(obj1 - obj0), 0, (Array) destinationArray, destinationIndex5, 8);
      int destinationIndex6 = destinationIndex5 + 8;
      Array.Copy((Array) BitConverter.GetBytes(obj0), 0, (Array) destinationArray, destinationIndex6, 8);
      int destinationIndex7 = destinationIndex6 + 8;
      Array.Copy((Array) BitConverter.GetBytes(117853008U), 0, (Array) destinationArray, destinationIndex7, 4);
      int destinationIndex8 = destinationIndex7 + 4;
      Array.Copy((Array) BitConverter.GetBytes(obj3 == 0U ? 0U : obj3 - 1U), 0, (Array) destinationArray, destinationIndex8, 4);
      int destinationIndex9 = destinationIndex8 + 4;
      Array.Copy((Array) BitConverter.GetBytes(obj1), 0, (Array) destinationArray, destinationIndex9, 8);
      int destinationIndex10 = destinationIndex9 + 8;
      Array.Copy((Array) BitConverter.GetBytes(obj3), 0, (Array) destinationArray, destinationIndex10, 4);
      int num6 = destinationIndex10 + 4;
      return destinationArray;
    }

    private static int \u00325U([In] ICollection<q14> obj0)
    {
      int num = 0;
      foreach (q14 q14 in (IEnumerable<q14>) obj0)
      {
        if (q14.\u0032vs)
          ++num;
      }
      return num;
    }
  }
}
