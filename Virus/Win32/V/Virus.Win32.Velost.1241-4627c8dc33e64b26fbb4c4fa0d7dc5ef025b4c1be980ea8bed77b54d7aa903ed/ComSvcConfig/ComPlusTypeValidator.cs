// Decompiled with JetBrains decompiler
// Type: Microsoft.Tools.ServiceModel.ComSvcConfig.ComPlusTypeValidator
// Assembly: ComSvcConfig, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: 502D58B8-8905-498F-84D2-67D5F99987D4
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00009-msil\Virus.Win32.Velost.1241-4627c8dc33e64b26fbb4c4fa0d7dc5ef025b4c1be980ea8bed77b54d7aa903ed.exe

using System;
using System.Collections.Generic;
using System.EnterpriseServices;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.ServiceModel.Channels;

namespace Microsoft.Tools.ServiceModel.ComSvcConfig
{
  internal static class ComPlusTypeValidator
  {
    private static Guid IID_Object = new Guid("{65074F7F-63C0-304E-AF0A-D51741CB4A8D}");
    private static Guid IID_IDisposable = new Guid("{805D7A98-D4AF-3F0F-967F-E5CF45312D2C}");
    private static Guid IID_IManagedObject = new Guid("{C3FCC19E-A970-11D2-8B5A-00A0C9B7C9C4}");
    private static Guid IID_IProcessInitializer = new Guid("{1113F52D-DC7F-4943-AED6-88D04027E32A}");
    private static Guid IID_IRemoteDispatch = new Guid("{6619A740-8154-43BE-A186-0319578E02DB}");
    private static Guid IID_IServicedComponentInfo = new Guid("{8165B19E-8D3A-4D0B-80C8-97DE310DB583}");
    private static Guid IID_IComponentRegistrar = new Guid("{A817E7A2-43FA-11D0-9E44-00AA00B6770A}");

    internal static bool DerivesFromServicedComponent(Guid iid, Guid clsid)
    {
      System.Type type1 = typeof (Message).Assembly.GetType("System.ServiceModel.ComIntegration.TypeCacheManager");
      object target = type1.InvokeMember("Provider", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetProperty, (Binder) null, (object) null, (object[]) null, CultureInfo.InvariantCulture);
      object[] args = new object[3]
      {
        (object) iid,
        (object) false,
        (object) true
      };
      Assembly assembly;
      try
      {
        assembly = type1.InvokeMember("ResolveAssemblyFromIID", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.InvokeMethod, (Binder) null, target, args, CultureInfo.InvariantCulture) as Assembly;
      }
      catch (TargetInvocationException ex)
      {
        if (ex.GetBaseException() is FileNotFoundException)
        {
          throw;
        }
        else
        {
          Console.WriteLine(iid.ToString() + ", " + (object) clsid);
          return false;
        }
      }
      bool flag = false;
      foreach (System.Type type2 in assembly.GetTypes())
      {
        if (type2.GUID == clsid)
        {
          for (System.Type baseType = type2.BaseType; (System.Type) null != baseType; baseType = baseType.BaseType)
          {
            if (typeof (ServicedComponent) == baseType)
            {
              flag = true;
              break;
            }
          }
        }
      }
      return flag;
    }

    internal static bool VerifyInterface(
      ComAdminInterfaceInfo interfaceInfo,
      bool allowReferences,
      Guid clsid)
    {
      return ComPlusTypeValidator.VerifyInterface(interfaceInfo, allowReferences, clsid, false);
    }

    internal static bool VerifyInterface(
      ComAdminInterfaceInfo interfaceInfo,
      bool allowReferences,
      Guid clsid,
      bool produceError)
    {
      if (ComPlusTypeValidator.IsInternalInterface(interfaceInfo.Iid))
      {
        if (produceError)
          ToolConsole.WriteError(Microsoft.Tools.ServiceModel.SR.GetString("IsInternalInterfaceAndCannotBeExposedOverWebService", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name), "");
        else
          ToolConsole.WriteWarning(Microsoft.Tools.ServiceModel.SR.GetString("IsInternalInterfaceAndCannotBeExposedOverWebService", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name));
        return false;
      }
      System.Type type1 = typeof (Message).Assembly.GetType("System.ServiceModel.ComIntegration.TypeCacheManager");
      object target = type1.InvokeMember("Provider", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetProperty, (Binder) null, (object) null, (object[]) null, CultureInfo.InvariantCulture);
      object[] args = new object[1]
      {
        (object) interfaceInfo.Iid
      };
      System.Type type2;
      try
      {
        type2 = type1.InvokeMember("VerifyType", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.InvokeMethod, (Binder) null, target, args, CultureInfo.InvariantCulture) as System.Type;
      }
      catch (TargetInvocationException ex)
      {
        if (ex.GetBaseException() is FileNotFoundException)
          throw ComPlusTypeValidator.CreateDescriptiveException((FileNotFoundException) ex.GetBaseException());
        string str = Microsoft.Tools.ServiceModel.SR.GetString("TypeResolutionForInterfaceFailed", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name, (object) ex.InnerException.Message);
        if (ComPlusTypeValidator.DerivesFromServicedComponent(interfaceInfo.Iid, clsid))
          str = str + " " + Microsoft.Tools.ServiceModel.SR.GetString("ClassInterfacesNotSupported");
        if (produceError)
          ToolConsole.WriteError(str, "");
        else
          ToolConsole.WriteNonVerboseWarning(str);
        return false;
      }
      MethodInfo[] methods = type2.GetMethods();
      if (methods.Length == 0)
      {
        if (produceError)
          ToolConsole.WriteError(Microsoft.Tools.ServiceModel.SR.GetString("InterfaceHasNoMethods", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name), "");
        else
          ToolConsole.WriteNonVerboseWarning(Microsoft.Tools.ServiceModel.SR.GetString("InterfaceHasNoMethods", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name));
        return false;
      }
      foreach (MethodInfo methodInfo in methods)
      {
        string typeMismatchDetails;
        foreach (ParameterInfo parameter in methodInfo.GetParameters())
        {
          System.Type type3 = parameter.ParameterType;
          if (type3.IsByRef)
            type3 = type3.GetElementType();
          if (!ComPlusTypeValidator.IsValidParameter(type3, (ICustomAttributeProvider) parameter, allowReferences, out typeMismatchDetails))
          {
            if (produceError)
              ToolConsole.WriteError(Microsoft.Tools.ServiceModel.SR.GetString("ParameterOfMethodInInterfaceHasANonCompliantType", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name, (object) methodInfo.Name, (object) parameter.Name, (object) typeMismatchDetails), "");
            else
              ToolConsole.WriteNonVerboseWarning(Microsoft.Tools.ServiceModel.SR.GetString("ParameterOfMethodInInterfaceHasANonCompliantType", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name, (object) methodInfo.Name, (object) parameter.Name, (object) typeMismatchDetails));
            return false;
          }
        }
        if (!ComPlusTypeValidator.IsValidParameter(methodInfo.ReturnType, methodInfo.ReturnTypeCustomAttributes, allowReferences, out typeMismatchDetails))
        {
          if (produceError)
            ToolConsole.WriteError(Microsoft.Tools.ServiceModel.SR.GetString("InvalidWebServiceReturnValue", (object) methodInfo.ReturnType.Name, (object) methodInfo.Name, Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name, (object) typeMismatchDetails), "");
          else
            ToolConsole.WriteNonVerboseWarning(Microsoft.Tools.ServiceModel.SR.GetString("InvalidWebServiceReturnValue", (object) methodInfo.ReturnType.Name, (object) methodInfo.Name, Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name, (object) typeMismatchDetails));
          return false;
        }
      }
      return true;
    }

    public static List<string> FetchAllMethodsForInterface(ComAdminInterfaceInfo interfaceInfo) => ComPlusTypeValidator.FetchAllMethodsForInterface(interfaceInfo, true);

    public static List<string> FetchAllMethodsForInterface(
      ComAdminInterfaceInfo interfaceInfo,
      bool produceWarning)
    {
      System.Type type1 = typeof (Message).Assembly.GetType("System.ServiceModel.ComIntegration.TypeCacheManager");
      object target = type1.InvokeMember("Provider", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetProperty, (Binder) null, (object) null, (object[]) null, CultureInfo.InvariantCulture);
      object[] args = new object[1]
      {
        (object) interfaceInfo.Iid
      };
      System.Type type2;
      try
      {
        type2 = type1.InvokeMember("VerifyType", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.InvokeMethod, (Binder) null, target, args, CultureInfo.InvariantCulture) as System.Type;
      }
      catch (TargetInvocationException ex)
      {
        if (ex.GetBaseException() is FileNotFoundException)
          throw ComPlusTypeValidator.CreateDescriptiveException((FileNotFoundException) ex.GetBaseException());
        if (produceWarning)
          ToolConsole.WriteWarning(Microsoft.Tools.ServiceModel.SR.GetString("TypeResolutionForInterfaceFailed", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name, (object) ex.InnerException.Message));
        return (List<string>) null;
      }
      MethodInfo[] methods = type2.GetMethods();
      if (methods.Length == 0)
        return (List<string>) null;
      List<string> stringList = new List<string>();
      foreach (MethodBase methodBase in methods)
        stringList.Add(methodBase.Name);
      return stringList;
    }

    private static Exception CreateDescriptiveException(FileNotFoundException oldException) => new Exception(oldException.Message + " " + Microsoft.Tools.ServiceModel.SR.GetString("InstallInGAC", (object) oldException.FileName));

    public static bool VerifyInterfaceMethods(
      ComAdminInterfaceInfo interfaceInfo,
      IList<string> methodNames,
      bool allowReferences,
      bool produceError)
    {
      if (ComPlusTypeValidator.IsInternalInterface(interfaceInfo.Iid))
      {
        if (produceError)
          ToolConsole.WriteError(Microsoft.Tools.ServiceModel.SR.GetString("IsInternalInterfaceAndCannotBeExposedOverWebService", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name), "");
        else
          ToolConsole.WriteWarning(Microsoft.Tools.ServiceModel.SR.GetString("IsInternalInterfaceAndCannotBeExposedOverWebService", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name));
        return false;
      }
      System.Type type1 = typeof (Message).Assembly.GetType("System.ServiceModel.ComIntegration.TypeCacheManager");
      object target = type1.InvokeMember("Provider", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetProperty, (Binder) null, (object) null, (object[]) null, CultureInfo.InvariantCulture);
      object[] args = new object[1]
      {
        (object) interfaceInfo.Iid
      };
      System.Type type2;
      try
      {
        type2 = type1.InvokeMember("VerifyType", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.InvokeMethod, (Binder) null, target, args, CultureInfo.InvariantCulture) as System.Type;
      }
      catch (TargetInvocationException ex)
      {
        if (ex.GetBaseException() is FileNotFoundException)
          throw ComPlusTypeValidator.CreateDescriptiveException((FileNotFoundException) ex.GetBaseException());
        if (produceError)
          ToolConsole.WriteError(Microsoft.Tools.ServiceModel.SR.GetString("TypeResolutionForInterfaceFailed", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name, (object) ex.InnerException.Message), "");
        else
          ToolConsole.WriteWarning(Microsoft.Tools.ServiceModel.SR.GetString("TypeResolutionForInterfaceFailed", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name, (object) ex.InnerException.Message));
        return false;
      }
      MethodInfo[] methods = type2.GetMethods();
      if (methods.Length == 0)
      {
        if (produceError)
          ToolConsole.WriteError(Microsoft.Tools.ServiceModel.SR.GetString("InterfaceHasNoMethods", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name), "");
        else
          ToolConsole.WriteWarning(Microsoft.Tools.ServiceModel.SR.GetString("InterfaceHasNoMethods", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name));
        return false;
      }
      foreach (string methodName in (IEnumerable<string>) methodNames)
      {
        bool flag = false;
        foreach (MethodInfo methodInfo in methods)
        {
          if (methodName == methodInfo.Name)
          {
            flag = true;
            string typeMismatchDetails;
            foreach (ParameterInfo parameter in methodInfo.GetParameters())
            {
              System.Type type3 = parameter.ParameterType;
              if (type3.IsByRef)
                type3 = type3.GetElementType();
              if (!ComPlusTypeValidator.IsValidParameter(type3, (ICustomAttributeProvider) parameter, allowReferences, out typeMismatchDetails))
              {
                if (produceError)
                  ToolConsole.WriteError(Microsoft.Tools.ServiceModel.SR.GetString("ParameterOfMethodInInterfaceHasANonCompliantType", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name, (object) methodInfo.Name, (object) parameter.Name, (object) typeMismatchDetails), "");
                else
                  ToolConsole.WriteWarning(Microsoft.Tools.ServiceModel.SR.GetString("ParameterOfMethodInInterfaceHasANonCompliantType", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name, (object) methodInfo.Name, (object) parameter.Name, (object) typeMismatchDetails));
                return false;
              }
            }
            if (!ComPlusTypeValidator.IsValidParameter(methodInfo.ReturnType, methodInfo.ReturnTypeCustomAttributes, allowReferences, out typeMismatchDetails))
            {
              if (produceError)
                ToolConsole.WriteError(Microsoft.Tools.ServiceModel.SR.GetString("InvalidWebServiceReturnValue", (object) methodInfo.ReturnType.Name, (object) methodInfo.Name, Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name, (object) typeMismatchDetails), "");
              else
                ToolConsole.WriteWarning(Microsoft.Tools.ServiceModel.SR.GetString("InvalidWebServiceReturnValue", (object) methodInfo.ReturnType.Name, (object) methodInfo.Name, Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name, (object) typeMismatchDetails));
              return false;
            }
          }
        }
        if (!flag)
          throw Tool.CreateException(Microsoft.Tools.ServiceModel.SR.GetString("MethodNotFoundOnInterface", Tool.Options.ShowGuids ? (object) interfaceInfo.Iid.ToString("B") : (object) interfaceInfo.Name, (object) methodName), (Exception) null);
      }
      return true;
    }

    public static bool IsInternalInterface(Guid iid) => iid == ComPlusTypeValidator.IID_Object || iid == ComPlusTypeValidator.IID_IDisposable || iid == ComPlusTypeValidator.IID_IManagedObject || iid == ComPlusTypeValidator.IID_IProcessInitializer || iid == ComPlusTypeValidator.IID_IRemoteDispatch || iid == ComPlusTypeValidator.IID_IServicedComponentInfo || iid == ComPlusTypeValidator.IID_IComponentRegistrar || iid.ToString("D").ToLowerInvariant().EndsWith("c000-000000000046", StringComparison.Ordinal);

    public static bool IsValidParameter(
      System.Type type,
      ICustomAttributeProvider attributeProvider,
      bool allowReferences,
      out string typeMismatchDetails)
    {
      typeMismatchDetails = type.ToString() + " ";
      foreach (MarshalAsAttribute customAttribute in attributeProvider.GetCustomAttributes(typeof (MarshalAsAttribute), true))
      {
        UnmanagedType unmanagedType = customAttribute.Value;
        switch (unmanagedType)
        {
          case UnmanagedType.IUnknown:
          case UnmanagedType.IDispatch:
          case UnmanagedType.Interface:
            if (!allowReferences)
              typeMismatchDetails += Microsoft.Tools.ServiceModel.SR.GetString("HasMarshalAsAttributeOfType", (object) unmanagedType);
            return allowReferences;
          default:
            continue;
        }
      }
      if (new XsdDataContractExporter().CanExport(type))
        return true;
      typeMismatchDetails += Microsoft.Tools.ServiceModel.SR.GetString("CannotBeExportedByDataContractExporter");
      return false;
    }
  }
}
