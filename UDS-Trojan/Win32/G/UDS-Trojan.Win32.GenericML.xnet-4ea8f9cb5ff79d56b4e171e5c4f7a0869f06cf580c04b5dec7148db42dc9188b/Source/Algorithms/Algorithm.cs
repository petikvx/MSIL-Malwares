// Decompiled with JetBrains decompiler
// Type: Path_Finder.Source.Algorithms.Algorithm
// Assembly: TypeDelega, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: FEF18FA9-51E7-447C-8FC7-9441C6E3C0DE
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4ea8f9cb5ff79d56b4e171e5c4f7a0869f06cf580c04b5dec7148db42dc9188b.exe

using Path_Finder.DataTypes;
using Path_Finder.Source.Managers;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Threading;

namespace Path_Finder.Source.Algorithms
{
  public class Algorithm
  {
    private CitiesLocations citiesLocations;
    private CitiesConnections citiesConnecitons;
    private Dictionary<City, CityInfo> foundCities;
    private Dictionary<City, CityInfo> citiesToExplore;
    private GraphLayoutCity graphLayout;
    private TextBox textBoxLog;
    private ResourceDictionary resourceDictionary;
    private bool isRunning;
    public GraphManager graphManager;
    private const int SLEEP_TIME = 500;

    public List<City> FindOptimalPath()
    {
      LogManager logManager = new LogManager(this.textBoxLog);
      bool flag = false;
      double num1 = -1.0;
      logManager.Clear();
      logManager.PrintStartAlg(this.StartCity, this.FinalCity, this.AlgHeuristic);
      City startCity = this.StartCity;
      CityInfo cityInfo1 = new CityInfo(this.StartCity, (City) null, this.FinalCity, this.GetCityCoordinates(this.StartCity), (Coordinates) null, this.GetCityCoordinates(this.FinalCity), 0.0, this.AlgHeuristic);
      this.foundCities = new Dictionary<City, CityInfo>();
      this.citiesToExplore = new Dictionary<City, CityInfo>();
      this.foundCities.Add(startCity, cityInfo1);
      this.citiesToExplore.Add(startCity, cityInfo1);
      while (this.citiesToExplore.Count != 0)
      {
        logManager.PrintFoundExploredCities();
        this.graphManager.UnmarkAllCities(this.graphLayout);
        this.graphManager.UnmarkAllEdges(this.graphLayout);
        this.graphManager.MarkAllFoundCities(new List<City>((IEnumerable<City>) this.foundCities.Keys), this.graphLayout);
        this.graphManager.MarkAllCitiesToExplore(new List<City>((IEnumerable<City>) this.citiesToExplore.Keys), this.graphLayout);
        this.graphManager.MarkStartCity(this.StartCity, this.graphLayout);
        this.graphManager.MarkFinalCity(this.FinalCity, this.graphLayout);
        this.Wait();
        City bestCity = this.FindBestCity(this.citiesToExplore);
        this.citiesToExplore.TryGetValue(bestCity, out cityInfo1);
        if (!flag || cityInfo1.PathDistance < num1)
        {
          List<City> cityList;
          this.citiesConnecitons.connections.TryGetValue(bestCity, out cityList);
          logManager.PrintBestCity(bestCity, cityInfo1);
          this.graphManager.UnmarkAllCities(this.graphLayout);
          this.graphManager.UnmarkAllEdges(this.graphLayout);
          this.graphManager.MarkBestCity(bestCity, this.graphLayout);
          logManager.PrintCityConnections(cityList);
          this.graphManager.MarkEdges(bestCity, cityList, this.graphLayout);
          this.graphManager.MarkAllCheckedCities(cityList, this.graphLayout);
          this.Wait();
          foreach (City city in cityList)
          {
            Coordinates coordinates1;
            this.citiesLocations.locations.TryGetValue(bestCity, out coordinates1);
            Coordinates coordinates2;
            this.citiesLocations.locations.TryGetValue(city, out coordinates2);
            CityInfo cityInfo2 = this.AlgHeuristic != Heuristic.Distance ? new CityInfo(city, bestCity, this.FinalCity, coordinates2, coordinates1, this.GetCityCoordinates(this.FinalCity), 1.0 + cityInfo1.FromStart, this.AlgHeuristic) : new CityInfo(city, bestCity, this.FinalCity, coordinates2, coordinates1, this.GetCityCoordinates(this.FinalCity), Algorithm.FindDistance(coordinates1, coordinates2) + cityInfo1.FromStart, this.AlgHeuristic);
            if (this.foundCities.ContainsKey(city))
            {
              CityInfo oldCityInfo;
              this.foundCities.TryGetValue(city, out oldCityInfo);
              if (cityInfo2.PathDistance < oldCityInfo.PathDistance)
              {
                logManager.PrintUpdatedCity(city, cityInfo2, oldCityInfo);
                this.graphManager.MarkUpdatedCity(city, this.graphLayout);
                oldCityInfo.PrevCity = cityInfo2.PrevCity;
                oldCityInfo.FromStart = cityInfo2.FromStart;
                if (city.Equals(this.FinalCity))
                  num1 = cityInfo2.FromStart;
              }
              else
              {
                logManager.PrintRejectedCity(city, cityInfo2, oldCityInfo);
                this.graphManager.MarkRejectedCity(city, this.graphLayout);
              }
            }
            else
            {
              this.foundCities.Add(city, cityInfo2);
              this.citiesToExplore.Add(city, cityInfo2);
              logManager.PrintAddedCity(city, cityInfo2);
              this.graphManager.MarkAddedCity(city, this.graphLayout);
              if (!flag && city.Equals(this.FinalCity))
              {
                flag = true;
                num1 = cityInfo2.FromStart;
              }
            }
          }
          this.Wait();
          cityInfo1.IsExplored = true;
          this.citiesToExplore.Remove(bestCity);
        }
        else
          break;
      }
      if (this.foundCities.ContainsKey(this.FinalCity))
      {
        City finalCity = this.FinalCity;
        CityInfo cityInfo3;
        this.foundCities.TryGetValue(finalCity, out cityInfo3);
        List<City> cities = new List<City>();
        cities.Add(finalCity);
        for (City prevCity = cityInfo3.PrevCity; prevCity != null; prevCity = cityInfo3.PrevCity)
        {
          City key = prevCity;
          cities.Add(key);
          this.foundCities.TryGetValue(key, out cityInfo3);
        }
        this.ReverseListOrder(ref cities);
        logManager.PrintPath(cities, Algorithm.CalculateTotalPath(cities, this.citiesLocations));
        this.graphManager.UnmarkAllCities(this.graphLayout);
        this.graphManager.UnmarkAllEdges(this.graphLayout);
        this.graphManager.MarkPath(cities, this.graphLayout);
        logManager.PrintEndAlg(true);
        return cities;
      }
      this.graphManager.UnmarkAllCities(this.graphLayout);
      this.graphManager.UnmarkAllEdges(this.graphLayout);
      this.graphManager.MarkStartCity(this.StartCity, this.graphLayout);
      this.graphManager.MarkFinalCity(this.FinalCity, this.graphLayout);
      logManager.PrintEndAlg(false);
      int num2 = (int) MessageBox.Show("Cannot find a path between the chosen cities.", "Path Finder", MessageBoxButton.OK, MessageBoxImage.Exclamation);
      return (List<City>) null;
    }

    public City StartCity { get; private set; }

    public City FinalCity { get; private set; }

    public Alg_Speed AlgSpeed { get; set; }

    public Heuristic AlgHeuristic { get; private set; }

    public bool IsRunning
    {
      get => this.isRunning;
      set => this.isRunning = value;
    }

    public MainWindow Window { get; set; }

    public Algorithm()
    {
      this.citiesLocations = (CitiesLocations) null;
      this.citiesConnecitons = (CitiesConnections) null;
      this.StartCity = (City) null;
      this.FinalCity = (City) null;
      this.AlgSpeed = Alg_Speed.Fast;
      this.AlgHeuristic = Heuristic.Distance;
      this.graphLayout = (GraphLayoutCity) null;
      this.textBoxLog = (TextBox) null;
      this.resourceDictionary = (ResourceDictionary) null;
      this.IsRunning = false;
      this.Window = (MainWindow) null;
      this.CanContinue = false;
    }

    public Algorithm(
      CitiesLocations _citiesLocations,
      CitiesConnections _citiesConnectios,
      City _startCity,
      City _finalCity,
      Alg_Speed _algSpeed,
      Heuristic _algHeuristic,
      ref GraphLayoutCity _graphLayout,
      ref TextBox _textBoxLog,
      ResourceDictionary _resourceDictionary,
      GraphManager _graphManager)
    {
      this.citiesLocations = _citiesLocations;
      this.citiesConnecitons = _citiesConnectios;
      this.StartCity = _startCity;
      this.FinalCity = _finalCity;
      this.AlgSpeed = _algSpeed;
      this.AlgHeuristic = _algHeuristic;
      this.graphLayout = _graphLayout;
      this.textBoxLog = _textBoxLog;
      this.resourceDictionary = _resourceDictionary;
      this.IsRunning = false;
      this.Window = (MainWindow) null;
      this.CanContinue = false;
      this.graphManager = _graphManager;
    }

    public static double FindDistance(Coordinates point1, Coordinates point2) => Math.Sqrt(Math.Pow((double) (point1.getX() - point2.getX()), 2.0) + Math.Pow((double) (point1.getY() - point2.getY()), 2.0));

    public static double CalculateTotalPath(List<City> cities, CitiesLocations citiesLocations)
    {
      if (cities.Count < 2)
        return -1.0;
      double totalPath = 0.0;
      Coordinates point1;
      citiesLocations.locations.TryGetValue(cities[0], out point1);
      for (int index = 1; index < cities.Count; ++index)
      {
        Coordinates point2;
        citiesLocations.locations.TryGetValue(cities[index], out point2);
        totalPath += Algorithm.FindDistance(point1, point2);
        point1 = point2;
      }
      return totalPath;
    }

    private City FindBestCity(Dictionary<City, CityInfo> cities)
    {
      City key1 = (City) null;
      double num1 = -1.0;
      int num2 = 0;
      foreach (City key2 in cities.Keys)
      {
        CityInfo cityInfo1;
        if (num2 == 0)
        {
          key1 = key2;
          cities.TryGetValue(key1, out cityInfo1);
          num1 = cityInfo1.PathDistance;
        }
        else
        {
          CityInfo cityInfo2;
          cities.TryGetValue(key2, out cityInfo2);
          double pathDistance = cityInfo2.PathDistance;
          if (pathDistance < num1)
          {
            key1 = key2;
            cityInfo1 = cityInfo2;
            num1 = pathDistance;
          }
        }
        ++num2;
      }
      return key1;
    }

    private Coordinates GetCityCoordinates(City city)
    {
      Coordinates cityCoordinates = (Coordinates) null;
      if (this.citiesLocations.locations.ContainsKey(city))
        this.citiesLocations.locations.TryGetValue(city, out cityCoordinates);
      return cityCoordinates;
    }

    private void ReverseListOrder(ref List<City> cities)
    {
      int count = cities.Count;
      for (int index = 0; index < count / 2; ++index)
      {
        City city = cities[index];
        cities[index] = cities[count - index - 1];
        cities[count - index - 1] = city;
      }
    }

    public bool CanContinue { get; set; }

    public Mutex WaitMutex { get; set; }

    public void RunAlgThread()
    {
      this.BlockUI();
      this.IsRunning = true;
      this.FindOptimalPath();
      this.IsRunning = false;
      this.UnblockUI();
    }

    private void BlockUI()
    {
      if (this.Window == null)
        return;
      ((DispatcherObject) this.Window.graphLayout).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.graphLayout).IsEnabled = false), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.ButtonOpen).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.ButtonOpen).IsEnabled = false), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.ButtonReset).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.ButtonReset).IsEnabled = false), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.ButtonDefault).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.ButtonDefault).IsEnabled = false), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.RadioButtonDistance).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.RadioButtonDistance).IsEnabled = false), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.RadioButtonHops).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.RadioButtonHops).IsEnabled = false), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.RadioButtonStep).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.RadioButtonStep).IsEnabled = false), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.RadioButtonNormal).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.RadioButtonNormal).IsEnabled = false), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.RadioButtonFast).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.RadioButtonFast).IsEnabled = false), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.ButtonClean).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.ButtonClean).IsEnabled = false), DispatcherPriority.Normal, (object[]) null);
    }

    private void UnblockUI()
    {
      if (this.Window == null)
        return;
      ((DispatcherObject) this.Window.graphLayout).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.graphLayout).IsEnabled = true), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.ButtonOpen).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.ButtonOpen).IsEnabled = true), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.ButtonReset).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.ButtonReset).IsEnabled = true), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.ButtonDefault).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.ButtonDefault).IsEnabled = true), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.RadioButtonDistance).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.RadioButtonDistance).IsEnabled = true), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.RadioButtonHops).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.RadioButtonHops).IsEnabled = true), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.RadioButtonStep).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.RadioButtonStep).IsEnabled = true), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.RadioButtonNormal).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.RadioButtonNormal).IsEnabled = true), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.RadioButtonFast).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.RadioButtonFast).IsEnabled = true), DispatcherPriority.Normal, (object[]) null);
      ((DispatcherObject) this.Window.ButtonClean).Dispatcher.Invoke((Delegate) (() => ((UIElement) this.Window.ButtonClean).IsEnabled = true), DispatcherPriority.Normal, (object[]) null);
    }

    private void Wait()
    {
      if (this.AlgSpeed == Alg_Speed.Steps)
      {
        bool flag = true;
        while (flag)
        {
          this.WaitMutex.WaitOne();
          flag = !this.CanContinue;
          this.WaitMutex.ReleaseMutex();
        }
        this.WaitMutex.WaitOne();
        this.CanContinue = false;
        this.WaitMutex.ReleaseMutex();
      }
      else if (this.AlgSpeed == Alg_Speed.Slow)
        Thread.Sleep(500);
      else if (this.AlgSpeed != Alg_Speed.Fast)
        ;
    }
  }
}
