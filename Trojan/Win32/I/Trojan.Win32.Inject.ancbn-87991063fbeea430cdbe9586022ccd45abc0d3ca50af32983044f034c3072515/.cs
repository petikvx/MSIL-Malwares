// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Ressource, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7A61D5AB-B799-4526-BF58-A6DA1297213F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan.Win32.Inject.ancbn-87991063fbeea430cdbe9586022ccd45abc0d3ca50af32983044f034c3072515.exe

using System;
using System.IO;

internal sealed class \uE012
{
  public static void \uE000(Stream _param0, Stream _param1)
  {
    byte[] buffer = new byte[32768];
    \uE012.\uE009 obj = new \uE012.\uE009(_param0);
    while (true)
    {
      int count = obj.\uE003(buffer, 0, buffer.Length);
      if (count > 0)
        _param1.Write(buffer, 0, count);
      else
        break;
    }
  }

  public sealed class \uE009
  {
    private \uE012.\uE00B \uE000 = new \uE012.\uE00B(32769);
    private \uE012.\uE00A \uE001;
    private \uE011 \uE002;
    private int \uE003 = -1;
    private int \uE004 = -1;
    private bool \uE005;
    private int \uE006;
    private long \uE007;
    private long \uE008;
    private bool \uE009;
    private int \uE00A;
    private bool \uE00B;

    public \uE009(Stream _param1) => this.\uE001 = new \uE012.\uE00A(_param1);

    public int \uE003(byte[] _param1, int _param2, int _param3)
    {
      if (_param1 == null)
        throw new ArgumentNullException();
      if (_param3 == 0 || this.\uE009)
        return 0;
      int num1 = 0;
      while (num1 < _param3)
      {
        while (this.\uE003 < 0 && !this.\uE009)
          this.\uE009 = !this.\uE000();
        if (!this.\uE009)
        {
          int num2 = this.\uE004(_param1, _param2 + num1, _param3 - num1);
          if (num2 > 0)
            num1 += num2;
          else
            this.\uE003 = -1;
        }
        else
          break;
      }
      return num1;
    }

    private bool \uE000()
    {
      if (this.\uE005)
        return false;
      this.\uE007 = this.\uE001.\uE004;
      this.\uE005 = this.\uE001.\uE000(1) > 0;
      this.\uE003 = this.\uE001.\uE000(2);
      switch (this.\uE003)
      {
        case 0:
          this.\uE001.\uE000();
          int num1 = this.\uE001.\uE000(16);
          int num2 = this.\uE001.\uE000(16);
          this.\uE006 = (num1 & ~num2) == num1 ? num1 : throw new InvalidOperationException();
          this.\uE002 = (\uE011) null;
          this.\uE00B = true;
          break;
        case 1:
          \uE00F[] objArray1 = \uE00D.\uE011;
          \uE00F[] objArray2 = \uE00D.\uE012;
          this.\uE006 = 0;
          this.\uE002 = \uE00D.\uE013;
          this.\uE00B = false;
          break;
        case 2:
          \uE00F[] objArray3;
          \uE00F[] objArray4;
          this.\uE000(this.\uE001, out objArray3, out objArray4);
          this.\uE006 = 0;
          this.\uE002 = \uE00D.\uE000(objArray3, objArray4);
          this.\uE00B = false;
          break;
        default:
          throw new InvalidOperationException();
      }
      this.\uE008 = this.\uE001.\uE004;
      return true;
    }

    private int \uE004(byte[] _param1, int _param2, int _param3)
    {
      int num1 = _param2;
      if (this.\uE003 == 0)
      {
        if (this.\uE006 > 0)
        {
          int num2 = Math.Min(_param3, this.\uE006);
          this.\uE001.\uE000(_param1, _param2, num2);
          this.\uE000.\uE000(_param1, _param2, num2);
          this.\uE006 -= num2;
          _param3 -= num2;
          _param2 += num2;
        }
      }
      else if (!this.\uE00B)
      {
        if (this.\uE00A > 0)
          this.\uE000(_param1, ref _param2, ref _param3);
        if (_param3 > 0)
        {
          do
          {
            int num3 = \uE012.\uE009.\uE009(this.\uE001, this.\uE002.\uE000);
            this.\uE00B = num3 == 256;
            if (!this.\uE00B)
            {
              if (num3 < 256)
              {
                _param1[_param2++] = (byte) num3;
                this.\uE000.\uE000((byte) num3);
                --_param3;
              }
              else if (num3 <= 285)
              {
                int num4 = \uE012.\uE009.\uE000(this.\uE001, num3);
                int num5 = \uE012.\uE009.\uE00A(this.\uE001, this.\uE002.\uE001);
                if ((long) num5 > this.\uE000.\uE003)
                  throw new InvalidOperationException();
                this.\uE004 = num5;
                this.\uE00A = num4;
                this.\uE000(_param1, ref _param2, ref _param3);
              }
            }
            else
              break;
          }
          while (_param3 > 0);
        }
      }
      this.\uE008 = this.\uE001.\uE004;
      return _param2 - num1;
    }

    private void \uE000(byte[] _param1, ref int _param2, ref int _param3)
    {
      int num = Math.Min(this.\uE00A, _param3);
      byte[] sourceArray = this.\uE000.\uE000(this.\uE004, Math.Min(num, this.\uE004));
      _param3 -= num;
      this.\uE00A -= num;
      while (num > sourceArray.Length)
      {
        Array.Copy((Array) sourceArray, 0, (Array) _param1, _param2, sourceArray.Length);
        _param2 += sourceArray.Length;
        num -= sourceArray.Length;
        this.\uE000.\uE000(sourceArray, 0, sourceArray.Length);
      }
      Array.Copy((Array) sourceArray, 0, (Array) _param1, _param2, num);
      _param2 += num;
      this.\uE000.\uE000(sourceArray, 0, num);
    }

    public bool \uE000(int _param1)
    {
      byte[] numArray1 = new byte[1024];
      int num1;
      for (; _param1 > 0; _param1 -= num1)
      {
        byte[] numArray2 = numArray1;
        int num2 = Math.Min(1024, _param1);
        if ((num1 = this.\uE003(numArray2, 0, num2)) <= 0)
          break;
      }
      return _param1 <= 0;
    }

    public void \uE000()
    {
      byte[] numArray = new byte[1024];
      do
        ;
      while (this.\uE003(numArray, 0, 1024) > 0);
    }

    private static int \uE009(\uE012.\uE00A _param0, \uE010 _param1)
    {
      while (_param1 != null && !_param1.\uE000)
        _param1 = _param0.\uE000(1) > 0 ? _param1.\uE003 : _param1.\uE002;
      return _param1 != null ? (int) _param1.\uE001 : throw new InvalidOperationException();
    }

    private static int \uE000(\uE012.\uE00A _param0, int _param1)
    {
      int num1;
      int num2;
      \uE00D.\uE00A(_param1, out num2, out num1);
      return num1 > 0 ? num2 + _param0.\uE000(num1) : num2;
    }

    private static int \uE00A(\uE012.\uE00A _param0, \uE010 _param1)
    {
      int num1 = \uE012.\uE009.\uE009(_param0, _param1);
      if (num1 > 29)
        throw new InvalidOperationException();
      int num2;
      int num3;
      \uE00D.\uE00B(num1, out num3, out num2);
      if (num2 <= 0)
        return num3;
      int num4 = _param0.\uE000(num2);
      if (num1 == 284 && num4 > 30)
        throw new InvalidOperationException();
      return num3 + num4;
    }

    private void \uE000(\uE012.\uE00A _param1, out \uE00F[] _param2, out \uE00F[] _param3)
    {
      int length1 = _param1.\uE000(5) + 257;
      int length2 = _param1.\uE000(5) + 1;
      int num = _param1.\uE000(4) + 4;
      if (length1 > 286)
        throw new InvalidOperationException();
      int[] numArray1 = \uE00D.\uE014;
      int[] numArray2 = new int[19];
      for (int index = 0; index < num; ++index)
        numArray2[numArray1[index]] = _param1.\uE000(3);
      \uE010 obj = \uE00D.\uE000(\uE00D.\uE000(numArray2));
      int[] numArray3 = \uE012.\uE009.\uE000(_param1, obj, length1 + length2);
      _param2 = new \uE00F[length1];
      for (int index = 0; index < length1; ++index)
        _param2[index].\uE001 = numArray3[index];
      \uE00D.\uE000(_param2);
      _param3 = new \uE00F[length2];
      for (int index = 0; index < length2; ++index)
        _param3[index].\uE001 = numArray3[index + length1];
      \uE00D.\uE000(_param3);
    }

    private static int[] \uE000(\uE012.\uE00A _param0, \uE010 _param1, int _param2)
    {
      int[] numArray = new int[_param2];
      for (int index1 = 0; index1 < _param2; ++index1)
      {
        int num1 = \uE012.\uE009.\uE009(_param0, _param1);
        if (num1 < 16)
        {
          numArray[index1] = num1;
        }
        else
        {
          switch (num1)
          {
            case 16:
              int num2 = _param0.\uE000(2) + 3;
              if (num2 + index1 > numArray.Length)
                throw new InvalidOperationException();
              for (int index2 = 0; index2 < num2; ++index2)
                numArray[index1 + index2] = numArray[index1 - 1];
              index1 += num2 - 1;
              continue;
            case 17:
              int num3 = _param0.\uE000(3) + 3;
              if (num3 + index1 > numArray.Length)
                throw new InvalidOperationException();
              index1 += num3 - 1;
              continue;
            case 18:
              int num4 = _param0.\uE000(7) + 11;
              if (num4 + index1 > numArray.Length)
                throw new InvalidOperationException();
              index1 += num4 - 1;
              continue;
            default:
              throw new InvalidOperationException();
          }
        }
      }
      return numArray;
    }
  }

  private sealed class \uE00A
  {
    private uint \uE000;
    private int \uE001;
    private int \uE002;
    private Stream \uE003;
    internal long \uE004;

    internal \uE00A(Stream _param1) => this.\uE003 = _param1;

    internal int \uE000(int _param1)
    {
      this.\uE004 += (long) _param1;
      for (int index = _param1 - (this.\uE002 - this.\uE001); index > 0; index -= 8)
      {
        int num = this.\uE003.ReadByte();
        if (num < 0)
          throw new InvalidOperationException();
        this.\uE000 |= checked ((uint) num) << this.\uE002;
        this.\uE002 += 8;
      }
      int num1 = (int) (this.\uE000 >> this.\uE001) & (1 << _param1) - 1;
      this.\uE001 += _param1;
      if (this.\uE002 == this.\uE001)
      {
        this.\uE002 = this.\uE001 = 0;
        this.\uE000 = 0U;
      }
      else if (this.\uE001 >= 8)
      {
        this.\uE000 >>= this.\uE001;
        this.\uE002 -= this.\uE001;
        this.\uE001 = 0;
      }
      return num1;
    }

    internal void \uE000()
    {
      if (this.\uE002 != this.\uE001)
        this.\uE004 += (long) (this.\uE002 - this.\uE001);
      this.\uE002 = this.\uE001 = 0;
      this.\uE000 = 0U;
    }

    internal void \uE000(byte[] _param1, int _param2, int _param3)
    {
      if (this.\uE002 != this.\uE001)
        throw new InvalidOperationException();
      int num = this.\uE003.Read(_param1, _param2, _param3);
      this.\uE004 += (long) (num << 3);
      if (num != _param3)
        throw new InvalidOperationException();
    }
  }

  private sealed class \uE00B
  {
    private byte[] \uE000;
    private int \uE001;
    internal int \uE002;
    internal long \uE003;

    internal \uE00B(int _param1)
    {
      this.\uE002 = _param1;
      this.\uE000 = new byte[_param1];
    }

    internal void \uE000(byte _param1)
    {
      this.\uE000[this.\uE001++] = _param1;
      if (this.\uE001 >= this.\uE002)
        this.\uE001 = 0;
      ++this.\uE003;
    }

    internal void \uE000(byte[] _param1, int _param2, int _param3)
    {
      this.\uE003 += (long) _param3;
      if (_param3 >= this.\uE002)
      {
        Array.Copy((Array) _param1, _param2, (Array) this.\uE000, 0, this.\uE002);
        this.\uE001 = 0;
      }
      else if (this.\uE001 + _param3 > this.\uE002)
      {
        int length1 = this.\uE002 - this.\uE001;
        int length2 = this.\uE001 + _param3 - this.\uE002;
        Array.Copy((Array) _param1, _param2, (Array) this.\uE000, this.\uE001, length1);
        Array.Copy((Array) _param1, _param2 + length1, (Array) this.\uE000, 0, length2);
        this.\uE001 = length2;
      }
      else
      {
        Array.Copy((Array) _param1, _param2, (Array) this.\uE000, this.\uE001, _param3);
        this.\uE001 += _param3;
        if (this.\uE001 != this.\uE002)
          return;
        this.\uE001 = 0;
      }
    }

    internal byte[] \uE000(int _param1, int _param2)
    {
      byte[] destinationArray = new byte[_param2];
      if (this.\uE001 >= _param1)
      {
        Array.Copy((Array) this.\uE000, this.\uE001 - _param1, (Array) destinationArray, 0, _param2);
      }
      else
      {
        int num = _param1 - this.\uE001;
        if (num < _param2)
        {
          Array.Copy((Array) this.\uE000, this.\uE002 - num, (Array) destinationArray, 0, num);
          Array.Copy((Array) this.\uE000, 0, (Array) destinationArray, num, _param2 - num);
        }
        else
          Array.Copy((Array) this.\uE000, this.\uE002 - num, (Array) destinationArray, 0, _param2);
      }
      return destinationArray;
    }
  }
}
