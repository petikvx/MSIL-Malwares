// Decompiled with JetBrains decompiler
// Type: ProtoBuf.Meta.CallbackSet
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using System;
using System.Reflection;

namespace ProtoBuf.Meta
{
  public class CallbackSet
  {
    private readonly MetaType metaType;
    private MethodInfo beforeSerialize;
    private MethodInfo afterSerialize;
    private MethodInfo beforeDeserialize;
    private MethodInfo afterDeserialize;

    internal CallbackSet(MetaType metaType) => this.metaType = metaType != null ? metaType : throw new ArgumentNullException(nameof (metaType));

    internal MethodInfo this[TypeModel.CallbackType callbackType]
    {
      get
      {
        switch (callbackType)
        {
          case TypeModel.CallbackType.BeforeSerialize:
            return this.beforeSerialize;
          case TypeModel.CallbackType.AfterSerialize:
            return this.afterSerialize;
          case TypeModel.CallbackType.BeforeDeserialize:
            return this.beforeDeserialize;
          case TypeModel.CallbackType.AfterDeserialize:
            return this.afterDeserialize;
          default:
            throw new ArgumentException("Callback type not supported: " + callbackType.ToString(), nameof (callbackType));
        }
      }
    }

    internal static bool CheckCallbackParameters(TypeModel model, MethodInfo method)
    {
      foreach (ParameterInfo parameter in method.GetParameters())
      {
        Type parameterType = parameter.ParameterType;
        if ((object) parameterType != (object) model.MapType(typeof (SerializationContext)) && (object) parameterType != (object) model.MapType(typeof (Type)))
          return false;
      }
      return true;
    }

    private MethodInfo SanityCheckCallback(TypeModel model, MethodInfo callback)
    {
      this.metaType.ThrowIfFrozen();
      if ((object) callback == null)
        return callback;
      if (callback.IsStatic)
        throw new ArgumentException("Callbacks cannot be static", nameof (callback));
      if ((object) callback.ReturnType != (object) model.MapType(typeof (void)) || !CallbackSet.CheckCallbackParameters(model, callback))
        throw CallbackSet.CreateInvalidCallbackSignature(callback);
      return callback;
    }

    internal static Exception CreateInvalidCallbackSignature(MethodInfo method) => (Exception) new NotSupportedException("Invalid callback signature in " + method.DeclaringType.FullName + "." + method.Name);

    public MethodInfo BeforeSerialize
    {
      get => this.beforeSerialize;
      set => this.beforeSerialize = this.SanityCheckCallback(this.metaType.Model, value);
    }

    public MethodInfo BeforeDeserialize
    {
      get => this.beforeDeserialize;
      set => this.beforeDeserialize = this.SanityCheckCallback(this.metaType.Model, value);
    }

    public MethodInfo AfterSerialize
    {
      get => this.afterSerialize;
      set => this.afterSerialize = this.SanityCheckCallback(this.metaType.Model, value);
    }

    public MethodInfo AfterDeserialize
    {
      get => this.afterDeserialize;
      set => this.afterDeserialize = this.SanityCheckCallback(this.metaType.Model, value);
    }

    public bool NonTrivial => (object) this.beforeSerialize != null || (object) this.beforeDeserialize != null || (object) this.afterSerialize != null || this.afterDeserialize != null;
  }
}
