// Decompiled with JetBrains decompiler
// Type: PBKDF2.Pbkdf2
// Assembly: SharpChrome, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D938FA4A-3611-4CA7-B3BE-AF9F6D845B7B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\VHO-Trojan.MSIL.Convagent.gen-340a639e1ec7cb2afa90a2aba177b368e13efc4dd1313e32af30b6ceb259f7d3.exe

using System;
using System.Security.Cryptography;
using System.Text;

namespace PBKDF2
{
  public class Pbkdf2
  {
    private readonly int BlockSize;
    private uint BlockIndex = 1;
    private byte[] BufferBytes;
    private int BufferStartIndex;
    private int BufferEndIndex;

    public Pbkdf2(HMAC algorithm, byte[] password, byte[] salt, int iterations)
    {
      if (algorithm == null)
        throw new ArgumentNullException(nameof (algorithm), "Algorithm cannot be null.");
      if (salt == null)
        throw new ArgumentNullException(nameof (salt), "Salt cannot be null.");
      if (password == null)
        throw new ArgumentNullException(nameof (password), "Password cannot be null.");
      this.Algorithm = algorithm;
      this.Algorithm.Key = password;
      this.Salt = salt;
      this.IterationCount = iterations;
      this.BlockSize = this.Algorithm.HashSize / 8;
      this.BufferBytes = new byte[this.BlockSize];
    }

    public Pbkdf2(HMAC algorithm, byte[] password, byte[] salt)
      : this(algorithm, password, salt, 1000)
    {
    }

    public Pbkdf2(HMAC algorithm, string password, string salt, int iterations)
      : this(algorithm, Encoding.UTF8.GetBytes(password), Encoding.UTF8.GetBytes(salt), iterations)
    {
    }

    public Pbkdf2(HMAC algorithm, string password, string salt)
      : this(algorithm, password, salt, 1000)
    {
    }

    public HMAC Algorithm { get; private set; }

    public byte[] Salt { get; private set; }

    public int IterationCount { get; private set; }

    public byte[] GetBytes(int count)
    {
      byte[] dst = new byte[count];
      int dstOffset = 0;
      int count1 = this.BufferEndIndex - this.BufferStartIndex;
      if (count1 > 0)
      {
        if (count < count1)
        {
          Buffer.BlockCopy((Array) this.BufferBytes, this.BufferStartIndex, (Array) dst, 0, count);
          this.BufferStartIndex += count;
          return dst;
        }
        Buffer.BlockCopy((Array) this.BufferBytes, this.BufferStartIndex, (Array) dst, 0, count1);
        this.BufferStartIndex = this.BufferEndIndex = 0;
        dstOffset += count1;
      }
      for (; dstOffset < count; dstOffset += this.BlockSize)
      {
        int count2 = count - dstOffset;
        this.BufferBytes = this.Func();
        if (count2 > this.BlockSize)
        {
          Buffer.BlockCopy((Array) this.BufferBytes, 0, (Array) dst, dstOffset, this.BlockSize);
        }
        else
        {
          Buffer.BlockCopy((Array) this.BufferBytes, 0, (Array) dst, dstOffset, count2);
          this.BufferStartIndex = count2;
          this.BufferEndIndex = this.BlockSize;
          return dst;
        }
      }
      return dst;
    }

    private byte[] Func()
    {
      byte[] numArray = new byte[this.Salt.Length + 4];
      Buffer.BlockCopy((Array) this.Salt, 0, (Array) numArray, 0, this.Salt.Length);
      Buffer.BlockCopy((Array) Pbkdf2.GetBytesFromInt(this.BlockIndex), 0, (Array) numArray, this.Salt.Length, 4);
      byte[] hash = this.Algorithm.ComputeHash(numArray);
      byte[] sourceArray = hash;
      for (int index1 = 2; index1 <= this.IterationCount; ++index1)
      {
        hash = this.Algorithm.ComputeHash(hash, 0, hash.Length);
        for (int index2 = 0; index2 < this.BlockSize; ++index2)
          sourceArray[index2] = (byte) ((uint) sourceArray[index2] ^ (uint) hash[index2]);
        Array.Copy((Array) sourceArray, (Array) hash, hash.Length);
      }
      if (this.BlockIndex == uint.MaxValue)
        throw new InvalidOperationException("Derived key too long.");
      ++this.BlockIndex;
      return sourceArray;
    }

    private static byte[] GetBytesFromInt(uint i)
    {
      byte[] bytes = BitConverter.GetBytes(i);
      if (!BitConverter.IsLittleEndian)
        return bytes;
      return new byte[4]
      {
        bytes[3],
        bytes[2],
        bytes[1],
        bytes[0]
      };
    }
  }
}
