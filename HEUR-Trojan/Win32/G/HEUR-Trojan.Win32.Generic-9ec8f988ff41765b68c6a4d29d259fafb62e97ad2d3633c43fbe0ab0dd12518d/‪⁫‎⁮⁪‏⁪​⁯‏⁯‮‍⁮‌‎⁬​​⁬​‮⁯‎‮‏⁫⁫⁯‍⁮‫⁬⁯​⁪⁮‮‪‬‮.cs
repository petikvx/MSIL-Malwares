// Decompiled with JetBrains decompiler
// Type: ‪⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮
// Assembly: ReadLineS0SAT, Version=2.0.8.1, Culture=neutral, PublicKeyToken=null
// MVID: 826822DE-6F21-4D67-9238-0DAF50EB618B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-9ec8f988ff41765b68c6a4d29d259fafb62e97ad2d3633c43fbe0ab0dd12518d.exe

using System;
using System.IO;
using System.Text;

public class \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮
{
  private static readonly byte[] \u200B⁭⁬​‮‭‎​⁮‫⁫⁮⁬⁭⁬‎‍‏‏‌‫⁮‏‬‏⁬⁪⁪‬⁯‮⁯‎⁪‫‫⁫⁭‍‫‮ = new byte[64]
  {
    (byte) 46,
    (byte) 47,
    (byte) 65,
    (byte) 66,
    (byte) 67,
    (byte) 68,
    (byte) 69,
    (byte) 70,
    (byte) 71,
    (byte) 72,
    (byte) 73,
    (byte) 74,
    (byte) 75,
    (byte) 76,
    (byte) 77,
    (byte) 78,
    (byte) 79,
    (byte) 80,
    (byte) 81,
    (byte) 82,
    (byte) 83,
    (byte) 84,
    (byte) 85,
    (byte) 86,
    (byte) 87,
    (byte) 88,
    (byte) 89,
    (byte) 90,
    (byte) 97,
    (byte) 98,
    (byte) 99,
    (byte) 100,
    (byte) 101,
    (byte) 102,
    (byte) 103,
    (byte) 104,
    (byte) 105,
    (byte) 106,
    (byte) 107,
    (byte) 108,
    (byte) 109,
    (byte) 110,
    (byte) 111,
    (byte) 112,
    (byte) 113,
    (byte) 114,
    (byte) 115,
    (byte) 116,
    (byte) 117,
    (byte) 118,
    (byte) 119,
    (byte) 120,
    (byte) 121,
    (byte) 122,
    (byte) 48,
    (byte) 49,
    (byte) 50,
    (byte) 51,
    (byte) 52,
    (byte) 53,
    (byte) 54,
    (byte) 55,
    (byte) 56,
    (byte) 57
  };
  private static readonly byte[] \u200E⁯‪‫‍⁮⁯‌‌⁫⁬⁫‭‬‮⁪‮⁪⁫⁮‎‏‌⁬⁬‭⁫‏⁬‍⁬⁯⁭⁮‮⁮⁪⁯⁫⁬‮ = new byte[128];
  private static readonly string \u202E‏‮​⁪⁫⁫⁫‎‍⁬‎⁬​‍‎⁮‭⁮⁬‍⁭‌‬⁭​⁮⁬⁭⁮‪‏‌⁭‏⁪⁪‪⁮‭‮ = "2y";
  private static readonly \u206D‬⁯‮‏‌⁪‬⁪⁫⁫‪⁯‫‎​⁮‍⁯⁪⁪‪‬‫⁬‭⁯‫‎⁭‫‪⁯⁪⁯‍‬‬⁮‭‮ \u200C​⁭‎‏‏‮‏⁫‬‮‏⁫‭⁫‬‮‬‬⁪‬‍‪‭‎⁮‫⁯⁪‪‍⁫‮⁬⁫‫‪‬⁬⁬‮ = (\u206D‬⁯‮‏‌⁪‬⁪⁫⁫‪⁯‫‎​⁮‍⁯⁪⁪‪‬‫⁬‭⁯‫‎⁭‫‪⁯⁪⁯‍‬‬⁮‭‮) new \u202B​⁮⁭⁯‎⁫⁮⁪‭‭⁭⁮‍‎‌⁯‫⁫‎​⁫​‪‬‬‍⁫⁬‎‫⁪‏‌⁪​‪‎‮⁮‮();

  static \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮()
  {
    \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200C​⁭‎‏‏‮‏⁫‬‮‏⁫‭⁫‬‮‬‬⁪‬‍‪‭‎⁮‫⁯⁪‪‍⁫‮⁬⁫‫‪‬⁬⁬‮.\u206E‬‫‪‍‬​⁯⁪‫‍⁮⁮‌‫‮‭⁯​‫‫⁬⁫⁯‭‌⁪⁬⁮​⁯⁮‮‏⁫‏‪⁮⁯‬‮((object) "2a");
    \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200C​⁭‎‏‏‮‏⁫‬‮‏⁫‭⁫‬‮‬‬⁪‬‍‪‭‎⁮‫⁯⁪‪‍⁫‮⁬⁫‫‪‬⁬⁬‮.\u206E‬‫‪‍‬​⁯⁪‫‍⁮⁮‌‫‮‭⁯​‫‫⁬⁫⁯‭‌⁪⁬⁮​⁯⁮‮‏⁫‏‪⁮⁯‬‮((object) "2y");
    \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200C​⁭‎‏‏‮‏⁫‬‮‏⁫‭⁫‬‮‬‬⁪‬‍‪‭‎⁮‫⁯⁪‪‍⁫‮⁬⁫‫‪‬⁬⁬‮.\u206E‬‫‪‍‬​⁯⁪‫‍⁮⁮‌‫‮‭⁯​‫‫⁬⁫⁯‭‌⁪⁬⁮​⁯⁮‮‏⁫‏‪⁮⁯‬‮((object) "2b");
    for (int index = 0; index < \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200E⁯‪‫‍⁮⁯‌‌⁫⁬⁫‭‬‮⁪‮⁪⁫⁮‎‏‌⁬⁬‭⁫‏⁬‍⁬⁯⁭⁮‮⁮⁪⁯⁫⁬‮.Length; ++index)
      \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200E⁯‪‫‍⁮⁯‌‌⁫⁬⁫‭‬‮⁪‮⁪⁫⁮‎‏‌⁬⁬‭⁫‏⁬‍⁬⁯⁭⁮‮⁮⁪⁯⁫⁬‮[index] = byte.MaxValue;
    for (int index = 0; index < \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200B⁭⁬​‮‭‎​⁮‫⁫⁮⁬⁭⁬‎‍‏‏‌‫⁮‏‬‏⁬⁪⁪‬⁯‮⁯‎⁪‫‫⁫⁭‍‫‮.Length; ++index)
      \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200E⁯‪‫‍⁮⁯‌‌⁫⁬⁫‭‬‮⁪‮⁪⁫⁮‎‏‌⁬⁬‭⁫‏⁬‍⁬⁯⁭⁮‮⁮⁪⁯⁫⁬‮[(int) \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200B⁭⁬​‮‭‎​⁮‫⁫⁮⁬⁭⁬‎‍‏‏‌‫⁮‏‬‏⁬⁪⁪‬⁯‮⁯‎⁪‫‫⁫⁭‍‫‮[index]] = (byte) index;
  }

  private static string \u206B​‌‎⁮⁭⁮⁭‭‍‮‏⁪⁮⁭⁪⁫⁪‫‌‫‪‮​⁫‭‮⁯⁭‌⁬‬‎‏⁫⁭‬⁫‬⁮‮(
    string _param0,
    byte[] _param1,
    byte[] _param2,
    int _param3)
  {
    if (!\u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200C​⁭‎‏‏‮‏⁫‬‮‏⁫‭⁫‬‮‬‬⁪‬‍‪‭‎⁮‫⁯⁪‪‍⁫‮⁬⁫‫‪‬⁬⁬‮.\u200E‪‏⁭‍⁭⁪‫‍‏‍‮⁮‬‌⁬⁫⁪‮‫⁯‮‮‭⁬⁯‮‭​⁭‫‪‮‫‎⁬⁮⁭⁭‍‮((object) _param0))
      throw new ArgumentException("Version " + _param0 + " is not accepted by this implementation.", "version");
    StringBuilder stringBuilder = new StringBuilder(60);
    stringBuilder.Append('$');
    stringBuilder.Append(_param0);
    stringBuilder.Append('$');
    stringBuilder.Append(_param3 < 10 ? "0" + _param3.ToString() : _param3.ToString());
    stringBuilder.Append('$');
    stringBuilder.Append(\u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u202A‬‏‏‮‪‮​⁬‪‬‭‭‫⁯​‎‫⁪‭‌‫‭⁪‏⁮⁯‎‎‬⁬‭‫‪‭⁭⁫‏‌‮‮(_param2));
    stringBuilder.Append(\u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u202A‬‏‏‮‪‮​⁬‪‬‭‭‫⁯​‎‫⁪‭‌‫‭⁪‏⁮⁯‎‎‬⁬‭‫‪‭⁭⁫‏‌‮‮(\u206B⁯⁭⁮‎⁭‫⁬‏⁬‎‮⁭‭‏‏⁯‮‮‬⁫‫‌‮‬⁮⁭⁫​‪​‍‬‌‭⁫‎‎⁬‭‮.\u202C⁯⁫‮‭⁪‌‍​‎⁭⁮‌‍‮‍‎‍⁬‏⁫‪‎‎⁯⁮‬⁮⁪‬‭‍‎⁭‌‬⁯⁫⁬⁮‮(_param1, _param2, _param3)));
    return stringBuilder.ToString();
  }

  public static string \u202C⁯⁫‮‭⁪‌‍​‎⁭⁮‌‍‮‍‎‍⁬‏⁫‪‎‎⁯⁮‬⁮⁪‬‭‍‎⁭‌‬⁯⁫⁬⁮‮(
    char[] _param0,
    byte[] _param1,
    int _param2)
  {
    return \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u202C⁯⁫‮‭⁪‌‍​‎⁭⁮‌‍‮‍‎‍⁬‏⁫‪‎‎⁯⁮‬⁮⁪‬‭‍‎⁭‌‬⁯⁫⁬⁮‮(\u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u202E‏‮​⁪⁫⁫⁫‎‍⁬‎⁬​‍‎⁮‭⁮⁬‍⁭‌‬⁭​⁮⁬⁭⁮‪‏‌⁭‏⁪⁪‪⁮‭‮, _param0, _param1, _param2);
  }

  public static string \u202C⁯⁫‮‭⁪‌‍​‎⁭⁮‌‍‮‍‎‍⁬‏⁫‪‎‎⁯⁮‬⁮⁪‬‭‍‎⁭‌‬⁯⁫⁬⁮‮(
    string _param0,
    char[] _param1,
    byte[] _param2,
    int _param3)
  {
    if (!\u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200C​⁭‎‏‏‮‏⁫‬‮‏⁫‭⁫‬‮‬‬⁪‬‍‪‭‎⁮‫⁯⁪‪‍⁫‮⁬⁫‫‪‬⁬⁬‮.\u200E‪‏⁭‍⁭⁪‫‍‏‍‮⁮‬‌⁬⁫⁪‮‫⁯‮‮‭⁬⁯‮‭​⁭‫‪‮‫‎⁬⁮⁭⁭‍‮((object) _param0))
      throw new ArgumentException("Version " + _param0 + " is not accepted by this implementation.", "version");
    if (_param1 == null)
      throw new ArgumentNullException("password");
    if (_param2 == null)
      throw new ArgumentNullException("salt");
    if (_param2.Length != 16)
      throw new \u202A⁯⁬⁬‪⁫‌‏‎‬⁮‬⁪⁬‬⁯‍‍‍‌‎‍‍‬‍‮‬⁫​⁬‎⁯‪‏‏‫‍‫‌‫‮("16 byte salt required: " + _param2.Length.ToString());
    if (_param3 < 4 || _param3 > 31)
      throw new ArgumentException("Invalid cost factor.", "cost");
    byte[] sourceArray = \u200C‍‌‪⁯⁫⁬⁭‏‫‍⁮‭‬‏‬⁬⁬⁪⁮⁬⁯⁫⁫‫‎‭​‬‭‏‭⁬⁮‫⁯⁭⁪‭‫‮.\u200B⁯⁪‌⁬‌​‎‏‍⁪‫‌⁫⁬​⁭⁭⁫‍⁯⁮‍⁮‬​‪⁫​‌⁬‎⁯⁮‪​⁫‏‫‎‮(_param1);
    byte[] destinationArray = new byte[sourceArray.Length >= 72 ? 72 : sourceArray.Length + 1];
    int length = Math.Min(sourceArray.Length, destinationArray.Length);
    Array.Copy((Array) sourceArray, 0, (Array) destinationArray, 0, length);
    Array.Clear((Array) sourceArray, 0, sourceArray.Length);
    string str = \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u206B​‌‎⁮⁭⁮⁭‭‍‮‏⁪⁮⁭⁪⁫⁪‫‌‫‪‮​⁫‭‮⁯⁭‌⁬‬‎‏⁫⁭‬⁫‬⁮‮(_param0, destinationArray, _param2, _param3);
    Array.Clear((Array) destinationArray, 0, destinationArray.Length);
    return str;
  }

  public static bool \u200D⁭‎⁪‍⁪⁪⁫‭⁭‍⁮‫‮‫‭‫⁯‎⁭⁯‍⁯⁭‬‍‫‍‬‮​‍‭​​‭‪⁫‎⁬‮(string _param0, char[] _param1)
  {
    if (_param0.Length != 60)
      throw new \u202A⁯⁬⁬‪⁫‌‏‎‬⁮‬⁪⁬‬⁯‍‍‍‌‎‍‍‬‍‮‬⁫​⁬‎⁯‪‏‏‫‍‫‌‫‮("Bcrypt String length: " + _param0.Length.ToString() + ", 60 required.");
    string str1 = _param0[0] == '$' && _param0[3] == '$' && _param0[6] == '$' ? _param0.Substring(1, 2) : throw new ArgumentException("Invalid Bcrypt String format.", "bcryptString");
    if (!\u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200C​⁭‎‏‏‮‏⁫‬‮‏⁫‭⁫‬‮‬‬⁪‬‍‪‭‎⁮‫⁯⁪‪‍⁫‮⁬⁫‫‪‬⁬⁬‮.\u200E‪‏⁭‍⁭⁪‫‍‏‍‮⁮‬‌⁬⁫⁪‮‫⁯‮‮‭⁬⁯‮‭​⁭‫‪‮‫‎⁬⁮⁭⁭‍‮((object) str1))
      throw new ArgumentException("Bcrypt version '" + str1 + "' is not supported by this implementation", "bcryptString");
    int num1;
    try
    {
      num1 = int.Parse(_param0.Substring(4, 2));
    }
    catch (Exception ex)
    {
      throw new ArgumentException("Invalid cost factor: " + _param0.Substring(4, 2), "bcryptString", ex);
    }
    if (num1 < 4 || num1 > 31)
      throw new ArgumentException("Invalid cost factor: " + num1.ToString() + ", 4 < cost < 31 expected.");
    if (_param1 == null)
      throw new ArgumentNullException("Missing password.");
    int startIndex = _param0.LastIndexOf('$') + 1;
    int num2 = _param0.Length - 31;
    byte[] numArray = \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u206A‭‌‫‫‮‎⁭‌⁯⁫‮‎‏‮⁬⁯⁯⁪‭‭‮⁭‮⁮‎‪⁭⁬⁫⁫​⁭⁫⁬‏​‫‌‮‮(_param0.Substring(startIndex, num2 - startIndex));
    string str2 = \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u202C⁯⁫‮‭⁪‌‍​‎⁭⁮‌‍‮‍‎‍⁬‏⁫‪‎‎⁯⁮‬⁮⁪‬‭‍‎⁭‌‬⁯⁫⁬⁮‮(str1, _param1, numArray, num1);
    return _param0.Equals(str2);
  }

  private static string \u202A‬‏‏‮‪‮​⁬‪‬‭‭‫⁯​‎‫⁪‭‌‫‭⁪‏⁮⁯‎‎‬⁬‭‫‪‭⁭⁫‏‌‮‮(byte[] _param0)
  {
    if (_param0.Length != 24 && _param0.Length != 16)
      throw new \u202A⁯⁬⁬‪⁫‌‏‎‬⁮‬⁪⁬‬⁯‍‍‍‌‎‍‍‬‍‮‬⁫​⁬‎⁯‪‏‏‫‍‫‌‫‮("Invalid length: " + _param0.Length.ToString() + ", 24 for key or 16 for salt expected");
    bool flag = false;
    if (_param0.Length == 16)
    {
      flag = true;
      byte[] destinationArray = new byte[18];
      Array.Copy((Array) _param0, 0, (Array) destinationArray, 0, _param0.Length);
      _param0 = destinationArray;
    }
    else
      _param0[_param0.Length - 1] = (byte) 0;
    MemoryStream memoryStream = new MemoryStream();
    int length1 = _param0.Length;
    for (int index = 0; index < length1; index += 3)
    {
      uint num1 = (uint) _param0[index];
      uint num2 = (uint) _param0[index + 1];
      uint num3 = (uint) _param0[index + 2];
      memoryStream.WriteByte(\u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200B⁭⁬​‮‭‎​⁮‫⁫⁮⁬⁭⁬‎‍‏‏‌‫⁮‏‬‏⁬⁪⁪‬⁯‮⁯‎⁪‫‫⁫⁭‍‫‮[(int) (num1 >> 2) & 63]);
      memoryStream.WriteByte(\u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200B⁭⁬​‮‭‎​⁮‫⁫⁮⁬⁭⁬‎‍‏‏‌‫⁮‏‬‏⁬⁪⁪‬⁯‮⁯‎⁪‫‫⁫⁭‍‫‮[((int) num1 << 4 | (int) (num2 >> 4)) & 63]);
      memoryStream.WriteByte(\u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200B⁭⁬​‮‭‎​⁮‫⁫⁮⁬⁭⁬‎‍‏‏‌‫⁮‏‬‏⁬⁪⁪‬⁯‮⁯‎⁪‫‫⁫⁭‍‫‮[((int) num2 << 2 | (int) (num3 >> 6)) & 63]);
      memoryStream.WriteByte(\u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200B⁭⁬​‮‭‎​⁮‫⁫⁮⁬⁭⁬‎‍‏‏‌‫⁮‏‬‏⁬⁪⁪‬⁯‮⁯‎⁪‫‫⁫⁭‍‫‮[(int) num3 & 63]);
    }
    string str = \u200C‍‌‪⁯⁫⁬⁭‏‫‍⁮‭‬‏‬⁬⁬⁪⁮⁬⁯⁫⁫‫‎‭​‬‭‏‭⁬⁮‫⁯⁭⁪‭‫‮.\u202E‍‌‎‍‫‪‎‌⁯‫⁫‏‮‏⁪⁯‫​‌‌⁫‬‍‍‮⁪⁫‮‬‪⁯​‮⁭‫⁫⁪‎‪‮(memoryStream.ToArray());
    int length2 = flag ? 22 : str.Length - 1;
    return str.Substring(0, length2);
  }

  private static byte[] \u206A‭‌‫‫‮‎⁭‌⁯⁫‮‎‏‮⁬⁯⁯⁪‭‭‮⁭‮⁮‎‪⁭⁬⁫⁫​⁭⁫⁬‏​‫‌‮‮(string _param0)
  {
    char[] charArray = _param0.ToCharArray();
    MemoryStream memoryStream = new MemoryStream(16);
    if (charArray.Length != 22)
      throw new \u202A⁯⁬⁬‪⁫‌‏‎‬⁮‬⁪⁬‬⁯‍‍‍‌‎‍‍‬‍‮‬⁫​⁬‎⁯‪‏‏‫‍‫‌‫‮("Invalid base64 salt length: " + charArray.Length.ToString() + " , 22 required.");
    for (int index = 0; index < charArray.Length; ++index)
    {
      int num = (int) charArray[index];
      if (num > 122 || num < 46 || num > 57 && num < 65)
        throw new ArgumentException("Salt string contains invalid character: " + num.ToString(), "saltString");
    }
    char[] destinationArray1 = new char[24];
    Array.Copy((Array) charArray, 0, (Array) destinationArray1, 0, charArray.Length);
    char[] chArray = destinationArray1;
    int length1 = chArray.Length;
    for (int index = 0; index < length1; index += 4)
    {
      byte num1 = \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200E⁯‪‫‍⁮⁯‌‌⁫⁬⁫‭‬‮⁪‮⁪⁫⁮‎‏‌⁬⁬‭⁫‏⁬‍⁬⁯⁭⁮‮⁮⁪⁯⁫⁬‮[(int) chArray[index]];
      byte num2 = \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200E⁯‪‫‍⁮⁯‌‌⁫⁬⁫‭‬‮⁪‮⁪⁫⁮‎‏‌⁬⁬‭⁫‏⁬‍⁬⁯⁭⁮‮⁮⁪⁯⁫⁬‮[(int) chArray[index + 1]];
      byte num3 = \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200E⁯‪‫‍⁮⁯‌‌⁫⁬⁫‭‬‮⁪‮⁪⁫⁮‎‏‌⁬⁬‭⁫‏⁬‍⁬⁯⁭⁮‮⁮⁪⁯⁫⁬‮[(int) chArray[index + 2]];
      byte num4 = \u202A⁫‎⁮⁪‏⁪​⁯‏⁯‮‍⁮‌‎⁬​​⁬​‮⁯‎‮‏⁫⁫⁯‍⁮‫⁬⁯​⁪⁮‮‪‬‮.\u200E⁯‪‫‍⁮⁯‌‌⁫⁬⁫‭‬‮⁪‮⁪⁫⁮‎‏‌⁬⁬‭⁫‏⁬‍⁬⁯⁭⁮‮⁮⁪⁯⁫⁬‮[(int) chArray[index + 3]];
      memoryStream.WriteByte((byte) ((int) num1 << 2 | (int) num2 >> 4));
      memoryStream.WriteByte((byte) ((int) num2 << 4 | (int) num3 >> 2));
      memoryStream.WriteByte((byte) ((uint) num3 << 6 | (uint) num4));
    }
    byte[] array = memoryStream.ToArray();
    byte[] numArray = new byte[16];
    byte[] destinationArray2 = numArray;
    int length2 = numArray.Length;
    Array.Copy((Array) array, 0, (Array) destinationArray2, 0, length2);
    return numArray;
  }
}
