// Decompiled with JetBrains decompiler
// Type: EntropyFileRNG
// Assembly: wacYTAgLgQAjexermaa, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8B2A0664-5AE5-48FF-9B05-FC8D65B8BF2C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-31211fd1239d9e0de50a1af9ad1e71a55be0dac1e55e06444d2537caa96bd0c6.exe

using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Digests;
using Org.BouncyCastle.Crypto.Prng;
using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Threading;

public sealed class EntropyFileRNG : RandomNumberGenerator
{
  private const int HmacSha256Length = 32;
  private const int TrueInt = 1;
  private const int FalseInt = 0;
  private const int PoolSize = 3072;
  private static byte[] HardCodedOptionalEntropy = new byte[31]
  {
    (byte) 138,
    (byte) 94,
    (byte) 137,
    (byte) 30,
    (byte) 86,
    (byte) 108,
    (byte) 102,
    (byte) 250,
    (byte) 111,
    (byte) 98,
    (byte) 74,
    (byte) 59,
    (byte) 158,
    (byte) 51,
    (byte) 196,
    (byte) 18,
    (byte) 40,
    (byte) 146,
    (byte) 47,
    (byte) 8,
    (byte) 156,
    (byte) 81,
    (byte) 31,
    (byte) 91,
    (byte) 133,
    (byte) 134,
    (byte) 26,
    (byte) 104,
    (byte) 239,
    (byte) 67,
    (byte) 2
  };
  private int disposed;
  private EntropyFileRNG.MixingAlgorithm myMixingAlgorithm;
  private EntropyFileRNG.PrngAlgorithm myRNGAlgorithm;
  private DigestRandomGenerator myRNG;
  private EventHandler EntropyFileRNG_Reseeded_Handler;

  private static event EventHandler Reseeded_Private;

  public static event EventHandler BecameAvailable;

  public event EventHandler Reseeded;

  public static byte[] \u003C\u002Ector\u003Eb__3_0get_SyntaxClose(IEnumerable<byte[]> byteArrays)
  {
    int length = 0;
    foreach (byte[] byteArray in byteArrays)
      checked { length += byteArray.Length; }
    byte[] destinationArray = new byte[length];
    int destinationIndex = 0;
    foreach (byte[] byteArray in byteArrays)
    {
      Array.Copy((Array) byteArray, 0, (Array) destinationArray, destinationIndex, byteArray.Length);
      destinationIndex += byteArray.Length;
    }
    return destinationArray;
  }

  public EntropyFileRNG(
    byte[] newSeed = null,
    EntropyFileRNG.MixingAlgorithm mixingAlgorithm = EntropyFileRNG.MixingAlgorithm.SHA256,
    EntropyFileRNG.PrngAlgorithm prngAlgorithm = EntropyFileRNG.PrngAlgorithm.SHA512_512bit)
  {
    this.myMixingAlgorithm = mixingAlgorithm;
    this.myRNGAlgorithm = prngAlgorithm;
    byte[] pool;
    EntropyFileRNG.Logget_HelpunloadPlugins(out pool, this.myMixingAlgorithm, newSeed);
    this.EntropyFileRNG_Reseeded_Handler = new EventHandler(this.QueueOnMainThreadvar_dumpset_Assembly);
    EntropyFileRNG.Reseeded_Private += this.EntropyFileRNG_Reseeded_Handler;
    this.get_AllowedCallerunloadPluginsGetPlugin(pool);
  }

  private void get_AllowedCallerunloadPluginsGetPlugin(byte[] pool)
  {
    if (pool == null)
      throw new CryptographicException("Refusing to reseed with null pool");
    try
    {
      if (pool.Length != 3072)
        throw new CryptographicException("Refusing to reseed with invalid pool");
      IDigest idigest;
      switch (this.myRNGAlgorithm)
      {
        case EntropyFileRNG.PrngAlgorithm.MD5_128bit:
          idigest = (IDigest) new MD5Digest();
          break;
        case EntropyFileRNG.PrngAlgorithm.RIPEMD128_128bit:
          idigest = (IDigest) new RipeMD128Digest();
          break;
        case EntropyFileRNG.PrngAlgorithm.RIPEMD160_160bit:
          idigest = (IDigest) new RipeMD160Digest();
          break;
        case EntropyFileRNG.PrngAlgorithm.SHA1_160bit:
          idigest = (IDigest) new Sha1Digest();
          break;
        case EntropyFileRNG.PrngAlgorithm.Tiger_192bit:
          idigest = (IDigest) new TigerDigest();
          break;
        case EntropyFileRNG.PrngAlgorithm.RIPEMD256_256bit:
          idigest = (IDigest) new RipeMD256Digest();
          break;
        case EntropyFileRNG.PrngAlgorithm.SHA256_256bit:
          idigest = (IDigest) new Sha256Digest();
          break;
        case EntropyFileRNG.PrngAlgorithm.RIPEMD320_320bit:
          idigest = (IDigest) new RipeMD320Digest();
          break;
        case EntropyFileRNG.PrngAlgorithm.SHA512_512bit:
          idigest = (IDigest) new Sha512Digest();
          break;
        case EntropyFileRNG.PrngAlgorithm.Whirlpool_512bit:
          idigest = (IDigest) new WhirlpoolDigest();
          break;
        default:
          throw new CryptographicException("Unknown prngAlgorithm specified: " + this.myRNGAlgorithm.ToString());
      }
      DigestRandomGenerator digestRandomGenerator = new DigestRandomGenerator(idigest);
      digestRandomGenerator.AddSeedMaterial(pool);
      this.myRNG = digestRandomGenerator;
    }
    finally
    {
      Array.Clear((Array) pool, 0, pool.Length);
    }
  }

  private void QueueOnMainThreadvar_dumpset_Assembly(object sender, EventArgs e)
  {
    byte[] pool;
    EntropyFileRNG.Logget_HelpunloadPlugins(out pool, this.myMixingAlgorithm);
    this.get_AllowedCallerunloadPluginsGetPlugin(pool);
    if (this.Reseeded == null)
      return;
    this.Reseeded((object) this, EventArgs.Empty);
  }

  public static void Loadget_AllowedCallerIsWindowVisible(
    byte[] newSeed,
    EntropyFileRNG.MixingAlgorithm mixingAlgorithm = EntropyFileRNG.MixingAlgorithm.SHA256)
  {
    byte[] pool;
    EntropyFileRNG.Logget_HelpunloadPlugins(out pool, mixingAlgorithm, newSeed);
    Array.Clear((Array) pool, 0, pool.Length);
  }

  private static HashAlgorithm SaveGroupGetMainTypeFromAssemblyTryRemoveComponent(
    EntropyFileRNG.MixingAlgorithm algorithm)
  {
    switch (algorithm)
    {
      case EntropyFileRNG.MixingAlgorithm.MD5:
        return (HashAlgorithm) MD5.Create();
      case EntropyFileRNG.MixingAlgorithm.RIPEMD160:
        return (HashAlgorithm) RIPEMD160.Create();
      case EntropyFileRNG.MixingAlgorithm.SHA1:
        return (HashAlgorithm) SHA1.Create();
      case EntropyFileRNG.MixingAlgorithm.SHA256:
        return (HashAlgorithm) SHA256.Create();
      case EntropyFileRNG.MixingAlgorithm.SHA512:
        return (HashAlgorithm) SHA512.Create();
      default:
        throw new ArgumentException("Unsupported algorithm");
    }
  }

  private static void Logget_HelpunloadPlugins(
    out byte[] pool,
    EntropyFileRNG.MixingAlgorithm mixingAlgorithm,
    byte[] newSeed = null)
  {
    if (newSeed != null && newSeed.Length < 8)
      throw new CryptographicException("Length >= 16 would be normal.  Length 8 is lame.  Length < 8 is insane.");
    HashAlgorithm tryRemoveComponent = EntropyFileRNG.SaveGroupGetMainTypeFromAssemblyTryRemoveComponent(mixingAlgorithm);
    try
    {
      FileStream randFileStream = EntropyFileRNG.set_HoursPlayedLastTwoWeekscheckCommandMappingsset_AvatarFull();
      try
      {
        pool = new byte[3072];
        int poolPosition = 0;
        if (randFileStream.Length == 0L)
        {
          if (newSeed == null)
            throw new CryptographicException("randFile nonexistent or zero-length, and newSeed not provided. randFile must be seeded before use.");
          EntropyFileRNG.SaveQueueOnMainThreadLoad(randFileStream, newSeed, tryRemoveComponent, pool, ref poolPosition);
        }
        else
        {
          EntropyFileRNG.set_Timeoutset_Headlineget_AllowedCaller(randFileStream, ref poolPosition, pool);
          EntropyFileRNG.SaveQueueOnMainThreadLoad(randFileStream, newSeed, tryRemoveComponent, pool, ref poolPosition);
        }
      }
      finally
      {
        randFileStream.Flush();
        randFileStream.Close();
      }
      if (newSeed == null)
        return;
      if (EntropyFileRNG.Reseeded_Private != null)
        EntropyFileRNG.Reseeded_Private((object) null, (EventArgs) null);
      if (EntropyFileRNG.BecameAvailable == null)
        return;
      EntropyFileRNG.BecameAvailable((object) null, (EventArgs) null);
    }
    finally
    {
      tryRemoveComponent.Dispose();
      if (newSeed != null)
        Array.Clear((Array) newSeed, 0, newSeed.Length);
    }
  }

  private static void SaveQueueOnMainThreadLoad(
    FileStream randFileStream,
    byte[] newSeed,
    HashAlgorithm myHashAlgorithm,
    byte[] pool,
    ref int poolPosition)
  {
    if (newSeed != null)
      EntropyFileRNG.\u003CAwake\u003Eb__12_0get_AllowedCallerOnDestroy(newSeed, myHashAlgorithm, ref poolPosition, pool);
    randFileStream.Position = 0L;
    randFileStream.SetLength(0L);
    byte[] numArray = new byte[3108];
    byte[] bytes = BitConverter.GetBytes(poolPosition);
    if (BitConverter.IsLittleEndian)
      Array.Reverse((Array) bytes);
    Array.Copy((Array) bytes, 0, (Array) numArray, 0, bytes.Length);
    int num1 = myHashAlgorithm.HashSize / 8;
    int num2;
    for (int offset = 0; offset < pool.Length; offset += num2)
    {
      num2 = offset + num1 > pool.Length ? pool.Length - offset : num1;
      Array.Copy((Array) myHashAlgorithm.ComputeHash(pool, offset, num2), 0, (Array) numArray, offset + 4, num2);
    }
    using (HMACSHA256 hmacshA256 = new HMACSHA256(EntropyFileRNG.HardCodedOptionalEntropy))
      Array.Copy((Array) hmacshA256.ComputeHash(numArray, 0, 3076), 0, (Array) numArray, 3076, 32);
    byte[] buffer = ProtectedData.Protect(numArray, EntropyFileRNG.HardCodedOptionalEntropy, DataProtectionScope.CurrentUser);
    Array.Clear((Array) numArray, 0, numArray.Length);
    randFileStream.Write(buffer, 0, buffer.Length);
    Array.Clear((Array) buffer, 0, buffer.Length);
  }

  private static void set_Timeoutset_Headlineget_AllowedCaller(
    FileStream randFileStream,
    ref int poolPosition,
    byte[] pool)
  {
    byte[] numArray1 = new byte[randFileStream.Length];
    randFileStream.Read(numArray1, 0, numArray1.Length);
    byte[] numArray2;
    try
    {
      numArray2 = ProtectedData.Unprotect(numArray1, EntropyFileRNG.HardCodedOptionalEntropy, DataProtectionScope.CurrentUser);
    }
    catch (Exception ex)
    {
      throw new CryptographicException("EntropyFileRNG failed to Unprotect random file", ex);
    }
    using (HMACSHA256 hmacshA256 = new HMACSHA256(EntropyFileRNG.HardCodedOptionalEntropy))
    {
      byte[] hash = hmacshA256.ComputeHash(numArray2, 0, 3076);
      for (int index = 0; index < 32; ++index)
      {
        if ((int) hash[index] != (int) numArray2[3076 + index])
          throw new CryptographicException("EntropyFileRNG found corrupt random file");
      }
      if (BitConverter.IsLittleEndian)
      {
        Array.Reverse((Array) numArray2, 0, 4);
        poolPosition = BitConverter.ToInt32(numArray2, 0);
      }
      Array.Copy((Array) numArray2, 4, (Array) pool, 0, 3072);
    }
  }

  private static FileStream set_HoursPlayedLastTwoWeekscheckCommandMappingsset_AvatarFull()
  {
    string path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "/tinhat.rnd";
    int num = 0;
    do
    {
      try
      {
        return new FileStream(path, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None);
      }
      catch
      {
        Thread.Sleep(1);
      }
      ++num;
    }
    while (num <= 10000);
    throw new CryptographicException("EntropyFileRNG too many failures trying to open rand file");
  }

  private static void \u003CAwake\u003Eb__12_0get_AllowedCallerOnDestroy(
    byte[] newSeed,
    HashAlgorithm myHashAlgorithm,
    ref int poolPosition,
    byte[] pool)
  {
    int num = myHashAlgorithm.HashSize / 8;
    int offset = 0;
    while (offset < newSeed.Length)
    {
      int count = offset + num > newSeed.Length ? newSeed.Length - offset : num;
      bool flag = true;
      int index1 = poolPosition;
      for (int index2 = offset; index2 < offset + count; ++index2)
      {
        if ((int) newSeed[index2] != (int) pool[index1])
        {
          flag = false;
          break;
        }
        ++index1;
        if (index1 == pool.Length)
          index1 = 0;
      }
      if (flag)
      {
        offset += count;
      }
      else
      {
        byte[] hash1 = myHashAlgorithm.ComputeHash(newSeed, offset, count);
        offset += count;
        byte[] hash2 = myHashAlgorithm.ComputeHash(pool, poolPosition, count);
        for (int index3 = 0; index3 < count; ++index3)
        {
          pool[poolPosition] = (byte) ((uint) hash2[index3] ^ (uint) hash1[index3]);
          ++poolPosition;
          if (poolPosition == pool.Length)
            poolPosition = 0;
        }
      }
    }
  }

  public override void GetBytes(byte[] data) => this.myRNG.NextBytes(data);

  public override void GetNonZeroBytes(byte[] data)
  {
    int index1 = 0;
    while (index1 < data.Length)
    {
      byte[] numArray = new byte[data.Length - index1];
      this.myRNG.NextBytes(numArray);
      for (int index2 = 0; index2 < numArray.Length; ++index2)
      {
        if (numArray[index2] != (byte) 0)
        {
          data[index1] = numArray[index2];
          ++index1;
        }
      }
    }
  }

  protected override void Dispose(bool disposing)
  {
    if (Interlocked.Exchange(ref this.disposed, 1) == 1)
      return;
    EntropyFileRNG.Reseeded_Private -= this.EntropyFileRNG_Reseeded_Handler;
    base.Dispose(disposing);
  }

  ~EntropyFileRNG() => this.Dispose(false);

  public enum PrngAlgorithm
  {
    MD5_128bit = 1,
    RIPEMD128_128bit = 2,
    RIPEMD160_160bit = 3,
    SHA1_160bit = 4,
    Tiger_192bit = 5,
    RIPEMD256_256bit = 6,
    SHA256_256bit = 7,
    RIPEMD320_320bit = 8,
    SHA512_512bit = 9,
    Whirlpool_512bit = 10, // 0x0000000A
  }

  public enum MixingAlgorithm
  {
    MD5 = 1,
    RIPEMD160 = 2,
    SHA1 = 3,
    SHA256 = 4,
    SHA512 = 5,
  }
}
