// Decompiled with JetBrains decompiler
// Type: Server.My.MySettings
// Assembly: Server, Version=2.0.0.2, Culture=neutral, PublicKeyToken=null
// MVID: 84A0DB64-644B-4D8C-8E08-B82602C6312E
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00009-msil\Worm.Win32.Autorun.ibt-f55bc1707b05226f88e41d8673331234ab851b4a8ccb380e183352433ca3c09f.exe

using Microsoft.VisualBasic.ApplicationServices;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Configuration;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Threading;

namespace Server.My
{
  [GeneratedCode("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
  [EditorBrowsable(EditorBrowsableState.Advanced)]
  [CompilerGenerated]
  internal sealed class MySettings : ApplicationSettingsBase
  {
    private static MySettings defaultInstance = (MySettings) SettingsBase.Synchronized((SettingsBase) new MySettings());
    private static bool addedHandler;
    private static object addedHandlerLockObject = RuntimeHelpers.GetObjectValue(new object());

    [DebuggerNonUserCode]
    public MySettings()
    {
    }

    [DebuggerNonUserCode]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    private static void AutoSaveSettings(object sender, EventArgs e)
    {
      bool mySettingsOnExit = MyProject.Application.SaveMySettingsOnExit;
      if ((uint) mySettingsOnExit - (uint) mySettingsOnExit < 0U)
        return;
      while (!mySettingsOnExit)
      {
        if (((mySettingsOnExit ? 1 : 0) & 0) == 0)
          return;
      }
      MySettingsProperty.Settings.Save();
      if ((uint) mySettingsOnExit <= uint.MaxValue)
        ;
    }

    public static MySettings Default
    {
      get
      {
        bool flag1 = !MySettings.addedHandler;
        if (false)
          ;
        while (flag1)
        {
          object handlerLockObject = MySettings.addedHandlerLockObject;
          ObjectFlowControl.CheckForSyncLockOnValueType(handlerLockObject);
          if ((uint) flag1 - (uint) flag1 <= uint.MaxValue)
            goto label_10;
label_3:
          try
          {
            bool flag2 = !MySettings.addedHandler;
            if ((uint) flag2 - (uint) flag2 >= 0U && false)
              goto label_8;
label_5:
            if (!flag2)
            {
              if ((uint) flag2 > uint.MaxValue)
                break;
              break;
            }
label_8:
            MyProject.Application.Shutdown += (ShutdownEventHandler) ((sender, e) =>
            {
              bool mySettingsOnExit = MyProject.Application.SaveMySettingsOnExit;
              if ((uint) mySettingsOnExit - (uint) mySettingsOnExit < 0U)
                return;
              while (!mySettingsOnExit)
              {
                if (((mySettingsOnExit ? 1 : 0) & 0) == 0)
                  return;
              }
              MySettingsProperty.Settings.Save();
              if ((uint) mySettingsOnExit <= uint.MaxValue)
                ;
            });
            if ((uint) flag2 <= uint.MaxValue)
            {
              MySettings.addedHandler = true;
              break;
            }
            goto label_5;
          }
          finally
          {
            Monitor.Exit(handlerLockObject);
          }
label_10:
          if (true)
          {
            Monitor.Enter(handlerLockObject);
            goto label_3;
          }
        }
        MySettings defaultInstance = MySettings.defaultInstance;
        return defaultInstance;
      }
    }
  }
}
