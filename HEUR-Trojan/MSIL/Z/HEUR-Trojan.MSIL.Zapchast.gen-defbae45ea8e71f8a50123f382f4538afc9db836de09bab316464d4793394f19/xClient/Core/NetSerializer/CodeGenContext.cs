// Decompiled with JetBrains decompiler
// Type: xClient.Core.NetSerializer.CodeGenContext
// Assembly: $77-Venom, Version=2.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC8E8704-647D-4CA7-99AB-BB7BE936B486
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan.MSIL.Zapchast.gen-defbae45ea8e71f8a50123f382f4538afc9db836de09bab316464d4793394f19.exe

using System;
using System.Collections.Generic;
using System.Reflection;

namespace xClient.Core.NetSerializer
{
  public sealed class CodeGenContext
  {
    private readonly Dictionary<Type, TypeData> m_typeMap;

    public CodeGenContext(Dictionary<Type, TypeData> typeMap)
    {
      this.m_typeMap = typeMap;
      TypeData type = this.m_typeMap[typeof (object)];
      this.SerializerSwitchMethodInfo = type.WriterMethodInfo;
      this.DeserializerSwitchMethodInfo = type.ReaderMethodInfo;
    }

    public MethodInfo SerializerSwitchMethodInfo { get; private set; }

    public MethodInfo DeserializerSwitchMethodInfo { get; private set; }

    public MethodInfo GetWriterMethodInfo(Type type) => this.m_typeMap[type].WriterMethodInfo;

    public MethodInfo GetReaderMethodInfo(Type type) => this.m_typeMap[type].ReaderMethodInfo;

    public bool IsGenerated(Type type) => this.m_typeMap[type].IsGenerated;

    public IDictionary<Type, TypeData> TypeMap => (IDictionary<Type, TypeData>) this.m_typeMap;

    private bool CanCallDirect(Type type) => type.IsValueType || type.IsArray || type.IsSealed && !this.IsGenerated(type);

    public TypeData GetTypeData(Type type) => this.m_typeMap[type];

    public TypeData GetTypeDataForCall(Type type)
    {
      if (!this.CanCallDirect(type))
        type = typeof (object);
      return this.GetTypeData(type);
    }
  }
}
