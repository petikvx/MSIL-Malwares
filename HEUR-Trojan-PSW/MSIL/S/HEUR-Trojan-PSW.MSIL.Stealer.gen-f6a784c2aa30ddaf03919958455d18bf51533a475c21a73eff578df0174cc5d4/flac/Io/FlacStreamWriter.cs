// Decompiled with JetBrains decompiler
// Type: flac.Io.FlacStreamWriter
// Assembly: STAThreadAttrib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 6EE3DE1A-E148-4FBA-A193-65BEA1824C00
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-PSW.MSIL.Stealer.gen-f6a784c2aa30ddaf03919958455d18bf51533a475c21a73eff578df0174cc5d4.exe

using System;
using System.IO;

namespace flac.Io
{
  public class FlacStreamWriter
  {
    private const int MAX_BITS_IN_CACHE = 8;
    private static readonly byte[] MASK = new byte[8]
    {
      (byte) 1,
      (byte) 3,
      (byte) 7,
      (byte) 15,
      (byte) 31,
      (byte) 63,
      (byte) 127,
      byte.MaxValue
    };
    private FileStream stream_;
    private CRC crc_;
    private byte cache_;
    private int bitsInCache_;

    public long Debug_BytesWritten => this.stream_.Position;

    public long Debug_BitsWritten => this.stream_.Position * 8L + (long) this.bitsInCache_;

    public CRC Crc => this.crc_;

    public int BitsToByteBoundary => Bit.ModBy8((long) (8 - Bit.ModBy8((long) this.bitsInCache_)));

    public FlacStreamWriter(FileStream stream)
    {
      this.stream_ = stream;
      this.crc_ = new CRC();
    }

    public void Truncate(long offset)
    {
      this.stream_.SetLength(0L);
      this.cache_ = (byte) 0;
      this.bitsInCache_ = 0;
    }

    private void Flush()
    {
      this.stream_.WriteByte(this.cache_);
      if (this.crc_.Running)
        this.crc_.AddByte(this.cache_);
      this.bitsInCache_ = 0;
      this.cache_ = (byte) 0;
    }

    private void putBit(byte bit)
    {
      this.cache_ = (byte) ((uint) this.cache_ << 1 | (uint) bit);
      ++this.bitsInCache_;
      if (this.bitsInCache_ != 8)
        return;
      this.Flush();
    }

    private void putByte(byte b)
    {
      ushort num1 = (ushort) ((uint) this.cache_ << 8 | (uint) b);
      this.cache_ = (byte) ((uint) num1 >> this.bitsInCache_);
      int bitsInCache = this.bitsInCache_;
      int num2 = 8 - this.bitsInCache_;
      ushort num3 = (ushort) (byte) ((uint) (byte) ((uint) num1 << num2) >> num2);
      this.Flush();
      this.cache_ = (byte) num3;
      this.bitsInCache_ = Bit.ModBy8((long) bitsInCache);
    }

    private void putBits(byte bits, int bitCount)
    {
      Debug.Assert(bitCount >= 0 && bitCount < 8);
      int index = bitCount - 1;
      while (index >= 0)
      {
        bits &= FlacStreamWriter.MASK[index];
        byte bit = (byte) ((uint) bits >> index);
        --index;
        this.putBit(bit);
      }
    }

    public void WriteBits(uint bits, int bitCount)
    {
      if (bitCount > 16)
      {
        int num1 = 32 - bitCount;
        uint num2 = bits << num1;
        this.WriteUShort((ushort) (num2 >> 16));
        bitCount -= 16;
        bits = (num2 & (uint) ushort.MaxValue) >> num1;
      }
      if (bitCount > 8)
      {
        int num3 = 16 - bitCount;
        ushort num4 = (ushort) (bits << num3);
        this.WriteByte((byte) ((uint) num4 >> 8));
        bitCount -= 8;
        bits = (uint) (((int) num4 & (int) byte.MaxValue) >> num3);
      }
      if (bitCount == 8)
      {
        this.putByte((byte) bits);
        bitCount -= 8;
      }
      this.putBits((byte) bits, bitCount);
    }

    private void WriteBitsAsULong(ulong bits, int bitCount)
    {
      if (bitCount > 32)
      {
        int num1 = 64 - bitCount;
        ulong num2 = bits << num1;
        this.WriteUInt((uint) (num2 >> 32));
        bitCount -= 32;
        bits = (num2 & (ulong) uint.MaxValue) >> num1;
      }
      this.WriteBits((uint) bits, bitCount);
    }

    public void WriteBits(int bits, int bitCount) => this.WriteBits((uint) bits, bitCount);

    public void WriteBitsAsLong(long bits, int bitCount) => this.WriteBitsAsULong((ulong) bits, bitCount);

    public void WriteBit(sbyte bit) => this.putBit((byte) bit);

    public void WriteByte(byte b) => this.putByte(b);

    public void WriteUShort(ushort bits)
    {
      this.putByte((byte) ((uint) bits >> 8));
      this.putByte((byte) ((uint) bits & (uint) byte.MaxValue));
    }

    public void WriteUInt(uint bits)
    {
      this.WriteUShort((ushort) (bits >> 16));
      this.WriteUShort((ushort) (bits & (uint) ushort.MaxValue));
    }

    public void WriteString(string s, int bitCount)
    {
      int result;
      int num = Math.DivRem(bitCount, 8, out result);
      Debug.Assert(result == 0);
      for (int index = 0; index < num; ++index)
        this.putByte((byte) s[index]);
    }

    public void WriteUnaryBitStream(int bitCount)
    {
      for (; bitCount >= 8; bitCount -= 8)
        this.putByte((byte) 0);
      for (; bitCount > 0; --bitCount)
        this.putBit((byte) 0);
      this.putBit((byte) 1);
    }
  }
}
