// Decompiled with JetBrains decompiler
// Type: Microsoft.MediaCenter.TV.Tuners.Log
// Assembly: Microsoft.MediaCenter.TV.Tuners.Interop, Version=6.1.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
// MVID: 4545DFBD-7834-4511-B0E8-46F2D6BF39B8
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00007-msil\Virus.Win32.Xpaj.gena-cd1c6eac0092a3981efe696f4cd6bf740246c6dcb9698d78918623e86d74734f.exe

using Microsoft.Win32;
using System;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;

namespace Microsoft.MediaCenter.TV.Tuners
{
  internal static class Log
  {
    private static string fileBaseName;
    private static string logSubPath;
    private static TextWriter traceWriter;
    private static Log.Level debugSwitchLevel;

    static unsafe Log()
    {
      // ISSUE: untyped stack allocation
      int pStorage = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
      Log.fileBaseName = "TunerInterop";
      Log.logSubPath = "\\Microsoft\\eHome\\Logs\\";
      try
      {
        Log.debugSwitchLevel = Log.Level.Info;
        string path1 = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) + Log.logSubPath;
        object[] objArray = new object[3]
        {
          (object) DateTime.Now.ToString("yyyy'-'MM'-'dd'-'HH'-'mm'-'ss", (IFormatProvider) CultureInfo.InvariantCulture),
          (object) Path.GetFileNameWithoutExtension(Process.GetCurrentProcess().MainModule.FileName),
          (object) Process.GetCurrentProcess().Id
        };
        string path2 = path1 + string.Format((IFormatProvider) CultureInfo.InvariantCulture, Log.fileBaseName + "Managed_{0}_{1}_{2}.log", objArray);
        Log.UpdateTraceLevel();
        if (!Directory.Exists(path1))
          Directory.CreateDirectory(path1);
        Log.traceWriter = TextWriter.Synchronized((TextWriter) new StreamWriter((Stream) File.Open(path2, FileMode.Append, FileAccess.Write, FileShare.Read)));
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        uint exceptionCode = (uint) Marshal.GetExceptionCode();
        if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint rethrow = 0;
        \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) pStorage);
        try
        {
          try
          {
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            rethrow = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
            if (rethrow != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          return;
          if (rethrow == 0U)
            return;
          throw;
        }
        finally
        {
          \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) pStorage, (int) rethrow);
        }
      }
    }

    public static void TraceError(string message) => Log.TraceWorker(Log.Level.Error, message);

    public static void TraceWarning(string message) => Log.TraceWorker(Log.Level.Warning, message);

    public static void TraceInfo(string message) => Log.TraceWorker(Log.Level.Info, message);

    public static void TraceVerbose(string message) => Log.TraceWorker(Log.Level.Verbose, message);

    private static unsafe void TraceWorker(Log.Level level, string message)
    {
      // ISSUE: untyped stack allocation
      int pStorage = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
      if (Log.debugSwitchLevel < level)
        return;
      if (Log.traceWriter == null)
        return;
      try
      {
        string str = string.Format((IFormatProvider) CultureInfo.InvariantCulture, "{0}:{1}:{2}", new object[3]
        {
          (object) DateTime.Now.ToString("o", (IFormatProvider) CultureInfo.InvariantCulture),
          (object) Thread.CurrentThread.ManagedThreadId,
          (object) message
        });
        Log.traceWriter.WriteLine(str);
        Log.traceWriter.Flush();
      }
      catch (ObjectDisposedException ex)
      {
        Log.debugSwitchLevel = Log.Level.Off;
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        uint exceptionCode = (uint) Marshal.GetExceptionCode();
        if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint rethrow = 0;
        \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) pStorage);
        try
        {
          try
          {
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            rethrow = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
            if (rethrow != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          return;
          if (rethrow == 0U)
            return;
          throw;
        }
        finally
        {
          \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) pStorage, (int) rethrow);
        }
      }
    }

    private static unsafe void UpdateTraceLevel()
    {
      // ISSUE: untyped stack allocation
      int pStorage = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
      try
      {
        RegistryKey localMachine = Registry.LocalMachine;
        if (localMachine == null)
          return;
        RegistryKey registryKey = localMachine.OpenSubKey("SOFTWARE\\debug\\" + Log.fileBaseName);
        if (registryKey != null)
        {
          object obj = registryKey.GetValue("TraceLevel");
          if (obj != null)
          {
            switch ((int) obj)
            {
              case 0:
                Log.debugSwitchLevel = Log.Level.Off;
                break;
              case 1:
                Log.debugSwitchLevel = Log.Level.Error;
                break;
              case 2:
                Log.debugSwitchLevel = Log.Level.Warning;
                break;
              case 3:
                Log.debugSwitchLevel = Log.Level.Info;
                break;
              case 4:
                Log.debugSwitchLevel = Log.Level.Verbose;
                break;
              default:
                Log.debugSwitchLevel = Log.Level.Verbose;
                break;
            }
          }
          registryKey.Close();
        }
        localMachine.Close();
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        uint exceptionCode = (uint) Marshal.GetExceptionCode();
        if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint rethrow = 0;
        \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) pStorage);
        try
        {
          try
          {
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            rethrow = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
            if (rethrow != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          return;
          if (rethrow == 0U)
            return;
          throw;
        }
        finally
        {
          \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) pStorage, (int) rethrow);
        }
      }
    }

    private enum Level
    {
      Off,
      Error,
      Warning,
      Info,
      Verbose,
    }
  }
}
