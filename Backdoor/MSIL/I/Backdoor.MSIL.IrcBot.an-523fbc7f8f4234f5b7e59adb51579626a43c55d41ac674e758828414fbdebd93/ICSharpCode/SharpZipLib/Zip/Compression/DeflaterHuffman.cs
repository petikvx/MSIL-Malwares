// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman
// Assembly: TheBot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E6D888C-8D83-46CE-907A-18F99381A0FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Backdoor.MSIL.IrcBot.an-523fbc7f8f4234f5b7e59adb51579626a43c55d41ac674e758828414fbdebd93.exe

using System;

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
  public class DeflaterHuffman
  {
    private const int \uE014 = 16384;
    private const int \uE013 = 286;
    private const int \uE012 = 30;
    private const int \uE011 = 19;
    private const int \uE010 = 16;
    private const int \uE00F = 17;
    private const int \uE00E = 18;
    private const int \uE00D = 256;
    private static readonly int[] \uE00C = new int[19]
    {
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    };
    private static readonly byte[] \uE00B = new byte[16]
    {
      (byte) 0,
      (byte) 8,
      (byte) 4,
      (byte) 12,
      (byte) 2,
      (byte) 10,
      (byte) 6,
      (byte) 14,
      (byte) 1,
      (byte) 9,
      (byte) 5,
      (byte) 13,
      (byte) 3,
      (byte) 11,
      (byte) 7,
      (byte) 15
    };
    private static short[] \uE00A = new short[286];
    private static byte[] \uE009 = new byte[286];
    private static short[] \uE008;
    private static byte[] \uE007;
    public DeflaterPending pending;
    private DeflaterHuffman.Tree \uE006;
    private DeflaterHuffman.Tree \uE005;
    private DeflaterHuffman.Tree \uE004;
    private short[] \uE003;
    private byte[] \uE002;
    private int \uE001;
    private int \uE000;

    static DeflaterHuffman()
    {
      int index1;
      for (index1 = 0; index1 < 144; DeflaterHuffman.\uE009[index1++] = (byte) 8)
        DeflaterHuffman.\uE00A[index1] = DeflaterHuffman.BitReverse(48 + index1 << 8);
      for (; index1 < 256; DeflaterHuffman.\uE009[index1++] = (byte) 9)
        DeflaterHuffman.\uE00A[index1] = DeflaterHuffman.BitReverse(256 + index1 << 7);
      for (; index1 < 280; DeflaterHuffman.\uE009[index1++] = (byte) 7)
        DeflaterHuffman.\uE00A[index1] = DeflaterHuffman.BitReverse(index1 - 256 << 9);
      for (; index1 < 286; DeflaterHuffman.\uE009[index1++] = (byte) 8)
        DeflaterHuffman.\uE00A[index1] = DeflaterHuffman.BitReverse(index1 - 88 << 8);
      DeflaterHuffman.\uE008 = new short[30];
      DeflaterHuffman.\uE007 = new byte[30];
      for (int index2 = 0; index2 < 30; ++index2)
      {
        DeflaterHuffman.\uE008[index2] = DeflaterHuffman.BitReverse(index2 << 11);
        DeflaterHuffman.\uE007[index2] = (byte) 5;
      }
    }

    public DeflaterHuffman(DeflaterPending pending)
    {
      this.pending = pending;
      this.\uE006 = new DeflaterHuffman.Tree(this, 286, 257, 15);
      this.\uE005 = new DeflaterHuffman.Tree(this, 30, 1, 15);
      this.\uE004 = new DeflaterHuffman.Tree(this, 19, 4, 7);
      this.\uE003 = new short[16384];
      this.\uE002 = new byte[16384];
    }

    public void Reset()
    {
      this.\uE001 = 0;
      this.\uE000 = 0;
      this.\uE006.Reset();
      this.\uE005.Reset();
      this.\uE004.Reset();
    }

    public void SendAllTrees(int blTreeCodes)
    {
      this.\uE004.BuildCodes();
      this.\uE006.BuildCodes();
      this.\uE005.BuildCodes();
      this.pending.WriteBits(this.\uE006.numCodes - 257, 5);
      this.pending.WriteBits(this.\uE005.numCodes - 1, 5);
      this.pending.WriteBits(blTreeCodes - 4, 4);
      for (int index = 0; index < blTreeCodes; ++index)
        this.pending.WriteBits((int) this.\uE004.length[DeflaterHuffman.\uE00C[index]], 3);
      this.\uE006.WriteTree(this.\uE004);
      this.\uE005.WriteTree(this.\uE004);
    }

    public void CompressBlock()
    {
      for (int index = 0; index < this.\uE001; ++index)
      {
        int code1 = (int) this.\uE002[index] & (int) byte.MaxValue;
        int num1 = (int) this.\uE003[index];
        int num2 = num1 - 1;
        if (num1 != 0)
        {
          int code2 = DeflaterHuffman.\uE001(code1);
          this.\uE006.WriteSymbol(code2);
          int count1 = (code2 - 261) / 4;
          if (count1 > 0 && count1 <= 5)
            this.pending.WriteBits(code1 & (1 << count1) - 1, count1);
          int code3 = DeflaterHuffman.\uE000(num2);
          this.\uE005.WriteSymbol(code3);
          int count2 = code3 / 2 - 1;
          if (count2 > 0)
            this.pending.WriteBits(num2 & (1 << count2) - 1, count2);
        }
        else
          this.\uE006.WriteSymbol(code1);
      }
      this.\uE006.WriteSymbol(256);
    }

    public void FlushStoredBlock(
      byte[] stored,
      int storedOffset,
      int storedLength,
      bool lastBlock)
    {
      this.pending.WriteBits(lastBlock ? 1 : 0, 3);
      this.pending.AlignToByte();
      this.pending.WriteShort(storedLength);
      this.pending.WriteShort(~storedLength);
      this.pending.WriteBlock(stored, storedOffset, storedLength);
      this.Reset();
    }

    public void FlushBlock(byte[] stored, int storedOffset, int storedLength, bool lastBlock)
    {
      this.\uE006.freqs[256]++;
      this.\uE006.BuildTree();
      this.\uE005.BuildTree();
      this.\uE006.CalcBLFreq(this.\uE004);
      this.\uE005.CalcBLFreq(this.\uE004);
      this.\uE004.BuildTree();
      int blTreeCodes = 4;
      for (int index = 18; index > blTreeCodes; --index)
      {
        if (this.\uE004.length[DeflaterHuffman.\uE00C[index]] > (byte) 0)
          blTreeCodes = index + 1;
      }
      int num1 = 14 + blTreeCodes * 3 + this.\uE004.GetEncodedLength() + this.\uE006.GetEncodedLength() + this.\uE005.GetEncodedLength() + this.\uE000;
      int num2 = this.\uE000;
      for (int index = 0; index < 286; ++index)
        num2 += (int) this.\uE006.freqs[index] * (int) DeflaterHuffman.\uE009[index];
      for (int index = 0; index < 30; ++index)
        num2 += (int) this.\uE005.freqs[index] * (int) DeflaterHuffman.\uE007[index];
      if (num1 >= num2)
        num1 = num2;
      if (storedOffset >= 0 && storedLength + 4 < num1 >> 3)
        this.FlushStoredBlock(stored, storedOffset, storedLength, lastBlock);
      else if (num1 == num2)
      {
        this.pending.WriteBits(2 + (lastBlock ? 1 : 0), 3);
        this.\uE006.SetStaticCodes(DeflaterHuffman.\uE00A, DeflaterHuffman.\uE009);
        this.\uE005.SetStaticCodes(DeflaterHuffman.\uE008, DeflaterHuffman.\uE007);
        this.CompressBlock();
        this.Reset();
      }
      else
      {
        this.pending.WriteBits(4 + (lastBlock ? 1 : 0), 3);
        this.SendAllTrees(blTreeCodes);
        this.CompressBlock();
        this.Reset();
      }
    }

    public bool IsFull() => this.\uE001 >= 16384;

    public bool TallyLit(int literal)
    {
      this.\uE003[this.\uE001] = (short) 0;
      byte[] numArray = this.\uE002;
      DeflaterHuffman deflaterHuffman = this;
      int num1;
      int num2 = num1 = deflaterHuffman.\uE001;
      deflaterHuffman.\uE001 = num1 + 1;
      int index = num2;
      int num3 = (int) (byte) literal;
      numArray[index] = (byte) num3;
      ++this.\uE006.freqs[literal];
      return this.IsFull();
    }

    public bool TallyDist(int distance, int length)
    {
      this.\uE003[this.\uE001] = (short) distance;
      byte[] numArray = this.\uE002;
      DeflaterHuffman deflaterHuffman = this;
      int num1;
      int num2 = num1 = deflaterHuffman.\uE001;
      deflaterHuffman.\uE001 = num1 + 1;
      int index1 = num2;
      int num3 = (int) (byte) (length - 3);
      numArray[index1] = (byte) num3;
      int index2 = DeflaterHuffman.\uE001(length - 3);
      ++this.\uE006.freqs[index2];
      if (index2 >= 265 && index2 < 285)
        this.\uE000 += (index2 - 261) / 4;
      int index3 = DeflaterHuffman.\uE000(distance - 1);
      ++this.\uE005.freqs[index3];
      if (index3 >= 4)
        this.\uE000 += index3 / 2 - 1;
      return this.IsFull();
    }

    public static short BitReverse(int toReverse) => (short) ((int) DeflaterHuffman.\uE00B[toReverse & 15] << 12 | (int) DeflaterHuffman.\uE00B[toReverse >> 4 & 15] << 8 | (int) DeflaterHuffman.\uE00B[toReverse >> 8 & 15] << 4 | (int) DeflaterHuffman.\uE00B[toReverse >> 12]);

    private static int \uE001(int _param0)
    {
      if (_param0 == (int) byte.MaxValue)
        return 285;
      int num = 257;
      for (; _param0 >= 8; _param0 >>= 1)
        num += 4;
      return num + _param0;
    }

    private static int \uE000(int _param0)
    {
      int num = 0;
      for (; _param0 >= 4; _param0 >>= 1)
        num += 2;
      return num + _param0;
    }

    private class Tree
    {
      public short[] freqs;
      public byte[] length;
      public int minNumCodes;
      public int numCodes;
      private short[] \uE003;
      private int[] \uE002;
      private int \uE001;
      private DeflaterHuffman \uE000;

      public Tree(DeflaterHuffman dh, int elems, int minCodes, int maxLength)
      {
        this.\uE000 = dh;
        this.minNumCodes = minCodes;
        this.\uE001 = maxLength;
        this.freqs = new short[elems];
        this.\uE002 = new int[maxLength];
      }

      public void Reset()
      {
        for (int index = 0; index < this.freqs.Length; index++)
          this.freqs[index] = (short) 0;
        this.\uE003 = (short[]) null;
        this.length = (byte[]) null;
      }

      public void WriteSymbol(int code) => this.\uE000.pending.WriteBits((int) this.\uE003[code] & (int) ushort.MaxValue, (int) this.length[code]);

      public void CheckEmpty()
      {
        bool flag = true;
        for (int index = 0; index < this.freqs.Length; index++)
        {
          if (this.freqs[index] == (short) 0)
            continue;
          flag = false;
        }
        if (!flag)
          throw new SharpZipBaseException(\uE01B.\uE000("\uE121\uE145\uE16D\uE170\uE174\uE179", 57600));
      }

      public void SetStaticCodes(short[] staticCodes, byte[] staticLengths)
      {
        this.\uE003 = staticCodes;
        this.length = staticLengths;
      }

      public void BuildCodes()
      {
        int length = this.freqs.Length;
        int[] numArray = new int[this.\uE001];
        int num1 = 0;
        this.\uE003 = new short[this.freqs.Length];
        for (int index = 0; index < this.\uE001; ++index)
        {
          numArray[index] = num1;
          num1 += this.\uE002[index] << 15 - index;
        }
        for (int index = 0; index < this.numCodes; ++index)
        {
          int num2 = (int) this.length[index];
          if (num2 > 0)
          {
            this.\uE003[index] = DeflaterHuffman.BitReverse(numArray[num2 - 1]);
            numArray[num2 - 1] += 1 << 16 - num2;
          }
        }
      }

      public void BuildTree()
      {
        int length = this.freqs.Length;
        int[] numArray1 = new int[length];
        int num1 = 0;
        int num2 = 0;
        for (int index1 = 0; index1 < length; ++index1)
        {
          int freq = (int) this.freqs[index1];
          if (freq != 0)
          {
            int index2;
            int index3;
            for (index2 = num1++; index2 > 0 && (int) this.freqs[numArray1[index3 = (index2 - 1) / 2]] > freq; index2 = index3)
              numArray1[index2] = numArray1[index3];
            numArray1[index2] = index1;
            num2 = index1;
          }
        }
        int num3;
        for (; num1 < 2; numArray1[num1++] = num3)
        {
          int num4;
          if (num2 >= 2)
            num4 = 0;
          else
            num2 = num4 = num2 + 1;
          num3 = num4;
        }
        this.numCodes = Math.Max(num2 + 1, this.minNumCodes);
        int num5 = num1;
        int[] numArray2 = new int[4 * num1 - 2];
        int[] numArray3 = new int[2 * num1 - 1];
        int num6 = num5;
        for (int index4 = 0; index4 < num1; ++index4)
        {
          int index5 = numArray1[index4];
          numArray2[2 * index4] = index5;
          numArray2[2 * index4 + 1] = -1;
          numArray3[index4] = (int) this.freqs[index5] << 8;
          numArray1[index4] = index4;
        }
        do
        {
          int index6 = numArray1[0];
          int index7 = numArray1[--num1];
          int index8 = 0;
          for (int index9 = 1; index9 < num1; index9 = index9 * 2 + 1)
          {
            if (index9 + 1 < num1 && numArray3[numArray1[index9]] > numArray3[numArray1[index9 + 1]])
              ++index9;
            numArray1[index8] = numArray1[index9];
            index8 = index9;
          }
          int num7 = numArray3[index7];
          int index10;
          while ((index10 = index8) > 0 && numArray3[numArray1[index8 = (index10 - 1) / 2]] > num7)
            numArray1[index10] = numArray1[index8];
          numArray1[index10] = index7;
          int index11 = numArray1[0];
          int index12 = num6++;
          numArray2[2 * index12] = index6;
          numArray2[2 * index12 + 1] = index11;
          int num8 = Math.Min(numArray3[index6] & (int) byte.MaxValue, numArray3[index11] & (int) byte.MaxValue);
          int num9;
          numArray3[index12] = num9 = numArray3[index6] + numArray3[index11] - num8 + 1;
          int index13 = 0;
          for (int index14 = 1; index14 < num1; index14 = index13 * 2 + 1)
          {
            if (index14 + 1 < num1 && numArray3[numArray1[index14]] > numArray3[numArray1[index14 + 1]])
              ++index14;
            numArray1[index13] = numArray1[index14];
            index13 = index14;
          }
          int index15;
          while ((index15 = index13) > 0 && numArray3[numArray1[index13 = (index15 - 1) / 2]] > num9)
            numArray1[index15] = numArray1[index13];
          numArray1[index15] = index12;
        }
        while (num1 > 1);
        if (numArray1[0] != numArray2.Length / 2 - 1)
          throw new SharpZipBaseException(\uE01B.\uE000("\uF7F1\uF7DC\uF7D8\uF7C9\uF799\uF7D0\uF7D7\uF7CF\uF7D8\uF7CB\uF7D0\uF7D8\uF7D7\uF7CD\uF799\uF7CF\uF7D0\uF7D6\uF7D5\uF7D8\uF7CD\uF7DC\uF7DD", 63417));
        this.\uE000(numArray2);
      }

      public int GetEncodedLength()
      {
        int encodedLength = 0;
        for (int index = 0; index < this.freqs.Length; ++index)
          encodedLength += (int) this.freqs[index] * (int) this.length[index];
        return encodedLength;
      }

      public void CalcBLFreq(DeflaterHuffman.Tree blTree)
      {
        int index1 = -1;
        int index2 = 0;
        while (index2 < this.numCodes)
        {
          int num1 = 1;
          int index3 = (int) this.length[index2];
          int num2;
          int num3;
          if (index3 == 0)
          {
            num2 = 138;
            num3 = 3;
          }
          else
          {
            num2 = 6;
            num3 = 3;
            if (index1 != index3)
            {
              ++blTree.freqs[index3];
              num1 = 0;
            }
          }
          index1 = index3;
          ++index2;
          while (index2 < this.numCodes && index1 == (int) this.length[index2])
          {
            ++index2;
            if (++num1 >= num2)
              break;
          }
          if (num1 < num3)
            blTree.freqs[index1] += (short) num1;
          else if (index1 != 0)
            ++blTree.freqs[16];
          else if (num1 <= 10)
            ++blTree.freqs[17];
          else
            ++blTree.freqs[18];
        }
      }

      public void WriteTree(DeflaterHuffman.Tree blTree)
      {
        int code1 = -1;
        int index = 0;
        while (index < this.numCodes)
        {
          int num1 = 1;
          int code2 = (int) this.length[index];
          int num2;
          int num3;
          if (code2 == 0)
          {
            num2 = 138;
            num3 = 3;
          }
          else
          {
            num2 = 6;
            num3 = 3;
            if (code1 != code2)
            {
              blTree.WriteSymbol(code2);
              num1 = 0;
            }
          }
          code1 = code2;
          ++index;
          while (index < this.numCodes && code1 == (int) this.length[index])
          {
            ++index;
            if (++num1 >= num2)
              break;
          }
          if (num1 < num3)
          {
            while (num1-- > 0)
              blTree.WriteSymbol(code1);
          }
          else if (code1 != 0)
          {
            blTree.WriteSymbol(16);
            this.\uE000.pending.WriteBits(num1 - 3, 2);
          }
          else if (num1 <= 10)
          {
            blTree.WriteSymbol(17);
            this.\uE000.pending.WriteBits(num1 - 3, 3);
          }
          else
          {
            blTree.WriteSymbol(18);
            this.\uE000.pending.WriteBits(num1 - 11, 7);
          }
        }
      }

      private void \uE000(int[] _param1)
      {
        this.length = new byte[this.freqs.Length];
        int length = _param1.Length / 2;
        int num1 = (length + 1) / 2;
        int num2 = 0;
        for (int index = 0; index < this.\uE001; ++index)
          this.\uE002[index] = 0;
        int[] numArray = new int[length];
        numArray[length - 1] = 0;
        for (int index = length - 1; index >= 0; --index)
        {
          if (_param1[2 * index + 1] != -1)
          {
            int num3 = numArray[index] + 1;
            if (num3 > this.\uE001)
            {
              num3 = this.\uE001;
              ++num2;
            }
            numArray[_param1[2 * index]] = numArray[_param1[2 * index + 1]] = num3;
          }
          else
          {
            ++this.\uE002[numArray[index] - 1];
            this.length[_param1[2 * index]] = (byte) numArray[index];
          }
        }
        if (num2 == 0)
          return;
        int index1 = this.\uE001 - 1;
        do
        {
          do
            ;
          while (this.\uE002[--index1] == 0);
          do
          {
            --this.\uE002[index1];
            ++this.\uE002[++index1];
            num2 -= 1 << this.\uE001 - 1 - index1;
          }
          while (num2 > 0 && index1 < this.\uE001 - 1);
        }
        while (num2 > 0);
        this.\uE002[this.\uE001 - 1] += num2;
        this.\uE002[this.\uE001 - 2] -= num2;
        int num4 = 2 * num1;
        for (int index2 = this.\uE001; index2 != 0; --index2)
        {
          int num5 = this.\uE002[index2 - 1];
          while (num5 > 0)
          {
            int index3 = 2 * _param1[num4++];
            if (_param1[index3 + 1] == -1)
            {
              this.length[_param1[index3]] = (byte) index2;
              --num5;
            }
          }
        }
      }
    }
  }
}
