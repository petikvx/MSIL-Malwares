// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer
// Assembly: Done, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EBE6DCED-6866-44D2-B309-A0C25849858B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Worm.MSIL.Autorun.jk-5bcc93e5d4639a5f95eb9ff6188099454019b185da8721fd79d0305ee3797532.exe

using System;

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
  public class PendingBuffer
  {
    protected byte[] buf;
    private int start;
    private int end;
    private uint bits;
    private int bitCount;

    public PendingBuffer()
      : this(4096)
    {
    }

    public PendingBuffer(int bufsize) => this.buf = new byte[(int) checked ((uint) bufsize)];

    public void Reset() => this.start = this.end = this.bitCount = 0;

    public void WriteByte(int b) => this.buf[this.end++] = (byte) b;

    public void WriteShort(int s)
    {
      this.buf[this.end++] = (byte) s;
      this.buf[this.end++] = (byte) (s >> 8);
    }

    public void WriteInt(int s)
    {
      this.buf[this.end++] = (byte) s;
      this.buf[this.end++] = (byte) (s >> 8);
      this.buf[this.end++] = (byte) (s >> 16);
      this.buf[this.end++] = (byte) (s >> 24);
    }

    public void WriteBlock(byte[] block, int offset, int len)
    {
      Array.Copy((Array) block, offset, (Array) this.buf, this.end, len);
      this.end += len;
    }

    public int BitCount => this.bitCount;

    public void AlignToByte()
    {
      if (this.bitCount > 0)
      {
        this.buf[this.end++] = (byte) this.bits;
        if (this.bitCount > 8)
          this.buf[this.end++] = (byte) (this.bits >> 8);
      }
      this.bits = 0U;
      this.bitCount = 0;
    }

    public void WriteBits(int b, int count)
    {
      this.bits |= (uint) (b << this.bitCount);
      this.bitCount += count;
      if (this.bitCount < 16)
        return;
      this.buf[this.end++] = (byte) this.bits;
      this.buf[this.end++] = (byte) (this.bits >> 8);
      this.bits >>= 16;
      this.bitCount -= 16;
    }

    public void WriteShortMSB(int s)
    {
      this.buf[this.end++] = (byte) (s >> 8);
      this.buf[this.end++] = (byte) s;
    }

    public bool IsFlushed => this.end == 0;

    public int Flush(byte[] output, int offset, int length)
    {
      if (this.bitCount >= 8)
      {
        this.buf[this.end++] = (byte) this.bits;
        this.bits >>= 8;
        this.bitCount -= 8;
      }
      if (length > this.end - this.start)
      {
        length = this.end - this.start;
        Array.Copy((Array) this.buf, this.start, (Array) output, offset, length);
        this.start = 0;
        this.end = 0;
      }
      else
      {
        Array.Copy((Array) this.buf, this.start, (Array) output, offset, length);
        this.start += length;
      }
      return length;
    }

    public byte[] ToByteArray()
    {
      byte[] destinationArray = new byte[(int) checked ((uint) unchecked (this.end - this.start))];
      Array.Copy((Array) this.buf, this.start, (Array) destinationArray, 0, destinationArray.Length);
      this.start = 0;
      this.end = 0;
      return destinationArray;
    }
  }
}
