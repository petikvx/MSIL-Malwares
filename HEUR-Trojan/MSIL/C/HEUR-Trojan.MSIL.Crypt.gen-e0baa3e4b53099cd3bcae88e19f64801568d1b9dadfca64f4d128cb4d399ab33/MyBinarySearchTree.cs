// Decompiled with JetBrains decompiler
// Type: D3DHelper.MyBinarySearchTree
// Assembly: XOBK, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 44C15233-611E-47F9-925F-576321862E3D
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.Crypt.gen-e0baa3e4b53099cd3bcae88e19f64801568d1b9dadfca64f4d128cb4d399ab33.exe

namespace D3DHelper
{
  public class MyBinarySearchTree
  {
    public TNode root;

    public MyBinarySearchTree() => this.root = (TNode) null;

    public void Insert(int i)
    {
      TNode tnode1;
      tnode1.iData = i;
      if (this.root == null)
      {
        this.root = tnode1;
      }
      else
      {
        TNode tnode2 = this.root;
        TNode tnode3;
        while (true)
        {
          tnode3 = tnode2;
          if (i < tnode2.iData)
          {
            tnode2 = tnode2.left;
            if (tnode2 == null)
              break;
          }
          else
          {
            tnode2 = tnode2.right;
            if (tnode2 == null)
              goto label_6;
          }
        }
        tnode3.left = tnode1;
        goto label_9;
label_6:
        tnode3.right = tnode1;
label_9:;
      }
    }

    public void inOrder(TNode theRoot)
    {
      if (theRoot == null)
        return;
      this.inOrder(theRoot.left);
      theRoot.displayNode();
      this.inOrder(theRoot.right);
    }

    public void preOrder(TNode theRoot)
    {
      if (theRoot == null)
        return;
      theRoot.displayNode();
      this.preOrder(theRoot.left);
      this.preOrder(theRoot.right);
    }

    public void postOrder(TNode theRoot)
    {
      if (theRoot == null)
        return;
      this.postOrder(theRoot.left);
      this.postOrder(theRoot.right);
      theRoot.displayNode();
    }

    public int FindMin()
    {
      TNode tnode = this.root;
      while (tnode.left != null)
        tnode = tnode.left;
      return tnode.iData;
    }

    public int FindMax()
    {
      TNode tnode = this.root;
      while (tnode.right != null)
        tnode = tnode.right;
      return tnode.iData;
    }

    public TNode Find(int key)
    {
      TNode tnode = this.root;
      while (tnode.iData != key)
      {
        tnode = key >= tnode.iData ? tnode.right : tnode.left;
        if (tnode == null)
          return (TNode) null;
      }
      return tnode;
    }
  }
}
