// Decompiled with JetBrains decompiler
// Type: Microsoft.MediaCenter.TV.Tuners.TunerCollection
// Assembly: Microsoft.MediaCenter.TV.Tuners.Interop, Version=6.1.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
// MVID: 4545DFBD-7834-4511-B0E8-46F2D6BF39B8
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00007-msil\Virus.Win32.Xpaj.gena-cd1c6eac0092a3981efe696f4cd6bf740246c6dcb9698d78918623e86d74734f.exe

using msclr;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace Microsoft.MediaCenter.TV.Tuners
{
  public class TunerCollection : ITunerCollection
  {
    private object m_SyncRoot;
    private Tuner[] m_Collection;

    private TunerEnumerator BuildEnumerator() => new TunerEnumerator(this.m_Collection);

    private void \u0021TunerCollection()
    {
      @lock lock1 = new @lock(this.m_SyncRoot);
      @lock lock2;
      // ISSUE: fault handler
      try
      {
        lock2 = lock1;
        Tuner[] collection = this.m_Collection;
        if (collection != null)
        {
          Tuner[] tunerArray = collection;
          int index = 0;
          if (0 < tunerArray.Length)
          {
            do
            {
              tunerArray[index]?.Dispose();
              ++index;
            }
            while (index < tunerArray.Length);
          }
          this.m_Collection = (Tuner[]) null;
        }
      }
      __fault
      {
        lock2.Dispose();
      }
      lock2.Dispose();
    }

    internal TunerCollection(TunerManager pManager, __FnPtr<byte (Tuner)> pPred)
    {
      this.m_Collection = pManager.GetCachedCollection(pPred, RecorderMgrFlags.rmf_WaitNone);
      // ISSUE: explicit constructor call
      base.\u002Ector();
    }

    internal TunerCollection(TunerManager pManager)
    {
      this.m_Collection = pManager.GetCachedCollection(RecorderMgrFlags.rmf_WaitNone);
      // ISSUE: explicit constructor call
      base.\u002Ector();
    }

    private void \u007ETunerCollection() => this.\u0021TunerCollection();

    IEnumerator<Tuner> IEnumerable<Tuner>.Generic_GetEnumerator() => (IEnumerator<Tuner>) this.BuildEnumerator();

    IEnumerator IEnumerable.IEnumerable_GetEnumerator() => (IEnumerator) this.BuildEnumerator();

    public virtual void Add(Tuner t) => throw new NotSupportedException();

    public virtual void Clear() => throw new NotSupportedException();

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual bool Contains(Tuner t) => throw new NotSupportedException();

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual bool Remove(Tuner t) => throw new NotSupportedException();

    public virtual void CopyTo(Array a, int i)
    {
      @lock lock1 = new @lock(this.m_SyncRoot);
      @lock lock2;
      // ISSUE: fault handler
      try
      {
        lock2 = lock1;
        IEnumerator enumerator = this.IEnumerable_GetEnumerator();
        int index = i;
        if (enumerator.MoveNext())
        {
          do
          {
            SafeComWrapper current = (SafeComWrapper) enumerator.Current;
            if (current != null && !current.IsInvalid)
            {
              a.SetValue((object) current, index);
              ++index;
            }
            else
              goto label_4;
          }
          while (enumerator.MoveNext());
          goto label_6;
label_4:
          throw new ApplicationException("unexpected failure to clone tuner collection member");
        }
      }
      __fault
      {
        lock2.Dispose();
      }
label_6:
      lock2.Dispose();
      // ISSUE: fault handler
      try
      {
      }
      __fault
      {
        lock2.Dispose();
      }
    }

    public virtual void CopyTo(Tuner[] a, int i)
    {
      @lock lock1 = new @lock(this.m_SyncRoot);
      @lock lock2;
      // ISSUE: fault handler
      try
      {
        lock2 = lock1;
        IEnumerator<Tuner> enumerator = this.Generic_GetEnumerator();
        int index = i;
        if (enumerator.MoveNext())
        {
          do
          {
            Tuner current = enumerator.Current;
            if (current != null && !current.IsInvalid)
            {
              a[index] = current;
              ++index;
            }
            else
              goto label_4;
          }
          while (enumerator.MoveNext());
          goto label_6;
label_4:
          throw new ApplicationException("unexpected failure to clone tuner collection member");
        }
      }
      __fault
      {
        lock2.Dispose();
      }
label_6:
      lock2.Dispose();
      // ISSUE: fault handler
      try
      {
      }
      __fault
      {
        lock2.Dispose();
      }
    }

    public virtual int Count => this.m_Collection.Length;

    public virtual bool IsReadOnly
    {
      [return: MarshalAs(UnmanagedType.U1)] get => true;
    }

    public virtual bool IsSynchronized
    {
      [return: MarshalAs(UnmanagedType.U1)] get => false;
    }

    public virtual object SyncRoot => this.m_SyncRoot;

    public virtual object Clone()
    {
      @lock lock1 = new @lock(this.m_SyncRoot);
      @lock lock2;
      Tuner[] tunerArray;
      // ISSUE: fault handler
      try
      {
        lock2 = lock1;
        Tuner[] collection = this.m_Collection;
        int length = collection.Length;
        tunerArray = new Tuner[length];
        int index = 0;
        if (0 < length)
        {
          do
          {
            Tuner tuner = \u003CModule\u003E.Microsoft\u002EMediaCenter\u002ETV\u002ETuners\u002Ememberwise_ref_clone\u003Cclass\u0020Microsoft\u003A\u003AMediaCenter\u003A\u003ATV\u003A\u003ATuners\u003A\u003ATuner\u0020\u005E\u003E(collection[index]);
            if (tuner != null && !tuner.IsInvalid)
            {
              tunerArray.SetValue((object) tuner, index);
              ++index;
              collection = this.m_Collection;
            }
            else
              goto label_4;
          }
          while (index < collection.Length);
          goto label_6;
label_4:
          throw new ApplicationException("unexpected failure to clone tuner collection member");
        }
      }
      __fault
      {
        lock2.Dispose();
      }
label_6:
      lock2.Dispose();
      return (object) tunerArray;
    }

    protected virtual void Dispose([MarshalAs(UnmanagedType.U1)] bool _param1)
    {
      if (_param1)
      {
        this.\u0021TunerCollection();
      }
      else
      {
        try
        {
          this.\u0021TunerCollection();
        }
        finally
        {
          // ISSUE: explicit finalizer call
          base.Finalize();
        }
      }
    }

    public virtual void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    ~TunerCollection() => this.Dispose(false);
  }
}
