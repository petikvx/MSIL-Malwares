// Decompiled with JetBrains decompiler
// Type: IRefl.Objects.BaseObserverObject
// Assembly: IRefl, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A29A65F6-B7ED-422C-83D4-B9EFD61E5F13
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-8e89881e34371e10b7f9cb943183a061aab9b22853cb7192e1ac09401f4cc545.exe

using IRefl.Pools;
using IRefl.Watchers;
using ProjNet.Structs;
using ProjNet.Templates;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace IRefl.Objects
{
  internal class BaseObserverObject : ServiceObserverWatcher
  {
    private double invocationRegistry;
    private double _WatcherRegistry;
    protected double m_MappingRegistry;
    protected double decoratorRegistry;
    private double connectionRegistry;
    private double _ParamRegistry;
    private double descriptorRegistry;
    private double _ResolverRegistry;
    private double importerRegistry;
    private double m_ProductRegistry;
    private double _DicRegistry;
    private double exceptionRegistry;
    private double _ErrorRegistry;
    private double m_ModelRegistry;
    protected double _MessageRegistry;
    protected double reponseRegistry;
    protected double strategyRegistry;
    protected double m_TestsRegistry;
    protected double _PoolRegistry;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public BaseObserverObject(List<Config> var1)
    {
      PageAdvisorStructBuilder.PrepareCreator();
      // ISSUE: explicit constructor call
      this.\u002Ector(var1, false);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public BaseObserverObject(List<Config> param, bool evaluatecounter)
    {
      PageAdvisorStructBuilder.PrepareCreator();
      // ISSUE: explicit constructor call
      base.\u002Ector(param, evaluatecounter);
      this.Name = "Krovak";
      this.MapAdvisor("EPSG");
      this.PrintAdvisor(9819L);
      Config config1 = this.PushMerchant("latitude_of_center");
      Config config2 = this.PushMerchant("longitude_of_center");
      Config config3 = this.PushMerchant("azimuth");
      Config config4 = this.PushMerchant("pseudo_standard_parallel_1");
      Config config5 = this.PushMerchant("scale_factor");
      Config config6 = this.PushMerchant("false_easting");
      Config config7 = this.PushMerchant("false_northing");
      if (config1 == null)
        throw new ArgumentException("Missing projection parameter 'latitude_of_center'");
      if (config2 == null)
        throw new ArgumentException("Missing projection parameter 'longitude_of_center'");
      if (config3 == null)
        throw new ArgumentException("Missing projection parameter 'azimuth'");
      if (config4 == null)
        throw new ArgumentException("Missing projection parameter 'pseudo_standard_parallel_1'");
      if (config6 == null)
        throw new ArgumentException("Missing projection parameter 'false_easting'");
      if (config7 == null)
        throw new ArgumentException("Missing projection parameter 'false_northing'");
      this.reponseRegistry = ValueObserverWatcher.PopAdvisor(config1.CountRegistry());
      this._MessageRegistry = ValueObserverWatcher.PopAdvisor(149.0 / 6.0);
      this.m_MappingRegistry = ValueObserverWatcher.PopAdvisor(config3.CountRegistry());
      this.decoratorRegistry = ValueObserverWatcher.PopAdvisor(config4.CountRegistry());
      this.strategyRegistry = config5.CountRegistry();
      this.invocationRegistry = config6.CountRegistry() * this.refRegistry;
      this._WatcherRegistry = config7.CountRegistry() * this.refRegistry;
      this.m_TestsRegistry = 1.0 - this._ConfigurationRegistry * this._ConfigurationRegistry / (this._InterpreterRegistry * this._InterpreterRegistry);
      this._PoolRegistry = Math.Sqrt(this.m_TestsRegistry);
      this.connectionRegistry = Math.Sin(this.m_MappingRegistry);
      this._ParamRegistry = Math.Cos(this.m_MappingRegistry);
      this.descriptorRegistry = Math.Sin(this.decoratorRegistry);
      this._ResolverRegistry = Math.Tan(this.decoratorRegistry / 2.0 + Math.PI / 4.0);
      double num1 = Math.Sin(this.reponseRegistry);
      double num2 = Math.Cos(this.reponseRegistry);
      double num3 = num2 * num2;
      this.importerRegistry = Math.Sqrt(1.0 + this.m_TestsRegistry * (num3 * num3) / (1.0 - this.m_TestsRegistry));
      this.m_ProductRegistry = this.importerRegistry * this._PoolRegistry / 2.0;
      double num4 = Math.Asin(num1 / this.importerRegistry);
      double num5 = this._PoolRegistry * num1;
      double num6 = Math.Pow((1.0 - num5) / (1.0 + num5), this.importerRegistry * this._PoolRegistry / 2.0);
      this._DicRegistry = Math.Pow(Math.Tan(this.reponseRegistry / 2.0 + Math.PI / 4.0), this.importerRegistry) * num6 / Math.Tan(num4 / 2.0 + Math.PI / 4.0);
      this.exceptionRegistry = Math.Pow(1.0 / this._DicRegistry, -1.0 / this.importerRegistry);
      this._ErrorRegistry = this.strategyRegistry * (Math.Sqrt(1.0 - this.m_TestsRegistry) / (1.0 - this.m_TestsRegistry * (num1 * num1))) / Math.Tan(this.decoratorRegistry);
      this.m_ModelRegistry = this._ErrorRegistry * Math.Pow(this._ResolverRegistry, this.descriptorRegistry);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] ComputeMerchant(double[] first)
    {
      int num1 = 3;
      if (BaseObserverObject.ConcatModel())
        ;
      double[] merchant;
      while (true)
      {
        double num2;
        double d;
        double num3;
        double num4;
        int num5;
        double num6;
        double num7;
        double a;
        double num8;
        switch (num1)
        {
          case 0:
          case 3:
            num6 = ValueObserverWatcher.PopAdvisor(first[0]) - this._MessageRegistry;
            if (BaseObserverObject.PatchModel())
            {
              num1 = 4;
              continue;
            }
            goto case 5;
          case 1:
          case 2:
            double num9 = Math.Pow((1.0 - num8) / (1.0 + num8), this.m_ProductRegistry);
            num3 = 2.0 * (Math.Atan(Math.Pow(Math.Tan(a / 2.0 + Math.PI / 4.0), this.importerRegistry) / this._DicRegistry * num9) - Math.PI / 4.0);
            num7 = -num6 * this.importerRegistry;
            num1 = 7;
            continue;
          case 4:
            a = ValueObserverWatcher.PopAdvisor(first[1]);
            num8 = this._PoolRegistry * Math.Sin(a);
            num5 = 1;
            break;
          case 5:
            d = Math.Asin(this._ParamRegistry * Math.Sin(num3) + this.connectionRegistry * num4 * Math.Cos(num7));
            num2 = Math.Asin(num4 * Math.Sin(num7) / Math.Cos(d));
            num5 = 6;
            break;
          case 6:
            double num10 = this.descriptorRegistry * num2;
            double num11 = this.m_ModelRegistry / Math.Pow(Math.Tan(d / 2.0 + Math.PI / 4.0), this.descriptorRegistry);
            double num12 = -(num11 * Math.Cos(num10)) * this._InterpreterRegistry;
            merchant = new double[2]
            {
              -(num11 * Math.Sin(num10)) * this._InterpreterRegistry,
              num12
            };
            num1 = 8;
            continue;
          case 7:
            num4 = Math.Cos(num3);
            goto case 5;
          case 8:
            goto label_11;
          default:
            num1 = 5;
            continue;
        }
        num1 = num5;
      }
label_11:
      return merchant;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] ConcatMerchant(double[] param)
    {
      int num1 = 4;
      double[] numArray;
      while (true)
      {
        int num2 = num1;
        double num3;
        double num4;
        double num5;
        double a;
        double key;
        bool flag;
        double num6;
        while (true)
        {
          double num7;
          int num8;
          switch (num2)
          {
            case 0:
            case 4:
              goto label_5;
            case 1:
              goto label_3;
            case 2:
              num3 = param[1] / this._InterpreterRegistry;
              int num9 = 1;
              num2 = BaseObserverObject.ConcatModel() ? num9 : num9;
              continue;
            case 3:
            case 8:
              double num10 = Math.Atan2(-num4, -num3) / this.descriptorRegistry;
              double num11 = 2.0 * (Math.Atan(Math.Pow(this._ErrorRegistry / num5, 1.0 / this.descriptorRegistry) * this._ResolverRegistry) - Math.PI / 4.0);
              double num12 = Math.Cos(num11);
              double d = Math.Asin(this._ParamRegistry * Math.Sin(num11) - this.connectionRegistry * num12 * Math.Cos(num10));
              num7 = this.exceptionRegistry * Math.Pow(Math.Tan(d / 2.0 + Math.PI / 4.0), 1.0 / this.importerRegistry);
              num6 = -Math.Asin(num12 * Math.Sin(num10) / Math.Cos(d)) / this.importerRegistry;
              key = 0.0;
              num8 = 15;
              break;
            case 5:
              if (flag || --num8 < 0)
                goto label_7;
              else
                break;
            case 6:
              goto label_8;
            case 7:
label_4:
              double num13 = this._PoolRegistry * Math.Sin(a);
              key = 2.0 * (Math.Atan(num7 * Math.Pow((1.0 + num13) / (1.0 - num13), this._PoolRegistry / 2.0)) - Math.PI / 4.0);
              if (BaseObserverObject.PatchModel())
              {
                num2 = 6;
                continue;
              }
              goto label_5;
            case 9:
              goto label_14;
            default:
              goto label_13;
          }
          a = key;
          goto label_4;
        }
label_3:
        num5 = Math.Sqrt(num4 * num4 + num3 * num3);
        num1 = 8;
        continue;
label_5:
        num4 = param[0] / this._InterpreterRegistry;
        num1 = 2;
        continue;
label_7:
        numArray = new double[2]
        {
          ValueObserverWatcher.SetAdvisor(num6 + this._MessageRegistry),
          ValueObserverWatcher.SetAdvisor(key)
        };
        num1 = 9;
        continue;
label_8:
        flag = Math.Abs(a - key) <= 1E-11;
        num1 = 5;
        continue;
label_13:
        num1 = 7;
      }
label_14:
      return numArray;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override OrderValuePool ManageItem()
    {
      int num = 0;
      OrderValuePool interceptorRegistry;
      while (true)
      {
        bool flag;
        switch (num)
        {
          case 0:
            flag = this.m_InterceptorRegistry == null;
            if (true)
            {
              num = 4;
              continue;
            }
            goto case 1;
          case 1:
          case 4:
            if (flag)
            {
              this.m_InterceptorRegistry = (ValueObserverWatcher) new BaseObserverObject(this.globalRegistry, !this._PropertyRegistry);
              goto case 2;
            }
            else
              break;
          case 2:
          case 3:
            break;
          case 5:
            goto label_9;
          default:
            num = 3;
            continue;
        }
        interceptorRegistry = (OrderValuePool) this.m_InterceptorRegistry;
        num = 5;
      }
label_9:
      return interceptorRegistry;
    }

    internal static bool PatchModel() => true;

    internal static bool ConcatModel() => false;
  }
}
