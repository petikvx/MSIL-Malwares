// Decompiled with JetBrains decompiler
// Type: Diploma.entity.Quaternion
// Assembly: FirstMatchCodeGr, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F6EA4DA3-79DC-4E24-BB6F-C97A77DCC118
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4ece28a4229d41e763203acb8c66af294e5461b01de2c4e25daddab193dfe554.exe

using System;

namespace Diploma.entity
{
  public class Quaternion : IVector
  {
    private Vector3 v;
    private double w;

    public Quaternion()
    {
      this.w = 1.0;
      this.v = new Vector3();
    }

    public Quaternion(double w, double x, double y, double z)
    {
      this.w = w;
      this.v = new Vector3(x, y, z);
    }

    public Quaternion(double w, Vector3 v)
    {
      this.w = w;
      this.v = new Vector3((IVector) v);
    }

    public Quaternion(Quaternion q)
    {
      this.w = q.w;
      this.v = new Vector3((IVector) q.v);
    }

    public Quaternion(double angle, Vector3 v, bool withangle)
    {
    }

    public double W => this.w;

    public double X => this.v.X;

    public double Y => this.v.Y;

    public double Z => this.v.Z;

    double IVector.this[int index]
    {
      get
      {
        switch (index)
        {
          case 0:
            return this.w;
          case 1:
            return this.v.X;
          case 2:
            return this.v.Y;
          case 3:
            return this.v.Z;
          default:
            return 0.0;
        }
      }
      set
      {
        switch (index)
        {
          case 0:
            this.w = value;
            break;
          case 1:
            this.v.X = value;
            break;
          case 2:
            this.v.Y = value;
            break;
          case 3:
            this.v.Z = value;
            break;
        }
      }
    }

    void IVector.print()
    {
      try
      {
        Console.WriteLine("Quaternion: [{0}, ({1}, {2}, {3})];", new object[4]
        {
          (object) this.w,
          (object) this.v.X,
          (object) this.v.Y,
          (object) this.v.Z
        });
      }
      catch (NullReferenceException ex)
      {
        Console.WriteLine("Empty Quaternion!");
      }
    }

    int IVector.length => 3;

    double IVector.norm() => this.getMagnitude();

    public double this[int index]
    {
      get
      {
        switch (index)
        {
          case 0:
            return this.w;
          case 1:
            return this.v.X;
          case 2:
            return this.v.Y;
          case 3:
            return this.v.Z;
          default:
            return 0.0;
        }
      }
      set
      {
        switch (index)
        {
          case 0:
            this.w = value;
            break;
          case 1:
            this.v.X = value;
            break;
          case 2:
            this.v.Y = value;
            break;
          case 3:
            this.v.Z = value;
            break;
        }
      }
    }

    public void changeToStandart()
    {
      this.w = 1.0;
      this.v = new Vector3();
    }

    public Quaternion getConjugateQuaternion() => new Quaternion(this.w, -1.0 * this.v.X, -1.0 * this.v.Y, -1.0 * this.v.Z);

    public double getNorm() => this.v * this.v + this.w * this.w;

    public double getMagnitude() => Math.Sqrt(this.getNorm());

    public Quaternion getInverse() => new Quaternion(1.0 / this.getNorm() * this.getConjugateQuaternion());

    public void changeValues(double neww, double newx, double newy, double newz)
    {
      this.w = neww;
      this.v = new Vector3(newx, newy, newz);
    }

    public void changeValues(Vector3 v, double w)
    {
      this.w = w;
      this.v = v;
    }

    public void changeValues(Quaternion q)
    {
      this.w = q.w;
      this.v = q.v;
    }

    public void print() => Console.WriteLine("[{0}, ({1}, {2}, {3})];", new object[4]
    {
      (object) this.w,
      (object) this.v.X,
      (object) this.v.Y,
      (object) this.v.Z
    });

    public void printInverse()
    {
      Console.Write("Inverse: ");
      this.getInverse().print();
    }

    public void printNorm() => Console.WriteLine("Norm: " + this.getNorm().ToString() + ";");

    public void printMagnitude() => Console.WriteLine("Magnitude: " + this.getMagnitude().ToString() + ";");

    public override string ToString() => "[" + this.w.ToString() + ",(" + this.v.X.ToString() + ", " + this.v.Y.ToString() + ", " + this.v.Z.ToString() + ")]";

    public static Quaternion Abs(Quaternion toAbs) => new Quaternion(Math.Abs(toAbs.w), Math.Abs(toAbs.X), Math.Abs(toAbs.Y), Math.Abs(toAbs.Z));

    public static Quaternion operator +(Quaternion q1, Quaternion q2) => new Quaternion(q1.w + q2.w, q1.v + q2.v);

    public static Quaternion operator -(Quaternion q1, Quaternion q2) => new Quaternion(q1.w - q2.w, q1.v - q2.v);

    public static Quaternion operator *(double a, Quaternion q) => new Quaternion(a * q.w, a * q.v);

    public static Quaternion operator *(int a, Quaternion q) => new Quaternion((double) a * q.w, a * q.v);

    public static Quaternion operator %(Quaternion q1, Quaternion q2) => new Quaternion(q1.w * q2.w - q1.v * q2.v, q1.v % q2.v + q1.w * q2.v + q2.w * q1.v);

    public static Quaternion operator *(Quaternion q1, Quaternion q2) => new Quaternion(q1.W * q2.W, q1.X * q2.X, q1.Y * q2.Y, q1.Z * q2.Z);

    public static double operator /(Quaternion q1, Quaternion q2) => q1.W * q2.W + q1.X * q2.X + q1.Y * q2.Y + q1.Z * q2.Z;

    public static Quaternion operator *(Quaternion q, Vector3 v)
    {
      Quaternion quaternion = new Quaternion(0.0, v.X, v.Y, v.Z);
      return new Quaternion(q * quaternion);
    }

    public static bool operator ==(Quaternion a, Quaternion b)
    {
      if ((object) a == (object) b)
        return true;
      return (object) a != null && (object) b != null && a.w == b.w && a.v == b.v;
    }

    public static bool operator !=(Quaternion a, Quaternion b) => !(a == b);

    public new bool Equals(object obj)
    {
      Quaternion quaternion = (Quaternion) obj;
      return this.w == quaternion.w && this.v == quaternion.v;
    }

    public override int GetHashCode() => 31 * (31 * (31 * (31 * 0 + this.w.GetHashCode()) + this.v.X.GetHashCode()) + this.v.Y.GetHashCode()) + this.v.Z.GetHashCode();
  }
}
