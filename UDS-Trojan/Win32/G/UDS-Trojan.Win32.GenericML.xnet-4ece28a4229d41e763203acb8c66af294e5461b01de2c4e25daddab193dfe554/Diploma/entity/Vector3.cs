// Decompiled with JetBrains decompiler
// Type: Diploma.entity.Vector3
// Assembly: FirstMatchCodeGr, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F6EA4DA3-79DC-4E24-BB6F-C97A77DCC118
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4ece28a4229d41e763203acb8c66af294e5461b01de2c4e25daddab193dfe554.exe

using System;

namespace Diploma.entity
{
  public class Vector3 : IVector
  {
    private double x;
    private double y;
    private double z;

    public Vector3()
    {
      this.x = 0.0;
      this.y = 0.0;
      this.z = 0.0;
    }

    public Vector3(double x, double y, double z)
    {
      this.x = x;
      this.y = y;
      this.z = z;
    }

    public Vector3(IVector v)
    {
      if (v.length == 3)
      {
        this.x = v[0];
        this.y = v[1];
        this.z = v[2];
      }
      else
        Console.WriteLine("Error while creating Vector3: amount of params isnot 3!");
    }

    double IVector.this[int index]
    {
      get
      {
        switch (index)
        {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            return 0.0;
        }
      }
      set
      {
        switch (index)
        {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
        }
      }
    }

    void IVector.print()
    {
      try
      {
        Console.WriteLine("Vector3: [{0}, {1}, {2}]", (object) this.x, (object) this.y, (object) this.z);
      }
      catch (NullReferenceException ex)
      {
        Console.WriteLine("Empty Vector3!");
      }
    }

    int IVector.length => 3;

    double IVector.norm() => Math.Sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

    public double X
    {
      get => this.x;
      set => this.x = value;
    }

    public double Y
    {
      get => this.y;
      set => this.y = value;
    }

    public double Z
    {
      get => this.z;
      set => this.z = value;
    }

    public double norm() => Math.Sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

    public static Vector3 operator +(Vector3 v1, Vector3 v2) => new Vector3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);

    public static Vector3 operator -(Vector3 a, Vector3 b) => new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);

    public static Vector3 operator *(double a, Vector3 v) => new Vector3(a * v.x, a * v.y, a * v.z);

    public static Vector3 operator *(int a, Vector3 v) => new Vector3((double) a * v.x, (double) a * v.y, (double) a * v.z);

    public static double operator *(Vector3 v1, Vector3 v2) => v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;

    public static Vector3 operator %(Vector3 v1, Vector3 v2) => new Vector3(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);

    public static bool operator ==(Vector3 a, Vector3 b)
    {
      if ((object) a == (object) b)
        return true;
      return (object) a != null && (object) b != null && a.x == b.x && a.y == b.y && a.z == b.z;
    }

    public static bool operator !=(Vector3 a, Vector3 b) => !(a == b);

    public bool Equals(Vector3 a) => this.x == a.x && this.y == a.y && this.z == a.z;

    public override int GetHashCode() => 31 * (31 * (31 * 0 + this.x.GetHashCode()) + this.y.GetHashCode()) + this.z.GetHashCode();
  }
}
