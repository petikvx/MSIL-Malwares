// Decompiled with JetBrains decompiler
// Type: 552264336354.737074588096
// Assembly: 087135227926, Version=10.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed
// MVID: 0DB320EA-9C28-4716-BA63-69641BABDE67
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Exploit.MSIL.Shellcode.gen-3283830ccf60d4481608cb301a1e81f6b89bd02ff08e41f6034488bc28baf010.exe

using \u003433898465903;
using \u003462605226301;
using \u003552264336354;
using \u003566559159672;
using \u003771916509144;
using \u003822138773656;
using \u003830680403346;
using \u003949304136191;
using \u003991227119410;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Reflection;

namespace \u003552264336354
{
  internal class \u003737074588096 : \u003547957345893
  {
    private static readonly \u003737074588096 \u003403516580492 = new \u003737074588096();

    internal static \u003547957345893 \u003350477269803 => (\u003547957345893) \u003737074588096.\u003403516580492;

    public virtual \u003381561884367<object> \u003573480817714(MethodBase _param1)
    {
      \u003821784578685.\u003260732825936((object) _param1, "method");
      Type type = typeof (object);
      ParameterExpression parameterExpression = Expression.Parameter(typeof (object[]), "args");
      return (\u003381561884367<object>) Expression.Lambda(typeof (\u003381561884367<object>), this.\u003780236456953(_param1, type, (ParameterExpression) null, parameterExpression), parameterExpression).Compile();
    }

    public virtual \u003481804917678<T, object> \u003777970466154<T>(
      MethodBase _param1)
    {
      \u003821784578685.\u003260732825936((object) _param1, "method");
      Type type = typeof (object);
      ParameterExpression parameterExpression1 = Expression.Parameter(type, "target");
      ParameterExpression parameterExpression2 = Expression.Parameter(typeof (object[]), "args");
      return (\u003481804917678<T, object>) Expression.Lambda(typeof (\u003481804917678<T, object>), this.\u003780236456953(_param1, type, parameterExpression1, parameterExpression2), parameterExpression1, parameterExpression2).Compile();
    }

    private Expression \u003780236456953(
      MethodBase _param1,
      Type _param2,
      ParameterExpression _param3,
      ParameterExpression _param4)
    {
      ParameterInfo[] parameters = _param1.GetParameters();
      Expression[] expressionArray;
      IList<\u003737074588096.\u003309985225678> objList1;
      if (parameters.Length == 0)
      {
        expressionArray = \u003141440380044.\u003458829377194<Expression>();
        objList1 = (IList<\u003737074588096.\u003309985225678>) \u003141440380044.\u003458829377194<\u003737074588096.\u003309985225678>();
      }
      else
      {
        expressionArray = new Expression[parameters.Length];
        objList1 = (IList<\u003737074588096.\u003309985225678>) new List<\u003737074588096.\u003309985225678>();
        for (int index1 = 0; index1 < parameters.Length; ++index1)
        {
          ParameterInfo parameterInfo = parameters[index1];
          Type type = parameterInfo.ParameterType;
          bool flag = false;
          if (type.IsByRef)
          {
            type = type.GetElementType();
            flag = true;
          }
          Expression index2 = (Expression) Expression.Constant((object) index1);
          Expression expression = this.\u003560012993671((Expression) Expression.ArrayIndex((Expression) _param4, index2), type, !flag);
          if (flag)
          {
            ParameterExpression parameterExpression = Expression.Variable(type);
            IList<\u003737074588096.\u003309985225678> objList2 = objList1;
            // ISSUE: object of a compiler-generated type is created
            // ISSUE: variable of a compiler-generated type
            \u003604162322746.\u003318572139883<> obj = new \u003604162322746.\u003318572139883<>();
            // ISSUE: reference to a compiler-generated field
            obj.\u003745676686177 = expression;
            ((\u003737074588096.\u003309985225678) obj).\u003165773471857 = parameterExpression;
            ((\u003737074588096.\u003309985225678) obj).\u003921894585833 = parameterInfo.IsOut;
            objList2.Add((\u003737074588096.\u003309985225678) obj);
            expression = (Expression) parameterExpression;
          }
          expressionArray[index1] = expression;
        }
      }
      Expression expression1 = !_param1.IsConstructor ? (!_param1.IsStatic ? (Expression) Expression.Call(this.\u003560012993671((Expression) _param3, _param1.DeclaringType), (MethodInfo) _param1, expressionArray) : (Expression) Expression.Call((MethodInfo) _param1, expressionArray)) : (Expression) Expression.New((ConstructorInfo) _param1, expressionArray);
      MethodInfo methodInfo = _param1 as MethodInfo;
      Expression expression2 = !(methodInfo != (MethodInfo) null) ? this.\u003560012993671(expression1, _param2) : (!(methodInfo.ReturnType != typeof (void)) ? (Expression) Expression.Block(expression1, (Expression) Expression.Constant((object) null)) : this.\u003560012993671(expression1, _param2));
      if (objList1.Count > 0)
      {
        IList<ParameterExpression> variables = (IList<ParameterExpression>) new List<ParameterExpression>();
        IList<Expression> expressionList = (IList<Expression>) new List<Expression>();
        foreach (\u003737074588096.\u003309985225678 obj in (IEnumerable<\u003737074588096.\u003309985225678>) objList1)
        {
          if (!obj.\u003921894585833)
          {
            // ISSUE: reference to a compiler-generated field
            expressionList.Add((Expression) Expression.Assign((Expression) obj.\u003165773471857, ((\u003604162322746.\u003318572139883<>) obj).\u003745676686177));
          }
          variables.Add(obj.\u003165773471857);
        }
        expressionList.Add(expression2);
        expression2 = (Expression) Expression.Block((IEnumerable<ParameterExpression>) variables, (IEnumerable<Expression>) expressionList);
      }
      return expression2;
    }

    public virtual Func<T> \u003487589840453<T>(Type _param1)
    {
      // ISSUE: object of a compiler-generated type is created
      // ISSUE: variable of a compiler-generated type
      \u003737074588096.\u003518332396896<T> obj = new \u003737074588096.\u003518332396896<T>();
      // ISSUE: reference to a compiler-generated field
      obj.type = _param1;
      // ISSUE: reference to a compiler-generated field
      \u003821784578685.\u003260732825936((object) obj.type, "type");
      // ISSUE: reference to a compiler-generated field
      if (obj.type.\u003207444793174())
      {
        // ISSUE: reference to a compiler-generated method
        return new Func<T>(obj.\u003CCreateDefaultConstructor\u003Eb__0);
      }
      try
      {
        Type type = typeof (T);
        // ISSUE: reference to a compiler-generated field
        return (Func<T>) Expression.Lambda(typeof (Func<T>), this.\u003560012993671((Expression) Expression.New(obj.type), type)).Compile();
      }
      catch
      {
        // ISSUE: reference to a compiler-generated method
        return new Func<T>(obj.\u003CCreateDefaultConstructor\u003Eb__1);
      }
    }

    public virtual Func<T, object> \u003661385013693<T>(PropertyInfo _param1)
    {
      \u003821784578685.\u003260732825936((object) _param1, "propertyInfo");
      Type type1 = typeof (T);
      Type type2 = typeof (object);
      ParameterExpression parameterExpression = Expression.Parameter(type1, "instance");
      return (Func<T, object>) Expression.Lambda(typeof (Func<T, object>), this.\u003560012993671(!_param1.GetGetMethod(true).IsStatic ? (Expression) Expression.MakeMemberAccess(this.\u003560012993671((Expression) parameterExpression, _param1.DeclaringType), (MemberInfo) _param1) : (Expression) Expression.MakeMemberAccess((Expression) null, (MemberInfo) _param1), type2), parameterExpression).Compile();
    }

    public virtual Func<T, object> \u003880287351003<T>(FieldInfo _param1)
    {
      \u003821784578685.\u003260732825936((object) _param1, "fieldInfo");
      ParameterExpression parameterExpression;
      return Expression.Lambda<Func<T, object>>(this.\u003560012993671(!_param1.IsStatic ? (Expression) Expression.Field(this.\u003560012993671((Expression) parameterExpression, _param1.DeclaringType), _param1) : (Expression) Expression.Field((Expression) null, _param1), typeof (object)), parameterExpression).Compile();
    }

    public virtual Action<T, object> \u003105069162686<T>(FieldInfo _param1)
    {
      \u003821784578685.\u003260732825936((object) _param1, "fieldInfo");
      if (_param1.DeclaringType.\u003465247563459() || _param1.IsInitOnly)
        return \u003275923193063.\u003292354127276.\u003712810484042<T>(_param1);
      ParameterExpression parameterExpression1 = Expression.Parameter(typeof (T), "source");
      ParameterExpression parameterExpression2 = Expression.Parameter(typeof (object), "value");
      Expression left = !_param1.IsStatic ? (Expression) Expression.Field(this.\u003560012993671((Expression) parameterExpression1, _param1.DeclaringType), _param1) : (Expression) Expression.Field((Expression) null, _param1);
      Expression right = this.\u003560012993671((Expression) parameterExpression2, left.Type);
      return (Action<T, object>) Expression.Lambda(typeof (Action<T, object>), (Expression) Expression.Assign(left, right), parameterExpression1, parameterExpression2).Compile();
    }

    public virtual Action<T, object> \u003557324281217<T>(PropertyInfo _param1)
    {
      \u003821784578685.\u003260732825936((object) _param1, "propertyInfo");
      if (_param1.DeclaringType.\u003465247563459())
        return \u003275923193063.\u003292354127276.\u003011394785423<T>(_param1);
      Type type1 = typeof (T);
      Type type2 = typeof (object);
      ParameterExpression parameterExpression1 = Expression.Parameter(type1, "instance");
      ParameterExpression parameterExpression2 = Expression.Parameter(type2, "value");
      Expression expression = this.\u003560012993671((Expression) parameterExpression2, _param1.PropertyType);
      MethodInfo setMethod = _param1.GetSetMethod(true);
      Expression body;
      if (setMethod.IsStatic)
        body = (Expression) Expression.Call(setMethod, expression);
      else
        body = (Expression) Expression.Call(this.\u003560012993671((Expression) parameterExpression1, _param1.DeclaringType), setMethod, expression);
      return (Action<T, object>) Expression.Lambda(typeof (Action<T, object>), body, parameterExpression1, parameterExpression2).Compile();
    }

    private Expression \u003560012993671(Expression _param1, Type _param2, bool _param3 = false)
    {
      Type type = _param1.Type;
      if (type == _param2 || !type.\u003465247563459() && _param2.IsAssignableFrom(type))
        return _param1;
      if (!_param2.\u003465247563459())
        return (Expression) Expression.Convert(_param1, _param2);
      Expression expression = (Expression) Expression.Unbox(_param1, _param2);
      if (_param3 && _param2.\u003493414655437())
      {
        MethodInfo method = typeof (Convert).GetMethod("To" + _param2.Name, new Type[1]
        {
          typeof (object)
        });
        if (method != (MethodInfo) null)
          expression = (Expression) Expression.Condition((Expression) Expression.TypeIs(_param1, _param2), expression, (Expression) Expression.Call(method, _param1));
      }
      return (Expression) Expression.Condition((Expression) Expression.Equal(_param1, (Expression) Expression.Constant((object) null, typeof (object))), (Expression) Expression.Default(_param2), expression);
    }

    private class \u003309985225678
    {
      public ParameterExpression \u003165773471857;
      public bool \u003921894585833;
      public Type \u003200500461082;
    }
  }
}
