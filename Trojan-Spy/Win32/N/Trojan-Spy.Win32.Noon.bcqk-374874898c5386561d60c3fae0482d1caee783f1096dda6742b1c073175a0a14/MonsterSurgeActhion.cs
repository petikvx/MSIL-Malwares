// Decompiled with JetBrains decompiler
// Type: mmxAH.MonsterSurgeActhion
// Assembly: IAsyncLocalValue, Version=1.0.2.2, Culture=neutral, PublicKeyToken=null
// MVID: 5C4F3FBF-C751-4B18-BBEA-B1DDBC6F76B9
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcqk-374874898c5386561d60c3fae0482d1caee783f1096dda6742b1c073175a0a14.exe

using System;
using System.Collections.Generic;

namespace mmxAH
{
  public class MonsterSurgeActhion
  {
    private GameEngine en;
    private short surgeLoc;
    private byte MonstersInEachGate = 0;
    private byte MonstersToOutscirts = 0;
    private bool isExtraMonsterToSurgeGate = false;

    public MonsterSurgeActhion(GameEngine eng, short pSurgheLoc)
    {
      this.en = eng;
      this.surgeLoc = pSurgheLoc;
    }

    public void Execute()
    {
      byte num1 = Math.Max((byte) this.en.openGates.Count, this.en.GetPlayersNumber());
      byte num2 = this.en.status.MonstersCouldBePlacedBefreLim();
      this.MonstersToOutscirts = (int) num1 <= (int) num2 ? (byte) 0 : (byte) ((uint) num1 - (uint) num2);
      byte num3 = (byte) ((uint) num1 - (uint) this.MonstersToOutscirts);
      this.MonstersInEachGate = (byte) ((uint) num3 / (uint) this.en.openGates.Count);
      byte remainMonsters = (byte) ((uint) num3 % (uint) this.en.openGates.Count);
      if (remainMonsters > (byte) 0)
      {
        this.isExtraMonsterToSurgeGate = true;
        --remainMonsters;
      }
      if (remainMonsters > (byte) 0)
        this.PlayerChoose(remainMonsters);
      else
        this.PlaceMonsters();
    }

    private void PlayerChoose(byte remainMonsters)
    {
      string str = "There ";
      string promt = (remainMonsters != (byte) 1 ? str + "are " + remainMonsters.ToString() + " more monsters" : str + "is 1 more monster ") + " to place. Where do your place it?";
      List<MultiChooseOpthion> opts = new List<MultiChooseOpthion>();
      foreach (GatePrototype openGate in this.en.openGates)
      {
        short archemLoc = openGate.GetArchemLoc();
        if ((int) archemLoc != (int) this.surgeLoc)
          opts.Add(new MultiChooseOpthion(this.en.locs[(int) archemLoc].GetTitle(), archemLoc));
      }
      this.en.io.MulthiChooceStart(opts, promt, remainMonsters, new FuncMulthiChooseRet(this.ExecutePlayerChooce));
    }

    private void ExecutePlayerChooce(List<short> locsIndexs)
    {
      foreach (int index in locsIndexs)
      {
        if (!((ArchemArea) this.en.locs[index]).MonseterPlaced())
          return;
      }
      this.PlaceMonsters();
    }

    private void PlaceMonsters()
    {
      if (this.isExtraMonsterToSurgeGate && !((ArchemArea) this.en.locs[(int) this.surgeLoc]).MonseterPlaced())
        return;
      foreach (GatePrototype openGate in this.en.openGates)
      {
        ArchemUnstableLoc loc = (ArchemUnstableLoc) this.en.locs[(int) openGate.GetArchemLoc()];
        for (int index = 0; index < (int) this.MonstersInEachGate; ++index)
        {
          if (!loc.MonseterPlaced())
            return;
        }
      }
      for (int index = 0; index < (int) this.MonstersToOutscirts; ++index)
      {
        if (!this.en.status.PlacedToOutscirts())
          return;
      }
      this.en.curs.resolvingMythos.Step2();
    }
  }
}
