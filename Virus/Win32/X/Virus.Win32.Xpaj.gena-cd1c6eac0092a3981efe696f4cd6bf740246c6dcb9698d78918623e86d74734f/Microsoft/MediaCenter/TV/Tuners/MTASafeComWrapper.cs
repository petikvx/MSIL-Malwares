// Decompiled with JetBrains decompiler
// Type: Microsoft.MediaCenter.TV.Tuners.MTASafeComWrapper
// Assembly: Microsoft.MediaCenter.TV.Tuners.Interop, Version=6.1.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
// MVID: 4545DFBD-7834-4511-B0E8-46F2D6BF39B8
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00007-msil\Virus.Win32.Xpaj.gena-cd1c6eac0092a3981efe696f4cd6bf740246c6dcb9698d78918623e86d74734f.exe

using msclr;
using System;
using System.Runtime.InteropServices;

namespace Microsoft.MediaCenter.TV.Tuners
{
  public abstract class MTASafeComWrapper : SafeComWrapper
  {
    private void TPSetObject(Guid riid, IntPtr punkObj) => base.SetObject(riid, punkObj);

    protected unsafe void TPDtor(IntPtr h)
    {
      if (!(h != IntPtr.Zero))
        return;
      try
      {
        void* pointer = h.ToPointer();
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) pointer + 8))((IntPtr) pointer);
      }
      catch (COMException ex)
      {
      }
    }

    protected unsafe MTASafeComWrapper(_GUID* riid, IntPtr ptr)
      : base(*(Guid*) (int) riid, ptr)
    {
    }

    protected unsafe MTASafeComWrapper(_GUID* riid, IUnknown* punkObj)
    {
      IntPtr punkObj1 = (IntPtr) (void*) punkObj;
      // ISSUE: explicit constructor call
      base.\u002Ector(*(Guid*) (int) riid, punkObj1);
    }

    protected MTASafeComWrapper()
    {
    }

    private void \u007EMTASafeComWrapper()
    {
      @lock lock1 = new @lock(this.m_Lock);
      @lock lock2;
      // ISSUE: fault handler
      try
      {
        lock2 = lock1;
        if (!(IntPtr.Zero == this.handle))
          goto label_4;
      }
      __fault
      {
        lock2.Dispose();
      }
      lock2.Dispose();
      return;
label_4:
      IntPtr handle;
      // ISSUE: fault handler
      try
      {
        handle = this.handle;
        this.handle = IntPtr.Zero;
      }
      __fault
      {
        lock2.Dispose();
      }
      lock2.Dispose();
      dv1<IntPtr> dv1 = new dv1<IntPtr>(this.TPDtor);
      dv1.BeginInvoke(handle, new AsyncCallback(InteropHelper.FireAndForget\u003CMicrosoft\u003A\u003AMediaCenter\u003A\u003ATV\u003A\u003ATuners\u003A\u003Adv1\u003CSystem\u003A\u003AIntPtr\u003E\u0020\u005E\u003E), (object) dv1);
    }

    private void \u0021MTASafeComWrapper()
    {
      try
      {
        IntPtr h = IntPtr.Zero;
        @lock lock1 = new @lock(this.m_Lock);
        @lock lock2;
        // ISSUE: fault handler
        try
        {
          lock2 = lock1;
          if (!(IntPtr.Zero == this.handle))
            goto label_5;
        }
        __fault
        {
          lock2.Dispose();
        }
        lock2.Dispose();
        return;
label_5:
        // ISSUE: fault handler
        try
        {
          h = this.handle;
          this.handle = IntPtr.Zero;
        }
        __fault
        {
          lock2.Dispose();
        }
        lock2.Dispose();
        this.TPDtor(h);
      }
      catch (COMException ex)
      {
      }
    }

    protected unsafe void SetObject(_GUID* riid, IUnknown* punkObj)
    {
      IntPtr punkObj1 = (IntPtr) (void*) punkObj;
      this.SetObject(*(Guid*) (int) riid, punkObj1);
    }

    protected override void SetObject(Guid riid, IntPtr punkObj) => InteropHelper.EndInvokeV\u003CMicrosoft\u003A\u003AMediaCenter\u003A\u003ATV\u003A\u003ATuners\u003A\u003Adv2\u003CSystem\u003A\u003AGuid\u002CSystem\u003A\u003AIntPtr\u003E\u0020\u005E\u003E(new dv2<Guid, IntPtr>(this.TPSetObject).BeginInvoke(riid, punkObj, (AsyncCallback) null, (object) null), "Microsoft::MediaCenter::TV::Tuners::MTASafeComWrapper::SetObject");

    internal static unsafe int GetNativePtrFromSafeHandle(
      SafeHandle wrapper,
      _GUID* riid,
      void** ppv)
    {
      IUnknown* pointer = (IUnknown*) wrapper.DangerousGetHandle().ToPointer();
      if ((IntPtr) pointer == IntPtr.Zero)
        return -2147467259;
      IUnknown* iunknownPtr = pointer;
      _GUID* guidPtr = riid;
      void** voidPtr = ppv;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      return __calli((__FnPtr<int (IntPtr, _GUID*, void**)>) *(int*) *(int*) pointer)((void**) iunknownPtr, guidPtr, (IntPtr) voidPtr);
    }

    internal static unsafe int GetNativePtrFromSafeHandle(object obj, _GUID* riid, void** ppv)
    {
      if (!typeof (SafeHandle).IsAssignableFrom(obj.GetType()))
        throw new ArgumentException(nameof (obj));
      return MTASafeComWrapper.GetNativePtrFromSafeHandle((SafeHandle) obj, riid, ppv);
    }

    internal static unsafe int GetNativePtrFromIntPtr(IntPtr pointer, _GUID* riid, void** ppv)
    {
      IUnknown* pointer1 = (IUnknown*) pointer.ToPointer();
      if ((IntPtr) pointer1 == IntPtr.Zero)
        return -2147467259;
      IUnknown* iunknownPtr = pointer1;
      _GUID* guidPtr = riid;
      void** voidPtr = ppv;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      return __calli((__FnPtr<int (IntPtr, _GUID*, void**)>) *(int*) *(int*) pointer1)((void**) iunknownPtr, guidPtr, (IntPtr) voidPtr);
    }

    protected override void Dispose([MarshalAs(UnmanagedType.U1)] bool _param1)
    {
      if (_param1)
      {
        try
        {
          this.\u007EMTASafeComWrapper();
        }
        finally
        {
          base.Dispose(true);
        }
      }
      else
      {
        try
        {
          this.\u0021MTASafeComWrapper();
        }
        finally
        {
          base.Dispose(false);
        }
      }
    }
  }
}
