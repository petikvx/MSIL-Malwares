// Decompiled with JetBrains decompiler
// Type: AstroMath.DailyPosition
// Assembly: IUnionSemanticCodeGr, Version=1.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 54936E77-57E9-4A01-8A40-CDD9C21A9B24
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4a11f3ee9b7abe32546655a9f702013b42b9f162a262dca3052e2761c20ed447.exe

using System;

namespace AstroMath
{
  public class DailyPosition
  {
    private DateTime t_utcdate;
    private Celestial.RADec t_position;
    private Celestial.LatLon t_location;
    private double t_minalt;
    private DailyPosition.VisibilityState t_state;
    private DateTime t_rise;
    private DateTime t_set;
    private DateTime i_rise;
    private DateTime i_set;
    private double t_moonfree;
    private double t_moonphase;

    public DailyPosition()
    {
      this.t_state = DailyPosition.VisibilityState.UpSome;
      this.t_moonfree = 0.0;
      this.t_moonphase = 0.0;
    }

    public DailyPosition(
      DateTime utcdateStart,
      DateTime utcdateEnd,
      Celestial.RADec tradec,
      Celestial.LatLon tlatlon,
      double tminAlt)
    {
      this.t_state = DailyPosition.VisibilityState.UpSome;
      this.t_moonfree = 0.0;
      this.t_moonphase = 0.0;
      double num1 = 0.0;
      double num2 = 0.0;
      double num3 = Transform.SinD(tminAlt);
      DateTime dateTime = utcdateStart;
      bool flag1 = false;
      bool flag2 = false;
      bool flag3 = false;
      double num4 = 1.0;
      tradec.Altitude(tradec.HourAngle(dateTime.AddHours(num4 - 1.0), tlatlon), tlatlon);
      double yminus = Math.Sin(tradec.Altitude(tradec.HourAngle(dateTime.AddHours(num4 - 1.0), tlatlon), tlatlon)) - num3;
      if (yminus > 0.0)
        flag3 = true;
      do
      {
        double yzero = Math.Sin(tradec.Altitude(tradec.HourAngle(dateTime.AddHours(num4), tlatlon), tlatlon)) - num3;
        double yplus = Math.Sin(tradec.Altitude(tradec.HourAngle(dateTime.AddHours(num4 + 1.0), tlatlon), tlatlon)) - num3;
        Planar.QuadRoot quadRoot = Planar.Quad(yminus, yzero, yplus);
        switch (quadRoot.nz)
        {
          case 1:
            if (yminus < 0.0)
            {
              num1 = num4 + quadRoot.zero1;
              flag1 = true;
              break;
            }
            num2 = num4 + quadRoot.zero1;
            flag2 = true;
            break;
          case 2:
            if (quadRoot.ye < 0.0)
            {
              num1 = num4 + quadRoot.zero2;
              num2 = num4 + quadRoot.zero1;
            }
            else
            {
              num1 = num4 + quadRoot.zero1;
              num2 = num4 + quadRoot.zero2;
            }
            flag1 = true;
            flag2 = true;
            break;
        }
        yminus = yplus;
        num4 += 2.0;
      }
      while (num4 != 25.0 && !(flag1 & flag2) && !(utcdateStart.AddHours(num4 + 1.0) > utcdateEnd));
      this.t_utcdate = utcdateStart;
      this.t_position = tradec;
      this.t_location = tlatlon;
      this.t_minalt = tminAlt;
      this.i_rise = utcdateStart;
      this.i_set = utcdateEnd;
      if (flag3 && !(flag1 | flag2))
      {
        this.t_state = DailyPosition.VisibilityState.UpAlways;
        this.t_rise = utcdateStart;
        this.t_set = utcdateEnd;
      }
      else if (!flag3 && flag1 && !flag2)
      {
        this.t_state = DailyPosition.VisibilityState.Rises;
        this.t_rise = dateTime.AddHours(num1);
        this.t_set = utcdateEnd;
      }
      else if (flag3 && !flag1 & flag2)
      {
        this.t_state = DailyPosition.VisibilityState.Falls;
        this.t_rise = utcdateStart;
        this.t_set = dateTime.AddHours(num2);
        if (!(this.t_rise > this.t_set))
          return;
        this.t_set = this.t_set.AddDays(1.0);
      }
      else if (flag3 && flag1 & flag2)
      {
        this.t_state = DailyPosition.VisibilityState.DownSome;
        this.t_rise = dateTime.AddHours(num1);
        this.t_set = dateTime.AddHours(num2);
        if (this.t_set - this.i_rise > this.i_set - this.t_rise)
          this.t_rise = this.i_rise;
        else
          this.t_set = this.i_set;
      }
      else
      {
        if (!flag3 && flag1 & flag2)
        {
          this.t_state = DailyPosition.VisibilityState.UpSome;
          this.t_rise = dateTime.AddHours(num1);
          this.t_set = dateTime.AddHours(num2);
          if (this.t_rise > this.t_set)
            this.t_set += TimeSpan.FromDays(1.0);
        }
        else
        {
          this.t_state = DailyPosition.VisibilityState.UpNever;
          this.t_rise = utcdateStart;
          this.t_set = utcdateStart;
        }
        if (this.t_rise < this.i_rise)
          this.t_rise = this.i_rise;
        if (!(this.t_set > this.i_set))
          return;
        this.t_set = this.i_set;
      }
    }

    public DailyPosition.VisibilityState Visibility => this.t_state;

    public DateTime UTCdate
    {
      get => this.t_utcdate;
      set => this.t_utcdate = value;
    }

    public DateTime IntervalStartDate
    {
      get => this.i_rise;
      set => this.i_rise = value;
    }

    public DateTime IntervalEndDate
    {
      get => this.i_set;
      set => this.i_set = value;
    }

    public DateTime Rising
    {
      get => this.t_rise;
      set => this.t_rise = value;
    }

    public DateTime Setting
    {
      get => this.t_set;
      set => this.t_set = value;
    }

    public double MoonFree
    {
      get => this.t_moonfree;
      set => this.t_moonfree = value;
    }

    public Celestial.RADec Position
    {
      get => this.t_position;
      set => this.t_position = value;
    }

    public Celestial.LatLon Location
    {
      get => this.t_location;
      set => this.t_location = value;
    }

    public double MinAlt
    {
      get => this.t_minalt;
      set => this.t_minalt = value;
    }

    public double MoonPhase
    {
      get => this.t_moonphase;
      set => this.t_moonphase = value;
    }

    public DateTime iRise
    {
      get => this.i_rise;
      set => this.i_rise = value;
    }

    public DateTime iSet
    {
      get => this.i_set;
      set => this.i_set = value;
    }

    public void SetMoonPhase(double sunRA, double moonRA) => this.t_moonphase = 1.0 - Math.Abs(Math.PI - Math.Abs(sunRA - moonRA)) / Math.PI;

    public static Celestial.RADec SunRADec(double jc2K)
    {
      double num1 = jc2K;
      double a = 2.0 * Math.PI * Planar.Frac(0.993133 + 99.997361 * num1);
      double num2 = 6893.0 * Math.Sin(a) + 72.0 * Math.Sin(2.0 * a);
      double num3 = 2.0 * Math.PI * Planar.Frac(0.7859453 + a / (2.0 * Math.PI) + (6191.2 * num1 + num2) / 1296000.0);
      double num4 = Math.Sin(num3);
      double num5 = Math.Cos(num3);
      double num6 = 0.91748 * num4;
      double num7 = 0.39778 * num4;
      double num8 = Math.Sqrt(1.0 - num7 * num7);
      double deg = 180.0 / Math.PI * Math.Atan(num7 / num8);
      double hours = 24.0 / Math.PI * Math.Atan(num6 / (num5 + num8));
      if (hours < 0.0)
        hours += 24.0;
      return new Celestial.RADec(Transform.HoursToRadians(hours), Transform.DegreesToRadians(deg));
    }

    public static Celestial.RADec MoonRaDec(double j2kC)
    {
      double num1 = Planar.Frac(0.606433 + 1336.855225 * j2kC);
      double a1 = 2.0 * Math.PI * Planar.Frac(0.374897 + 1325.55241 * j2kC);
      double a2 = 2.0 * Math.PI * Planar.Frac(0.993133 + 99.997361 * j2kC);
      double a3 = 2.0 * Math.PI * Planar.Frac(0.827361 + 1236.853086 * j2kC);
      double num2 = 2.0 * Math.PI * Planar.Frac(0.259086 + 1342.227825 * j2kC);
      double num3 = 22640.0 * Math.Sin(a1) - 4586.0 * Math.Sin(a1 - 2.0 * a3) + 2370.0 * Math.Sin(2.0 * a3) + 769.0 * Math.Sin(2.0 * a1) - 668.0 * Math.Sin(a2) - 412.0 * Math.Sin(2.0 * num2) - 212.0 * Math.Sin(2.0 * a1 - 2.0 * a3) - 206.0 * Math.Sin(a1 + a2 - 2.0 * a3) + 192.0 * Math.Sin(a1 + 2.0 * a3) - 165.0 * Math.Sin(a2 - 2.0 * a3) - 125.0 * Math.Sin(a3) - 110.0 * Math.Sin(a1 + a2) + 148.0 * Math.Sin(a1 - a2) - 55.0 * Math.Sin(2.0 * num2 - 2.0 * a3);
      double a4 = num2 + (num3 + 412.0 * Math.Sin(2.0 * num2) + 541.0 * Math.Sin(a2)) / 206264.8062;
      double a5 = num2 - 2.0 * a3;
      double num4 = -526.0 * Math.Sin(a5) + 44.0 * Math.Sin(a1 + a5) - 31.0 * Math.Sin(-a1 + a5) - 23.0 * Math.Sin(a2 + a5) + 11.0 * Math.Sin(-a2 + a5) - 25.0 * Math.Sin(-2.0 * a1 + num2) + 21.0 * Math.Sin(-a1 + num2);
      double num5 = 2.0 * Math.PI * Planar.Frac(num1 + num3 / 1296000.0);
      double num6 = (18520.0 * Math.Sin(a4) + num4) / 206264.8062;
      double num7 = Math.Cos(num6);
      double num8 = num7 * Math.Cos(num5);
      double num9 = num7 * Math.Sin(num5);
      double num10 = Math.Sin(num6);
      double num11 = 0.91748 * num9 - 0.39778 * num10;
      double x = 0.39778 * num9 + 0.91748 * num10;
      double num12 = Math.Sqrt(1.0 - Math.Pow(x, 2.0));
      double deg = 180.0 / Math.PI * Math.Atan(x / num12);
      double hours = 24.0 / Math.PI * Math.Atan(num11 / (num8 + num12));
      if (hours < 0.0)
        hours += 24.0;
      return new Celestial.RADec(Transform.HoursToRadians(hours), Transform.DegreesToRadians(deg));
    }

    public static double MaxAltitude(
      DateTime DuskUTC,
      DateTime DawnUTC,
      Celestial.RADec position,
      Celestial.LatLon location)
    {
      double num1 = position.HourAngle(DuskUTC, location);
      double num2 = position.HourAngle(DawnUTC, location);
      double radians1 = position.Altitude(num1, location);
      double radians2 = position.Altitude(num2, location);
      double totalHours = (DawnUTC - DuskUTC).TotalHours;
      double hours1 = Transform.RadiansToHours(num1);
      Transform.RadiansToHours(num2);
      double hours2 = Transform.RadiansToHours(radians1);
      double hours3 = Transform.RadiansToHours(radians2);
      return hours1 < 24.0 - totalHours ? (hours2 <= hours3 ? radians2 : radians1) : position.Altitude(Transform.HoursToRadians(0.0), location);
    }

    public enum VisibilityState
    {
      UpSome,
      UpAlways,
      Rises,
      Falls,
      DownSome,
      UpNever,
    }
  }
}
