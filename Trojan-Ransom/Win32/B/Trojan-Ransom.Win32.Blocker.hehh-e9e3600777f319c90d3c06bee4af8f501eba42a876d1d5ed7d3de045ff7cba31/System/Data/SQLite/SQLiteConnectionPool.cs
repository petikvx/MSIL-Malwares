// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteConnectionPool
// Assembly: sysrt, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F2102D52-57B0-4622-A1CB-9DE0B00E107F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Blocker.hehh-e9e3600777f319c90d3c06bee4af8f501eba42a876d1d5ed7d3de045ff7cba31.exe

using System.Collections.Generic;

namespace System.Data.SQLite
{
  internal static class SQLiteConnectionPool
  {
    private static SortedList<string, SQLiteConnectionPool.Pool> _connections = new SortedList<string, SQLiteConnectionPool.Pool>((IComparer<string>) StringComparer.OrdinalIgnoreCase);
    private static int _poolVersion = 1;

    internal static SQLiteConnectionHandle Remove(
      string fileName,
      int maxPoolSize,
      out int version)
    {
      lock (SQLiteConnectionPool._connections)
      {
        version = SQLiteConnectionPool._poolVersion;
        SQLiteConnectionPool.Pool queue;
        if (!SQLiteConnectionPool._connections.TryGetValue(fileName, out queue))
        {
          SQLiteConnectionPool.Pool pool = new SQLiteConnectionPool.Pool(SQLiteConnectionPool._poolVersion, maxPoolSize);
          SQLiteConnectionPool._connections.Add(fileName, pool);
          return (SQLiteConnectionHandle) null;
        }
        version = queue.PoolVersion;
        queue.MaxPoolSize = maxPoolSize;
        SQLiteConnectionPool.ResizePool(queue, false);
        while (queue.Queue.Count > 0)
        {
          if (queue.Queue.Dequeue().Target is SQLiteConnectionHandle target)
            return target;
        }
        return (SQLiteConnectionHandle) null;
      }
    }

    internal static void ClearAllPools()
    {
      lock (SQLiteConnectionPool._connections)
      {
        foreach (KeyValuePair<string, SQLiteConnectionPool.Pool> connection in SQLiteConnectionPool._connections)
        {
          while (connection.Value.Queue.Count > 0)
          {
            if (connection.Value.Queue.Dequeue().Target is SQLiteConnectionHandle target)
              target.Dispose();
          }
          if (SQLiteConnectionPool._poolVersion <= connection.Value.PoolVersion)
            SQLiteConnectionPool._poolVersion = connection.Value.PoolVersion + 1;
        }
        SQLiteConnectionPool._connections.Clear();
      }
    }

    internal static void ClearPool(string fileName)
    {
      lock (SQLiteConnectionPool._connections)
      {
        SQLiteConnectionPool.Pool pool;
        if (!SQLiteConnectionPool._connections.TryGetValue(fileName, out pool))
          return;
        ++pool.PoolVersion;
        while (pool.Queue.Count > 0)
        {
          if (pool.Queue.Dequeue().Target is SQLiteConnectionHandle target)
            target.Dispose();
        }
      }
    }

    internal static void Add(string fileName, SQLiteConnectionHandle hdl, int version)
    {
      lock (SQLiteConnectionPool._connections)
      {
        SQLiteConnectionPool.Pool queue;
        if (SQLiteConnectionPool._connections.TryGetValue(fileName, out queue) && version == queue.PoolVersion)
        {
          SQLiteConnectionPool.ResizePool(queue, true);
          queue.Queue.Enqueue(new WeakReference((object) hdl, false));
          GC.KeepAlive((object) hdl);
        }
        else
          hdl.Close();
      }
    }

    private static void ResizePool(SQLiteConnectionPool.Pool queue, bool forAdding)
    {
      int maxPoolSize = queue.MaxPoolSize;
      if (forAdding && maxPoolSize > 0)
        --maxPoolSize;
      while (queue.Queue.Count > maxPoolSize)
      {
        if (queue.Queue.Dequeue().Target is SQLiteConnectionHandle target)
          target.Dispose();
      }
    }

    internal class Pool
    {
      internal readonly Queue<WeakReference> Queue = new Queue<WeakReference>();
      internal int PoolVersion;
      internal int MaxPoolSize;

      internal Pool(int version, int maxSize)
      {
        this.PoolVersion = version;
        this.MaxPoolSize = maxSize;
      }
    }
  }
}
