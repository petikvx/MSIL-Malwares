// Decompiled with JetBrains decompiler
// Type: eg2012.channelClasses
// Assembly: SinkStack, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A02AD0B4-EB98-42A4-95E2-E2AB11E6E27B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.06-msil\UDS-DangerousObject.Multi.Generic-1dfce723a17d9979985d027a8b4bf09a943153bb9ff23d082b21825c41104f96.exe

using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Windows.Forms;
using System.Xml.Linq;

namespace eg2012
{
  [StandardModule]
  internal sealed class channelClasses
  {
    internal static channelClasses.ChannelSetup ActiveChannel;
    internal static channelClasses.ChannelGuide Guide;
    internal static ChannelPlan Plan;

    internal class ChannelSetup
    {
      public ChannelSetup()
      {
        this.HD = false;
        this.Virtual = false;
        this.BugDur = new Dictionary<string, int>();
      }

      internal string dirResVid { get; set; }

      internal string dirResBug { get; set; }

      internal string GuideFn { get; set; }

      internal string PlanLocalFn { get; set; }

      internal string PlanFn { get; set; }

      internal string DirLocalBug { get; set; }

      internal string DirBug { get; set; }

      internal bool HD { get; set; }

      internal string defVideoStyle { get; set; }

      internal bool Virtual { get; set; }

      internal Dictionary<string, int> BugDur { get; set; }

      internal string Ext => this.HD ? ".mov" : ".via";

      internal bool MoveBug(string id)
      {
        // ISSUE: reference to a compiler-generated field
        if (this._Virtual)
          return true;
        if (this.HD)
          return this.MoveFile(id + this.Ext);
        bool flag = this.MoveFile(id + ".via");
        this.MoveFile(id + "_w.via");
        this.MoveFile(id + "_v.via");
        return flag;
      }

      private bool MoveFile(string fn)
      {
        // ISSUE: reference to a compiler-generated field
        FileInfo fileInfo1 = new FileInfo(this._dirResBug + fn);
        // ISSUE: reference to a compiler-generated field
        FileInfo fileInfo2 = new FileInfo(this._DirBug + fn);
        bool flag;
        if (!fileInfo1.Exists)
        {
          flag = false;
        }
        else
        {
          if (fileInfo2.Exists)
          {
            if (DateTime.Compare(fileInfo2.LastWriteTimeUtc, fileInfo1.LastWriteTimeUtc) == 0)
            {
              flag = true;
              goto label_14;
            }
            else
            {
              try
              {
                fileInfo2.Delete();
              }
              catch (Exception ex)
              {
                ProjectData.SetProjectError(ex);
                flag = false;
                ProjectData.ClearProjectError();
                goto label_14;
              }
            }
          }
          fileInfo1.CopyTo(fileInfo2.FullName);
          if (!string.IsNullOrWhiteSpace(this.DirLocalBug))
          {
            // ISSUE: reference to a compiler-generated field
            FileInfo fileInfo3 = new FileInfo(this._DirLocalBug + fn);
            if (!fileInfo3.Exists && DateTime.Compare(fileInfo3.LastWriteTimeUtc, fileInfo1.LastWriteTimeUtc) != 0)
            {
              try
              {
                fileInfo1.CopyTo(fileInfo3.FullName, true);
              }
              catch (Exception ex)
              {
                ProjectData.SetProjectError(ex);
                ProjectData.ClearProjectError();
              }
            }
          }
          flag = true;
        }
label_14:
        return flag;
      }

      internal XElement bugStat(string id)
      {
        string str = string.Format("{0}reports\\{1}.xml", (object) this.DirBug, (object) id);
        if (File.Exists(str))
        {
          try
          {
            return XDocument.Load(str).Root;
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            ProjectData.ClearProjectError();
          }
        }
        return new XElement(XName.Get("reports", ""));
      }

      internal XElement combStat(string key, DateTime FromDay, DateTime ToDay)
      {
        SortedList<DateTime, XElement> source = new SortedList<DateTime, XElement>();
        List<string> values = new List<string>();
        try
        {
          FileInfo[] files = new DirectoryInfo(this.DirBug + "reports").GetFiles();
          int index = 0;
          while (index < files.Length)
          {
            FileInfo fileInfo = files[index];
            if (fileInfo.Name.ToLower().Contains(key.ToLower()))
            {
              string str = fileInfo.Name.Replace(fileInfo.Extension, string.Empty);
              XDocument xdocument = XDocument.Load(fileInfo.FullName);
              try
              {
                foreach (XElement element in xdocument.Root.Elements((XName) "report"))
                {
                  try
                  {
                    // ISSUE: reference to a compiler-generated method
                    DateTime dateTime = DateTime.Parse(eg2012.My.InternalXmlHelper.get_AttributeValue(element, XName.Get("time", "")));
                    if (DateTime.Compare(dateTime, FromDay) >= 0 && DateTime.Compare(dateTime, ToDay.AddHours(18.0)) <= 0 && !source.ContainsKey(dateTime))
                    {
                      source[dateTime] = element;
                      if (!values.Contains(str))
                        values.Add(str);
                    }
                  }
                  catch (Exception ex)
                  {
                    ProjectData.SetProjectError(ex);
                    ProjectData.ClearProjectError();
                  }
                }
              }
              finally
              {
                IEnumerator<XElement> enumerator;
                enumerator?.Dispose();
              }
            }
            checked { ++index; }
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        XElement xelement1 = new XElement(XName.Get("reports", ""));
        // ISSUE: reference to a compiler-generated method
        xelement1.Add((object) eg2012.My.InternalXmlHelper.CreateAttribute(XName.Get("title", ""), (object) string.Join(", ", (IEnumerable<string>) values)));
        XElement xelement2 = xelement1;
        int num = checked (source.Count - 1);
        int index1 = 0;
        while (index1 <= num)
        {
          xelement2.Add((object) source.ElementAt<KeyValuePair<DateTime, XElement>>(index1).Value);
          checked { ++index1; }
        }
        return xelement2;
      }

      internal void ReportList(ComboBox c)
      {
        c.Items.Clear();
        Dictionary<string, FileInfo> dictionary = new Dictionary<string, FileInfo>();
        List<FileInfo> fileInfoList = new List<FileInfo>();
        Dictionary<string, int> keys = new Dictionary<string, int>();
        try
        {
          FileInfo[] files = new DirectoryInfo(this.DirBug + "reports").GetFiles();
          int index = 0;
          while (index < files.Length)
          {
            FileInfo fileInfo = files[index];
            dictionary[fileInfo.Name.Replace(fileInfo.Extension, string.Empty)] = fileInfo;
            checked { ++index; }
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        int months = 0;
        do
        {
          DateTime dateTime = DateAndTime.Now;
          dateTime = dateTime.AddMonths(months);
          string key = dateTime.ToString("yyyy_MM");
          if (dictionary.ContainsKey(key))
            c.Items.Add((object) key);
          checked { months += -1; }
        }
        while (months >= -2);
        try
        {
          foreach (KeyValuePair<string, FileInfo> keyValuePair in dictionary)
          {
            if ((DateAndTime.Now - keyValuePair.Value.LastWriteTimeUtc).TotalDays > 365.0)
              fileInfoList.Add(keyValuePair.Value);
            else if (keyValuePair.Key.Contains("_"))
            {
              string[] source = keyValuePair.Key.Split('_');
              int num = ((IEnumerable<string>) source).Count<string>();
              int count = 1;
              while (count <= num)
              {
                string key = string.Join("_", source, 0, count);
                this.addOne(keys, key);
                checked { ++count; }
              }
            }
          }
        }
        finally
        {
          Dictionary<string, FileInfo>.Enumerator enumerator;
          enumerator.Dispose();
        }
        try
        {
          foreach (KeyValuePair<string, FileInfo> keyValuePair1 in dictionary)
          {
            try
            {
              foreach (KeyValuePair<string, FileInfo> keyValuePair2 in dictionary)
              {
                if (Operators.CompareString(keyValuePair1.Key, keyValuePair2.Key, false) != 0 && keyValuePair2.Key.StartsWith(keyValuePair1.Key))
                  this.addOne(keys, keyValuePair1.Key);
              }
            }
            finally
            {
              Dictionary<string, FileInfo>.Enumerator enumerator;
              enumerator.Dispose();
            }
          }
        }
        finally
        {
          Dictionary<string, FileInfo>.Enumerator enumerator;
          enumerator.Dispose();
        }
        try
        {
          foreach (KeyValuePair<string, int> keyValuePair in keys)
          {
            if (keyValuePair.Value > 1 && !c.Items.Contains((object) keyValuePair.Key))
              c.Items.Add((object) keyValuePair.Key);
          }
        }
        finally
        {
          Dictionary<string, int>.Enumerator enumerator;
          enumerator.Dispose();
        }
        try
        {
          string path = this.DirBug + "old_reports\\";
          if (!Directory.Exists(path))
            Directory.CreateDirectory(path);
          try
          {
            foreach (FileInfo fileInfo in fileInfoList)
            {
              string str = path + fileInfo.Name;
              if (File.Exists(str))
                File.Delete(str);
              fileInfo.MoveTo(str);
            }
          }
          finally
          {
            List<FileInfo>.Enumerator enumerator;
            enumerator.Dispose();
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        if (c.Items.Count <= 0)
          return;
        c.SelectedIndex = 0;
      }

      private void addOne(Dictionary<string, int> keys, string key)
      {
        int num = keys.ContainsKey(key) ? checked (keys[key] + 1) : 1;
        keys[key] = num;
      }

      internal void ViaList(ComboBox c)
      {
        c.Items.Clear();
        // ISSUE: reference to a compiler-generated field
        if (this._Virtual)
          return;
        c.Items.Add((object) string.Empty);
        string key1 = "[reserveeritud]";
        c.Items.Add((object) key1);
        channelClasses.ActiveChannel.BugDur[key1] = 0;
        // ISSUE: reference to a compiler-generated field
        FileInfo[] files = new DirectoryInfo(this._dirResBug).GetFiles();
        int index = 0;
        while (index < files.Length)
        {
          FileInfo fileInfo = files[index];
          if (Operators.CompareString(fileInfo.Extension.ToLower(), channelClasses.ActiveChannel.Ext, false) == 0 && !fileInfo.Name.Contains("_w.") && !fileInfo.Name.Contains("_v."))
          {
            string key2 = fileInfo.Name.Replace(fileInfo.Extension, string.Empty);
            c.Items.Add((object) key2);
            // ISSUE: reference to a compiler-generated field
            this._BugDur[key2] = this.GetDuration(fileInfo.FullName);
          }
          checked { ++index; }
        }
        if (c.Items.Count <= 0)
          return;
        c.SelectedIndex = 0;
      }

      internal void ViaList(ComboBox c, string name)
      {
        if (string.IsNullOrWhiteSpace(name) || c.Items.Contains((object) name))
          return;
        c.Items.Add((object) name);
        // ISSUE: reference to a compiler-generated field
        // ISSUE: reference to a compiler-generated field
        this._BugDur[name] = this.GetDuration(this._dirResBug + name + ".via");
        c.SelectedIndex = checked (c.Items.Count - 1);
      }

      private int GetDuration(string fn)
      {
        RuntimeHelpers.GetObjectValue(new object());
        return 88;
      }
    }

    internal class ChannelGuide
    {
      private XDocument xGuide;
      private int _todayIndex;

      internal ChannelGuide(ComboBox c)
      {
        this._todayIndex = 0;
        if (File.Exists(channelClasses.ActiveChannel.GuideFn))
        {
          this.xGuide = XDocument.Load(channelClasses.ActiveChannel.GuideFn);
        }
        else
        {
          XDocument xdocument = new XDocument(new XDeclaration("1.0", "UTF-8", "yes"), (object[]) null);
          xdocument.Add((object) new XElement(XName.Get("data", "")));
          this.xGuide = xdocument;
        }
        c.Items.Clear();
        List<string> stringList = new List<string>();
        try
        {
          foreach (XContainer element in this.xGuide.Root.Elements())
          {
            string s = element.Elements(XName.Get("Kuupaev", "")).Last<XElement>().Value;
            if (!stringList.Contains(s))
            {
              stringList.Add(s);
              DateTime result;
              if (DateTime.TryParse(s, out result))
              {
                string str = result.ToString("ddd, dd.MM.yyyy");
                if (this._todayIndex == 0 && DateTime.Compare(result, DateAndTime.Now.Date) == 0)
                  this._todayIndex = c.Items.Count;
                c.Items.Add((object) str);
              }
            }
          }
        }
        finally
        {
          IEnumerator<XElement> enumerator;
          enumerator?.Dispose();
        }
      }

      internal int TodayIndex => this._todayIndex;

      internal void Fill(string d, ListView l)
      {
        // ISSUE: variable of a compiler-generated type
        channelClasses.ChannelGuide._Closure\u0024__5\u002D0 closure50;
        // ISSUE: object of a compiler-generated type is created
        // ISSUE: reference to a compiler-generated method
        IEnumerable<XElement> source = this.xGuide.Root.Elements().Where<XElement>(new Func<XElement, bool>(new channelClasses.ChannelGuide._Closure\u0024__5\u002D0(closure50)
        {
          \u0024VB\u0024Local_d = d
        }._Lambda\u0024__0));
        Func<XElement, XElement> selector;
        // ISSUE: reference to a compiler-generated field
        if (channelClasses.ChannelGuide._Closure\u0024__.\u0024I5\u002D1 != null)
        {
          // ISSUE: reference to a compiler-generated field
          selector = channelClasses.ChannelGuide._Closure\u0024__.\u0024I5\u002D1;
        }
        else
        {
          // ISSUE: reference to a compiler-generated field
          channelClasses.ChannelGuide._Closure\u0024__.\u0024I5\u002D1 = selector = (Func<XElement, XElement>) (el => el);
        }
        IEnumerable<XElement> xelements = source.Select<XElement, XElement>(selector);
        l.Items.Clear();
        try
        {
          foreach (XElement xItem in xelements)
            l.Items.Add(new channelClasses.GuideItem(xItem).toListViewItem());
        }
        finally
        {
          IEnumerator<XElement> enumerator;
          enumerator?.Dispose();
        }
      }

      internal void Fill(string tFind, ListBox lFind)
      {
        // ISSUE: variable of a compiler-generated type
        channelClasses.ChannelGuide._Closure\u0024__6\u002D0 closure60_1;
        // ISSUE: object of a compiler-generated type is created
        // ISSUE: variable of a compiler-generated type
        channelClasses.ChannelGuide._Closure\u0024__6\u002D0 closure60_2 = new channelClasses.ChannelGuide._Closure\u0024__6\u002D0(closure60_1);
        // ISSUE: reference to a compiler-generated field
        closure60_2.\u0024VB\u0024Me = this;
        lFind.Items.Clear();
        if (tFind.Length < 2)
          return;
        // ISSUE: reference to a compiler-generated field
        closure60_2.\u0024VB\u0024Local_key = tFind.ToLower().Trim();
        // ISSUE: reference to a compiler-generated method
        IEnumerable<XElement> source1 = this.xGuide.Root.Elements().Where<XElement>(new Func<XElement, bool>(closure60_2._Lambda\u0024__0));
        Func<XElement, string> keySelector1;
        // ISSUE: reference to a compiler-generated field
        if (channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D1 != null)
        {
          // ISSUE: reference to a compiler-generated field
          keySelector1 = channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D1;
        }
        else
        {
          // ISSUE: reference to a compiler-generated field
          channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D1 = keySelector1 = (Func<XElement, string>) (el => el.Elements(XName.Get("Production_nr", "")).Last<XElement>().Value);
        }
        IOrderedEnumerable<XElement> source2 = source1.OrderBy<XElement, string>(keySelector1);
        Func<XElement, XElement> selector1;
        // ISSUE: reference to a compiler-generated field
        if (channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D2 != null)
        {
          // ISSUE: reference to a compiler-generated field
          selector1 = channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D2;
        }
        else
        {
          // ISSUE: reference to a compiler-generated field
          channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D2 = selector1 = (Func<XElement, XElement>) (el => el);
        }
        IEnumerable<XElement> xelements1 = source2.Select<XElement, XElement>(selector1);
        try
        {
          foreach (XElement xelement in xelements1)
          {
            string str = xelement.Elements(XName.Get("Production_nr", "")).Last<XElement>().Value + " = " + xelement.Elements(XName.Get("Saade", "")).Last<XElement>().Value;
            if (!lFind.Items.Contains((object) str))
              lFind.Items.Add((object) str);
          }
        }
        finally
        {
          IEnumerator<XElement> enumerator;
          enumerator?.Dispose();
        }
        if (lFind.Items.Count > 1)
          return;
        // ISSUE: reference to a compiler-generated field
        closure60_2.\u0024VB\u0024Local_seq = tFind.ToLower().ToCharArray();
        // ISSUE: reference to a compiler-generated method
        IEnumerable<XElement> source3 = this.xGuide.Root.Elements().Where<XElement>(new Func<XElement, bool>(closure60_2._Lambda\u0024__3));
        Func<XElement, string> keySelector2;
        // ISSUE: reference to a compiler-generated field
        if (channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D4 != null)
        {
          // ISSUE: reference to a compiler-generated field
          keySelector2 = channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D4;
        }
        else
        {
          // ISSUE: reference to a compiler-generated field
          channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D4 = keySelector2 = (Func<XElement, string>) (el => el.Elements(XName.Get("Saade", "")).Last<XElement>().Value);
        }
        IOrderedEnumerable<XElement> source4 = source3.OrderBy<XElement, string>(keySelector2);
        Func<XElement, string> keySelector3;
        // ISSUE: reference to a compiler-generated field
        if (channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D5 != null)
        {
          // ISSUE: reference to a compiler-generated field
          keySelector3 = channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D5;
        }
        else
        {
          // ISSUE: reference to a compiler-generated field
          channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D5 = keySelector3 = (Func<XElement, string>) (el => el.Elements(XName.Get("Production_nr", "")).Last<XElement>().Value);
        }
        IOrderedEnumerable<XElement> source5 = source4.ThenBy<XElement, string>(keySelector3);
        Func<XElement, XElement> selector2;
        // ISSUE: reference to a compiler-generated field
        if (channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D6 != null)
        {
          // ISSUE: reference to a compiler-generated field
          selector2 = channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D6;
        }
        else
        {
          // ISSUE: reference to a compiler-generated field
          channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D6 = selector2 = (Func<XElement, XElement>) (el => el);
        }
        IEnumerable<XElement> xelements2 = source5.Select<XElement, XElement>(selector2);
        try
        {
          foreach (XElement xelement in xelements2)
          {
            string str = xelement.Elements(XName.Get("Production_nr", "")).Last<XElement>().Value + " = " + xelement.Elements(XName.Get("Saade", "")).Last<XElement>().Value;
            if (!lFind.Items.Contains((object) str))
              lFind.Items.Add((object) str);
          }
        }
        finally
        {
          IEnumerator<XElement> enumerator;
          enumerator?.Dispose();
        }
        if (lFind.Items.Count > 1)
          return;
        // ISSUE: reference to a compiler-generated method
        IEnumerable<XElement> source6 = this.xGuide.Root.Elements().Where<XElement>(new Func<XElement, bool>(closure60_2._Lambda\u0024__7));
        Func<XElement, string> keySelector4;
        // ISSUE: reference to a compiler-generated field
        if (channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D8 != null)
        {
          // ISSUE: reference to a compiler-generated field
          keySelector4 = channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D8;
        }
        else
        {
          // ISSUE: reference to a compiler-generated field
          channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D8 = keySelector4 = (Func<XElement, string>) (el => el.Elements(XName.Get("Saade", "")).Last<XElement>().Value);
        }
        IOrderedEnumerable<XElement> source7 = source6.OrderBy<XElement, string>(keySelector4);
        Func<XElement, string> keySelector5;
        // ISSUE: reference to a compiler-generated field
        if (channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D9 != null)
        {
          // ISSUE: reference to a compiler-generated field
          keySelector5 = channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D9;
        }
        else
        {
          // ISSUE: reference to a compiler-generated field
          channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D9 = keySelector5 = (Func<XElement, string>) (el => el.Elements(XName.Get("Production_nr", "")).Last<XElement>().Value);
        }
        IOrderedEnumerable<XElement> source8 = source7.ThenBy<XElement, string>(keySelector5);
        Func<XElement, XElement> selector3;
        // ISSUE: reference to a compiler-generated field
        if (channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D10 != null)
        {
          // ISSUE: reference to a compiler-generated field
          selector3 = channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D10;
        }
        else
        {
          // ISSUE: reference to a compiler-generated field
          channelClasses.ChannelGuide._Closure\u0024__.\u0024I6\u002D10 = selector3 = (Func<XElement, XElement>) (el => el);
        }
        IEnumerable<XElement> xelements3 = source8.Select<XElement, XElement>(selector3);
        try
        {
          foreach (XElement xelement in xelements3)
          {
            string str = xelement.Elements(XName.Get("Production_nr", "")).Last<XElement>().Value + " = " + xelement.Elements(XName.Get("Saade", "")).Last<XElement>().Value;
            if (!lFind.Items.Contains((object) str))
              lFind.Items.Add((object) str);
          }
        }
        finally
        {
          IEnumerator<XElement> enumerator;
          enumerator?.Dispose();
        }
      }

      private bool ContainsSequense(string S, char[] seq)
      {
        char[] chArray = seq;
        int index = 0;
        while (index < chArray.Length)
        {
          char ch = chArray[index];
          int startIndex = checked (S.IndexOf(ch, startIndex) + 1);
          if (startIndex == 0)
            return false;
          checked { ++index; }
        }
        return true;
      }

      private bool ContainsSequense(string S, char[] seq, int lives)
      {
        char[] chArray = seq;
        int index = 0;
        while (index < chArray.Length)
        {
          char ch = chArray[index];
          int startIndex;
          int num = checked (S.IndexOf(ch, startIndex) + 1);
          if (num == 0)
          {
            if (lives < 1)
              return false;
            checked { --lives; }
          }
          else
            startIndex = num;
          checked { ++index; }
        }
        return true;
      }

      internal string Find(string id)
      {
        IEnumerable<XElement> source1 = this.xGuide.Root.Elements().Where<XElement>((Func<XElement, bool>) (el => el.Elements(XName.Get("Production_nr", "")).Last<XElement>().Value.ToLower().StartsWith(id)));
        Func<XElement, XElement> selector;
        // ISSUE: reference to a compiler-generated field
        if (channelClasses.ChannelGuide._Closure\u0024__.\u0024I9\u002D1 != null)
        {
          // ISSUE: reference to a compiler-generated field
          selector = channelClasses.ChannelGuide._Closure\u0024__.\u0024I9\u002D1;
        }
        else
        {
          // ISSUE: reference to a compiler-generated field
          channelClasses.ChannelGuide._Closure\u0024__.\u0024I9\u002D1 = selector = (Func<XElement, XElement>) (el => el);
        }
        IEnumerable<XElement> source2 = source1.Select<XElement, XElement>(selector);
        return source2.Count<XElement>() == 0 ? string.Empty : source2.Elements<XElement>(XName.Get("Saade", "")).Last<XElement>().Value;
      }
    }

    internal class GuideItem
    {
      private string _id;
      private string _title;
      private DateTime _Date_Time;
      private string _timeStr;
      private string _dateStr;

      internal GuideItem(XElement xItem)
      {
        this._id = string.Empty;
        this._title = string.Empty;
        this._Date_Time = DateTime.MinValue;
        this._timeStr = string.Empty;
        this._dateStr = string.Empty;
        try
        {
          this._timeStr = xItem.Element((XName) "Kell").Value;
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        try
        {
          this._dateStr = xItem.Element((XName) "Kuupaev").Value;
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        try
        {
          this._id = xItem.Element((XName) "Production_nr").Value;
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        try
        {
          this._title = xItem.Element((XName) "Saade").Value;
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        this._Date_Time = this.GetDate(this._dateStr, this._timeStr);
      }

      private DateTime GetDate(string dStr, string tStr)
      {
        DateTime result = DateTime.MinValue;
        if (DateTime.TryParse(dStr, out result) && tStr.Contains(":"))
        {
          string[] strArray = tStr.Split(':');
          result = result.AddHours(Conversion.Val(strArray[0])).AddMinutes(Conversion.Val(strArray[1]) + 5.0);
        }
        return result;
      }

      internal string ID => this._id;

      internal string Title => this._title;

      internal DateTime Date_Time => this._Date_Time;

      internal ListViewItem toListViewItem()
      {
        ListViewItem listViewItem = new ListViewItem();
        listViewItem.Tag = (object) this;
        listViewItem.Text = this._timeStr;
        listViewItem.SubItems.Add(this._id);
        listViewItem.SubItems.Add(this._title);
        if ((DateAndTime.Now - this._Date_Time).TotalMinutes > 0.0)
          listViewItem.ForeColor = Color.DarkBlue;
        channelClasses.Plan.Check(listViewItem);
        return listViewItem;
      }

      internal XElement ToXml()
      {
        XElement xml = new XElement(XName.Get("pr", ""));
        // ISSUE: reference to a compiler-generated method
        xml.Add((object) eg2012.My.InternalXmlHelper.CreateAttribute(XName.Get("id", ""), (object) this._id));
        // ISSUE: reference to a compiler-generated method
        xml.Add((object) eg2012.My.InternalXmlHelper.CreateAttribute(XName.Get("title", ""), (object) this._title));
        // ISSUE: reference to a compiler-generated method
        xml.Add((object) eg2012.My.InternalXmlHelper.CreateAttribute(XName.Get("date", ""), (object) this._dateStr));
        // ISSUE: reference to a compiler-generated method
        xml.Add((object) eg2012.My.InternalXmlHelper.CreateAttribute(XName.Get("time", ""), (object) this._timeStr));
        return xml;
      }
    }

    internal class PlanRule
    {
      private object Condition;
      private string _Value;
      private List<int> slots;

      internal XElement Source { get; set; }

      internal bool Changed { get; set; }

      internal PlanRule(XElement xRule)
      {
        // ISSUE: reference to a compiler-generated field
        this._Source = xRule;
        this.Init();
      }

      internal void Init()
      {
        // ISSUE: reference to a compiler-generated field
        // ISSUE: reference to a compiler-generated method
        this._Value = eg2012.My.InternalXmlHelper.get_AttributeValue(this._Source, XName.Get("file", ""));
        this.slots = new List<int>();
        this.slots.Add(-1);
        // ISSUE: reference to a compiler-generated field
        // ISSUE: reference to a compiler-generated method
        string str = eg2012.My.InternalXmlHelper.get_AttributeValue(this._Source, XName.Get("slot", ""));
        if (string.IsNullOrWhiteSpace(str))
          return;
        string[] strArray = str.Split(',');
        int index = 0;
        while (index < strArray.Length)
        {
          int result;
          if (int.TryParse(strArray[index], out result) && !this.slots.Contains(result))
            this.slots.Add(result);
          checked { ++index; }
        }
      }

      internal string Value => this._Value;

      internal string get_Value(int slot) => this.slots.Contains(slot) ? this._Value : string.Empty;

      internal bool Activated => this._Value.Length > 0;

      internal static string DateString(DateTime dFrom, DateTime dTo)
      {
        int hour1 = dFrom.Hour;
        if (hour1 >= 0 && hour1 <= 5)
          dFrom = dFrom.AddDays(-1.0);
        int hour2 = dTo.Hour;
        if (hour2 >= 0 && hour2 <= 5)
          dTo = dTo.AddDays(-1.0);
        return string.Format("{0:dd.MM.yyyy}-{1:dd.MM.yyyy}", (object) dFrom, (object) dTo);
      }

      internal static string TimeString(DateTime dMin, DateTime dMax)
      {
        int hour1 = dMin.Hour;
        int num1;
        switch (hour1)
        {
          case 0:
            num1 = 23;
            break;
          case 6:
            num1 = 6;
            break;
          default:
            num1 = checked (hour1 - 1);
            break;
        }
        int hour2 = dMax.Hour;
        int num2;
        switch (hour2)
        {
          case 5:
            num2 = 5;
            break;
          case 23:
            num2 = 0;
            break;
          default:
            num2 = checked (hour2 + 1);
            break;
        }
        return string.Format("{0:00}-{1:00}", (object) num1, (object) num2);
      }
    }

    internal class PlanRuleEditor
    {
      private channelClasses.PlanRule _Rule;
      private Dictionary<string, string> _Changes;
      private bool _Register;

      internal PlanRuleEditor(channelClasses.PlanRule r, bool reg)
      {
        this._Changes = new Dictionary<string, string>();
        this._Rule = r;
        this._Register = reg;
      }

      internal channelClasses.PlanRule Rule => this._Rule;

      internal bool Register => this._Register && this._Rule.Activated;

      internal Dictionary<string, string> Changes => this._Changes;

      internal void Sync()
      {
        try
        {
          foreach (KeyValuePair<string, string> change in this._Changes)
            this.Rule.Source.SetAttributeValue((XName) change.Key, (object) change.Value);
        }
        finally
        {
          Dictionary<string, string>.Enumerator enumerator;
          enumerator.Dispose();
        }
        this._Changes.Clear();
        this._Rule.Init();
        this._Rule.Source.SetAttributeValue((XName) "modified", (object) DateAndTime.Now);
      }

      public override string ToString()
      {
        // ISSUE: reference to a compiler-generated method
        DateTime dateTime = DateTime.Parse(eg2012.My.InternalXmlHelper.get_AttributeValue(this._Rule.Source, XName.Get("created", "")));
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        return string.Format("{0} ({1}-{2:yyMMdd-HHmmss)}", (object) eg2012.My.InternalXmlHelper.get_AttributeValue(this._Rule.Source, XName.Get("file", "")), (object) eg2012.My.InternalXmlHelper.get_AttributeValue(this._Rule.Source, XName.Get("title", "")), (object) dateTime);
      }
    }
  }
}
