// Decompiled with JetBrains decompiler
// Type: RiskManagement.Rules
// Assembly: IRefle, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 09188B70-FC90-4B10-A900-838DE205A659
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.02-msil\Backdoor.MSIL.Crysan.drn-7517431630373a1eec83586fad357154d832851724f8aa57ce6561d87ee8f8f1.exe

using SimpleJSON;
using System;
using System.Collections.Generic;
using System.Globalization;

namespace RiskManagement
{
  public class Rules
  {
    public int SprintCount { get; private set; }

    public int MaxImpact { get; private set; }

    public Card[] Cards { get; private set; }

    public int InitialResources { get; private set; }

    public int NormalPlanningCount { get; private set; }

    public int NormalPlanningCost { get; private set; }

    public int OverPlanningCost { get; private set; }

    public int SprintsWonWithoutPlanning { get; private set; }

    public float[] RiskChances { get; private set; }

    public bool EconomicsAffectsAll { get; private set; }

    public int StayOnSprintMinDiff { get; private set; }

    public bool OnlyOneWinner { get; private set; }

    private Rules()
    {
    }

    public static Rules Deserialize(JSONNode json)
    {
      int asInt = json["max-impact"].AsInt;
      return new Rules()
      {
        SprintCount = json["sprints"].AsInt,
        MaxImpact = asInt,
        Cards = Rules.ParseDeck(json["deck"], asInt),
        InitialResources = json["initial-resources"].AsInt,
        NormalPlanningCount = json["normal-planning-count"].AsInt,
        NormalPlanningCost = json["normal-planning-cost"].AsInt,
        OverPlanningCost = json["over-planning-cost"].AsInt,
        SprintsWonWithoutPlanning = json["sprints-won-without-planning"].AsInt,
        RiskChances = Rules.ParseRiskChances(json["risk-chances"]),
        EconomicsAffectsAll = json["economics-affects-all"].AsBool,
        StayOnSprintMinDiff = json["stay-on-sprint-min-diff"].AsInt,
        OnlyOneWinner = json["only-one-winner"].AsBool
      };
    }

    private static float[] ParseRiskChances(JSONNode json)
    {
      float[] riskChances = new float[json.Count];
      for (int aIndex = 0; aIndex < riskChances.Length; ++aIndex)
        riskChances[aIndex] = json[aIndex].AsFloat;
      return riskChances;
    }

    private static Card[] ParseDeck(JSONNode json, int maxImpact)
    {
      int count = json.Count;
      List<Card> cardList = new List<Card>();
      for (int aIndex1 = 0; aIndex1 < count; ++aIndex1)
      {
        JSONNode jsonNode = json[aIndex1];
        for (int aIndex2 = 0; aIndex2 < maxImpact * 2; ++aIndex2)
        {
          for (int index = 0; index < jsonNode[aIndex2].AsInt; ++index)
          {
            bool flag = aIndex2 < maxImpact;
            cardList.Add(new Card()
            {
              Impact = flag ? -(maxImpact - aIndex2) : maxImpact * 2 - aIndex2,
              Type = aIndex1
            });
          }
        }
      }
      return cardList.ToArray();
    }

    public override string ToString() => string.Format("sprints: {0},\nmax-impact:{1},\ndeck: \n{2},\n\ninitial-resources: {3},\n\nnormal-planning-count: {4},\nnormal-planning-cost: {5},\nover-planning-cost: {6},\nsprints-won-without-planning: {7},\n\nrisk-chances: {8},\n\neconomics-affects-all: {9},\nstay-on-sprint-min-diff: {10},\nonly-one-winner: {11}", (object) this.SprintCount, (object) this.MaxImpact, (object) this.CardsToString(), (object) this.InitialResources, (object) this.NormalPlanningCount, (object) this.NormalPlanningCost, (object) this.OverPlanningCost, (object) this.SprintsWonWithoutPlanning, (object) this.RiskChancesToString(), (object) this.EconomicsAffectsAll, (object) this.StayOnSprintMinDiff, (object) this.OnlyOneWinner);

    private string CardsToString()
    {
      string str = "[\n\t";
      int num = 0;
      foreach (Card card in this.Cards)
      {
        if (num != card.Type)
        {
          str += "\n\t";
          num = card.Type;
        }
        str = str + card?.ToString() + " ";
      }
      return str + "\n]";
    }

    private string RiskChancesToString()
    {
      string str = "[ " + this.RiskChances[0].ToString((IFormatProvider) CultureInfo.InvariantCulture);
      for (int index = 1; index < this.RiskChances.Length; ++index)
        str = str + ", " + this.RiskChances[index].ToString((IFormatProvider) CultureInfo.InvariantCulture);
      return str + " ]";
    }
  }
}
