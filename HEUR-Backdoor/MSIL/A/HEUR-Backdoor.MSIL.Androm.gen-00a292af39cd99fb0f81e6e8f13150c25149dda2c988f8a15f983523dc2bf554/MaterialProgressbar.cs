// Decompiled with JetBrains decompiler
// Type: MaterialSurface.MaterialProgressbar
// Assembly: PropagationFl, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 45597167-9313-4C0B-891A-DAD42EC632D8
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Backdoor.MSIL.Androm.gen-00a292af39cd99fb0f81e6e8f13150c25149dda2c988f8a15f983523dc2bf554.exe

using System;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;

namespace MaterialSurface
{
  public class MaterialProgressbar : Control, IMaterialControl
  {
    private const int WmPaint = 15;
    private const int START_ANGLE = 270;
    private readonly Timer animationDirector = new Timer()
    {
      Interval = 1
    };
    private Color primaryColor = Color.BlueViolet;
    private bool isInditermine = false;
    private int targetPos;
    private int curPos;
    private int _value = 0;
    private int incPos;
    private int changeDelay = 50;
    private int marqueeWidth;
    private int valueAngle;
    private int posAngle = 270;
    private int incAngle;
    private int targetAngle;
    private float cicularWidth = 3.8f;
    private int maximum = 100;
    private int minimum = 0;
    private int step = 10;
    private int padding;
    private MaterialProgressbar.ProgressBarType barType;
    public bool IsAnimating = false;

    [Category("Appearance Material")]
    [Description("")]
    public float CircularWidth
    {
      get => this.cicularWidth;
      set
      {
        this.cicularWidth = value;
        this.padding = Convert.ToInt32((float) (((double) this.cicularWidth + 2.0) / 2.0));
        this.Invalidate();
      }
    }

    [Category("Appearance Material")]
    [Description("")]
    public Color PrimaryColor
    {
      get => this.primaryColor;
      set
      {
        this.primaryColor = value;
        this.Invalidate();
      }
    }

    [Category("Appearance Material")]
    [Description("")]
    public MaterialProgressbar.ProgressBarType Type
    {
      get => this.barType;
      set
      {
        this.barType = value;
        if (this.barType == MaterialProgressbar.ProgressBarType.Cicular)
        {
          if (this.DesignMode && this._value < 10)
          {
            this._value = 25;
            this.valueAngle = Convert.ToInt32((float) ((double) this._value / (double) this.maximum * 360.0));
          }
          if (this.Height < 40)
          {
            this.Height = 40;
            this.Width = this.Height;
          }
        }
        this.Invalidate();
      }
    }

    [Category("Appearance Material")]
    [Description("")]
    public bool IsIndetermine
    {
      get => this.isInditermine;
      set
      {
        this.isInditermine = value;
        if (this.isInditermine)
        {
          if (this._value < 10)
            this._value = 25;
          this.marqueeWidth = Convert.ToInt32((float) this._value / (float) this.Maximum * (float) this.Width);
          this.valueAngle = Convert.ToInt32((float) ((double) this._value / (double) this.maximum * 360.0));
          this.animationDirector.Start();
        }
        this.Invalidate();
      }
    }

    [Category("Appearance Material")]
    [Description("The bigger the slower animation.")]
    public int ChangeDelay
    {
      get => this.changeDelay;
      set
      {
        this.changeDelay = value;
        if (this.changeDelay < 10)
          this.changeDelay = 10;
        this.incAngle = 360 / this.changeDelay;
        this.incPos = this.Width / this.changeDelay;
      }
    }

    [Category("Behavior")]
    [Description("")]
    public int Value
    {
      get => this._value;
      set
      {
        this._value = value;
        if (this._value < this.minimum)
          this._value = this.minimum;
        if (this._value > this.maximum)
          this._value = this.maximum;
        this.targetAngle = Convert.ToInt32((float) ((double) this._value / (double) this.maximum * 360.0));
        this.targetPos = Convert.ToInt32((float) this._value / (float) this.maximum * (float) this.Width);
        if (this.isInditermine || this.DesignMode)
        {
          this.marqueeWidth = this.targetPos;
          this.valueAngle = this.targetAngle;
        }
        else
          this.animationDirector.Start();
        this.Invalidate();
      }
    }

    [Category("Behavior")]
    [Description("")]
    public int Maximum
    {
      get => this.maximum;
      set
      {
        this.maximum = value;
        this.marqueeWidth = Convert.ToInt32((float) this._value / (float) this.maximum * (float) this.Width);
        this.valueAngle = Convert.ToInt32((float) ((double) this._value / (double) this.maximum * 360.0));
        this.Invalidate();
      }
    }

    [Category("Behavior")]
    [Description("")]
    public int Minimum
    {
      get => this.minimum;
      set => this.minimum = value;
    }

    [Category("Behavior")]
    [Description("")]
    public int Step
    {
      get => this.step;
      set => this.step = value;
    }

    public MouseState MouseState { get; set; }

    public MaterialProgressbar()
    {
      this.SetStyle(ControlStyles.UserPaint | ControlStyles.ResizeRedraw | ControlStyles.SupportsTransparentBackColor | ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer, true);
      this.DoubleBuffered = true;
      this.Size = new Size(400, 8);
      this.padding = Convert.ToInt32((float) (((double) this.cicularWidth + 0.5) / 2.0));
      this.incAngle = 360 / this.changeDelay;
      this.targetAngle = this.valueAngle = Convert.ToInt32((float) ((double) this._value / (double) this.maximum * 360.0));
      this.targetPos = this.curPos = this.Value / this.Maximum * this.Width;
      this.incPos = this.Width / this.changeDelay;
      this.animationDirector.Tick += new EventHandler(this.OnAnimate);
    }

    private void OnAnimate(object sender, EventArgs e)
    {
      this.IsAnimating = true;
      if (this.isInditermine)
      {
        if (this.barType == MaterialProgressbar.ProgressBarType.Normal)
        {
          if (this.DesignMode)
          {
            this.curPos = 0;
            return;
          }
          if (this.curPos < this.Width)
            this.curPos += this.incPos;
          else
            this.curPos = -this.marqueeWidth;
        }
        else
        {
          if (this.DesignMode)
          {
            this.posAngle = 270;
            return;
          }
          if (this.posAngle <= 630)
            this.posAngle += this.incAngle;
          else
            this.posAngle = 270;
        }
      }
      else if (this.barType == MaterialProgressbar.ProgressBarType.Normal)
      {
        if (this.marqueeWidth != this.targetPos || this.curPos != 0)
        {
          if (this.curPos != 0)
          {
            if (this.curPos < this.Width)
              this.curPos += this.incPos;
            else
              this.curPos = -this.marqueeWidth;
            if (this.curPos <= 0 && this.curPos + this.incPos > 0)
              this.curPos = 0;
          }
          if (Math.Abs(this.marqueeWidth - this.targetPos) < this.incPos)
            this.marqueeWidth = this.targetPos;
          else
            this.marqueeWidth += this.marqueeWidth < this.targetPos ? this.incPos / 2 : -this.incPos / 2;
        }
        else
        {
          this.IsAnimating = false;
          this.animationDirector.Stop();
        }
      }
      else if (this.valueAngle != this.targetAngle || this.posAngle != 270)
      {
        if (this.posAngle >= 630 || this.posAngle == 270)
          this.posAngle = 270;
        else
          this.posAngle += this.incAngle;
        if (Math.Abs(this.valueAngle - this.targetAngle) < this.incAngle)
          this.valueAngle = this.targetAngle;
        else
          this.valueAngle += this.valueAngle < this.targetAngle ? this.incAngle / 2 : -this.incAngle / 2;
      }
      else
      {
        this.IsAnimating = false;
        this.animationDirector.Stop();
      }
      this.Invalidate();
    }

    protected override void OnPaint(PaintEventArgs e)
    {
      base.OnPaint(e);
      Graphics graphics = e.Graphics;
      graphics.SmoothingMode = SmoothingMode.HighQuality;
      if (this.barType == MaterialProgressbar.ProgressBarType.Normal)
      {
        graphics.FillRectangle((Brush) new SolidBrush(Color.FromArgb(80, this.primaryColor)), 0, 0, this.Width, this.Height);
        graphics.FillRectangle((Brush) new SolidBrush(this.primaryColor), this.curPos, 0, this.marqueeWidth, this.Height);
      }
      else
      {
        Color color = !(this.Parent is MaterialCard) ? this.Parent.BackColor : ((MaterialCard) this.Parent).CardColor;
        graphics.Clear(color);
        graphics.DrawArc(new Pen((Brush) new SolidBrush(this.primaryColor), this.cicularWidth), this.padding, this.padding, this.Width - this.padding * 2, this.Height - this.padding * 2, this.posAngle, this.valueAngle);
      }
    }

    protected override void OnCreateControl()
    {
      base.OnCreateControl();
      if (!this.isInditermine)
        return;
      this.animationDirector.Start();
    }

    protected override void OnSizeChanged(EventArgs e)
    {
      base.OnSizeChanged(e);
      if (this.barType == MaterialProgressbar.ProgressBarType.Cicular)
        this.Width = this.Height;
      this.incPos = this.Width / this.changeDelay;
      if (this._value == 100)
        this.curPos = this.Width;
      else
        this.targetPos = Convert.ToInt32((float) this._value / (float) this.Maximum * (float) this.Width);
      this.Invalidate();
    }

    public void Increment(int value)
    {
      if (this.Value + value < this.maximum)
        this.Value += value;
      else
        this.Value = this.maximum;
    }

    public void PerformStep() => this.Increment(this.step);

    public enum ProgressBarType
    {
      Normal,
      Cicular,
    }
  }
}
