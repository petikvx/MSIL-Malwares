// Decompiled with JetBrains decompiler
// Type: HeavyDuck.SafeNativeMethods
// Assembly: RemotingFieldCachedD, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EDD4CF72-357A-47DC-BB8E-50FC31FC092E
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.PowerShell.gen-1095c007bb641be5c286e491a4f4ced026984a7767f930ee09c4d2995b5a76f2.exe

using HeavyDuck.Properties;
using Microsoft.Win32.SafeHandles;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;

namespace HeavyDuck
{
  internal static class SafeNativeMethods
  {
    public const int MaxPath = 256;
    private const string LongPathPrefix = "\\\\?\\";
    public const char StreamSeparator = ':';
    public const int DefaultBufferSize = 4096;
    private const int ErrorFileNotFound = 2;
    private static readonly char[] InvalidStreamNameChars = ((IEnumerable<char>) Path.GetInvalidFileNameChars()).Where<char>((Func<char, bool>) (c => c < '\u0001' || c > '\u001F')).ToArray<char>();

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, ThrowOnUnmappableChar = true, BestFitMapping = false)]
    private static extern int FormatMessage(
      int dwFlags,
      IntPtr lpSource,
      int dwMessageId,
      int dwLanguageId,
      StringBuilder lpBuffer,
      int nSize,
      IntPtr vaListArguments);

    [DllImport("kernel32", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern int GetFileAttributes(string fileName);

    [DllImport("kernel32", CharSet = CharSet.Unicode, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool GetFileSizeEx(
      SafeFileHandle handle,
      out SafeNativeMethods.LargeInteger size);

    [DllImport("kernel32.dll")]
    private static extern int GetFileType(SafeFileHandle handle);

    [DllImport("kernel32", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern SafeFileHandle CreateFile(
      string name,
      SafeNativeMethods.NativeFileAccess access,
      FileShare share,
      IntPtr security,
      FileMode mode,
      SafeNativeMethods.NativeFileFlags flags,
      IntPtr template);

    [DllImport("kernel32", CharSet = CharSet.Unicode, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool DeleteFile(string name);

    [DllImport("kernel32", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool BackupRead(
      SafeFileHandle hFile,
      ref SafeNativeMethods.Win32StreamId pBuffer,
      int numberOfBytesToRead,
      out int numberOfBytesRead,
      [MarshalAs(UnmanagedType.Bool)] bool abort,
      [MarshalAs(UnmanagedType.Bool)] bool processSecurity,
      ref IntPtr context);

    [DllImport("kernel32", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool BackupRead(
      SafeFileHandle hFile,
      SafeHGlobalHandle pBuffer,
      int numberOfBytesToRead,
      out int numberOfBytesRead,
      [MarshalAs(UnmanagedType.Bool)] bool abort,
      [MarshalAs(UnmanagedType.Bool)] bool processSecurity,
      ref IntPtr context);

    [DllImport("kernel32", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool BackupSeek(
      SafeFileHandle hFile,
      int bytesToSeekLow,
      int bytesToSeekHigh,
      out int bytesSeekedLow,
      out int bytesSeekedHigh,
      ref IntPtr context);

    private static int MakeHRFromErrorCode(int errorCode) => -2147024896 | errorCode;

    private static string GetErrorMessage(int errorCode)
    {
      StringBuilder lpBuffer = new StringBuilder(512);
      if (SafeNativeMethods.FormatMessage(12800, IntPtr.Zero, errorCode, 0, lpBuffer, lpBuffer.Capacity, IntPtr.Zero) != 0)
        return lpBuffer.ToString();
      return string.Format((IFormatProvider) Resources.Culture, "", new object[1]
      {
        (object) errorCode
      });
    }

    private static void ThrowIOError(int errorCode, string path)
    {
      switch (errorCode)
      {
        case 0:
          break;
        case 2:
          if (string.IsNullOrEmpty(path))
            throw new FileNotFoundException();
          throw new FileNotFoundException((string) null, path);
        case 87:
          throw new IOException(SafeNativeMethods.GetErrorMessage(errorCode), SafeNativeMethods.MakeHRFromErrorCode(errorCode));
        case 206:
          throw new PathTooLongException();
        case 995:
          throw new OperationCanceledException();
        default:
          Marshal.ThrowExceptionForHR(SafeNativeMethods.MakeHRFromErrorCode(errorCode));
          break;
      }
    }

    public static void ThrowLastIOError(string path)
    {
      int lastWin32Error = Marshal.GetLastWin32Error();
      if (lastWin32Error == 0)
        return;
      if (0 <= Marshal.GetHRForLastWin32Error())
        throw new Win32Exception(lastWin32Error);
      SafeNativeMethods.ThrowIOError(lastWin32Error, path);
    }

    public static SafeNativeMethods.NativeFileAccess ToNative(
      this FileAccess access)
    {
      SafeNativeMethods.NativeFileAccess native = (SafeNativeMethods.NativeFileAccess) 0;
      if (FileAccess.Read == (FileAccess.Read & access))
        native |= SafeNativeMethods.NativeFileAccess.GenericRead;
      if (FileAccess.Write == (FileAccess.Write & access))
        native |= SafeNativeMethods.NativeFileAccess.GenericWrite;
      return native;
    }

    public static string BuildStreamPath(string filePath, string streamName)
    {
      string str = filePath;
      if (!string.IsNullOrEmpty(filePath))
      {
        if (1 == str.Length)
          str = ".\\" + str;
        str = str + ":" + streamName + ":$DATA";
        if (256 <= str.Length)
          str = "\\\\?\\" + str;
      }
      return str;
    }

    public static void ValidateStreamName(string streamName)
    {
    }

    public static int SafeGetFileAttributes(string name)
    {
      int fileAttributes = !string.IsNullOrEmpty(name) ? SafeNativeMethods.GetFileAttributes(name) : throw new ArgumentNullException(nameof (name));
      if (-1 == fileAttributes && 2 != Marshal.GetLastWin32Error())
        SafeNativeMethods.ThrowLastIOError(name);
      return fileAttributes;
    }

    public static bool SafeDeleteFile(string name)
    {
      bool flag = !string.IsNullOrEmpty(name) ? SafeNativeMethods.DeleteFile(name) : throw new ArgumentNullException(nameof (name));
      if (!flag && 2 != Marshal.GetLastWin32Error())
        SafeNativeMethods.ThrowLastIOError(name);
      return flag;
    }

    public static SafeFileHandle SafeCreateFile(
      string path,
      SafeNativeMethods.NativeFileAccess access,
      FileShare share,
      IntPtr security,
      FileMode mode,
      SafeNativeMethods.NativeFileFlags flags,
      IntPtr template)
    {
      SafeFileHandle file = SafeNativeMethods.CreateFile(path, access, share, security, mode, flags, template);
      if (!file.IsInvalid && 1 != SafeNativeMethods.GetFileType(file))
        file.Dispose();
      return file;
    }

    private static long GetFileSize(string path, SafeFileHandle handle)
    {
      long fileSize = 0;
      if (handle != null && !handle.IsInvalid)
      {
        SafeNativeMethods.LargeInteger size;
        if (SafeNativeMethods.GetFileSizeEx(handle, out size))
          fileSize = size.ToInt64();
        else
          SafeNativeMethods.ThrowLastIOError(path);
      }
      return fileSize;
    }

    public static long GetFileSize(string path)
    {
      long fileSize = 0;
      if (!string.IsNullOrEmpty(path))
      {
        using (SafeFileHandle file = SafeNativeMethods.SafeCreateFile(path, SafeNativeMethods.NativeFileAccess.GenericRead, FileShare.Read, IntPtr.Zero, FileMode.Open, (SafeNativeMethods.NativeFileFlags) 0, IntPtr.Zero))
          fileSize = SafeNativeMethods.GetFileSize(path, file);
      }
      return fileSize;
    }

    public static IList<SafeNativeMethods.Win32StreamInfo> ListStreams(
      string filePath)
    {
      if (string.IsNullOrEmpty(filePath))
        throw new ArgumentNullException(nameof (filePath));
      List<SafeNativeMethods.Win32StreamInfo> win32StreamInfoList = new List<SafeNativeMethods.Win32StreamInfo>();
      using (SafeFileHandle file = SafeNativeMethods.SafeCreateFile(filePath, SafeNativeMethods.NativeFileAccess.GenericRead, FileShare.Read, IntPtr.Zero, FileMode.Open, SafeNativeMethods.NativeFileFlags.BackupSemantics, IntPtr.Zero))
      {
        using (StreamName streamName = new StreamName())
        {
          if (!file.IsInvalid)
          {
            SafeNativeMethods.Win32StreamId pBuffer = new SafeNativeMethods.Win32StreamId();
            int numberOfBytesToRead = Marshal.SizeOf((object) pBuffer);
            bool flag = false;
            IntPtr zero = IntPtr.Zero;
            int numberOfBytesRead;
            try
            {
              while (!flag)
              {
                if (!SafeNativeMethods.BackupRead(file, ref pBuffer, numberOfBytesToRead, out numberOfBytesRead, false, false, ref zero))
                  flag = true;
                else if (numberOfBytesToRead != numberOfBytesRead)
                {
                  flag = true;
                }
                else
                {
                  string str;
                  if (0 >= pBuffer.StreamNameSize)
                  {
                    str = (string) null;
                  }
                  else
                  {
                    streamName.EnsureCapacity(pBuffer.StreamNameSize);
                    if (!SafeNativeMethods.BackupRead(file, streamName.MemoryBlock, pBuffer.StreamNameSize, out numberOfBytesRead, false, false, ref zero))
                    {
                      str = (string) null;
                      flag = true;
                    }
                    else
                      str = streamName.ReadStreamName(numberOfBytesRead >> 1);
                  }
                  if (!string.IsNullOrEmpty(str))
                    win32StreamInfoList.Add(new SafeNativeMethods.Win32StreamInfo()
                    {
                      StreamType = (FileStreamType) pBuffer.StreamId,
                      StreamAttributes = (FileStreamAttributes) pBuffer.StreamAttributes,
                      StreamSize = pBuffer.Size.ToInt64(),
                      StreamName = str
                    });
                  if (!flag && !SafeNativeMethods.BackupSeek(file, pBuffer.Size.Low, pBuffer.Size.High, out int _, out int _, ref zero))
                    flag = true;
                }
              }
            }
            finally
            {
              SafeNativeMethods.BackupRead(file, streamName.MemoryBlock, 0, out numberOfBytesRead, true, false, ref zero);
            }
          }
        }
      }
      return (IList<SafeNativeMethods.Win32StreamInfo>) win32StreamInfoList;
    }

    [Flags]
    public enum NativeFileFlags : uint
    {
      WriteThrough = 2147483648, // 0x80000000
      Overlapped = 1073741824, // 0x40000000
      NoBuffering = 536870912, // 0x20000000
      RandomAccess = 268435456, // 0x10000000
      SequentialScan = 134217728, // 0x08000000
      DeleteOnClose = 67108864, // 0x04000000
      BackupSemantics = 33554432, // 0x02000000
      PosixSemantics = 16777216, // 0x01000000
      OpenReparsePoint = 2097152, // 0x00200000
      OpenNoRecall = 1048576, // 0x00100000
    }

    [Flags]
    public enum NativeFileAccess : uint
    {
      GenericRead = 2147483648, // 0x80000000
      GenericWrite = 1073741824, // 0x40000000
    }

    private struct LargeInteger
    {
      public readonly int Low;
      public readonly int High;

      public long ToInt64() => (long) this.High * 4294967296L + (long) this.Low;
    }

    private struct Win32StreamId
    {
      public readonly int StreamId;
      public readonly int StreamAttributes;
      public SafeNativeMethods.LargeInteger Size;
      public readonly int StreamNameSize;
    }

    public struct Win32StreamInfo
    {
      public FileStreamType StreamType;
      public FileStreamAttributes StreamAttributes;
      public long StreamSize;
      public string StreamName;
    }
  }
}
