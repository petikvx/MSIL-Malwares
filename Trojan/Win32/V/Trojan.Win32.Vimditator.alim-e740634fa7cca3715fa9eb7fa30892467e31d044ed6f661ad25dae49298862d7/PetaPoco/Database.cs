// Decompiled with JetBrains decompiler
// Type: PetaPoco.Database
// Assembly: PolicyExcept, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 52F55652-F9DF-416D-B2DD-AA6DA3298B76
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\Trojan.Win32.Vimditator.alim-e740634fa7cca3715fa9eb7fa30892467e31d044ed6f661ad25dae49298862d7.exe

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Reflection;
using System.Reflection.Emit;
using System.Text.RegularExpressions;
using System.Threading;

namespace PetaPoco
{
  public class Database : IDisposable
  {
    private Database.DBType _dbType;
    private static Regex rxParams;
    private static Regex rxParamsPrefix;
    private Regex rxSelect;
    private Regex rxFrom;
    private static Regex rxColumns;
    private static Regex rxOrderBy;
    private static Regex rxDistinct;
    private static Dictionary<string, object> MultiPocoFactories;
    private static Dictionary<string, object> AutoMappers;
    private static ReaderWriterLockSlim RWLock;
    private string _connectionString;
    private string _providerName;
    private DbProviderFactory _factory;
    private IDbConnection _sharedConnection;
    private IDbTransaction _transaction;
    private int _sharedConnectionDepth;
    private int _transactionDepth;
    private bool _transactionCancelled;
    private string _lastSql;
    private object[] _lastArgs;
    private string _paramPrefix;

    public Database(IDbConnection connection)
    {
      // ISSUE: unable to decompile the method.
    }

    public Database(string connectionString, string providerName)
    {
      // ISSUE: unable to decompile the method.
    }

    public Database(string connectionString, DbProviderFactory provider)
    {
      // ISSUE: unable to decompile the method.
    }

    public Database(string connectionStringName)
    {
      // ISSUE: unable to decompile the method.
    }

    private void CommonConstruct()
    {
      // ISSUE: unable to decompile the method.
    }

    public void Dispose()
    {
      // ISSUE: unable to decompile the method.
    }

    public bool KeepConnectionAlive
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
      set
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public void OpenSharedConnection()
    {
      // ISSUE: unable to decompile the method.
    }

    public void CloseSharedConnection()
    {
      // ISSUE: unable to decompile the method.
    }

    public IDbConnection Connection
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public Transaction GetTransaction()
    {
      // ISSUE: unable to decompile the method.
    }

    public virtual void OnBeginTransaction()
    {
      // ISSUE: unable to decompile the method.
    }

    public virtual void OnEndTransaction()
    {
      // ISSUE: unable to decompile the method.
    }

    public void BeginTransaction()
    {
      // ISSUE: unable to decompile the method.
    }

    private void CleanupTransaction()
    {
      // ISSUE: unable to decompile the method.
    }

    public void AbortTransaction()
    {
      // ISSUE: unable to decompile the method.
    }

    public void CompleteTransaction()
    {
      // ISSUE: unable to decompile the method.
    }

    public static string ProcessParams(string _sql, object[] args_src, List<object> args_dest)
    {
      // ISSUE: unable to decompile the method.
    }

    private void AddParam(IDbCommand cmd, object item, string ParameterPrefix)
    {
      // ISSUE: unable to decompile the method.
    }

    public IDbCommand CreateCommand(
      IDbConnection connection,
      string sql,
      params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public virtual void OnException(Exception x)
    {
      // ISSUE: unable to decompile the method.
    }

    public virtual IDbConnection OnConnectionOpened(IDbConnection conn)
    {
      // ISSUE: unable to decompile the method.
    }

    public virtual void OnConnectionClosing(IDbConnection conn)
    {
      // ISSUE: unable to decompile the method.
    }

    public virtual void OnExecutingCommand(IDbCommand cmd)
    {
      // ISSUE: unable to decompile the method.
    }

    public virtual void OnExecutedCommand(IDbCommand cmd)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Execute(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Execute(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public T ExecuteScalar<T>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public T ExecuteScalar<T>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    private string AddSelectClause<T>(string sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public bool EnableAutoSelect
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
      set
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public bool EnableNamedParams
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
      set
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public bool ForceDateTimesToUtc
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
      set
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public List<T> Fetch<T>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<T> Fetch<T>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public static bool SplitSqlForPaging(
      string sql,
      out string sqlCount,
      out string sqlSelectRemoved,
      out string sqlOrderBy)
    {
      // ISSUE: unable to decompile the method.
    }

    public void BuildPageQueries<T>(
      long skip,
      long take,
      string sql,
      ref object[] args,
      out string sqlCount,
      out string sqlPage)
    {
      // ISSUE: unable to decompile the method.
    }

    public PetaPoco.Page<T> Page<T>(
      long page,
      long itemsPerPage,
      string sql,
      params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public PetaPoco.Page<T> Page<T>(long page, long itemsPerPage, Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<T> Fetch<T>(long page, long itemsPerPage, string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<T> Fetch<T>(long page, long itemsPerPage, Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<T> SkipTake<T>(long skip, long take, string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<T> SkipTake<T>(long skip, long take, Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<T> Query<T>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<TRet> Fetch<T1, T2, TRet>(
      Func<T1, T2, TRet> cb,
      string sql,
      params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<TRet> Fetch<T1, T2, T3, TRet>(
      Func<T1, T2, T3, TRet> cb,
      string sql,
      params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<TRet> Fetch<T1, T2, T3, T4, TRet>(
      Func<T1, T2, T3, T4, TRet> cb,
      string sql,
      params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<TRet> Query<T1, T2, TRet>(
      Func<T1, T2, TRet> cb,
      string sql,
      params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<TRet> Query<T1, T2, T3, TRet>(
      Func<T1, T2, T3, TRet> cb,
      string sql,
      params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<TRet> Query<T1, T2, T3, T4, TRet>(
      Func<T1, T2, T3, T4, TRet> cb,
      string sql,
      params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<TRet> Fetch<T1, T2, TRet>(Func<T1, T2, TRet> cb, Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<TRet> Fetch<T1, T2, T3, TRet>(Func<T1, T2, T3, TRet> cb, Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<TRet> Fetch<T1, T2, T3, T4, TRet>(Func<T1, T2, T3, T4, TRet> cb, Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<TRet> Query<T1, T2, TRet>(Func<T1, T2, TRet> cb, Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<TRet> Query<T1, T2, T3, TRet>(Func<T1, T2, T3, TRet> cb, Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<TRet> Query<T1, T2, T3, T4, TRet>(
      Func<T1, T2, T3, T4, TRet> cb,
      Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<T1> Fetch<T1, T2>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<T1> Fetch<T1, T2, T3>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<T1> Fetch<T1, T2, T3, T4>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<T1> Query<T1, T2>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<T1> Query<T1, T2, T3>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<T1> Query<T1, T2, T3, T4>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<T1> Fetch<T1, T2>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<T1> Fetch<T1, T2, T3>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public List<T1> Fetch<T1, T2, T3, T4>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<T1> Query<T1, T2>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<T1> Query<T1, T2, T3>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<T1> Query<T1, T2, T3, T4>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    private object GetAutoMapper(Type[] types);

    private Delegate FindSplitPoint(
      Type typeThis,
      Type typeNext,
      string sql,
      IDataReader r,
      ref int pos)
    {
      // ISSUE: unable to decompile the method.
    }

    private Func<IDataReader, object, TRet> CreateMultiPocoFactory<TRet>(
      Type[] types,
      string sql,
      IDataReader r)
    {
      // ISSUE: unable to decompile the method.
    }

    private Func<IDataReader, object, TRet> GetMultiPocoFactory<TRet>(
      Type[] types,
      string sql,
      IDataReader r)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<TRet> Query<TRet>(
      Type[] types,
      object cb,
      string sql,
      params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public IEnumerable<T> Query<T>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public bool Exists<T>(object primaryKey)
    {
      // ISSUE: unable to decompile the method.
    }

    public T Single<T>(object primaryKey)
    {
      // ISSUE: unable to decompile the method.
    }

    public T SingleOrDefault<T>(object primaryKey)
    {
      // ISSUE: unable to decompile the method.
    }

    public T Single<T>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public T SingleOrDefault<T>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public T First<T>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public T FirstOrDefault<T>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public T Single<T>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public T SingleOrDefault<T>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public T First<T>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public T FirstOrDefault<T>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public string EscapeTableName(string str)
    {
      // ISSUE: unable to decompile the method.
    }

    public string EscapeSqlIdentifier(string str)
    {
      // ISSUE: unable to decompile the method.
    }

    public object Insert(string tableName, string primaryKeyName, object poco)
    {
      // ISSUE: unable to decompile the method.
    }

    public object Insert(string tableName, string primaryKeyName, bool autoIncrement, object poco)
    {
      // ISSUE: unable to decompile the method.
    }

    public object Insert(object poco)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Update(
      string tableName,
      string primaryKeyName,
      object poco,
      object primaryKeyValue)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Update(
      string tableName,
      string primaryKeyName,
      object poco,
      object primaryKeyValue,
      IEnumerable<string> columns)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Update(string tableName, string primaryKeyName, object poco)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Update(
      string tableName,
      string primaryKeyName,
      object poco,
      IEnumerable<string> columns)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Update(object poco, IEnumerable<string> columns)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Update(object poco)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Update(object poco, object primaryKeyValue)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Update(object poco, object primaryKeyValue, IEnumerable<string> columns)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Update<T>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Update<T>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Delete(string tableName, string primaryKeyName, object poco)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Delete(
      string tableName,
      string primaryKeyName,
      object poco,
      object primaryKeyValue)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Delete(object poco)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Delete<T>(object pocoOrPrimaryKey)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Delete<T>(string sql, params object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public int Delete<T>(Sql sql)
    {
      // ISSUE: unable to decompile the method.
    }

    public bool IsNew(string primaryKeyName, object poco)
    {
      // ISSUE: unable to decompile the method.
    }

    public bool IsNew(object poco)
    {
      // ISSUE: unable to decompile the method.
    }

    public void Save(string tableName, string primaryKeyName, object poco)
    {
      // ISSUE: unable to decompile the method.
    }

    public void Save(object poco)
    {
      // ISSUE: unable to decompile the method.
    }

    public int CommandTimeout
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
      set
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public int OneTimeCommandTimeout
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
      set
      {
        // ISSUE: unable to decompile the method.
      }
    }

    private void DoPreExecute(IDbCommand cmd)
    {
      // ISSUE: unable to decompile the method.
    }

    public string LastSQL
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public object[] LastArgs
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public string LastCommand
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public string FormatCommand(IDbCommand cmd)
    {
      // ISSUE: unable to decompile the method.
    }

    public string FormatCommand(string sql, object[] args)
    {
      // ISSUE: unable to decompile the method.
    }

    public static IMapper Mapper
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
      set
      {
        // ISSUE: unable to decompile the method.
      }
    }

    static Database()
    {
      // ISSUE: unable to decompile the method.
    }

    private enum DBType
    {
      SqlServer,
      SqlServerCE,
      MySql,
      PostgreSQL,
      Oracle,
      SQLite,
    }

    private class MultiPocoFactory
    {
      public List<Delegate> m_Delegates;

      public Delegate GetItem(int index)
      {
        // ISSUE: unable to decompile the method.
      }

      public MultiPocoFactory()
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public class PocoColumn
    {
      public string ColumnName;
      public PropertyInfo PropertyInfo;
      public bool ResultColumn;

      public virtual void SetValue(object target, object val)
      {
        // ISSUE: unable to decompile the method.
      }

      public virtual object GetValue(object target)
      {
        // ISSUE: unable to decompile the method.
      }

      public virtual object ChangeType(object val)
      {
        // ISSUE: unable to decompile the method.
      }

      public PocoColumn()
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public class ExpandoColumn : Database.PocoColumn
    {
      public override void SetValue(object target, object val)
      {
        // ISSUE: unable to decompile the method.
      }

      public override object GetValue(object target)
      {
        // ISSUE: unable to decompile the method.
      }

      public override object ChangeType(object val)
      {
        // ISSUE: unable to decompile the method.
      }

      public ExpandoColumn()
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public class PocoData
    {
      private static ReaderWriterLockSlim RWLock;
      private static Dictionary<Type, Database.PocoData> m_PocoDatas;
      private static List<Func<object, object>> m_Converters;
      private static MethodInfo fnGetValue;
      private static MethodInfo fnIsDBNull;
      private static FieldInfo fldConverters;
      private static MethodInfo fnListGetItem;
      private static MethodInfo fnInvoke;
      public Type type;
      private Dictionary<string, Delegate> PocoFactories;

      public static Database.PocoData ForObject(object o, string primaryKeyName)
      {
        // ISSUE: unable to decompile the method.
      }

      public static Database.PocoData ForType(Type t)
      {
        // ISSUE: unable to decompile the method.
      }

      public PocoData()
      {
        // ISSUE: unable to decompile the method.
      }

      public PocoData(Type t)
      {
        // ISSUE: unable to decompile the method.
      }

      private static bool IsIntegralType(Type t)
      {
        // ISSUE: unable to decompile the method.
      }

      public Delegate GetFactory(
        string sql,
        string connString,
        bool ForceDateTimesToUtc,
        int firstColumn,
        int countColumns,
        IDataReader r)
      {
        // ISSUE: unable to decompile the method.
      }

      private static void AddConverterToStack(ILGenerator il, Func<object, object> converter)
      {
        // ISSUE: unable to decompile the method.
      }

      private static Func<object, object> GetConverter(
        bool forceDateTimesToUtc,
        Database.PocoColumn pc,
        Type srcType,
        Type dstType)
      {
        // ISSUE: unable to decompile the method.
      }

      private static T RecurseInheritedTypes<T>(Type t, Func<Type, T> cb)
      {
        // ISSUE: unable to decompile the method.
      }

      public string[] QueryColumns
      {
        get
        {
          // ISSUE: unable to decompile the method.
        }
        private set
        {
          // ISSUE: unable to decompile the method.
        }
      }

      public TableInfo TableInfo
      {
        get
        {
          // ISSUE: unable to decompile the method.
        }
        private set
        {
          // ISSUE: unable to decompile the method.
        }
      }

      public Dictionary<string, Database.PocoColumn> Columns
      {
        get
        {
          // ISSUE: unable to decompile the method.
        }
        private set
        {
          // ISSUE: unable to decompile the method.
        }
      }

      static PocoData()
      {
        // ISSUE: unable to decompile the method.
      }
    }
  }
}
