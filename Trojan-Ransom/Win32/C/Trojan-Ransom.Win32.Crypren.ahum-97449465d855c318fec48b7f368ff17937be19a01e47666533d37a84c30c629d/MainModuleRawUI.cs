// Decompiled with JetBrains decompiler
// Type: ModuleNameSpace.MainModuleRawUI
// Assembly: copierimp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B91267B9-A6E6-4499-A0E0-76087ADE7AE9
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.06-msil\Trojan-Ransom.Win32.Crypren.ahum-97449465d855c318fec48b7f368ff17937be19a01e47666533d37a84c30c629d.exe

using System;
using System.Management.Automation.Host;
using System.Runtime.InteropServices;

namespace ModuleNameSpace
{
  internal class MainModuleRawUI : PSHostRawUserInterface
  {
    private const int STD_OUTPUT_HANDLE = -11;

    [DllImport("kernel32.dll", EntryPoint = "ReadConsoleOutputW", CharSet = CharSet.Unicode, SetLastError = true)]
    internal static extern bool ReadConsoleOutput(
      IntPtr hConsoleOutput,
      [MarshalAs(UnmanagedType.LPArray), Out] MainModuleRawUI.CHAR_INFO[,] lpBuffer,
      MainModuleRawUI.COORD dwBufferSize,
      MainModuleRawUI.COORD dwBufferCoord,
      ref MainModuleRawUI.SMALL_RECT lpReadRegion);

    [DllImport("kernel32.dll", EntryPoint = "WriteConsoleOutputW", CharSet = CharSet.Unicode, SetLastError = true)]
    internal static extern bool WriteConsoleOutput(
      IntPtr hConsoleOutput,
      [MarshalAs(UnmanagedType.LPArray), In] MainModuleRawUI.CHAR_INFO[,] lpBuffer,
      MainModuleRawUI.COORD dwBufferSize,
      MainModuleRawUI.COORD dwBufferCoord,
      ref MainModuleRawUI.SMALL_RECT lpWriteRegion);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool ScrollConsoleScreenBuffer(
      IntPtr hConsoleOutput,
      [In] ref MainModuleRawUI.SMALL_RECT lpScrollRectangle,
      [In] ref MainModuleRawUI.SMALL_RECT lpClipRectangle,
      MainModuleRawUI.COORD dwDestinationOrigin,
      [In] ref MainModuleRawUI.CHAR_INFO lpFill);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr GetStdHandle(int nStdHandle);

    public override ConsoleColor BackgroundColor
    {
      get => Console.BackgroundColor;
      set => Console.BackgroundColor = value;
    }

    public override Size BufferSize
    {
      get => Console_Info.IsOutputRedirected() ? new Size(120, 50) : new Size(Console.BufferWidth, Console.BufferHeight);
      set
      {
        Console.BufferWidth = value.Width;
        Console.BufferHeight = value.Height;
      }
    }

    public override Coordinates CursorPosition
    {
      get => new Coordinates(Console.CursorLeft, Console.CursorTop);
      set
      {
        Console.CursorTop = value.Y;
        Console.CursorLeft = value.X;
      }
    }

    public override int CursorSize
    {
      get => Console.CursorSize;
      set => Console.CursorSize = value;
    }

    public override void FlushInputBuffer()
    {
      if (Console_Info.IsInputRedirected())
        return;
      while (Console.KeyAvailable)
        Console.ReadKey(true);
    }

    public override ConsoleColor ForegroundColor
    {
      get => Console.ForegroundColor;
      set => Console.ForegroundColor = value;
    }

    public override BufferCell[,] GetBufferContents(Rectangle rectangle)
    {
      IntPtr stdHandle = MainModuleRawUI.GetStdHandle(-11);
      MainModuleRawUI.CHAR_INFO[,] lpBuffer = new MainModuleRawUI.CHAR_INFO[rectangle.Bottom - rectangle.Top + 1, rectangle.Right - rectangle.Left + 1];
      MainModuleRawUI.COORD dwBufferSize = new MainModuleRawUI.COORD()
      {
        X = (short) (rectangle.Right - rectangle.Left + 1),
        Y = (short) (rectangle.Bottom - rectangle.Top + 1)
      };
      MainModuleRawUI.COORD dwBufferCoord = new MainModuleRawUI.COORD()
      {
        X = 0,
        Y = 0
      };
      MainModuleRawUI.SMALL_RECT lpReadRegion = new MainModuleRawUI.SMALL_RECT()
      {
        Left = (short) rectangle.Left,
        Top = (short) rectangle.Top,
        Right = (short) rectangle.Right,
        Bottom = (short) rectangle.Bottom
      };
      MainModuleRawUI.ReadConsoleOutput(stdHandle, lpBuffer, dwBufferSize, dwBufferCoord, ref lpReadRegion);
      BufferCell[,] bufferContents = new BufferCell[rectangle.Bottom - rectangle.Top + 1, rectangle.Right - rectangle.Left + 1];
      for (int index1 = 0; index1 <= rectangle.Bottom - rectangle.Top; ++index1)
      {
        for (int index2 = 0; index2 <= rectangle.Right - rectangle.Left; ++index2)
          bufferContents[index1, index2] = new BufferCell(lpBuffer[index1, index2].AsciiChar, (ConsoleColor) ((int) lpBuffer[index1, index2].Attributes & 15), (ConsoleColor) (((int) lpBuffer[index1, index2].Attributes & 240) / 16), BufferCellType.Complete);
      }
      return bufferContents;
    }

    public override bool KeyAvailable => Console.KeyAvailable;

    public override Size MaxPhysicalWindowSize => new Size(Console.LargestWindowWidth, Console.LargestWindowHeight);

    public override Size MaxWindowSize => new Size(Console.BufferWidth, Console.BufferWidth);

    public override KeyInfo ReadKey(ReadKeyOptions options)
    {
      ConsoleKeyInfo consoleKeyInfo = Console.ReadKey((options & ReadKeyOptions.NoEcho) != (ReadKeyOptions) 0);
      ControlKeyStates controlKeyState = (ControlKeyStates) 0;
      if ((consoleKeyInfo.Modifiers & ConsoleModifiers.Alt) != (ConsoleModifiers) 0)
        controlKeyState |= ControlKeyStates.RightAltPressed | ControlKeyStates.LeftAltPressed;
      if ((consoleKeyInfo.Modifiers & ConsoleModifiers.Control) != (ConsoleModifiers) 0)
        controlKeyState |= ControlKeyStates.RightCtrlPressed | ControlKeyStates.LeftCtrlPressed;
      if ((consoleKeyInfo.Modifiers & ConsoleModifiers.Shift) != (ConsoleModifiers) 0)
        controlKeyState |= ControlKeyStates.ShiftPressed;
      if (Console.CapsLock)
        controlKeyState |= ControlKeyStates.CapsLockOn;
      if (Console.NumberLock)
        controlKeyState |= ControlKeyStates.NumLockOn;
      return new KeyInfo((int) consoleKeyInfo.Key, consoleKeyInfo.KeyChar, controlKeyState, (options & ReadKeyOptions.IncludeKeyDown) != (ReadKeyOptions) 0);
    }

    public override void ScrollBufferContents(
      Rectangle source,
      Coordinates destination,
      Rectangle clip,
      BufferCell fill)
    {
      if (source.Left > clip.Right || source.Right < clip.Left || source.Top > clip.Bottom || source.Bottom < clip.Top)
        return;
      IntPtr stdHandle = MainModuleRawUI.GetStdHandle(-11);
      MainModuleRawUI.SMALL_RECT lpScrollRectangle = new MainModuleRawUI.SMALL_RECT()
      {
        Left = (short) source.Left,
        Top = (short) source.Top,
        Right = (short) source.Right,
        Bottom = (short) source.Bottom
      };
      MainModuleRawUI.SMALL_RECT lpClipRectangle = new MainModuleRawUI.SMALL_RECT()
      {
        Left = (short) clip.Left,
        Top = (short) clip.Top,
        Right = (short) clip.Right,
        Bottom = (short) clip.Bottom
      };
      MainModuleRawUI.COORD dwDestinationOrigin = new MainModuleRawUI.COORD()
      {
        X = (short) destination.X,
        Y = (short) destination.Y
      };
      MainModuleRawUI.CHAR_INFO lpFill = new MainModuleRawUI.CHAR_INFO()
      {
        AsciiChar = fill.Character,
        Attributes = (ushort) (fill.ForegroundColor + (int) fill.BackgroundColor * 16)
      };
      MainModuleRawUI.ScrollConsoleScreenBuffer(stdHandle, ref lpScrollRectangle, ref lpClipRectangle, dwDestinationOrigin, ref lpFill);
    }

    public override void SetBufferContents(Rectangle rectangle, BufferCell fill)
    {
      if (rectangle.Left >= 0)
        Console.MoveBufferArea(rectangle.Left, rectangle.Top, rectangle.Right - rectangle.Left + 1, rectangle.Bottom - rectangle.Top + 1, this.BufferSize.Width, this.BufferSize.Height, fill.Character, fill.ForegroundColor, fill.BackgroundColor);
      else
        Console.MoveBufferArea(0, 0, this.BufferSize.Width, this.BufferSize.Height, this.BufferSize.Width, this.BufferSize.Height, fill.Character, fill.ForegroundColor, fill.BackgroundColor);
    }

    public override void SetBufferContents(Coordinates origin, BufferCell[,] contents)
    {
      IntPtr stdHandle = MainModuleRawUI.GetStdHandle(-11);
      MainModuleRawUI.CHAR_INFO[,] lpBuffer = new MainModuleRawUI.CHAR_INFO[contents.GetLength(0), contents.GetLength(1)];
      MainModuleRawUI.COORD dwBufferSize = new MainModuleRawUI.COORD()
      {
        X = (short) contents.GetLength(1),
        Y = (short) contents.GetLength(0)
      };
      MainModuleRawUI.COORD dwBufferCoord = new MainModuleRawUI.COORD()
      {
        X = 0,
        Y = 0
      };
      MainModuleRawUI.SMALL_RECT lpWriteRegion = new MainModuleRawUI.SMALL_RECT()
      {
        Left = (short) origin.X,
        Top = (short) origin.Y,
        Right = (short) (origin.X + contents.GetLength(1) - 1),
        Bottom = (short) (origin.Y + contents.GetLength(0) - 1)
      };
      for (int index1 = 0; index1 < contents.GetLength(0); ++index1)
      {
        for (int index2 = 0; index2 < contents.GetLength(1); ++index2)
          lpBuffer.Address(index1, index2) = new MainModuleRawUI.CHAR_INFO()
          {
            AsciiChar = contents[index1, index2].Character,
            Attributes = (ushort) (contents[index1, index2].ForegroundColor + (int) contents[index1, index2].BackgroundColor * 16)
          };
      }
      MainModuleRawUI.WriteConsoleOutput(stdHandle, lpBuffer, dwBufferSize, dwBufferCoord, ref lpWriteRegion);
    }

    public override Coordinates WindowPosition
    {
      get => new Coordinates()
      {
        X = Console.WindowLeft,
        Y = Console.WindowTop
      };
      set
      {
        Console.WindowLeft = value.X;
        Console.WindowTop = value.Y;
      }
    }

    public override Size WindowSize
    {
      get => new Size()
      {
        Height = Console.WindowHeight,
        Width = Console.WindowWidth
      };
      set
      {
        Console.WindowWidth = value.Width;
        Console.WindowHeight = value.Height;
      }
    }

    public override string WindowTitle
    {
      get => Console.Title;
      set => Console.Title = value;
    }

    [StructLayout(LayoutKind.Explicit)]
    public struct CHAR_INFO
    {
      [FieldOffset(0)]
      internal char UnicodeChar;
      [FieldOffset(0)]
      internal char AsciiChar;
      [FieldOffset(2)]
      internal ushort Attributes;
    }

    public struct COORD
    {
      public short X;
      public short Y;
    }

    public struct SMALL_RECT
    {
      public short Left;
      public short Top;
      public short Right;
      public short Bottom;
    }
  }
}
