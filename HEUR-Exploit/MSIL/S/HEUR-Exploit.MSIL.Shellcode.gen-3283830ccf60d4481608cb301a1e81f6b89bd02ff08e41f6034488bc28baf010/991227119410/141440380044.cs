// Decompiled with JetBrains decompiler
// Type: 991227119410.141440380044
// Assembly: 087135227926, Version=10.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed
// MVID: 0DB320EA-9C28-4716-BA63-69641BABDE67
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Exploit.MSIL.Shellcode.gen-3283830ccf60d4481608cb301a1e81f6b89bd02ff08e41f6034488bc28baf010.exe

using \u003462605226301;
using \u003545704640419;
using \u003991227119410;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace \u003991227119410
{
  internal static class \u003141440380044
  {
    public static bool \u003585487845797<T>(ICollection<T> _param0) => _param0 == null || _param0.Count == 0;

    public static void \u003555166478378<T>(this IList<T> _param0, IEnumerable<T> _param1)
    {
      if (_param0 == null)
        throw new ArgumentNullException("initial");
      if (_param1 == null)
        return;
      foreach (T obj in _param1)
        _param0.Add(obj);
    }

    public static bool \u003527540921678(Type _param0)
    {
      \u003821784578685.\u003260732825936((object) _param0, "type");
      return typeof (IDictionary).IsAssignableFrom(_param0) || \u003560732527318.\u003695199970905(_param0, typeof (IDictionary<,>)) || \u003560732527318.\u003695199970905(_param0, typeof (IReadOnlyDictionary<,>));
    }

    public static ConstructorInfo \u003940405028291(Type _param0, Type _param1)
    {
      Type type = typeof (IList<>).MakeGenericType(_param1);
      return \u003141440380044.\u003109848411990(_param0, _param1, type);
    }

    public static ConstructorInfo \u003109848411990(
      Type _param0,
      Type _param1,
      Type _param2)
    {
      Type type = typeof (IEnumerable<>).MakeGenericType(_param1);
      ConstructorInfo constructorInfo = (ConstructorInfo) null;
      foreach (ConstructorInfo constructor in _param0.GetConstructors(BindingFlags.Instance | BindingFlags.Public))
      {
        IList<ParameterInfo> parameters = (IList<ParameterInfo>) constructor.GetParameters();
        if (parameters.Count == 1)
        {
          Type parameterType = parameters[0].ParameterType;
          if (type == parameterType)
          {
            constructorInfo = constructor;
            break;
          }
          if (constructorInfo == (ConstructorInfo) null && parameterType.IsAssignableFrom(_param2))
            constructorInfo = constructor;
        }
      }
      return constructorInfo;
    }

    public static bool \u003345606775256<T>(this IList<T> _param0, T _param1) => _param0.\u003582772414654<T>(_param1, (IEqualityComparer<T>) EqualityComparer<T>.Default);

    public static bool \u003582772414654<T>(
      this IList<T> _param0,
      T _param1,
      IEqualityComparer<T> _param2)
    {
      if (_param0.\u003716496901415<T>(_param1, _param2))
        return false;
      _param0.Add(_param1);
      return true;
    }

    public static bool \u003716496901415<TSource>(
      this IEnumerable<TSource> _param0,
      TSource _param1,
      IEqualityComparer<TSource> _param2)
    {
      if (_param2 == null)
        _param2 = (IEqualityComparer<TSource>) EqualityComparer<TSource>.Default;
      if (_param0 == null)
        throw new ArgumentNullException("source");
      foreach (TSource x in _param0)
      {
        if (_param2.Equals(x, _param1))
          return true;
      }
      return false;
    }

    public static bool \u003136225306920<T>(
      this IList<T> _param0,
      IEnumerable<T> _param1,
      IEqualityComparer<T> _param2)
    {
      bool flag = true;
      foreach (T obj in _param1)
      {
        if (!_param0.\u003582772414654<T>(obj, _param2))
          flag = false;
      }
      return flag;
    }

    public static int \u003723489693319<T>(this IEnumerable<T> _param0, Func<T, bool> _param1)
    {
      int num = 0;
      foreach (T obj in _param0)
      {
        if (_param1(obj))
          return num;
        ++num;
      }
      return -1;
    }

    public static bool \u003438564837179<T>(
      this List<T> _param0,
      T _param1,
      IEqualityComparer _param2)
    {
      for (int index = 0; index < _param0.Count; ++index)
      {
        if (_param2.Equals((object) _param1, (object) _param0[index]))
          return true;
      }
      return false;
    }

    public static int \u003665293128292<T>(this List<T> _param0, T _param1)
    {
      for (int index = 0; index < _param0.Count; ++index)
      {
        if ((object) _param1 == (object) _param0[index])
          return index;
      }
      return -1;
    }

    private static IList<int> \u003724460907845(IList _param0, int _param1)
    {
      IList<int> intList = (IList<int>) new List<int>();
      IList list1 = _param0;
      while (true)
      {
        intList.Add(list1.Count);
        if (intList.Count != _param1 && list1.Count != 0 && list1[0] is IList list2)
          list1 = list2;
        else
          break;
      }
      return intList;
    }

    private static void \u003742097609363(IList _param0, Array _param1, int[] _param2)
    {
      int length1 = _param2.Length;
      if (length1 == _param1.Rank)
      {
        _param1.SetValue(\u003141440380044.\u003634185982632(_param0, _param2), _param2);
      }
      else
      {
        int length2 = _param1.GetLength(length1);
        if (((ICollection) \u003141440380044.\u003634185982632(_param0, _param2)).Count != length2)
          throw new Exception("Cannot deserialize non-cubical array as multidimensional array.");
        int[] numArray = new int[length1 + 1];
        for (int index = 0; index < length1; ++index)
          numArray[index] = _param2[index];
        for (int index = 0; index < _param1.GetLength(length1); ++index)
        {
          numArray[length1] = index;
          \u003141440380044.\u003742097609363(_param0, _param1, numArray);
        }
      }
    }

    private static object \u003634185982632(IList _param0, int[] _param1)
    {
      IList list = _param0;
      for (int index1 = 0; index1 < _param1.Length; ++index1)
      {
        int index2 = _param1[index1];
        if (index1 == _param1.Length - 1)
          return list[index2];
        list = (IList) list[index2];
      }
      return (object) list;
    }

    public static Array \u003494612457018(IList _param0, Type _param1, int _param2)
    {
      IList<int> source = \u003141440380044.\u003724460907845(_param0, _param2);
      while (source.Count < _param2)
        source.Add(0);
      Array instance = Array.CreateInstance(_param1, source.ToArray<int>());
      \u003141440380044.\u003742097609363(_param0, instance, \u003141440380044.\u003458829377194<int>());
      return instance;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] \u003458829377194<T>() => Enumerable.Empty<T>() is T[] objArray ? objArray : new T[0];
  }
}
