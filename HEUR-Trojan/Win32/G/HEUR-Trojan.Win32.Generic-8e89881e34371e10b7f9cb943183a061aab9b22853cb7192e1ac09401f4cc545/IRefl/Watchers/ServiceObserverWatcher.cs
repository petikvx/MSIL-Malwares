// Decompiled with JetBrains decompiler
// Type: IRefl.Watchers.ServiceObserverWatcher
// Assembly: IRefl, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A29A65F6-B7ED-422C-83D4-B9EFD61E5F13
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-8e89881e34371e10b7f9cb943183a061aab9b22853cb7192e1ac09401f4cc545.exe

using IRefl.Adapter;
using IRefl.Producers;
using ProjNet.Structs;
using ProjNet.Templates;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text;

namespace IRefl.Watchers
{
  internal abstract class ServiceObserverWatcher : 
    ValueObserverWatcher,
    GlobalPrototypeAdapter,
    CodeObjectProducer
  {
    protected bool _PropertyRegistry;
    protected double parserRegistry;
    protected double _InterpreterRegistry;
    protected double _ConfigurationRegistry;
    protected double refRegistry;
    protected List<Config> globalRegistry;
    protected ValueObserverWatcher m_InterceptorRegistry;
    private string definitionRegistry;
    private string contextRegistry;
    private string m_PrinterRegistry;
    private long _ClientRegistry;
    private string m_RulesRegistry;
    private string _DatabaseRegistry;

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected ServiceObserverWatcher(List<Config> first, bool checkivk)
    {
      PageAdvisorStructBuilder.PrepareCreator();
      // ISSUE: explicit constructor call
      this.\u002Ector(first);
      this._PropertyRegistry = checkivk;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected ServiceObserverWatcher(List<Config> config)
    {
      PageAdvisorStructBuilder.PrepareCreator();
      this._PropertyRegistry = false;
      // ISSUE: explicit constructor call
      base.\u002Ector();
      this.globalRegistry = config;
      Config config1 = this.PushMerchant("semi_major");
      Config config2 = this.PushMerchant("semi_minor");
      if (config1 == null)
        throw new ArgumentException("Missing projection parameter 'semi_major'");
      if (config2 == null)
        throw new ArgumentException("Missing projection parameter 'semi_minor'");
      this._InterpreterRegistry = config1.CountRegistry();
      this._ConfigurationRegistry = config2.CountRegistry();
      this.refRegistry = this.PushMerchant("unit").CountRegistry();
      this.parserRegistry = 1.0 - this._ConfigurationRegistry * this._ConfigurationRegistry / (this._InterpreterRegistry * this._InterpreterRegistry);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public Config PushMerchant(int idx_instance) => this.globalRegistry[idx_instance];

    [MethodImpl(MethodImplOptions.NoInlining)]
    public Config PushMerchant(string value)
    {
      int num1 = 3;
      Config config;
      while (true)
      {
        // ISSUE: variable of a compiler-generated type
        ServiceObserverWatcher.ConsumerServiceSpec consumerServiceSpec;
        int num2;
        switch (num1)
        {
          case 0:
          case 3:
            // ISSUE: object of a compiler-generated type is created
            consumerServiceSpec = new ServiceObserverWatcher.ConsumerServiceSpec();
            num2 = 2;
            break;
          case 1:
          case 2:
            // ISSUE: reference to a compiler-generated field
            consumerServiceSpec.m_StubAdvisor = value;
            goto case 4;
          case 4:
            // ISSUE: reference to a compiler-generated method
            config = this.globalRegistry.Find(new Predicate<Config>(consumerServiceSpec.ConnectStatus));
            num2 = 5;
            break;
          case 5:
            goto label_7;
          default:
            num2 = 4;
            break;
        }
        num1 = num2;
      }
label_7:
      return config;
    }

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public int CreateItem() => this.globalRegistry.Count;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public string ChangeMerchant() => this.ChangeMerchant();

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public string RestartItem() => this.definitionRegistry;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void PatchAdvisor(string setup) => this.definitionRegistry = setup;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public string OrderItem() => this.contextRegistry;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void VisitAdvisor(string v) => this.contextRegistry = v;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public string CountItem() => this.m_PrinterRegistry;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void MapAdvisor(string spec) => this.m_PrinterRegistry = spec;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public long SelectItem() => this._ClientRegistry;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void PrintAdvisor(long config_X) => this._ClientRegistry = config_X;

    public string Name
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => this.m_RulesRegistry;
      [MethodImpl(MethodImplOptions.NoInlining)] set => this.m_RulesRegistry = value;
    }

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public string EnableItem() => this._DatabaseRegistry;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void CountAdvisor(string var1) => this._DatabaseRegistry = var1;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override string RevertStatus()
    {
      int num1 = 7;
      string str;
      while (true)
      {
        int num2 = num1;
        StringBuilder stringBuilder;
        int idx_instance;
        while (true)
        {
          bool propertyRegistry;
          switch (num2)
          {
            case 0:
            case 4:
label_14:
              if (!propertyRegistry)
                goto label_13;
              else
                goto label_15;
            case 1:
              stringBuilder.AppendFormat("PARAM_MT[\"{0}\"", (object) this.Name);
              idx_instance = 0;
              break;
            case 2:
              ++idx_instance;
              break;
            case 3:
            case 5:
              stringBuilder.Append("]");
              goto label_13;
            case 6:
              if (!this._PropertyRegistry)
                goto case 1;
              else
                goto label_11;
            case 7:
              goto label_1;
            case 8:
              goto label_17;
            default:
              if (ServiceObserverWatcher.ComputeModel())
              {
                num2 = 0;
                continue;
              }
              goto case 1;
          }
          if (idx_instance >= this.CreateItem())
          {
            stringBuilder.Append("]");
            propertyRegistry = this._PropertyRegistry;
            goto label_14;
          }
          else
            goto label_9;
label_13:
          str = stringBuilder.ToString();
          if (true)
            num2 = 8;
          else
            goto label_14;
        }
label_1:
        stringBuilder = new StringBuilder();
        num1 = 6;
        continue;
label_9:
        stringBuilder.AppendFormat(", {0}", (object) this.PushMerchant(idx_instance).RestartRegistry());
        num1 = 2;
        continue;
label_11:
        stringBuilder.Append("INVERSE_MT[");
        num1 = 1;
        continue;
label_15:
        num1 = 3;
      }
label_17:
      return str;
    }

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override string AssetItem()
    {
      int num1 = 0;
      string str;
      while (true)
      {
        int num2 = num1;
        StringBuilder stringBuilder;
        int idx_instance;
        bool flag;
        while (true)
        {
          switch (num2)
          {
            case 0:
              stringBuilder = new StringBuilder();
              if (true)
              {
                num2 = 1;
                continue;
              }
              goto case 3;
            case 1:
              goto label_3;
            case 2:
            case 5:
              if (this._PropertyRegistry)
                stringBuilder.Append("</CT_InverseTransform>");
              else
                stringBuilder.Append("</CT_ParameterizedMathTransform>");
              stringBuilder.Append("</CT_MathTransform>");
              str = stringBuilder.ToString();
              num2 = 8;
              continue;
            case 3:
            case 7:
              ++idx_instance;
              goto case 6;
            case 4:
              if (flag)
              {
                stringBuilder.AppendFormat(this.PushMerchant(idx_instance).StopRegistry());
                if (!ServiceObserverWatcher.RestartModel())
                {
                  num2 = 7;
                  continue;
                }
                goto label_3;
              }
              else
              {
                num2 = 2;
                continue;
              }
            case 6:
              flag = idx_instance < this.CreateItem();
              goto case 4;
            case 8:
              goto label_20;
            default:
              num2 = 4;
              continue;
          }
        }
label_3:
        stringBuilder.Append("<CT_MathTransform>");
        if (this._PropertyRegistry)
          stringBuilder.AppendFormat("<CT_InverseTransform Name=\"{0}\">", (object) this.ChangeMerchant());
        else
          stringBuilder.AppendFormat("<CT_ParameterizedMathTransform Name=\"{0}\">", (object) this.ChangeMerchant());
        idx_instance = 0;
        num1 = 6;
      }
label_20:
      return str;
    }

    public abstract double[] ConcatMerchant(double[] first);

    public abstract double[] ComputeMerchant(double[] last);

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override void CalcMerchant() => this._PropertyRegistry = !this._PropertyRegistry;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    internal bool SelectAdvisor() => this._PropertyRegistry;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] PublishMerchant(double[] value)
    {
      int num1 = 5;
      double[] numArray1;
      while (true)
      {
        int num2 = num1;
        bool flag;
        while (true)
        {
          switch (num2)
          {
            case 0:
            case 5:
              goto label_8;
            case 1:
              goto label_3;
            case 2:
            case 3:
              if (!flag)
              {
                numArray1 = this.ConcatMerchant(value);
                int num3 = 6;
                num2 = ServiceObserverWatcher.RestartModel() ? num3 : num3;
                continue;
              }
              goto label_1;
            case 4:
              goto label_1;
            case 6:
              goto label_9;
            default:
              goto label_7;
          }
        }
label_3:
        flag = !this._PropertyRegistry;
        num1 = 3;
        continue;
label_7:
        num1 = 4;
        continue;
label_8:
        double[] numArray2 = new double[3];
        num1 = 1;
      }
label_1:
      numArray1 = this.ComputeMerchant(value);
label_9:
      return numArray1;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override List<double[]> FlushMerchant(List<double[]> key)
    {
      List<double[]> numArrayList = new List<double[]>(key.Count);
      for (int index = 0; index < key.Count; ++index)
      {
        double[] numArray = key[index];
        numArrayList.Add(this.PublishMerchant(numArray));
      }
      return numArrayList;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public bool InvokeItem(object setup)
    {
      int num1 = 4;
      bool flag1;
      while (true)
      {
        // ISSUE: variable of a compiler-generated type
        ServiceObserverWatcher.AttributeStatusService attributeStatusService;
        // ISSUE: variable of a compiler-generated type
        ServiceObserverWatcher.MockAdvisor mockAdvisor;
        bool flag2;
        int num2;
        Config config;
        switch (num1)
        {
          case 0:
            // ISSUE: reference to a compiler-generated field
            if (attributeStatusService.m_ExpressionAdvisor >= this.globalRegistry.Count)
            {
              num1 = 1;
              continue;
            }
            // ISSUE: reference to a compiler-generated method
            config = this.globalRegistry.Find(new Predicate<Config>(attributeStatusService.AddStatus));
            num2 = 5;
            break;
          case 1:
            // ISSUE: reference to a compiler-generated field
            if (this.SelectAdvisor() == mockAdvisor.tagAdvisor.SelectAdvisor())
            {
              flag1 = true;
              num2 = 10;
              break;
            }
            goto label_16;
          case 2:
          case 9:
            // ISSUE: reference to a compiler-generated field
            attributeStatusService.m_ExpressionAdvisor = 0;
            goto case 0;
          case 3:
          case 5:
            flag2 = config == null;
            if (true)
            {
              num1 = 8;
              continue;
            }
            goto case 4;
          case 4:
            // ISSUE: object of a compiler-generated type is created
            mockAdvisor = new ServiceObserverWatcher.MockAdvisor();
            num2 = 6;
            break;
          case 6:
            if (setup is ServiceObserverWatcher)
            {
              // ISSUE: reference to a compiler-generated field
              mockAdvisor.tagAdvisor = setup as ServiceObserverWatcher;
              // ISSUE: reference to a compiler-generated field
              if (mockAdvisor.tagAdvisor.CreateItem() == this.CreateItem())
              {
                // ISSUE: object of a compiler-generated type is created
                attributeStatusService = new ServiceObserverWatcher.AttributeStatusService();
                // ISSUE: reference to a compiler-generated field
                attributeStatusService._ValAdvisor = mockAdvisor;
                int num3 = 9;
                num1 = ServiceObserverWatcher.RestartModel() ? num3 : num3;
                continue;
              }
              goto label_6;
            }
            else
              goto label_4;
          case 7:
          case 10:
            goto label_23;
          case 8:
            if (!flag2)
            {
              // ISSUE: reference to a compiler-generated field
              // ISSUE: reference to a compiler-generated field
              // ISSUE: reference to a compiler-generated field
              if (config.CountRegistry() == attributeStatusService._ValAdvisor.tagAdvisor.PushMerchant(attributeStatusService.m_ExpressionAdvisor).CountRegistry())
              {
                // ISSUE: reference to a compiler-generated field
                attributeStatusService.m_ExpressionAdvisor++;
                if (ServiceObserverWatcher.ComputeModel())
                {
                  num1 = 0;
                  continue;
                }
                goto case 3;
              }
              else
                goto label_19;
            }
            else
              goto label_9;
          default:
            if (true)
            {
              num1 = 7;
              continue;
            }
            goto case 2;
        }
        num1 = num2;
      }
label_4:
      flag1 = false;
      goto label_23;
label_6:
      flag1 = false;
      goto label_23;
label_9:
      flag1 = false;
      goto label_23;
label_16:
      flag1 = false;
      goto label_23;
label_19:
      flag1 = false;
label_23:
      return flag1;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double FillAdvisor(double def) => Math.Pow(def, 3.0);

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double SetupAdvisor(double i) => Math.Pow(i, 4.0);

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double ValidateAdvisor(ref double instance, ref double ord) => Math.Max(instance, ord);

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double AwakeAdvisor(ref double v, ref double result) => v < result ? v : result;

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double CalculateAdvisor(double instance, double second) => instance - instance / second * second;

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double ExcludeAdvisor(double i)
    {
      int num1 = 4;
      if (true)
        goto label_5;
label_1:
      double num2 = -1.0;
      goto label_7;
label_5:
      bool flag;
      while (true)
      {
        switch (num1)
        {
          case 0:
          case 4:
            flag = i < 0.0;
            num1 = 3;
            continue;
          case 1:
          case 2:
            goto label_1;
          case 3:
            if (!flag)
            {
              num2 = 1.0;
              num1 = 5;
              continue;
            }
            goto label_1;
          case 5:
            goto label_7;
          default:
            num1 = 1;
            continue;
        }
      }
label_7:
      return num2;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double MoveAdvisor(double item)
    {
      int num1 = 3;
      double num2;
      while (true)
      {
        int num3 = num1;
        bool flag1;
        bool flag2;
        while (true)
        {
          switch (num3)
          {
            case 0:
            case 3:
              goto label_4;
            case 1:
            case 5:
              goto label_14;
            case 2:
              goto label_17;
            case 4:
              goto label_2;
            case 6:
              if (!flag2)
                goto case 7;
              else
                goto label_16;
            case 7:
              flag1 = Math.Abs(item) <= Math.PI;
              int num4 = 8;
              num3 = ServiceObserverWatcher.RestartModel() ? num4 : num4;
              continue;
            case 8:
              goto label_5;
            case 9:
              goto label_21;
            default:
              goto label_20;
          }
        }
label_2:
        long num5;
        ++num5;
        num1 = 1;
        continue;
label_4:
        num5 = 0L;
        num1 = 7;
        continue;
label_5:
        if (!flag1)
        {
          if ((long) Math.Abs(item / Math.PI) < 2L)
          {
            item -= ServiceObserverWatcher.ExcludeAdvisor(item) * (2.0 * Math.PI);
            goto label_2;
          }
          else if ((double) (long) Math.Abs(item / (2.0 * Math.PI)) < (double) int.MaxValue)
          {
            item -= (double) (long) (item / (2.0 * Math.PI)) * (2.0 * Math.PI);
            goto label_2;
          }
          else if ((double) (long) Math.Abs(item / 13493037698.238832) < (double) int.MaxValue)
          {
            item -= (double) (long) (item / 13493037698.238832) * 13493037698.238832;
            goto label_2;
          }
          else if ((double) (long) Math.Abs(item / 2.8976077779357651E+19) >= (double) int.MaxValue)
          {
            item -= ServiceObserverWatcher.ExcludeAdvisor(item) * (2.0 * Math.PI);
            goto label_2;
          }
          else
          {
            num1 = 2;
            continue;
          }
        }
        else
          goto label_16;
label_14:
        flag2 = (double) num5 > 4.0;
        num1 = 6;
        continue;
label_16:
        num2 = item;
        num1 = 9;
        continue;
label_17:
        item -= (double) (long) (item / 2.8976077779357651E+19) * 2.8976077779357651E+19;
        goto label_2;
label_20:
        num1 = 4;
      }
label_21:
      return num2;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double CustomizeAdvisor(double info, double cont, double state)
    {
      double num = info * cont;
      return state / Math.Sqrt(1.0 - num * num);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double ComputeAdvisor(double key, double result)
    {
      int num1 = 5;
      double advisor;
      while (true)
      {
        int num2 = num1;
        bool flag;
        while (true)
        {
          switch (num2)
          {
            case 0:
            case 5:
              flag = key > 1E-07;
              if (true)
              {
                num2 = 2;
                continue;
              }
              goto label_10;
            case 1:
            case 2:
              if (flag)
              {
                if (true)
                {
                  num2 = 4;
                  continue;
                }
                goto label_5;
              }
              else
                goto label_2;
            case 3:
            case 6:
              goto label_10;
            case 4:
              goto label_5;
            default:
              if (true)
              {
                num2 = 3;
                continue;
              }
              goto label_10;
          }
        }
label_2:
        advisor = 2.0 * result;
        num1 = 6;
      }
label_5:
      double num3 = key * result;
      advisor = (1.0 - key * key) * (result / (1.0 - num3 * num3) - 0.5 / key * Math.Log((1.0 - num3) / (1.0 + num3)));
label_10:
      return advisor;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static void ConcatAdvisor(double var1, out double map, out double dic)
    {
      map = Math.Sin(var1);
      dic = Math.Cos(var1);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double CheckAdvisor(double key, double token, double consumer)
    {
      int num1 = 3;
      double num2;
      while (true)
      {
        int num3 = num1;
        double num4;
        while (true)
        {
          switch (num3)
          {
            case 0:
            case 2:
              goto label_1;
            case 1:
            case 4:
              goto label_2;
            case 3:
              num4 = key * consumer;
              num3 = 4;
              continue;
            case 5:
              goto label_7;
            default:
              goto label_5;
          }
        }
label_1:
        double y;
        num4 = Math.Pow((1.0 - num4) / (1.0 + num4), y);
        num2 = Math.Tan(0.5 * (Math.PI / 2.0 - token)) / num4;
        num1 = 5;
        continue;
label_2:
        y = 0.5 * key;
        goto label_1;
label_5:
        num1 = 0;
      }
label_7:
      return num2;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double QueryAdvisor(double v, double reg, out long filter)
    {
      int num1 = 5;
      double var1;
      while (true)
      {
        int num2 = num1;
        double num3;
        bool flag;
        double num4;
        while (true)
        {
          long num5;
          double map;
          double dic;
          double num6;
          double num7;
          switch (num2)
          {
            case 0:
            case 5:
              goto label_11;
            case 1:
            case 7:
              var1 = ServiceObserverWatcher.ReflectAdvisor(0.5 * reg);
              flag = v < 1E-10;
              if (!ServiceObserverWatcher.RestartModel())
              {
                num2 = 4;
                continue;
              }
              goto case 2;
            case 2:
              num5 = 1L;
              break;
            case 3:
label_17:
              num3 = 0.5 * num7 * num7 / dic * (reg / (1.0 - num4) - map / num7 + 0.5 / v * Math.Log((1.0 - num6) / (1.0 + num6)));
              if (ServiceObserverWatcher.ComputeModel())
              {
                num2 = 8;
                continue;
              }
              goto label_18;
            case 4:
              goto label_2;
            case 6:
              if (Math.Abs(num3) > 1E-07)
              {
                ++num5;
                break;
              }
              goto label_13;
            case 8:
              goto label_1;
            case 9:
              goto label_18;
            default:
              if (true)
              {
                num2 = 3;
                continue;
              }
              goto label_11;
          }
          if (num5 <= 25L)
          {
            ServiceObserverWatcher.ConcatAdvisor(var1, out map, out dic);
            num6 = v * map;
            num7 = 1.0 - num6 * num6;
            goto label_17;
          }
          else if (ServiceObserverWatcher.ComputeModel())
            num2 = 9;
          else
            goto label_17;
        }
label_1:
        var1 += num3;
        num1 = 6;
        continue;
label_2:
        if (!flag)
        {
          num4 = v * v;
          num1 = 2;
          continue;
        }
        break;
label_11:
        filter = 0L;
        num1 = 7;
      }
      return var1;
label_13:
      return var1;
label_18:
      throw new ArgumentException("Convergence error.");
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double ReflectAdvisor(double asset)
    {
      int num1 = 4;
      double num2;
      while (true)
      {
        int num3 = num1;
        bool flag;
        while (true)
        {
          switch (num3)
          {
            case 0:
            case 2:
label_5:
              asset = 1.0;
              goto case 3;
            case 1:
              if (flag)
              {
                if (asset <= 1.0)
                {
                  asset = -1.0;
                  goto case 3;
                }
                else
                  goto label_11;
              }
              else
                break;
            case 3:
            case 5:
              break;
            case 4:
              goto label_1;
            case 6:
              goto label_13;
            default:
              num3 = 5;
              continue;
          }
          num2 = Math.Asin(asset);
          if (true)
            num3 = 6;
          else
            goto label_5;
        }
label_1:
        flag = Math.Abs(asset) > 1.0;
        num1 = 1;
        continue;
label_11:
        num1 = 0;
      }
label_13:
      return num2;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double UpdateAdvisor(double last, double ivk, out long res)
    {
      int num1 = 1;
      if (true)
        goto label_3;
label_1:
      double num2;
      double num3 = last * num2;
      double y;
      double a;
      double num4 = Math.PI / 2.0 - 2.0 * Math.Atan(ivk * Math.Pow((1.0 - num3) / (1.0 + num3), y)) - a;
      a += num4;
      goto label_6;
label_2:
      int num5;
      num1 = num5;
label_3:
      while (true)
      {
        switch (num1)
        {
          case 0:
            goto label_1;
          case 1:
            goto label_14;
          case 2:
          case 5:
            goto label_16;
          case 3:
          case 4:
            goto label_6;
          case 6:
            goto label_12;
          case 7:
            goto label_5;
          case 8:
            goto label_15;
          default:
            if (true)
            {
              num1 = 3;
              continue;
            }
            goto label_5;
        }
      }
label_5:
      y = 0.5 * last;
      num5 = 6;
      goto label_2;
label_12:
      a = Math.PI / 2.0 - 2.0 * Math.Atan(ivk);
      long num6 = 0;
      goto label_10;
label_15:
      throw new ArgumentException("Convergence error - phi2z-conv");
label_16:
      double num7;
      return num7;
label_6:
      if (Math.Abs(num4) <= 1E-10)
      {
        num7 = a;
        num5 = 2;
        goto label_2;
      }
      else
        ++num6;
label_10:
      if (num6 > 15L)
      {
        num5 = 8;
        goto label_2;
      }
      else
      {
        num2 = Math.Sin(a);
        if (!ServiceObserverWatcher.RestartModel())
        {
          num1 = 0;
          goto label_3;
        }
      }
label_14:
      res = 0L;
      num5 = 7;
      goto label_2;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double DeleteAdvisor(double res) => 1.0 - 0.25 * res * (1.0 + res / 16.0 * (3.0 + 1.25 * res));

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double RemoveAdvisor(double var1) => 0.375 * var1 * (1.0 + 0.25 * var1 * (1.0 + 15.0 / 32.0 * var1));

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double DefineAdvisor(double last) => 15.0 / 256.0 * last * last * (1.0 + 0.75 * last);

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double RunAdvisor(double var1) => var1 * var1 * var1 * 0.011393229166666666;

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double ManageAdvisor(double last)
    {
      int num1 = 4;
      double num2;
      while (true)
      {
        int num3 = num1;
        double num4;
        double num5;
        while (true)
        {
          switch (num3)
          {
            case 0:
            case 4:
              goto label_5;
            case 1:
            case 2:
              num2 = Math.Sqrt(Math.Pow(num5, num5) * Math.Pow(num4, num4));
              if (true)
              {
                num3 = 5;
                continue;
              }
              goto label_7;
            case 3:
              num4 = 1.0 - last;
              goto case 1;
            case 5:
              goto label_7;
            default:
              if (true)
              {
                num3 = 1;
                continue;
              }
              goto label_5;
          }
        }
label_5:
        num5 = 1.0 + last;
        num1 = 3;
      }
label_7:
      return num2;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double NewAdvisor(
      double var1,
      double ord,
      double state,
      double map2,
      double key3)
    {
      return var1 * key3 - ord * Math.Sin(2.0 * key3) + state * Math.Sin(4.0 * key3) - map2 * Math.Sin(6.0 * key3);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static long DestroyAdvisor(double var1) => (long) ((var1 + 180.0) / 6.0 + 1.0);

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double ResolveAdvisor(double setup, bool writereg)
    {
      int num1 = 2;
      if (ServiceObserverWatcher.ComputeModel())
        goto label_5;
label_1:
      int num2 = setup <= 180.0 ? 1 : 0;
label_3:
      if (num2 == 0)
        throw new ArgumentOutOfRangeException("x", setup.ToString((IFormatProvider) CultureInfo.InvariantCulture) + " not a valid longitude in degrees.");
      goto label_13;
label_5:
      while (true)
      {
        int num3;
        switch (num1)
        {
          case 0:
          case 2:
            if (!writereg)
            {
              num3 = 5;
              break;
            }
            if (setup >= -180.0)
            {
              if (ServiceObserverWatcher.ComputeModel())
              {
                num1 = 4;
                continue;
              }
              goto label_13;
            }
            else
              goto label_2;
          case 1:
          case 5:
            goto label_9;
          case 3:
            goto label_13;
          case 4:
            goto label_1;
          case 6:
            goto label_16;
          default:
            num3 = 3;
            break;
        }
        num1 = num3;
      }
label_2:
      num2 = 0;
      goto label_3;
label_9:
      num2 = setup <= -180.0 ? 0 : (setup < 180.0 ? 1 : 0);
      goto label_3;
label_13:
      double num4 = ValueObserverWatcher.PopAdvisor(setup);
      if (true)
      {
        num1 = 6;
        goto label_5;
      }
label_16:
      return num4;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected static double ResetAdvisor(double info, bool compareselection)
    {
      int num1 = 5;
      if (!ServiceObserverWatcher.RestartModel())
        goto label_7;
label_1:
      int num2;
      int num3;
      if (!compareselection)
        num2 = 0;
      else if (info < -90.0)
      {
        num3 = 0;
        goto label_13;
      }
      else
        goto label_11;
label_6:
      num1 = num2;
label_7:
      while (true)
      {
        switch (num1)
        {
          case 0:
          case 1:
            if (info > -90.0)
            {
              num1 = 4;
              continue;
            }
            goto label_4;
          case 2:
          case 4:
            goto label_3;
          case 3:
            goto label_11;
          case 5:
            goto label_1;
          case 6:
            goto label_16;
          default:
            goto label_8;
        }
      }
label_3:
      num3 = info < 90.0 ? 1 : 0;
      goto label_13;
label_4:
      num3 = 0;
      goto label_13;
label_8:
      num2 = 3;
      goto label_6;
label_16:
      double num4;
      return num4;
label_11:
      num3 = info <= 90.0 ? 1 : 0;
label_13:
      if (num3 == 0)
        throw new ArgumentOutOfRangeException("y", info.ToString((IFormatProvider) CultureInfo.InvariantCulture) + " not a valid latitude in degrees.");
      num4 = ValueObserverWatcher.PopAdvisor(info);
      int num5 = 6;
      num1 = ServiceObserverWatcher.RestartModel() ? num5 : num5;
      goto label_7;
    }

    internal static bool ComputeModel() => true;

    internal static bool RestartModel() => false;
  }
}
