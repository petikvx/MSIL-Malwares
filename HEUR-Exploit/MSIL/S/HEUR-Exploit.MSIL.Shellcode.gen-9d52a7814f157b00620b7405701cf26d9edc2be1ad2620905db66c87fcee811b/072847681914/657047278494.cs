// Decompiled with JetBrains decompiler
// Type: 072847681914.657047278494
// Assembly: 341658236064, Version=3.1.2.23007, Culture=neutral, PublicKeyToken=31bf3856ad364e35
// MVID: 307D4BC7-4605-49A1-A696-CC8CC5C1D6BD
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Exploit.MSIL.Shellcode.gen-9d52a7814f157b00620b7405701cf26d9edc2be1ad2620905db66c87fcee811b.exe

using \u003072847681914;
using \u003341658236064.Properties;
using \u003785552231676;
using \u003802842917103;
using \u003896890811494;
using \u003942160936230;
using Microsoft.Build.Framework;
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;

namespace \u003072847681914
{
  public class \u003657047278494 : \u003281886728672
  {
    private const string \u003519188888924 = "netstandard";
    private const string \u003425194392519 = "System.Runtime";
    private static readonly Version \u003408767036071 = new Version(4, 1, 0, 0);
    private static readonly Guid \u003108791227033 = new Guid("7DAC8207-D3AE-4c75-9B67-92801A497D44");

    [Required]
    public ITaskItem[] \u003526077586298 { get; set; }

    [Output]
    public bool \u003179344125007 { get; set; }

    protected override void ExecuteCore() => this.\u003179344125007 = this.\u003694680044339();

    private bool \u003694680044339()
    {
      foreach (ITaskItem taskItem in this.\u003526077586298)
      {
        string path = \u003621632334933.\u003701855565446(taskItem);
        if (path != null)
        {
          if (File.Exists(path))
          {
            try
            {
              if (\u003657047278494.\u003135081556616(path))
                return true;
            }
            catch (Exception ex) when (\u003657047278494.\u003750083371807(ex))
            {
              this.\u003868242702593.\u003588109117808(\u003064471764011.\u003538786200227, ex.Message, path);
            }
          }
        }
      }
      return false;
    }

    private static bool \u003750083371807(Exception _param0) => _param0 is BadImageFormatException || _param0 is UnauthorizedAccessException || _param0 is NotSupportedException || _param0 is ArgumentException && !(_param0 is ArgumentNullException) || _param0 is SecurityException || _param0 is IOException;

    internal static bool \u003135081556616(string _param0)
    {
      if (Environment.OSVersion.Platform == PlatformID.Unix || Environment.OSVersion.Platform == PlatformID.MacOSX)
      {
        foreach (AssemblyName referencedAssembly in Assembly.ReflectionOnlyLoadFrom(_param0).GetReferencedAssemblies())
        {
          if (referencedAssembly.Name.Equals("netstandard", StringComparison.Ordinal))
            return true;
        }
      }
      else
      {
        string fullPath = Path.GetFullPath(_param0);
        // ISSUE: object of a compiler-generated type is created
        \u003657047278494.IMetaDataDispenser o1 = (\u003657047278494.IMetaDataDispenser) new \u003648679946565();
        \u003657047278494.IMetaDataDispenser metaDataDispenser = o1;
        string szScope = fullPath;
        Guid guid = \u003657047278494.\u003108791227033;
        ref Guid local = ref guid;
        \u003657047278494.IMetaDataAssemblyImport o2 = (\u003657047278494.IMetaDataAssemblyImport) metaDataDispenser.OpenScope(szScope, 0U, ref local);
        IntPtr zero = IntPtr.Zero;
        uint[] asmRefs = new uint[16];
        \u003657047278494.\u003398370684475 amdInfo = new \u003657047278494.\u003398370684475()
        {
          \u003456239642942 = IntPtr.Zero,
          \u003277158960667 = 0,
          \u003375615879501 = IntPtr.Zero,
          \u003144989035763 = 0,
          \u003800203896603 = IntPtr.Zero,
          \u003301186203765 = 0
        };
        try
        {
          uint iFetched;
          do
          {
            o2.EnumAssemblyRefs(ref zero, asmRefs, (uint) asmRefs.Length, out iFetched);
            for (uint index = 0; index < iFetched; ++index)
            {
              IntPtr ppbPublicKeyOrToken;
              uint pcbPublicKeyOrToken;
              uint pchNameOut;
              IntPtr ppbHashValue;
              uint pcbHashValue;
              uint pdwAssemblyRefFlags;
              o2.GetAssemblyRefProps(asmRefs[(int) index], out ppbPublicKeyOrToken, out pcbPublicKeyOrToken, (StringBuilder) null, 0U, out pchNameOut, ref amdInfo, out ppbHashValue, out pcbHashValue, out pdwAssemblyRefFlags);
              StringBuilder strName = new StringBuilder((int) pchNameOut + 1);
              o2.GetAssemblyRefProps(asmRefs[(int) index], out ppbPublicKeyOrToken, out pcbPublicKeyOrToken, strName, (uint) strName.Capacity, out pchNameOut, ref amdInfo, out ppbHashValue, out pcbHashValue, out pdwAssemblyRefFlags);
              string str = strName.ToString();
              // ISSUE: reference to a compiler-generated field
              if (str.Equals("netstandard", StringComparison.Ordinal) || str.Equals("System.Runtime", StringComparison.Ordinal) && new Version((int) amdInfo.\u003041339079569, (int) amdInfo.\u003743671294512, (int) amdInfo.\u003839393842926, (int) amdInfo.\u003746320739957) >= \u003657047278494.\u003408767036071)
                return true;
            }
          }
          while (iFetched > 0U);
        }
        finally
        {
          if (zero != IntPtr.Zero)
            o2.CloseEnum(zero);
          if (o2 != null)
            Marshal.ReleaseComObject((object) o2);
          if (o1 != null)
            Marshal.ReleaseComObject((object) o1);
        }
      }
      return false;
    }

    public \u003657047278494()
      : base()
    {
    }

    [TypeLibType(TypeLibTypeFlags.FCanCreate)]
    [Guid("E5CB7A31-7512-11d2-89CE-0080C792E5D8")]
    [ClassInterface(ClassInterfaceType.None)]
    [ComImport]
    internal class \u003539901401221
    {
      [return: MarshalAs(UnmanagedType.Interface)]
      public abstract object DefineScope([In] ref Guid rclsid, [In] uint dwCreateFlags, [In] ref Guid riid);
    }

    [Guid("809c652e-7396-11d2-9771-00a0c9b4d50c")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    [TypeLibType(TypeLibTypeFlags.FRestricted)]
    [ComImport]
    internal interface IMetaDataDispenser
    {
      [return: MarshalAs(UnmanagedType.Interface)]
      object OpenScope([MarshalAs(UnmanagedType.LPWStr), In] string szScope, [In] uint dwOpenFlags, [In] ref Guid riid);

      [return: MarshalAs(UnmanagedType.Interface)]
      object OpenScopeOnMemory([In] IntPtr pData, [In] uint cbData, [In] uint dwOpenFlags, [In] ref Guid riid);

      void GetAssemblyProps(
        uint mdAsm,
        out IntPtr pPublicKeyPtr,
        out uint ucbPublicKeyPtr,
        out uint uHashAlg,
        StringBuilder strName,
        uint cchNameIn,
        out uint cchNameRequired,
        IntPtr amdInfo,
        out uint dwFlags);
    }

    [Guid("EE62470B-E94B-424e-9B7C-2F00C9249F93")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    internal interface IMetaDataAssemblyImport
    {
      void GetAssemblyRefProps(
        uint mdAsmRef,
        out IntPtr ppbPublicKeyOrToken,
        out uint pcbPublicKeyOrToken,
        StringBuilder strName,
        uint cchNameIn,
        out uint pchNameOut,
        ref \u003657047278494.\u003398370684475 amdInfo,
        out IntPtr ppbHashValue,
        out uint pcbHashValue,
        out uint pdwAssemblyRefFlags);

      void GetFileProps(
        [In] uint mdFile,
        StringBuilder strName,
        uint cchName,
        out uint cchNameRequired,
        out IntPtr bHashData,
        out uint cchHashBytes,
        out uint dwFileFlags);

      void GetExportedTypeProps();

      void GetManifestResourceProps();

      void EnumAssemblyRefs(
        [In, Out] ref IntPtr phEnum,
        [MarshalAs(UnmanagedType.LPArray), Out] uint[] asmRefs,
        uint asmRefCount,
        out uint iFetched);

      void EnumFiles([In, Out] ref IntPtr phEnum, [MarshalAs(UnmanagedType.LPArray), Out] uint[] fileRefs, uint fileRefCount, out uint iFetched);

      void EnumExportedTypes();

      void EnumManifestResources();

      void GetAssemblyFromScope(out uint mdAsm);

      void FindExportedTypeByName();

      void FindManifestResourceByName();

      [MethodImpl(MethodImplOptions.PreserveSig)]
      void CloseEnum([In] IntPtr phEnum);

      void FindAssembliesByName();

      [DebuggerHidden]
      IMetaDataAssemblyImport(int _param1)
      {
        ((\u003657047278494.\u003398370684475) this).\u003624938142797 = _param1;
        // ISSUE: reference to a compiler-generated field
        ((\u003889142146773.\u003412956158922) this).\u003761930847507 = Environment.CurrentManagedThreadId;
      }
    }

    internal struct \u003398370684475
    {
      public ushort \u003743671294512;
      public ushort \u003839393842926;
      public ushort \u003746320739957;
      public IntPtr \u003456239642942;
      public uint \u003277158960667;
      public IntPtr \u003375615879501;
      public uint \u003144989035763;
      public IntPtr \u003800203896603;
      public uint \u003301186203765;
      private int \u003624938142797;
    }
  }
}
