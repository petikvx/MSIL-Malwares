// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: nkricnalAl, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8F238D28-5A10-4BC1-8318-2ABF5F2B8ACE
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Exploit.MSIL.Certutil.gen-800f0b3cb78a8f0934c09d710a8e42286275cbaa10dbdb1841669f6280f0ab51.exe

using System;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading;

internal class \u003CModule\u003E
{
  [Generation(779919613)]
  internal static TaiwanCalendar ë\u0012\u000Fi\u00BB;
  [get_IsCancellationRequested(-2070263416)]
  internal static TaiwanCalendar n\u00AE\u00A5Uí;
  [Get_IsCompressed(1768919339)]
  internal static set_NumberDecimalDigits óÇE\u0026B;
  [ArgIterator(879102686)]
  internal static S_Base32Char \u0085Kwâ\u000E;
  [Get_PointerToSymbolTable(464977374)]
  internal static Set_AppDomainManagerType \u00B6\u002A\u001E\u0084\u0040;
  [get_IsCancellationRequested(-1003546452)]
  internal static Marshal \u001EÁC\u0014\u0027;
  [SimplifyBranches(-914245689)]
  internal static PointerToSymbolTable ç\u0025\u000BT2;
  [EndsUncondJmpBlk(-1494668322)]
  internal static S_Base32Char ýdØwÕ;
  [Generation(-1958317151)]
  internal static GetScopeFromOffset \u0034lÜ\u0084\u0011;
  [EndsUncondJmpBlk(483882118)]
  internal static S_Base32Char Ýß\u0021\u0095\u000A;
  [Get_PointerToSymbolTable(131905808)]
  internal static GetScopeFromOffset \u000A\u002A\u00ADI\u00A6;
  [get_IsCancellationRequested(-1056284382)]
  internal static PointerToSymbolTable \u009D\u008AæÓB;
  [Get_PointerToSymbolTable(848860632)]
  internal static CompletedEvent \u0015H\u007B5Ã;
  [Target(55212189)]
  internal static CheckSumOffset \u0036\u007Bm\u00B3\u003C;
  [StartOfUserTypes(-35622848)]
  internal static Get_RawData ô\u0027\u00AD\u002Að;
  [StartOfUserTypes(-141334828)]
  internal static CompletedEvent \u0081\u0085\u0006\u0093`;
  [ReadEventMapRow(1604735695)]
  internal static CheckSumOffset \u0094`7g\u000D;
  [Get_IsAsync(1069727717)]
  internal static CSIDL_PERSONAL \u001DeEFÔ;
  [Set_IsPreserveSig(322881908)]
  internal static Get_RawData \u002D\u00A8ò\u0001\u0009;
  [LocalDateTime(-214364810)]
  internal static EnsureDestinationSize \u00F7\u0020\u0085\u0021\u00B1;
  [ReadEventMapRow(-1176633031)]
  internal static NotInitialized RzU\u00B8ç;
  [Get_IsAsync(-1719844573)]
  internal static NotInitialized \u001Ewc\u00B8\u0008;
  [Get_IsCompressed(-40226111)]
  internal static PointerToSymbolTable \u008C\u0095\u0080\u0095\u0001;
  [M_OptionalPset(918434903)]
  internal static CSIDL_PERSONAL \u00AFóß\u0014\u001D;
  [S_MANSLOT(581955010)]
  internal static \u003C\u003E9__191_0 \u0018ÅÏê\u00B8;
  [M_OptionalPset(-386160067)]
  internal static PointerToSymbolTable \u00845\u0018þ\u0013;
  [LocalDateTime(-273537810)]
  internal static PointerToSymbolTable Æ\u0011\u003D\u002A2;
  [get_IsCancellationRequested(-871228186)]
  internal static CSIDL_PERSONAL i\u0094\u0024\u00A9Ï;
  [Target(171498477)]
  internal static \u003C\u003E9__191_0 ÿ\u002EË\u0098\u0027;
  [LocalDateTime(-636661876)]
  internal static ReUseDeletedParamRows xÞ2\u000AÕ;
  [EndsUncondJmpBlk(-267707280)]
  internal static PointerToSymbolTable \u0010Ï\u0007\u00B7â;
  [Get_IsCompressed(-989581523)]
  internal static CRYPT_USER_KEYSET bÉgWÒ;
  [ReadEventMapRow(-1946887323)]
  internal static GetMethods \u0099\u00B4\u003D\u00A5\u0018;
  [LocalDateTime(-1876160086)]
  internal static PointerToSymbolTable \u0004iZÃr;
  [Set_IsPreserveSig(-1977799686)]
  internal static Invalid \u0018hç\u0093Q;
  [Target(988817125)]
  internal static PointerToSymbolTable Ä\u0091uI\u00A8;
  [Get_PointerToSymbolTable(662232798)]
  internal static EnsureDestinationSize \u0013Ó\u00B3\u0095z;
  [get_IsCancellationRequested(373833800)]
  internal static CSIDL_PERSONAL \u0031\u0023\u0098ÖÂ;
  [ReadEventMapRow(-1146292777)]
  internal static GetMethods \u00AE\u00B7Õ\u00ACq;
  [Target(1590315031)]
  internal static CRYPT_USER_KEYSET \u001A\u00A2\u0081D\u0014;
  [get_IsCancellationRequested(70369996)]
  internal static CRYPT_USER_KEYSET é\u0016\u0006\u00A7\u0028;
  [get_IsCancellationRequested(1837987084)]
  internal static CSIDL_PERSONAL \u00BCßº5\u0026;
  [M_OptionalPset(-1149919383)]
  internal static CreationOptionsForReplicas \u0006\u002CVt\u0006;
  [SimplifyBranches(-1903082803)]
  internal static SecurityPermissionFlag \u008B4\u0028r\u0003;
  [ExpandPredefinedFormat(-593273632)]
  internal static CSIDL_PERSONAL \u007Fª\u009A\u0001\u0004;
  [ReadEventMapRow(-2141269739)]
  internal static Set_AssemblyOSTable Ó\u0013\u00A1\u00190;
  [Target(2127406375)]
  internal static CSIDL_PERSONAL ÊOçÓ\u003B;
  [StartOfUserTypes(881554178)]
  internal static AddGenericParams n\u007B\u0096µ\u0081;
  [Get_IsCompressed(308302855)]
  internal static RawData \u008DÈ8Å\u0015;
  [Target(-170654381)]
  internal static M_tailIndex ÐQg\u00B4\u005B;
  [M_OptionalPset(1002948117)]
  internal static HotHeapStreamCLR40 ZÄ5V\u008D;
  [M_OptionalPset(-1404356951)]
  internal static HebrewNumberParsingContext S\u00B3êI\u0082;
  [Set_IsPreserveSig(692832390)]
  internal static set_AssemblyPublicKey ÌÄúX\u00AF;
  [ExpandPredefinedFormat(-23859838)]
  internal static ApplyEditAndContinue w\u0087t\u00F7î;
  [ExpandPredefinedFormat(-1831171620)]
  internal static HKEY_CURRENT_USER À\u000AáIó;
  [StartOfUserTypes(1052424026)]
  internal static CRYPT_USER_KEYSET \u002Es\u00A5F\u0083;
  [Set_IsPreserveSig(1777963072)]
  internal static IgnoreNonSpace äæÉJÊ;
  [Set_IsPreserveSig(111653534)]
  internal static CheckSumOffset GA\u00B0\u00A28;
  [ArgIterator(885364354)]
  internal static CheckSumOffset \u0082I_\u0021\u00A7;
  [S_MANSLOT(-1393020350)]
  internal static CheckSumOffset ÞìaÂY;
  [EndsUncondJmpBlk(-1214223512)]
  internal static MarshalBlobWriter ã\u003A\u00AD\u0097\u008A;
  [SimplifyBranches(1540269045)]
  internal static CRYPT_USER_KEYSET \u00AC\u001CòX\u009B;
  [Get_IsCompressed(1734384591)]
  internal static Vt s\u000F\u001CS3;
  [Set_IsPreserveSig(-448422820)]
  internal static EnsureDestinationSize \u00AB\u00A4l\u0089\u0012;
  [ReadEventMapRow(-403357715)]
  internal static ManagedMask \u009A\u005B\u003C\u00D7u;
  [Set_IsPreserveSig(-1453781620)]
  internal static _i \u0097\u00287\u007BÊ;
  [M_OptionalPset(-654556329)]
  internal static SetErrorMode \u0014\u00AF5\u0086F;
  [Get_PointerToSymbolTable(-469402424)]
  internal static CustomAttributeCollection \u00F7\u005Bû\u002FÁ;
  [ArgIterator(-453969980)]
  internal static Set_IsNoMangle \u0087ÔQÞ\u00A7;
  [Get_IsCompressed(-181739171)]
  internal static S_Base32Char \u0033\u00BB\u00A5ój;
  [Target(-2037776219)]
  internal static GetScopeFromOffset \u00A59Ì\u0006Ç;
  [Get_IsCompressed(635394899)]
  internal static ManagedMask Ò\u00B9\u000B\u00AF\u002C;
  [LocalDateTime(2095146200)]
  internal static GetMethodFromHandle ÿÂ\u0014ÚÑ;
  [S_MANSLOT(1010661396)]
  internal static LoadAllTables M\u00AE\u003F\u0012\u00BF;
  [Set_IsPreserveSig(2648412)]
  internal static S_Base32Char î\u00A2Ô\u000BÞ;
  [ExpandPredefinedFormat(-1606971750)]
  internal static CreateClassOrValueType ý\u0010O\u00A4\u0017;
  [M_OptionalPset(-1266009853)]
  internal static Status \u00A5\u0086\u001DwË;
  [StartOfUserTypes(1141052526)]
  internal static Get_PreserveUSOffsets ØwgË\u0090;
  [Get_IsAsync(-1069413999)]
  internal static Vt \u0025\u009Ct\u007B\u0006;
  [SimplifyBranches(-494505461)]
  internal static PointerToSymbolTable r\u003BW\u0023í;
  [M_OptionalPset(-881043091)]
  internal static Get_AssemblyFlags Så\u0085\u009D\u00B6;
  [Target(-779780551)]
  internal static CheckSumOffset \u00BB\u001A\u000B\u005Bp;
  [LocalDateTime(-2091984568)]
  internal static CheckSumOffset \u000C\u001D7\u0027ß;
  [ReadEventMapRow(215640399)]
  internal static CheckSumOffset ÌÐ\u00A1Év;
  [Get_IsAsync(1314669705)]
  internal static CSIDL_PERSONAL \u00A2\u000E\u0027XM;
  [M_OptionalPset(1908243707)]
  internal static Get_RawData \u0084vÞ\u00B0\u00B7;
  [get_IsCancellationRequested(-1904055230)]
  internal static Invalid J\u0020\u00A8ýE;
  [ArgIterator(-1081646322)]
  internal static CSIDL_PERSONAL \u00B2\u000BÇ\u005C\u00A6;
  [ArgIterator(-626196896)]
  internal static MaxValueDiv10 Á\u0040\u0086_1;
  [EndsUncondJmpBlk(2082842622)]
  internal static TypeCode \u002Fae\u00B2Ó;
  [Get_PointerToSymbolTable(-1867532586)]
  internal static ResolveConstant SÓ\u009F\u0015Ã;
  [ArgIterator(936698902)]
  internal static ModuleWriterBase k\u0023\u00A2\u0012ë;
  [ArgIterator(-1451479654)]
  internal static CSIDL_PERSONAL \u00AEÜT\u0014\u008D;
  [get_IsCancellationRequested(-1777457026)]
  internal static CSIDL_PERSONAL \u002Fj\u009B\u0017\u00A8;
  [ReadEventMapRow(2124129301)]
  internal static _K ÿ\u00B3\u000E`\u0004;
  [Generation(-274934067)]
  internal static Popi_popi_popi \u0081\u00226ò\u0082;
  [Generation(-2025975385)]
  internal static UseSatelliteAssem \u0018\u00B7ñªº;
  [StartOfUserTypes(1577171450)]
  internal static CRYPT_USER_KEYSET ÜÂÍ\u00B28;
  [get_IsCancellationRequested(-2035630430)]
  internal static USER32 ôX\u00B8i\u0007;
  [Get_IsCompressed(-1478910593)]
  internal static TmDefaultChar \u0095ã\u008EDn;
  [ArgIterator(-556076914)]
  internal static CRYPT_USER_KEYSET \u008C\u00BF\u00A8þè;
  [get_IsCancellationRequested(1163877548)]
  internal static AddGenericParams S\u00BCôüa;
  [StartOfUserTypes(-529084782)]
  internal static CompletedEvent \u006023\u005D\u001A;
  [Get_PointerToSymbolTable(1854359766)]
  internal static ApplyEditAndContinue îO3\u0023\u0006;
  [Get_PointerToSymbolTable(-1416249734)]
  internal static AnsiCurrencySymbol \u008B7MU\u009A;
  [M_OptionalPset(1114290549)]
  internal static CSIDL_PERSONAL n\u003Aïv\u00B9;
  [get_IsCancellationRequested(1910608720)]
  internal static Get_AssemblyFlags \u00A9\u0007f\u0012l;
  [M_OptionalPset(-517278831)]
  internal static KindShift \u008B\u007D\u008D\u00B1B;
  [M_OptionalPset(-1428901773)]
  internal static HKEY_CURRENT_USER I\u0011êü\u0040;
  [SimplifyBranches(-46540709)]
  internal static SaMonthGenitiveNames ñ\u00A6\u002E\u00BCÍ;
  [ExpandPredefinedFormat(1996380946)]
  internal static TaiwanCalendar \u0010\u00A5í\u00A3\u00B1;
  [ReadEventMapRow(-1081564343)]
  internal static HKEY_CURRENT_USER nD4o\u0091;
  [Get_PointerToSymbolTable(1799948436)]
  internal static FieldGetter ó\u00B2\u003Dj\u00A1;
  [S_MANSLOT(-530202244)]
  internal static CompletedEvent \u0083\u0095\u0019X\u00B7;
  [ReadEventMapRow(-97897473)]
  internal static RelocsStripped y\u002E\u00B2\u0082î;
  [LocalDateTime(1354144110)]
  internal static CurrentValueName Ø\u0080Ô\u0097e;
  [StartOfUserTypes(1194633810)]
  internal static m_filterAddr ÄènÍ\u00A1;
  [S_MANSLOT(-1579682894)]
  internal static CompletedEvent \u008A\u0091Gõ\u007E;
  [get_IsCancellationRequested(-1724634502)]
  internal static HKEY_CURRENT_USER \u0016æåÊØ;
  [Get_IsCompressed(-1215717483)]
  internal static SetCheckSum d\u0003äÝ\u0006;
  [Target(-208808777)]
  internal static CustomAttributeCollection òæ\u003F\u0096\u0008;
  [Get_IsCompressed(-1941697517)]
  internal static TypeUInt32 Þ\u0099ï\u008F\u003C;
  [ArgIterator(-2138257096)]
  internal static Get_s_internalSyncObject ÚvÿgX;
  [Set_IsPreserveSig(-111278094)]
  internal static Get_MemberInfo Ø\u0091\u003CÙ\u00A1;
  [Target(1449515619)]
  internal static CSIDL_PERSONAL \u008F\u007BÓµ3;
  [SimplifyBranches(1795669841)]
  internal static TypeDefId Ù\u0008\u0095Ö\u007C;
  [Set_IsPreserveSig(2110704748)]
  internal static GetMethods \u0031\u002D\u0025þ1;
  [StartOfUserTypes(-1028612992)]
  internal static MethodOverrideTokens \u00B1\u0026\u0083\u00B9E;
  [ReadEventMapRow(55363979)]
  internal static Set_NestedClassTable \u0001\u0022tÎy;
  [Get_PointerToSymbolTable(-1863930932)]
  internal static IsForwarder ëàç\u001D\u0024;
  [S_MANSLOT(-361372536)]
  internal static M_Group \u0021\u009Dæm\u00BB;
  [Get_IsCompressed(-581489159)]
  internal static Get_AssemblyFlags \u0022õ\u0094\u0087\u00B0;
  [StartOfUserTypes(-631720702)]
  internal static CompletedEvent \u007E\u0082\u00A4É\u003D;
  [ArgIterator(1038316736)]
  internal static CompletedEvent w\u0085Ûwc;
  [Generation(-1307689133)]
  internal static CompletedEvent \u005E\u0024ÁYR;
  [Set_IsPreserveSig(657437358)]
  internal static HKEY_CURRENT_USER \u0001\u003D\u000Bø\u0029;
  [SimplifyBranches(-1566853549)]
  internal static AddGenericParams ÀD\u0016\u00AE\u0025;
  [Get_IsCompressed(467331517)]
  internal static AddGenericParams \u002F\u0040ÉÚõ;
  [ReadEventMapRow(-561169581)]
  internal static Major \u0038z\u0010ÆI;
  [M_OptionalPset(-1587866923)]
  internal static Invalid \u001EÜ\u00A5\u00A4Ó;
  [S_MANSLOT(-2067561220)]
  internal static M_algId w\u000DáZ\u005D;
  [StartOfUserTypes(-1388595138)]
  internal static Permission \u00BBj\u008A\u00228;
  [StartOfUserTypes(-1499231128)]
  internal static CRYPT_USER_KEYSET ãê\u00D7\u0021\u00B7;
  [Set_IsPreserveSig(1227339286)]
  internal static CompletedEvent á\u0016\u009F\u000E\u008B;
  [M_OptionalPset(-737824127)]
  internal static CSIDL_PERSONAL \u0085\u008A\u009CMl;
  [Get_IsCompressed(-686442533)]
  internal static HKEY_CURRENT_USER Ä\u0020\u0097h\u001F;
  [StartOfUserTypes(-142095664)]
  internal static MDWriteMethodBodies5 \u00A1\u003EbjD;

  static \u003CModule\u003E()
  {
    // ISSUE: field reference
    \u003CModule\u003E.S_ActionToActionObjShunt(__fieldref (\u003CModule\u003E.\u00A1\u003EbjD), (byte) 81);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Source(__fieldref (\u003CModule\u003E.Ä\u0020\u0097h\u001F), (byte) 79);
    // ISSUE: field reference
    \u003CModule\u003E.ITokenCreator(__fieldref (\u003CModule\u003E.\u0085\u008A\u009CMl), (byte) 62);
    // ISSUE: field reference
    \u003CModule\u003E.BaseOfCode(__fieldref (\u003CModule\u003E.á\u0016\u009F\u000E\u008B), (byte) 121);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.ãê\u00D7\u0021\u00B7), (byte) 216);
    // ISSUE: field reference
    \u003CModule\u003E.IsNotPublic(__fieldref (\u003CModule\u003E.\u00BBj\u008A\u00228), (byte) 147);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.w\u000DáZ\u005D), (byte) 37);
    // ISSUE: field reference
    \u003CModule\u003E.GetTokenInformation(__fieldref (\u003CModule\u003E.\u001EÜ\u00A5\u00A4Ó), (byte) 113);
    // ISSUE: field reference
    \u003CModule\u003E.ExclusiveReference(__fieldref (\u003CModule\u003E.\u0038z\u0010ÆI), (byte) 127);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.\u002F\u0040ÉÚõ), (byte) 47);
    // ISSUE: field reference
    \u003CModule\u003E.LOCALE_SABBREVMONTHNAME4(__fieldref (\u003CModule\u003E.ÀD\u0016\u00AE\u0025), (byte) 74);
    // ISSUE: field reference
    \u003CModule\u003E.IsNotPublic(__fieldref (\u003CModule\u003E.\u0001\u003D\u000Bø\u0029), (byte) 110);
    // ISSUE: field reference
    \u003CModule\u003E.TransformBlock(__fieldref (\u003CModule\u003E.\u005E\u0024ÁYR), (byte) 174);
    // ISSUE: field reference
    \u003CModule\u003E.IsOut(__fieldref (\u003CModule\u003E.w\u0085Ûwc), (byte) 12);
    // ISSUE: field reference
    \u003CModule\u003E.Assertion(__fieldref (\u003CModule\u003E.\u007E\u0082\u00A4É\u003D), (byte) 225);
    // ISSUE: field reference
    \u003CModule\u003E.BaseOfCode(__fieldref (\u003CModule\u003E.\u0022õ\u0094\u0087\u00B0), (byte) 134);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Source(__fieldref (\u003CModule\u003E.\u0021\u009Dæm\u00BB), (byte) 181);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Source(__fieldref (\u003CModule\u003E.ëàç\u001D\u0024), (byte) 200);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.\u0001\u0022tÎy), (byte) 81);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.\u00B1\u0026\u0083\u00B9E), (byte) 14);
    // ISSUE: field reference
    \u003CModule\u003E.ExclusiveReference(__fieldref (\u003CModule\u003E.\u0031\u002D\u0025þ1), (byte) 13);
    // ISSUE: field reference
    \u003CModule\u003E.Assertion(__fieldref (\u003CModule\u003E.Ù\u0008\u0095Ö\u007C), (byte) 254);
    // ISSUE: field reference
    \u003CModule\u003E.S_ActionToActionObjShunt(__fieldref (\u003CModule\u003E.\u008F\u007BÓµ3), (byte) 8);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Source(__fieldref (\u003CModule\u003E.Ø\u0091\u003CÙ\u00A1), (byte) 185);
    // ISSUE: field reference
    \u003CModule\u003E.LOCALE_SABBREVMONTHNAME4(__fieldref (\u003CModule\u003E.ÚvÿgX), (byte) 112);
    // ISSUE: field reference
    \u003CModule\u003E.GetTokenInformation(__fieldref (\u003CModule\u003E.Þ\u0099ï\u008F\u003C), (byte) 246);
    // ISSUE: field reference
    \u003CModule\u003E.TransformBlock(__fieldref (\u003CModule\u003E.òæ\u003F\u0096\u0008), (byte) 23);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Company(__fieldref (\u003CModule\u003E.d\u0003äÝ\u0006), (byte) 43);
    // ISSUE: field reference
    \u003CModule\u003E.BaseOfCode(__fieldref (\u003CModule\u003E.\u0016æåÊØ), (byte) 137);
    // ISSUE: field reference
    \u003CModule\u003E.ExclusiveReference(__fieldref (\u003CModule\u003E.\u008A\u0091Gõ\u007E), (byte) 40);
    // ISSUE: field reference
    \u003CModule\u003E.ExclusiveReference(__fieldref (\u003CModule\u003E.ÄènÍ\u00A1), (byte) 1);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.Ø\u0080Ô\u0097e), (byte) 10);
    // ISSUE: field reference
    \u003CModule\u003E.ExclusiveReference(__fieldref (\u003CModule\u003E.y\u002E\u00B2\u0082î), (byte) 221);
    // ISSUE: field reference
    \u003CModule\u003E.IsOut(__fieldref (\u003CModule\u003E.\u0083\u0095\u0019X\u00B7), (byte) 216);
    // ISSUE: field reference
    \u003CModule\u003E.BaseOfCode(__fieldref (\u003CModule\u003E.ó\u00B2\u003Dj\u00A1), (byte) 221);
    // ISSUE: field reference
    \u003CModule\u003E.GetMessageForHR(__fieldref (\u003CModule\u003E.nD4o\u0091), (byte) 28);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Company(__fieldref (\u003CModule\u003E.\u0010\u00A5í\u00A3\u00B1), (byte) 141);
    // ISSUE: field reference
    \u003CModule\u003E.ExclusiveReference(__fieldref (\u003CModule\u003E.ñ\u00A6\u002E\u00BCÍ), (byte) 65);
    // ISSUE: field reference
    \u003CModule\u003E.GetTokenInformation(__fieldref (\u003CModule\u003E.I\u0011êü\u0040), (byte) 38);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.\u008B\u007D\u008D\u00B1B), (byte) 18);
    // ISSUE: field reference
    \u003CModule\u003E.ITokenCreator(__fieldref (\u003CModule\u003E.\u00A9\u0007f\u0012l), (byte) 97);
    // ISSUE: field reference
    \u003CModule\u003E.ITokenCreator(__fieldref (\u003CModule\u003E.n\u003Aïv\u00B9), (byte) 94);
    // ISSUE: field reference
    \u003CModule\u003E.GetSerialNumber(__fieldref (\u003CModule\u003E.\u008B7MU\u009A), (byte) 163);
    // ISSUE: field reference
    \u003CModule\u003E.IsOut(__fieldref (\u003CModule\u003E.îO3\u0023\u0006), (byte) 117);
    // ISSUE: field reference
    \u003CModule\u003E.GetSerialNumber(__fieldref (\u003CModule\u003E.\u006023\u005D\u001A), (byte) 15);
    // ISSUE: field reference
    \u003CModule\u003E.BaseOfCode(__fieldref (\u003CModule\u003E.S\u00BCôüa), (byte) 211);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.\u008C\u00BF\u00A8þè), (byte) 135);
    // ISSUE: field reference
    \u003CModule\u003E.S_ActionToActionObjShunt(__fieldref (\u003CModule\u003E.\u0095ã\u008EDn), (byte) 140);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Source(__fieldref (\u003CModule\u003E.ôX\u00B8i\u0007), (byte) 55);
    // ISSUE: field reference
    \u003CModule\u003E.ITokenCreator(__fieldref (\u003CModule\u003E.ÜÂÍ\u00B28), (byte) 221);
    // ISSUE: field reference
    \u003CModule\u003E.ExclusiveReference(__fieldref (\u003CModule\u003E.\u0018\u00B7ñªº), (byte) 158);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.\u0081\u00226ò\u0082), (byte) 81);
    // ISSUE: field reference
    \u003CModule\u003E.ITokenCreator(__fieldref (\u003CModule\u003E.ÿ\u00B3\u000E`\u0004), (byte) 15);
    // ISSUE: field reference
    \u003CModule\u003E.S_ActionToActionObjShunt(__fieldref (\u003CModule\u003E.\u002Fj\u009B\u0017\u00A8), (byte) 25);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.\u00AEÜT\u0014\u008D), (byte) 254);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.k\u0023\u00A2\u0012ë), (byte) 195);
    // ISSUE: field reference
    \u003CModule\u003E.IsNotPublic(__fieldref (\u003CModule\u003E.SÓ\u009F\u0015Ã), (byte) 60);
    // ISSUE: field reference
    \u003CModule\u003E.IsNotPublic(__fieldref (\u003CModule\u003E.\u002Fae\u00B2Ó), (byte) 64);
    // ISSUE: field reference
    \u003CModule\u003E.ITokenCreator(__fieldref (\u003CModule\u003E.Á\u0040\u0086_1), (byte) 48);
    // ISSUE: field reference
    \u003CModule\u003E.GetSerialNumber(__fieldref (\u003CModule\u003E.\u00B2\u000BÇ\u005C\u00A6), (byte) 154);
    // ISSUE: field reference
    \u003CModule\u003E.TransformBlock(__fieldref (\u003CModule\u003E.J\u0020\u00A8ýE), (byte) 199);
    // ISSUE: field reference
    \u003CModule\u003E.ITokenCreator(__fieldref (\u003CModule\u003E.\u0084vÞ\u00B0\u00B7), (byte) 223);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Company(__fieldref (\u003CModule\u003E.\u00A2\u000E\u0027XM), (byte) 125);
    // ISSUE: field reference
    \u003CModule\u003E.IsOut(__fieldref (\u003CModule\u003E.ÌÐ\u00A1Év), (byte) 25);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.\u000C\u001D7\u0027ß), (byte) 176);
    // ISSUE: field reference
    \u003CModule\u003E.BaseOfCode(__fieldref (\u003CModule\u003E.\u00BB\u001A\u000B\u005Bp), (byte) 117);
    // ISSUE: field reference
    \u003CModule\u003E.LOCALE_SABBREVMONTHNAME4(__fieldref (\u003CModule\u003E.Så\u0085\u009D\u00B6), (byte) 158);
    // ISSUE: field reference
    \u003CModule\u003E.IsNotPublic(__fieldref (\u003CModule\u003E.r\u003BW\u0023í), (byte) 90);
    // ISSUE: field reference
    \u003CModule\u003E.Assertion(__fieldref (\u003CModule\u003E.\u0025\u009Ct\u007B\u0006), (byte) 83);
    // ISSUE: field reference
    \u003CModule\u003E.IsOut(__fieldref (\u003CModule\u003E.ØwgË\u0090), byte.MaxValue);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.\u00A5\u0086\u001DwË), (byte) 184);
    // ISSUE: field reference
    \u003CModule\u003E.TransformBlock(__fieldref (\u003CModule\u003E.ý\u0010O\u00A4\u0017), (byte) 103);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.î\u00A2Ô\u000BÞ), (byte) 246);
    // ISSUE: field reference
    \u003CModule\u003E.IsNotPublic(__fieldref (\u003CModule\u003E.M\u00AE\u003F\u0012\u00BF), (byte) 101);
    // ISSUE: field reference
    \u003CModule\u003E.GetMessageForHR(__fieldref (\u003CModule\u003E.ÿÂ\u0014ÚÑ), (byte) 60);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Company(__fieldref (\u003CModule\u003E.Ò\u00B9\u000B\u00AF\u002C), (byte) 145);
    // ISSUE: field reference
    \u003CModule\u003E.Assertion(__fieldref (\u003CModule\u003E.\u00A59Ì\u0006Ç), (byte) 46);
    // ISSUE: field reference
    \u003CModule\u003E.GetMessageForHR(__fieldref (\u003CModule\u003E.\u0033\u00BB\u00A5ój), (byte) 141);
    // ISSUE: field reference
    \u003CModule\u003E.LOCALE_SABBREVMONTHNAME4(__fieldref (\u003CModule\u003E.\u0087ÔQÞ\u00A7), (byte) 143);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Company(__fieldref (\u003CModule\u003E.\u00F7\u005Bû\u002FÁ), (byte) 115);
    // ISSUE: field reference
    \u003CModule\u003E.TransformBlock(__fieldref (\u003CModule\u003E.\u0014\u00AF5\u0086F), (byte) 29);
    // ISSUE: field reference
    \u003CModule\u003E.IsNotPublic(__fieldref (\u003CModule\u003E.\u0097\u00287\u007BÊ), (byte) 191);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Source(__fieldref (\u003CModule\u003E.\u009A\u005B\u003C\u00D7u), (byte) 115);
    // ISSUE: field reference
    \u003CModule\u003E.GetMessageForHR(__fieldref (\u003CModule\u003E.\u00AB\u00A4l\u0089\u0012), (byte) 68);
    // ISSUE: field reference
    \u003CModule\u003E.TransformBlock(__fieldref (\u003CModule\u003E.s\u000F\u001CS3), (byte) 52);
    // ISSUE: field reference
    \u003CModule\u003E.S_ActionToActionObjShunt(__fieldref (\u003CModule\u003E.\u00AC\u001CòX\u009B), (byte) 52);
    // ISSUE: field reference
    \u003CModule\u003E.GetMessageForHR(__fieldref (\u003CModule\u003E.ã\u003A\u00AD\u0097\u008A), (byte) 133);
    // ISSUE: field reference
    \u003CModule\u003E.GetMessageForHR(__fieldref (\u003CModule\u003E.ÞìaÂY), (byte) 73);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.\u0082I_\u0021\u00A7), (byte) 143);
    // ISSUE: field reference
    \u003CModule\u003E.BaseOfCode(__fieldref (\u003CModule\u003E.GA\u00B0\u00A28), (byte) 105);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Source(__fieldref (\u003CModule\u003E.äæÉJÊ), (byte) 206);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.\u002Es\u00A5F\u0083), (byte) 91);
    // ISSUE: field reference
    \u003CModule\u003E.ExclusiveReference(__fieldref (\u003CModule\u003E.À\u000AáIó), (byte) 142);
    // ISSUE: field reference
    \u003CModule\u003E.TransformBlock(__fieldref (\u003CModule\u003E.w\u0087t\u00F7î), (byte) 7);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Source(__fieldref (\u003CModule\u003E.ÌÄúX\u00AF), (byte) 236);
    // ISSUE: field reference
    \u003CModule\u003E.ITokenCreator(__fieldref (\u003CModule\u003E.S\u00B3êI\u0082), (byte) 97);
    // ISSUE: field reference
    \u003CModule\u003E.GetMessageForHR(__fieldref (\u003CModule\u003E.ZÄ5V\u008D), (byte) 29);
    // ISSUE: field reference
    \u003CModule\u003E.GetSerialNumber(__fieldref (\u003CModule\u003E.ÐQg\u00B4\u005B), (byte) 248);
    // ISSUE: field reference
    \u003CModule\u003E.IsNotPublic(__fieldref (\u003CModule\u003E.\u008DÈ8Å\u0015), (byte) 165);
    // ISSUE: field reference
    \u003CModule\u003E.ITokenCreator(__fieldref (\u003CModule\u003E.n\u007B\u0096µ\u0081), (byte) 218);
    // ISSUE: field reference
    \u003CModule\u003E.ExclusiveReference(__fieldref (\u003CModule\u003E.ÊOçÓ\u003B), (byte) 207);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Company(__fieldref (\u003CModule\u003E.Ó\u0013\u00A1\u00190), (byte) 59);
    // ISSUE: field reference
    \u003CModule\u003E.Assertion(__fieldref (\u003CModule\u003E.\u007Fª\u009A\u0001\u0004), (byte) 114);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.\u008B4\u0028r\u0003), (byte) 43);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.\u0006\u002CVt\u0006), (byte) 4);
    // ISSUE: field reference
    \u003CModule\u003E.ITokenCreator(__fieldref (\u003CModule\u003E.\u00BCßº5\u0026), (byte) 70);
    // ISSUE: field reference
    \u003CModule\u003E.Assertion(__fieldref (\u003CModule\u003E.é\u0016\u0006\u00A7\u0028), (byte) 143);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.\u001A\u00A2\u0081D\u0014), (byte) 123);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.\u00AE\u00B7Õ\u00ACq), (byte) 89);
    // ISSUE: field reference
    \u003CModule\u003E.IsOut(__fieldref (\u003CModule\u003E.\u0031\u0023\u0098ÖÂ), (byte) 177);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Company(__fieldref (\u003CModule\u003E.\u0013Ó\u00B3\u0095z), (byte) 251);
    // ISSUE: field reference
    \u003CModule\u003E.Assertion(__fieldref (\u003CModule\u003E.Ä\u0091uI\u00A8), (byte) 97);
    // ISSUE: field reference
    \u003CModule\u003E.BaseOfCode(__fieldref (\u003CModule\u003E.\u0018hç\u0093Q), (byte) 7);
    // ISSUE: field reference
    \u003CModule\u003E.GetSerialNumber(__fieldref (\u003CModule\u003E.\u0004iZÃr), (byte) 44);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.\u0099\u00B4\u003D\u00A5\u0018), (byte) 156);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Source(__fieldref (\u003CModule\u003E.bÉgWÒ), (byte) 166);
    // ISSUE: field reference
    \u003CModule\u003E.S_ActionToActionObjShunt(__fieldref (\u003CModule\u003E.\u0010Ï\u0007\u00B7â), (byte) 231);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.xÞ2\u000AÕ), (byte) 246);
    // ISSUE: field reference
    \u003CModule\u003E.BaseOfCode(__fieldref (\u003CModule\u003E.ÿ\u002EË\u0098\u0027), (byte) 65);
    // ISSUE: field reference
    \u003CModule\u003E.GetMessageForHR(__fieldref (\u003CModule\u003E.i\u0094\u0024\u00A9Ï), (byte) 12);
    // ISSUE: field reference
    \u003CModule\u003E.GetTokenInformation(__fieldref (\u003CModule\u003E.Æ\u0011\u003D\u002A2), (byte) 238);
    // ISSUE: field reference
    \u003CModule\u003E.IsNotPublic(__fieldref (\u003CModule\u003E.\u00845\u0018þ\u0013), (byte) 172);
    // ISSUE: field reference
    \u003CModule\u003E.LOCALE_SABBREVMONTHNAME4(__fieldref (\u003CModule\u003E.\u0018ÅÏê\u00B8), (byte) 215);
    // ISSUE: field reference
    \u003CModule\u003E.S_ActionToActionObjShunt(__fieldref (\u003CModule\u003E.\u00AFóß\u0014\u001D), (byte) 219);
    // ISSUE: field reference
    \u003CModule\u003E.Stloc_3(__fieldref (\u003CModule\u003E.\u008C\u0095\u0080\u0095\u0001), (byte) 41);
    // ISSUE: field reference
    \u003CModule\u003E.IsNotPublic(__fieldref (\u003CModule\u003E.\u001Ewc\u00B8\u0008), (byte) 54);
    // ISSUE: field reference
    \u003CModule\u003E.ExclusiveReference(__fieldref (\u003CModule\u003E.RzU\u00B8ç), (byte) 125);
    // ISSUE: field reference
    \u003CModule\u003E.S_ActionToActionObjShunt(__fieldref (\u003CModule\u003E.\u00F7\u0020\u0085\u0021\u00B1), (byte) 8);
    // ISSUE: field reference
    \u003CModule\u003E.TransformBlock(__fieldref (\u003CModule\u003E.\u002D\u00A8ò\u0001\u0009), (byte) 157);
    // ISSUE: field reference
    \u003CModule\u003E.LOCALE_SABBREVMONTHNAME4(__fieldref (\u003CModule\u003E.\u001DeEFÔ), (byte) 252);
    // ISSUE: field reference
    \u003CModule\u003E.GetSerialNumber(__fieldref (\u003CModule\u003E.\u0094`7g\u000D), (byte) 251);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.\u0081\u0085\u0006\u0093`), (byte) 246);
    // ISSUE: field reference
    \u003CModule\u003E.LOCALE_SABBREVMONTHNAME4(__fieldref (\u003CModule\u003E.ô\u0027\u00AD\u002Að), (byte) 159);
    // ISSUE: field reference
    \u003CModule\u003E.GetMessageForHR(__fieldref (\u003CModule\u003E.\u0036\u007Bm\u00B3\u003C), (byte) 2);
    // ISSUE: field reference
    \u003CModule\u003E.IsOut(__fieldref (\u003CModule\u003E.\u0015H\u007B5Ã), (byte) 176);
    // ISSUE: field reference
    \u003CModule\u003E.ExclusiveReference(__fieldref (\u003CModule\u003E.\u009D\u008AæÓB), (byte) 206);
    // ISSUE: field reference
    \u003CModule\u003E.BaseOfCode(__fieldref (\u003CModule\u003E.\u000A\u002A\u00ADI\u00A6), (byte) 2);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.Ýß\u0021\u0095\u000A), (byte) 247);
    // ISSUE: field reference
    \u003CModule\u003E.IsOut(__fieldref (\u003CModule\u003E.\u0034lÜ\u0084\u0011), (byte) 57);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.ýdØwÕ), (byte) 76);
    // ISSUE: field reference
    \u003CModule\u003E.BaseOfCode(__fieldref (\u003CModule\u003E.ç\u0025\u000BT2), (byte) 13);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.\u001EÁC\u0014\u0027), (byte) 174);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Source(__fieldref (\u003CModule\u003E.\u00B6\u002A\u001E\u0084\u0040), (byte) 69);
    // ISSUE: field reference
    \u003CModule\u003E.OutOfMemory(__fieldref (\u003CModule\u003E.\u0085Kwâ\u000E), (byte) 99);
    // ISSUE: field reference
    \u003CModule\u003E.ITokenCreator(__fieldref (\u003CModule\u003E.óÇE\u0026B), (byte) 73);
    // ISSUE: field reference
    \u003CModule\u003E.GetTokenInformation(__fieldref (\u003CModule\u003E.n\u00AE\u00A5Uí), (byte) 70);
    // ISSUE: field reference
    \u003CModule\u003E.Get_Company(__fieldref (\u003CModule\u003E.ë\u0012\u000Fi\u00BB), (byte) 58);
    \u003CModule\u003E.NoResourceLookup();
  }

  private static void NoResourceLookup()
  {
    string str = "COR";
    // ISSUE: type reference
    // ISSUE: type reference
    MethodInfo methodInfo = (MethodInfo) set_NumberDecimalDigits.SystemManagement((object) (Type) \u003CModule\u003E.ë\u0012\u000Fi\u00BB(__typeref (Environment)), "GetEnvironmentVariable", new Type[1]
    {
      (Type) \u003CModule\u003E.n\u00AE\u00A5Uí(__typeref (string))
    });
    if ((object) methodInfo != null)
    {
      if (Marshal.Abort((object) "1", Set_AppDomainManagerType.EnclosingTypeEquals((object) methodInfo, (object) null, new object[1]
      {
        (object) \u003CModule\u003E.\u0085Kwâ\u000E(str, "_ENABLE_PROFILING")
      })))
        \u003CModule\u003E.ç\u0025\u000BT2((string) null);
    }
    if (\u003CModule\u003E.\u0034lÜ\u0084\u0011(\u003CModule\u003E.ýdØwÕ(str, "_PROFILER")) != null || \u003CModule\u003E.\u000A\u002A\u00ADI\u00A6(\u003CModule\u003E.Ýß\u0021\u0095\u000A(str, "_ENABLE_PROFILING")) != null)
      \u003CModule\u003E.\u009D\u008AæÓB((string) null);
    Thread thread = (Thread) \u003CModule\u003E.\u0015H\u007B5Ã((object) new ParameterizedThreadStart(\u003CModule\u003E.TimeSpanFormat));
    \u003CModule\u003E.\u0036\u007Bm\u00B3\u003C((object) thread, true);
    \u003CModule\u003E.ô\u0027\u00AD\u002Að((object) thread, (object) null);
  }

  private static void TimeSpanFormat([In] object obj0)
  {
    if (!(obj0 is Thread thread))
    {
      thread = (Thread) \u003CModule\u003E.\u0081\u0085\u0006\u0093`((object) new ParameterizedThreadStart(\u003CModule\u003E.TimeSpanFormat));
      \u003CModule\u003E.\u0094`7g\u000D((object) thread, true);
      \u003CModule\u003E.\u002D\u00A8ò\u0001\u0009((object) thread, \u003CModule\u003E.\u001DeEFÔ());
      \u003CModule\u003E.\u00F7\u0020\u0085\u0021\u00B1(500);
    }
    while (true)
    {
      if (NotInitialized.Get_ModuleName() || \u003CModule\u003E.\u001Ewc\u00B8\u0008())
        \u003CModule\u003E.\u008C\u0095\u0080\u0095\u0001((string) null);
      bool flag = false;
      \u003CModule\u003E._stringtable(\u003CModule\u003E.\u0018ÅÏê\u00B8(\u003CModule\u003E.\u00AFóß\u0014\u001D()), ref flag);
      if (flag)
        \u003CModule\u003E.\u00845\u0018þ\u0013((string) null);
      if (\u003CModule\u003E.Label())
        \u003CModule\u003E.Æ\u0011\u003D\u002A2((string) null);
      Process process = (Process) CSIDL_PERSONAL.MEM_FREE();
      if (\u003CModule\u003E.xÞ2\u000AÕ(\u003CModule\u003E.ÿ\u002EË\u0098\u0027((object) process), IntPtr.Zero))
        \u003CModule\u003E.\u0010Ï\u0007\u00B7â("");
      \u003CModule\u003E.bÉgWÒ((object) process);
      if (\u003CModule\u003E.DateWordToken("") > \u003CModule\u003E.\u0099\u00B4\u003D\u00A5\u0018())
        \u003CModule\u003E.\u0004iZÃr("");
      if (!\u003CModule\u003E.\u0018hç\u0093Q((object) thread))
        \u003CModule\u003E.Ä\u0091uI\u00A8((string) null);
      \u003CModule\u003E.\u0013Ó\u00B3\u0095z(1000);
    }
  }

  [DllImport("kernel32.dll", EntryPoint = "IsDebuggerPresent")]
  private static extern bool Label();

  [DllImport("kernel32.dll", EntryPoint = "CheckRemoteDebuggerPresent", SetLastError = true)]
  private static extern bool _stringtable([In] IntPtr obj0, [In] ref bool obj1);

  [DllImport("kernel32.dll", EntryPoint = "OutputDebugString", CharSet = CharSet.Auto)]
  private static extern int DateWordToken([In] string obj0);

  [DllImport("kernel32.dll", EntryPoint = "CloseHandle")]
  private static extern bool FixBranches([In] IntPtr obj0);

  static void Get_Company([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num2 = num1 - 1]) << 24) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num3 = num2 - 1]) << 16);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E._capacity(num4 + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num6 = num5 - 1]) << 8)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[1] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int _capacity([In] int obj0);

  static void GetTokenInformation([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num2 = num1 - 1]) << 16) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num3 = num2 - 1]) << 24);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.CJKMinuteSuff(num4 + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num6 = num5 - 1]) << 8)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[0] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int CJKMinuteSuff([In] int obj0);

  static void ITokenCreator([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num2 = num1 - 1]) << 24) + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num3 = num2 - 1]) << 16);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.m_cultureName(num4 + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num6 = num5 - 1]) << 8)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[3] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int m_cultureName([In] int obj0);

  static void OutOfMemory([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num1 = length - 1]) << 16) + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num2 = num1 - 1]) << 24) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num3 = num2 - 1]) << 0);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.Get_Port(num4 + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num6 = num5 - 1]) << 8)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[1] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int Get_Port([In] int obj0);

  static void Get_Source([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num2 = num1 - 1]) << 8) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num3 = num2 - 1]) << 16);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.Tuesday(num4 + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num6 = num5 - 1]) << 24)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[1] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int Tuesday([In] int obj0);

  static void BaseOfCode([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num2 = num1 - 1]) << 16) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num3 = num2 - 1]) << 24);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.IsPunctuation(num4 + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num6 = num5 - 1]) << 8)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[1] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int IsPunctuation([In] int obj0);

  static void IsOut([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num2 = num1 - 1]) << 24) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num3 = num2 - 1]) << 8);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.Get_EndColumn(num4 + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num6 = num5 - 1]) << 16)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[4] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int Get_EndColumn([In] int obj0);

  static void ExclusiveReference([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num1 = length - 1]) << 24) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num2 = num1 - 1]) << 16) + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num3 = num2 - 1]) << 8);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.ProbeForSufficientStack(num4 + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num6 = num5 - 1]) << 0)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[2] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int ProbeForSufficientStack([In] int obj0);

  static void GetMessageForHR([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num1 = length - 1]) << 16) + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num2 = num1 - 1]) << 24) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num3 = num2 - 1]) << 0);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.EscapeAssemblyName(num4 + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num6 = num5 - 1]) << 8)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[2] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int EscapeAssemblyName([In] int obj0);

  static void LOCALE_SABBREVMONTHNAME4([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num1 = length - 1]) << 16) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num2 = num1 - 1]) << 24) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num3 = num2 - 1]) << 0);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.RawENCMapRow(num4 + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num6 = num5 - 1]) << 8)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[4] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int RawENCMapRow([In] int obj0);

  static void GetSerialNumber([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num1 = length - 1]) << 24) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num2 = num1 - 1]) << 16) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num3 = num2 - 1]) << 8);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.Get_HasMethods(num4 + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num6 = num5 - 1]) << 0)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[0] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int Get_HasMethods([In] int obj0);

  static void TransformBlock([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num2 = num1 - 1]) << 24) + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num3 = num2 - 1]) << 16);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.Get_IsAddOn(num4 + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num6 = num5 - 1]) << 8)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[2] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int Get_IsAddOn([In] int obj0);

  static void S_ActionToActionObjShunt([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num2 = num1 - 1]) << 16) + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num3 = num2 - 1]) << 24);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.BeginExceptionBlock(num4 + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num6 = num5 - 1]) << 8)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[1] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int BeginExceptionBlock([In] int obj0);

  static void IsNotPublic([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num1 = length - 1]) << 24) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num2 = num1 - 1]) << 8) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num3 = num2 - 1]) << 16);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.ListConstantMD(num4 + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num6 = num5 - 1]) << 0)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[0] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int ListConstantMD([In] int obj0);

  static void Stloc_3([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num1 = length - 1]) << 16) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num2 = num1 - 1]) << 8) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num3 = num2 - 1]) << 24);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.Subtract(num4 + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num6 = num5 - 1]) << 0)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[4] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int Subtract([In] int obj0);

  static void Assertion([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num1 = length - 1]) << 16) + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num2 = num1 - 1]) << 8) + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num3 = num2 - 1]) << 0);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.WaitForCallbackToComplete(num4 + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num6 = num5 - 1]) << 24)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[3] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int WaitForCallbackToComplete([In] int obj0);
}
