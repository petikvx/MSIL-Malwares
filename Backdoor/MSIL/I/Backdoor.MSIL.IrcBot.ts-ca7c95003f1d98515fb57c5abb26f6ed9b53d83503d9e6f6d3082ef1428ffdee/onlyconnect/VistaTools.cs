// Decompiled with JetBrains decompiler
// Type: onlyconnect.VistaTools
// Assembly: Irc9, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E7A76116-F62B-4512-BE9B-418015CDF203
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Backdoor.MSIL.IrcBot.ts-ca7c95003f1d98515fb57c5abb26f6ed9b53d83503d9e6f6d3082ef1428ffdee.exe

using System;
using System.Runtime.InteropServices;

namespace onlyconnect
{
  public class VistaTools
  {
    public const uint STANDARD_RIGHTS_REQUIRED = 983040;
    public const uint TOKEN_ASSIGN_PRIMARY = 1;
    public const uint TOKEN_DUPLICATE = 2;
    public const uint TOKEN_IMPERSONATE = 4;
    public const uint TOKEN_QUERY = 8;
    public const uint TOKEN_QUERY_SOURCE = 16;
    public const uint TOKEN_ADJUST_PRIVILEGES = 32;
    public const uint TOKEN_ADJUST_GROUPS = 64;
    public const uint TOKEN_ADJUST_DEFAULT = 128;
    public const uint TOKEN_ADJUST_SESSIONID = 256;
    public const uint TOKEN_ALL_ACCESS_P = 983295;

    [DllImport("advapi32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool OpenProcessToken(
      IntPtr ProcessHandle,
      uint DesiredAccess,
      out IntPtr TokenHandle);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr GetCurrentProcess();

    [DllImport("advapi32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool GetTokenInformation(
      IntPtr TokenHandle,
      TOKEN_INFORMATION_CLASS TokenInformationClass,
      IntPtr TokenInformation,
      uint TokenInformationLength,
      out uint ReturnLength);

    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool CloseHandle(IntPtr hObject);

    [DllImport("kernel32.dll", CharSet = CharSet.Ansi)]
    public static extern IntPtr LoadLibrary(string lpFileName);

    [DllImport("kernel32.dll", CharSet = CharSet.Ansi)]
    public static extern IntPtr GetProcAddress(IntPtr hmodule, string procName);

    public static bool IsVista() => Environment.OSVersion.Version.Major >= 6;

    public static bool IsReallyVista()
    {
      IntPtr hmodule = VistaTools.LoadLibrary("kernel32");
      return hmodule.ToInt32() != 0 && VistaTools.GetProcAddress(hmodule, "CreateThreadpoolWait").ToInt32() != 0;
    }

    public static bool IsElevated()
    {
      if (!VistaTools.IsReallyVista())
        throw new VistaToolsException("Function requires Vista or higher");
      IntPtr TokenHandle = IntPtr.Zero;
      IntPtr currentProcess = VistaTools.GetCurrentProcess();
      if (currentProcess == IntPtr.Zero)
        throw new VistaToolsException("Error getting current process handle");
      if (!VistaTools.OpenProcessToken(currentProcess, 8U, out TokenHandle))
        throw new VistaToolsException("Error opening process token");
      try
      {
        TOKEN_ELEVATION structure;
        structure.TokenIsElevated = 0U;
        uint ReturnLength = 0;
        int num1 = Marshal.SizeOf((object) structure);
        IntPtr num2 = Marshal.AllocHGlobal(num1);
        try
        {
          Marshal.StructureToPtr((object) structure, num2, true);
          if (!VistaTools.GetTokenInformation(TokenHandle, TOKEN_INFORMATION_CLASS.TokenElevation, num2, (uint) num1, out ReturnLength) | (long) num1 != (long) ReturnLength)
            throw new VistaToolsException("Error getting token information");
          structure = (TOKEN_ELEVATION) Marshal.PtrToStructure(num2, typeof (TOKEN_ELEVATION));
        }
        finally
        {
          Marshal.FreeHGlobal(num2);
        }
        return structure.TokenIsElevated != 0U;
      }
      finally
      {
        VistaTools.CloseHandle(TokenHandle);
      }
    }

    public static TOKEN_ELEVATION_TYPE GetElevationType()
    {
      if (!VistaTools.IsReallyVista())
        throw new VistaToolsException("Function requires Vista or higher");
      IntPtr TokenHandle = IntPtr.Zero;
      IntPtr currentProcess = VistaTools.GetCurrentProcess();
      if (currentProcess == IntPtr.Zero)
        throw new VistaToolsException("Error getting current process handle");
      if (!VistaTools.OpenProcessToken(currentProcess, 8U, out TokenHandle))
        throw new VistaToolsException("Error opening process token");
      try
      {
        TOKEN_ELEVATION_TYPE structure = TOKEN_ELEVATION_TYPE.TokenElevationTypeDefault;
        uint ReturnLength = 0;
        uint num1 = (uint) Marshal.SizeOf((object) (int) structure);
        IntPtr num2 = Marshal.AllocHGlobal((int) num1);
        try
        {
          if (!VistaTools.GetTokenInformation(TokenHandle, TOKEN_INFORMATION_CLASS.TokenElevationType, num2, num1, out ReturnLength) | (int) num1 != (int) ReturnLength)
            throw new VistaToolsException("Error getting token information");
          structure = (TOKEN_ELEVATION_TYPE) Marshal.ReadInt32(num2);
        }
        finally
        {
          Marshal.FreeHGlobal(num2);
        }
        return structure;
      }
      finally
      {
        VistaTools.CloseHandle(TokenHandle);
      }
    }
  }
}
