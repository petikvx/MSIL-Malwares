// Decompiled with JetBrains decompiler
// Type: .
// Assembly: derver, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 76892F40-3DAD-430C-AF53-E7AE49BEB72F
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Generic-07a4bc5a4a12d6d36ee0484e98a39c60cb30aff0d55c88d79edf9fd137667aca.exe

using \u0003;
using \u0008;
using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace \u0002
{
  internal sealed class \u0002 : Stream
  {
    protected internal \u0002.\u0003 \u0001;
    protected internal byte[] \u0001;
    protected internal int \u0001;
    private byte[] \u0002 = new byte[1];
    protected internal Stream \u0001;
    protected internal byte[] \u0003 = (byte[]) null;
    internal uint[] \u0001 = (uint[]) null;
    [NonSerialized]
    internal static \u0004 \u0089;

    [SpecialName]
    bool Stream.\u0001() => this.\u0001.CanRead;

    [SpecialName]
    bool Stream.\u0002() => this.\u0001.CanSeek;

    [SpecialName]
    bool Stream.\u0003() => this.\u0001.CanWrite;

    [SpecialName]
    long Stream.\u0001() => (long) this.\u0001;

    [SpecialName]
    long Stream.\u0002() => this.\u0001.Position;

    [SpecialName]
    void Stream.\u0001([In] long obj0) => this.\u0001.Position = obj0;

    void Stream.\u0001() => this.\u0001.Flush();

    long Stream.\u0001([In] long obj0, [In] SeekOrigin obj1) => this.\u0001.Seek(obj0, obj1);

    void Stream.\u0002([In] long obj0) => this.\u0001.SetLength(obj0);

    void Stream.\u0001([In] byte[] obj0, [In] int obj1, [In] int obj2) => this.\u0001.Write(obj0, obj1, obj2);

    void Stream.\u0001([In] byte obj0) => this.\u0001.WriteByte(obj0);

    public \u0002([In] Stream obj0)
      : this(obj0, new \u0002.\u0003(), 4096)
    {
    }

    public \u0002([In] Stream obj0, [In] \u0002.\u0003 obj1, [In] int obj2)
    {
      this.\u0001 = obj0;
      this.\u0001 = obj1;
      try
      {
        this.\u0001 = (int) obj0.Length;
      }
      catch (Exception ex)
      {
        this.\u0001 = 0;
      }
      this.\u0001 = obj2 > 0 ? new byte[(int) checked ((uint) obj2)] : throw new ArgumentOutOfRangeException(\u0002.\u0002.\u0089(971));
    }

    void Stream.\u0002() => this.\u0001.Close();

    unsafe int Stream.\u0001()
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      *(int*) voidPtr = ((Stream) this).Read(this.\u0002, 0, 1);
      if (*(int*) voidPtr <= 0)
        goto label_3;
      else
        goto label_2;
label_1:
      return *(int*) ((IntPtr) voidPtr + 4);
label_2:
      *(int*) ((IntPtr) voidPtr + 4) = (int) this.\u0002[0] & (int) byte.MaxValue;
      goto label_1;
label_3:
      *(int*) ((IntPtr) voidPtr + 4) = -1;
      goto label_1;
    }

    unsafe int Stream.\u0001([In] byte[] obj0, [In] int obj1, [In] int obj2)
    {
      int num = 8;
      void* voidPtr;
      if (num != 0)
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(num);
      }
      else
        goto label_8;
label_2:
      do
      {
        try
        {
          do
          {
            *(int*) voidPtr = \u0005.\u0001(this.\u0001, obj0, obj1, obj2);
          }
          while (false);
        }
        catch (Exception ex)
        {
          throw new \u0001.\u0006(ex.ToString());
        }
        if (*(int*) voidPtr > 0)
          goto label_17;
      }
      while (false);
      if (\u0005.\u0001(this.\u0001))
        throw new \u0001.\u0006(\u0002.\u0002.\u0089(984));
      goto label_7;
label_17:
      *(int*) ((IntPtr) voidPtr + 4) = *(int*) voidPtr;
      goto label_15;
label_7:
      num = \u0005.\u0001(this.\u0001) ? 1 : 0;
label_8:
      if (num != 0)
      {
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 4) = 0;
          if (true)
          {
            if (false)
              ;
          }
          else
            goto label_7;
        }
        else
          goto label_2;
      }
      else
      {
        if (!\u0005.\u0001(this.\u0001))
          throw new InvalidOperationException(\u0002.\u0002.\u0089(1009));
        \u0005.\u0001(this);
        goto label_2;
      }
label_15:
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    static \u0002() => \u0006.\u0002.\u0001(typeof (\u0002.\u0002));
  }
}
