// Decompiled with JetBrains decompiler
// Type: flac.FlacStream
// Assembly: STAThreadAttrib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 6EE3DE1A-E148-4FBA-A193-65BEA1824C00
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-PSW.MSIL.Stealer.gen-f6a784c2aa30ddaf03919958455d18bf51533a475c21a73eff578df0174cc5d4.exe

using flac.Format;
using flac.Io;
using System.IO;

namespace flac
{
  public class FlacStream
  {
    private Signature signature_;
    private MetadataBlockStreamInfo streamInfo_;
    private FileStream fileStream_;
    private FlacStreamReader reader_;
    private FlacStreamWriter writer_;

    public event MetadataCallback MetadataRead;

    public event FrameCallback BeforeFrameDataRead;

    public FlacStreamReader Reader => this.reader_;

    public FlacStreamWriter Writer => this.writer_;

    public FileStream FileStream => this.fileStream_;

    public MetadataBlockStreamInfo StreamInfo => this.streamInfo_;

    public void Decode()
    {
      this.signature_ = new Signature();
      this.signature_.Read(this);
      this.streamInfo_ = MetadataBlock.New(this) as MetadataBlockStreamInfo;
      Validation.IsValid(this.streamInfo_ != null);
      MetadataBlock metadataBlock = (MetadataBlock) this.streamInfo_;
      if (this.MetadataRead != null)
        this.MetadataRead((MetadataBlock) this.streamInfo_);
      while (!metadataBlock.Header.IsLastMetadataBlock)
      {
        metadataBlock = MetadataBlock.New(this);
        if (this.MetadataRead != null)
          this.MetadataRead(metadataBlock);
      }
      while (!this.reader_.Done)
      {
        Frame frame = new Frame();
        long debugBytesRead = this.reader_.Debug_BytesRead;
        frame.ReadHeader(this);
        bool flag = false;
        if (this.BeforeFrameDataRead != null)
        {
          FrameCallbackArgs args = new FrameCallbackArgs(frame, this);
          args.Offset = debugBytesRead;
          this.BeforeFrameDataRead(args);
          if (!args.ContinueDecoding)
            break;
          flag = args.HaveReadData;
        }
        if (!flag)
        {
          frame.ReadData(this);
          frame.ReadFooter(this);
        }
      }
    }

    public void Close() => this.fileStream_.Close();

    public void Encode()
    {
      this.signature_ = new Signature();
      this.signature_.Write(this);
    }

    public FlacStream(
      string file,
      FlacStream.StreamMode mode,
      FlacStream.StreamAccessMode accessMode)
    {
      FileMode mode1;
      switch (mode)
      {
        case FlacStream.StreamMode.OpenExisting:
          mode1 = FileMode.Open;
          break;
        case FlacStream.StreamMode.CreateNew:
          mode1 = FileMode.Create;
          break;
        default:
          throw new FlacDebugException();
      }
      switch (accessMode)
      {
        case FlacStream.StreamAccessMode.Read:
        case FlacStream.StreamAccessMode.Write:
        case FlacStream.StreamAccessMode.Both:
          FileAccess access = (FileAccess) accessMode;
          this.fileStream_ = new FileStream(file, mode1, access, FileShare.Read);
          if ((accessMode & FlacStream.StreamAccessMode.Read) == FlacStream.StreamAccessMode.Read)
            this.reader_ = new FlacStreamReader(this.fileStream_);
          if ((accessMode & FlacStream.StreamAccessMode.Write) != FlacStream.StreamAccessMode.Write)
            break;
          this.writer_ = new FlacStreamWriter(this.fileStream_);
          break;
        default:
          throw new FlacDebugException();
      }
    }

    public enum StreamAccessMode
    {
      Read = 1,
      Write = 2,
      Both = 3,
    }

    public enum StreamMode
    {
      OpenExisting,
      CreateNew,
    }
  }
}
