// Decompiled with JetBrains decompiler
// Type: Microsoft.Tools.RegAsm.RegAsm
// Assembly: RegAsm, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: 097EDB82-DB75-4D42-81B4-3BEFAFAFEBC0
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Virus.Win32.Sality.q-052b60d6a15faafc5f2db590d83230c23f3f890cbf1c8075e3c07e9f1a58e29c.exe

using System;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Security.Policy;
using System.Text;
using System.Threading;

namespace Microsoft.Tools.RegAsm
{
  internal class RegAsm
  {
    private const string strDocStringPrefix = "";
    private const string strManagedTypeThreadingModel = "Both";
    private const string strClassesRootRegKey = "HKEY_CLASSES_ROOT";
    private const int SuccessReturnCode = 0;
    private const int ErrorReturnCode = 100;
    private const int MAX_PATH = 260;
    internal static RegAsmOptions s_Options;

    internal static int Main(string[] aArgs)
    {
      int ReturnCode = 0;
      Microsoft.Tools.RegAsm.RegAsm.SetConsoleUI();
      if (!Microsoft.Tools.RegAsm.RegAsm.ParseArguments(aArgs, ref Microsoft.Tools.RegAsm.RegAsm.s_Options, ref ReturnCode))
        return ReturnCode;
      Microsoft.Tools.RegAsm.RegAsm.PrintLogo();
      return Microsoft.Tools.RegAsm.RegAsm.Run();
    }

    internal static int Run()
    {
      int num = 0;
      try
      {
        string fullPath = Path.GetFullPath(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName);
        if (!File.Exists(fullPath))
        {
          StringBuilder buffer = new StringBuilder(261);
          if (Microsoft.Tools.RegAsm.RegAsm.SearchPath((string) null, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName, (string) null, buffer.Capacity + 1, buffer, (int[]) null) == 0)
            throw new ApplicationException(Resource.FormatString("Err_InputFileNotFound", (object) Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName));
          Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName = buffer.ToString();
        }
        else
          Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName = fullPath;
        Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName = new FileInfo(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName).FullName;
        if (Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strRegFileName != null)
          Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strRegFileName = new FileInfo(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strRegFileName).FullName;
        string directoryName = Path.GetDirectoryName(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName);
        if (Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strTypeLibName != null)
          Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strTypeLibName = !(Path.GetDirectoryName(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strTypeLibName) == "") ? new FileInfo(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strTypeLibName).FullName : Path.Combine(directoryName, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strTypeLibName);
        if (Microsoft.Tools.RegAsm.RegAsm.s_Options.m_bTypeLibSpecified)
        {
          if (Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strTypeLibName == null)
          {
            Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strTypeLibName = !Microsoft.Tools.RegAsm.RegAsm.ContainsEmbeddedTlb(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName) ? (Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Length < 4 || string.Compare(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Substring(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Length - 4), ".dll", StringComparison.OrdinalIgnoreCase) != 0 && string.Compare(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Substring(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Length - 4), ".exe", StringComparison.OrdinalIgnoreCase) != 0 ? Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName + ".tlb" : Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Substring(0, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Length - 4) + ".tlb") : Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName;
            if (!Directory.Exists(Path.GetDirectoryName(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strTypeLibName)))
              Directory.CreateDirectory(Path.GetDirectoryName(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strTypeLibName));
          }
          else
          {
            if (!Directory.Exists(Path.GetDirectoryName(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strTypeLibName)))
              Directory.CreateDirectory(Path.GetDirectoryName(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strTypeLibName));
            if (Microsoft.Tools.RegAsm.RegAsm.ContainsEmbeddedTlb(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName))
              throw new ApplicationException(Resource.FormatString("Err_TlbNameNotAllowedWithEmbedded"));
          }
        }
        if (Microsoft.Tools.RegAsm.RegAsm.s_Options.m_bRegFileSpecified && Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strRegFileName == null)
          Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strRegFileName = Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Length < 4 || string.Compare(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Substring(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Length - 4), ".dll", StringComparison.OrdinalIgnoreCase) != 0 && string.Compare(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Substring(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Length - 4), ".exe", StringComparison.OrdinalIgnoreCase) != 0 ? Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName + ".reg" : Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Substring(0, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName.Length - 4) + ".reg";
        if (Microsoft.Tools.RegAsm.RegAsm.s_Options.m_bRegFileSpecified && !Directory.Exists(Path.GetDirectoryName(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strRegFileName)))
          Directory.CreateDirectory(Path.GetDirectoryName(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strRegFileName));
        string currentDirectory = Environment.CurrentDirectory;
        RemoteRegAsm remoteRegAsm = (RemoteRegAsm) ((AppDomain.CreateDomain(nameof (RegAsm), (Evidence) null, new AppDomainSetup()
        {
          ApplicationBase = directoryName
        }) ?? throw new ApplicationException(Resource.FormatString("Err_CannotCreateAppDomain"))).CreateInstanceFrom(Assembly.GetExecutingAssembly().CodeBase, "Microsoft.Tools.RegAsm.RemoteRegAsm") ?? throw new ApplicationException(Resource.FormatString("Err_CannotCreateRemoteRegAsm"))).Unwrap();
        if (remoteRegAsm != null)
          num = remoteRegAsm.Run(Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAssemblyName, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strTypeLibName, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_bRegister, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_bSetCodeBase, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strRegFileName, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_bNoLogo, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_bSilentMode, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_bVerboseMode, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_bTypeLibSpecified, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_bRegFileSpecified, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_Flags, Microsoft.Tools.RegAsm.RegAsm.s_Options.m_strAsmPath);
      }
      catch (Exception ex)
      {
        Output.WriteError(ex);
        num = 100;
      }
      return num;
    }

    private static void SetConsoleUI()
    {
      Thread currentThread = Thread.CurrentThread;
      currentThread.CurrentUICulture = CultureInfo.CurrentUICulture.GetConsoleFallbackUICulture();
      if (Environment.OSVersion.Platform == PlatformID.Win32Windows || Console.OutputEncoding.CodePage == currentThread.CurrentUICulture.TextInfo.OEMCodePage || Console.OutputEncoding.CodePage == currentThread.CurrentUICulture.TextInfo.ANSICodePage)
        return;
      currentThread.CurrentUICulture = new CultureInfo("en-US");
    }

    private static bool ContainsEmbeddedTlb(string strFileName)
    {
      ITypeLib TypeLib = (ITypeLib) null;
      try
      {
        Microsoft.Tools.RegAsm.RegAsm.LoadTypeLibEx(strFileName, REGKIND.REGKIND_NONE, out TypeLib);
      }
      catch (Exception ex)
      {
      }
      return TypeLib != null;
    }

    private static bool ParseArguments(
      string[] aArgs,
      ref RegAsmOptions Options,
      ref int ReturnCode)
    {
      Options = new RegAsmOptions();
      CommandLine commandLine;
      try
      {
        commandLine = new CommandLine(aArgs, new string[11]
        {
          "+regfile",
          "+tlb",
          "unregister",
          "registered",
          "codebase",
          "nologo",
          "silent",
          "verbose",
          "?",
          "help",
          "*asmpath"
        });
      }
      catch (ApplicationException ex)
      {
        Microsoft.Tools.RegAsm.RegAsm.PrintLogo();
        Output.WriteError((Exception) ex);
        ReturnCode = 100;
        return false;
      }
      if (commandLine.NumArgs + commandLine.NumOpts < 1)
      {
        Microsoft.Tools.RegAsm.RegAsm.PrintUsage();
        ReturnCode = 0;
        return false;
      }
      Options.m_strAssemblyName = commandLine.GetNextArg();
      Option nextOption;
      while ((nextOption = commandLine.GetNextOption()) != null)
      {
        if (nextOption.Name.Equals("regfile"))
        {
          Options.m_strRegFileName = nextOption.Value;
          Options.m_bRegFileSpecified = true;
        }
        else if (nextOption.Name.Equals("tlb"))
        {
          Options.m_strTypeLibName = nextOption.Value;
          Options.m_bTypeLibSpecified = true;
        }
        else if (nextOption.Name.Equals("codebase"))
          Options.m_bSetCodeBase = true;
        else if (nextOption.Name.Equals("unregister"))
          Options.m_bRegister = false;
        else if (nextOption.Name.Equals("registered"))
          Options.m_Flags |= TypeLibExporterFlags.OnlyReferenceRegistered;
        else if (nextOption.Name.Equals("asmpath"))
          Options.m_strAsmPath = Options.m_strAsmPath != null ? Options.m_strAsmPath + ";" + nextOption.Value : nextOption.Value;
        else if (nextOption.Name.Equals("nologo"))
          Options.m_bNoLogo = true;
        else if (nextOption.Name.Equals("silent"))
        {
          Output.SetSilent(true);
          Options.m_bSilentMode = true;
        }
        else if (nextOption.Name.Equals("verbose"))
        {
          Options.m_bVerboseMode = true;
        }
        else
        {
          if (nextOption.Name.Equals("?") || nextOption.Name.Equals("help"))
          {
            Microsoft.Tools.RegAsm.RegAsm.PrintUsage();
            ReturnCode = 0;
            return false;
          }
          Microsoft.Tools.RegAsm.RegAsm.PrintLogo();
          Output.WriteError(Resource.FormatString("Err_InvalidOption"));
          ReturnCode = 100;
          return false;
        }
      }
      if (!Options.m_bRegister && Options.m_bRegFileSpecified)
      {
        Microsoft.Tools.RegAsm.RegAsm.PrintLogo();
        Output.WriteError(Resource.FormatString("Err_CannotGenRegFileForUnregister"));
        ReturnCode = 100;
        return false;
      }
      if (Options.m_bTypeLibSpecified && Options.m_bRegFileSpecified)
      {
        Microsoft.Tools.RegAsm.RegAsm.PrintLogo();
        Output.WriteError(Resource.FormatString("Err_CannotGenRegFileAndExpTlb"));
        ReturnCode = 100;
        return false;
      }
      if (Options.m_strAsmPath != null && !Options.m_bRegFileSpecified)
      {
        Microsoft.Tools.RegAsm.RegAsm.PrintLogo();
        Output.WriteError(Resource.FormatString("Err_AsmPathCanOnlyBeUsedWithRegFile"));
        ReturnCode = 100;
        return false;
      }
      if (Options.m_strAssemblyName != null)
        return true;
      Microsoft.Tools.RegAsm.RegAsm.PrintLogo();
      Output.WriteError(Resource.FormatString("Err_NoInputFile"));
      ReturnCode = 100;
      return false;
    }

    private static void PrintLogo()
    {
      if (Microsoft.Tools.RegAsm.RegAsm.s_Options.m_bNoLogo)
        return;
      Output.WriteInfo(Resource.FormatString("Msg_Copyright", (object) "2.0.50727.42"));
    }

    private static void PrintUsage()
    {
      Microsoft.Tools.RegAsm.RegAsm.PrintLogo();
      string str = "Msg_Usage_";
      string message = "temp";
      int num = 0;
      while (message != null)
      {
        message = Resource.GetStringIfExists(num >= 10 ? str + (object) num : str + "0" + (object) num);
        if (message != null)
          Output.WriteInfo(message);
        ++num;
      }
    }

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    internal static extern int SearchPath(
      string path,
      string fileName,
      string extension,
      int numBufferChars,
      StringBuilder buffer,
      int[] filePart);

    [DllImport("oleaut32.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
    private static extern void LoadTypeLibEx(
      string strTypeLibName,
      REGKIND regKind,
      out ITypeLib TypeLib);
  }
}
