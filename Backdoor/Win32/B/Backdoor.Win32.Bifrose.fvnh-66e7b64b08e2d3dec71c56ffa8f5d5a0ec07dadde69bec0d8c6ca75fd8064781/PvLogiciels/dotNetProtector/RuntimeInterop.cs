// Decompiled with JetBrains decompiler
// Type: PvLogiciels.dotNetProtector.RuntimeInterop
// Assembly: WindowsApplication2, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D5C71B5F-F461-47E0-84D8-7434506C39DF
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Backdoor.Win32.Bifrose.fvnh-66e7b64b08e2d3dec71c56ffa8f5d5a0ec07dadde69bec0d8c6ca75fd8064781.exe

using \u0081Ç;
using \u0082\u00B6;
using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

namespace PvLogiciels.dotNetProtector
{
  public class RuntimeInterop : IRuntime
  {
    internal Assembly[] \u0081\u00A5;
    internal Assembly \u0081\u00A1;
    internal string \u0081\u009F;

    private static unsafe byte* ñ(Assembly _param0) => (byte*) Marshal.GetHINSTANCE(_param0.GetLoadedModules()[0]).ToPointer();

    internal RuntimeInterop() => this.\u0081\u00A5 = new Assembly[0];

    internal unsafe Assembly \u0081ê(IntPtr _param1)
    {
      int id = AppDomain.CurrentDomain.Id;
      byte* numPtr = (byte*) \u0082µ.\u0081\u0098(_param1.ToPointer());
      if ((IntPtr) numPtr == IntPtr.Zero)
        return (Assembly) null;
      IntPtr ptr = (IntPtr) (void*) numPtr;
      _param1 = ptr;
      int num1 = Marshal.ReadInt32(ptr);
      int length1 = Marshal.ReadInt32(_param1, 4);
      int length2 = Marshal.ReadInt32(_param1, 8);
      IntPtr source1 = (IntPtr) (void*) (numPtr + 12);
      IntPtr source2 = (IntPtr) (void*) (numPtr + length1 + 12);
      byte[] numArray = new byte[length1];
      byte[] destination = numArray;
      int length3 = length1;
      Marshal.Copy(source1, destination, 0, length3);
      Assembly assembly;
      if (length2 != 0)
      {
        byte[] rawSymbolStore = new byte[length2];
        Marshal.Copy(source2, numArray, 0, length2);
        assembly = Assembly.Load(numArray, rawSymbolStore);
      }
      else
        assembly = Assembly.Load(numArray);
      Marshal.FreeCoTaskMem(_param1);
      if ((object) assembly != null && num1 >= 0)
      {
        Type[] types = assembly.GetTypes();
        IntPtr num2 = types[types.Length - 1].TypeHandle.Value;
        \u0082µ.\u0081\u009A((byte*) Marshal.GetHINSTANCE(assembly.GetLoadedModules()[0]).ToPointer(), num2.ToPointer(), num1, id);
      }
      return assembly;
    }

    internal static unsafe void \u0081Ô(Assembly _param0)
    {
      string assemblyString = PvLogiciels.dotNetProtector.Runtime.GetAssemblyString(_param0);
      IntPtr ptr = IntPtr.Zero;
      if (assemblyString != (string) null)
        ptr = Marshal.StringToCoTaskMemAnsi(assemblyString);
      \u0082µ.\u0081\u009A((byte*) Marshal.GetHINSTANCE(_param0.GetLoadedModules()[0]).ToPointer(), (void*) 0, (int*) 0, (sbyte*) ptr.ToPointer(), AppDomain.CurrentDomain.Id);
      if (!(ptr != IntPtr.Zero))
        return;
      Marshal.FreeCoTaskMem(ptr);
    }

    public static IRuntime InitRuntime()
    {
      RuntimeInterop runtimeInterop = new RuntimeInterop();
      if (AppDomain.CurrentDomain.IsDefaultAppDomain())
      {
        AppDomain.CurrentDomain.ProcessExit += new EventHandler(RuntimeInterop.AppDomain_ProcessExit);
        return (IRuntime) runtimeInterop;
      }
      AppDomain.CurrentDomain.DomainUnload += new EventHandler(new \u0081Ú(AppDomain.CurrentDomain, AppDomain.CurrentDomain.Id).\u0081\u009E);
      return (IRuntime) runtimeInterop;
    }

    public static void AppDomain_ProcessExit(object sender, EventArgs e)
    {
      GC.Collect();
      GC.WaitForPendingFinalizers();
      \u0082µ.\u0081\u00A0();
    }

    public virtual void NGenInitRuntime()
    {
    }

    public virtual Assembly GetEntryAssembly()
    {
      if ((object) \u0081ã.\u0081\u00B6 != null)
        return \u0081ã.\u0081\u00B6;
      Assembly entryAssembly = Assembly.GetEntryAssembly();
      if ((object) entryAssembly != null)
      {
        \u0081ã.\u0081\u00B6 = entryAssembly;
        return entryAssembly;
      }
      Assembly executingAssembly = Assembly.GetExecutingAssembly();
      if (executingAssembly.FullName.StartsWith("PvLogiciels.dotNetProtector.Runtime"))
        return (Assembly) null;
      \u0081ã.\u0081\u00B6 = executingAssembly;
      return executingAssembly;
    }

    public virtual ulong GetComputerHash() => \u0082µ.\u0081\u00A9();

    public virtual void UnloadAppdomain(AppDomain domain)
    {
      int id = domain.Id;
      AppDomain.Unload(domain);
      \u0082µ.ü(id);
    }

    public virtual int UnloadDomain() => \u0082µ.ü(AppDomain.CurrentDomain.Id);

    public virtual unsafe int InitModule(Type pReserved1, IntPtr pReserved2, string Reserved3)
    {
      IntPtr ptr = IntPtr.Zero;
      if (Reserved3 != (string) null)
        ptr = Marshal.StringToCoTaskMemAnsi(Reserved3);
      IntPtr num1 = pReserved1.TypeHandle.Value;
      int num2 = \u0082µ.\u0081\u009A((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer(), num1.ToPointer(), (int*) pReserved2.ToPointer(), (sbyte*) ptr.ToPointer(), AppDomain.CurrentDomain.Id);
      if (ptr != IntPtr.Zero)
        Marshal.FreeCoTaskMem(ptr);
      if (num2 == 2)
      {
        this.\u0081\u00A1 = pReserved1.Assembly;
        this.\u0081\u009F = pReserved1.Assembly.GetName().Name;
        int length = \u0082µ.\u0081\u00AD();
        if (length != 0)
        {
          this.\u0081\u00A5 = new Assembly[length];
          int index = 0;
          if (0 < length)
          {
            do
            {
              this.\u0081\u00A5[index] = (Assembly) null;
              ++index;
            }
            while (index < length);
          }
        }
      }
      return num2;
    }

    public virtual unsafe string DesignLicenseKey(Type pReserved1, string pReserved2)
    {
      IntPtr ptr = Marshal.AllocCoTaskMem(IntPtr.Size);
      IntPtr coTaskMemAnsi = Marshal.StringToCoTaskMemAnsi(pReserved2);
      \u0082µ.\u0081\u00B2((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer(), (sbyte*) coTaskMemAnsi.ToPointer(), (sbyte**) ptr.ToPointer());
      IntPtr num = Marshal.ReadIntPtr(ptr);
      string str = (string) null;
      if (num != IntPtr.Zero)
      {
        string stringAnsi = Marshal.PtrToStringAnsi(num);
        Marshal.FreeHGlobal(num);
        str = stringAnsi;
      }
      Marshal.FreeCoTaskMem(ptr);
      if (!(coTaskMemAnsi != IntPtr.Zero))
        return str;
      Marshal.FreeCoTaskMem(coTaskMemAnsi);
      return str;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool SameSoftware(Assembly pReserved, IntPtr pSoft, ulong SwMajor)
    {
      int num;
      if (\u0082µ.\u0081\u00B7((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pSoft.ToPointer(), SwMajor, &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    public virtual unsafe int HardwareScore(Assembly pReserved, ulong HwConfig1, ulong HwConfig2)
    {
      int num;
      if (\u0082µ.\u0081À((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), HwConfig1, HwConfig2, &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num;
    }

    public virtual unsafe IntPtr GenProductKey(
      Assembly pReserved,
      IntPtr pKeys,
      uint LicenseID,
      ulong data)
    {
      sbyte* numPtr;
      if (\u0082µ.\u0081Æ((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), LicenseID, data, &numPtr) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) numPtr;
    }

    public virtual unsafe IntPtr GenProductKey(
      Assembly pReserved,
      IntPtr pKeys,
      uint LicenseID)
    {
      sbyte* numPtr;
      if (\u0082µ.\u0081Æ((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), LicenseID, &numPtr) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) numPtr;
    }

    public virtual unsafe uint GetLicenseId(Assembly pReserved, IntPtr pProductKey)
    {
      uint licenseId;
      if (\u0082µ.\u0081Ì((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pProductKey.ToPointer(), &licenseId) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return licenseId;
    }

    public virtual unsafe ulong GetProductkeyData(Assembly pReserved, IntPtr pProductKey)
    {
      uint num;
      ulong productkeyData;
      if (\u0082µ.\u0081Ì((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pProductKey.ToPointer(), &num, &productkeyData) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return productkeyData;
    }

    public virtual unsafe IntPtr DecodeActivationString(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr pActivationString)
    {
      byte* numPtr;
      if (\u0082µ.\u0081\u008D((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), (sbyte*) pActivationString.ToPointer(), &numPtr) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) numPtr;
    }

    public virtual unsafe IntPtr EncodeActivationRequest(Assembly pReserved, IntPtr preq)
    {
      sbyte* numPtr;
      if (\u0082µ.\u0081\u0096((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), preq.ToPointer(), &numPtr) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) numPtr;
    }

    public virtual unsafe IntPtr GetConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration)
    {
      sbyte* config;
      if (\u0082µ.\u0081å((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, &config) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) config;
    }

    public virtual unsafe IntPtr GetConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration,
      IntPtr pAssemblyFile)
    {
      sbyte* config;
      if (\u0082µ.\u0081å((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, (sbyte*) pAssemblyFile.ToPointer(), &config) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) config;
    }

    public virtual unsafe IntPtr GetConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration,
      AssemblyName Name)
    {
      string name = Name.Name;
      byte[] bytes = Encoding.UTF8.GetBytes(string.Concat((object) "\0"));
      GCHandle gcHandle = GCHandle.Alloc((object) bytes, GCHandleType.Pinned);
      IntPtr num1 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) bytes, 0);
      sbyte* config;
      int num2 = \u0082µ.\u0081å((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, (byte*) num1.ToPointer(), (ushort) Name.Version.Major, (ushort) Name.Version.Minor, &config);
      gcHandle.Free();
      if (num2 == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) config;
    }

    public virtual unsafe IntPtr GetUsbConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration,
      ulong UsbHash,
      ulong UsbIdentity)
    {
      sbyte* usbConfig;
      if (\u0082µ.\u0081ï((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, UsbHash, UsbIdentity, &usbConfig) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbConfig;
    }

    public virtual unsafe IntPtr GetUsbConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration,
      ulong UsbHash,
      ulong UsbIdentity,
      IntPtr pAssemblyFile)
    {
      sbyte* usbConfig;
      if (\u0082µ.\u0081ï((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, UsbHash, UsbIdentity, (sbyte*) pAssemblyFile.ToPointer(), &usbConfig) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbConfig;
    }

    public virtual unsafe IntPtr GetUsbConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration,
      ulong UsbHash,
      ulong UsbIdentity,
      AssemblyName Name)
    {
      string name = Name.Name;
      byte[] bytes = Encoding.UTF8.GetBytes(string.Concat((object) "\0"));
      GCHandle gcHandle = GCHandle.Alloc((object) bytes, GCHandleType.Pinned);
      IntPtr num1 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) bytes, 0);
      sbyte* usbConfig;
      int num2 = \u0082µ.\u0081ï((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, UsbHash, UsbIdentity, (byte*) num1.ToPointer(), (ushort) Name.Version.Major, (ushort) Name.Version.Minor, &usbConfig);
      gcHandle.Free();
      if (num2 == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbConfig;
    }

    public virtual unsafe IntPtr GenerateLicense(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr preq)
    {
      sbyte* license;
      if (\u0082µ.\u0081ô((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), preq.ToPointer(), &license) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) license;
    }

    public virtual unsafe IntPtr GenerateLicense(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr preq,
      int tolerance,
      [MarshalAs(UnmanagedType.U1)] bool ignoreMinor,
      long RuntimeLicensesLimit)
    {
      sbyte* license;
      if (\u0082µ.\u0081ô((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), preq.ToPointer(), tolerance, ignoreMinor ? 1 : 0, RuntimeLicensesLimit, &license) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) license;
    }

    public virtual unsafe IntPtr GenerateUsbLicense(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr preq)
    {
      sbyte* usbLicense;
      if (\u0082µ.\u0081ü((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), preq.ToPointer(), &usbLicense, (byte) 0) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbLicense;
    }

    public virtual unsafe IntPtr GenerateUsbLicense(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr preq,
      int tolerance,
      [MarshalAs(UnmanagedType.U1)] bool ignoreMinor,
      long RuntimeLicensesLimit)
    {
      sbyte* usbLicense;
      if (\u0082µ.\u0081ü((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), preq.ToPointer(), tolerance, ignoreMinor ? 1 : 0, RuntimeLicensesLimit, &usbLicense, (byte) 0) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbLicense;
    }

    public virtual unsafe Assembly ResolveAssembly(string Name)
    {
      // ISSUE: untyped stack allocation
      int num1 = (int) __untypedstackalloc(\u0082µ.ï());
      try
      {
        AssemblyName assemblyName = new AssemblyName(Name);
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        uint exceptionCode = (uint) Marshal.GetExceptionCode();
        if (\u0082µ.à((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint num2 = 0;
        \u0082µ.æ((void*) Marshal.GetExceptionPointers(), (void*) num1);
        try
        {
          try
          {
            return (Assembly) null;
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            num2 = (uint) \u0082µ.ê((void*) Marshal.GetExceptionPointers());
            if (num2 != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          if (num2 != 0U)
            throw;
        }
        finally
        {
          \u0082µ.\u00B9((void*) num1, (int) num2);
        }
      }
      byte[] bytes = Encoding.UTF8.GetBytes(Name);
      GCHandle gcHandle = GCHandle.Alloc((object) bytes, GCHandleType.Pinned);
      IntPtr num3 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) bytes, 0);
      int index = \u0082µ.\u0082\u0084(num3.ToPointer());
      if (index >= 0)
      {
        Assembly[] assemblyArray = this.\u0081\u00A5;
        if (index < assemblyArray.Length)
        {
          if ((object) assemblyArray[index] == null)
            this.\u0081\u00A5[index] = this.\u0081ê(num3);
          gcHandle.Free();
          return this.\u0081\u00A5[index];
        }
      }
      gcHandle.Free();
      return new AssemblyName(Name).Name == this.\u0081\u009F ? this.\u0081\u00A1 : (Assembly) null;
    }

    public virtual int ExecuteEmbLockAssembly(Type pReserved1, int Reserved2) => \u0081È.\u0081Þ(pReserved1.Assembly, Reserved2);

    public virtual unsafe Assembly GetEmbLockAssembly(Type pReserved1)
    {
      byte* numPtr = (byte*) \u0082µ.\u0081\u0083((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer());
      if ((IntPtr) numPtr == IntPtr.Zero)
        return (Assembly) null;
      IntPtr ptr = (IntPtr) (void*) numPtr;
      int length1 = Marshal.ReadInt32(ptr);
      IntPtr source = (IntPtr) (void*) (numPtr + 4);
      byte[] rawAssembly = new byte[length1];
      byte[] destination = rawAssembly;
      int length2 = length1;
      Marshal.Copy(source, destination, 0, length2);
      Assembly embLockAssembly = Assembly.Load(rawAssembly);
      Marshal.FreeCoTaskMem(ptr);
      return embLockAssembly;
    }

    public virtual unsafe Assembly GetEmbLockAssemblyName(Type pReserved1)
    {
      byte* numPtr = (byte*) \u0082µ.Ë((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer());
      if ((IntPtr) numPtr == IntPtr.Zero)
        return (Assembly) null;
      IntPtr ptr = (IntPtr) (void*) numPtr;
      string stringAnsi = Marshal.PtrToStringAnsi(ptr);
      Marshal.FreeCoTaskMem(ptr);
      Assembly lockAssemblyName = (Assembly) null;
      try
      {
        lockAssemblyName = Assembly.Load(stringAnsi);
      }
      catch (Exception ex)
      {
      }
      return lockAssemblyName;
    }

    public virtual unsafe ArrayList GetEmbLockAssemblyServices(Type pReserved1)
    {
      byte* ptr1 = (byte*) \u0082µ.\u0082\u008E((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer());
      if ((IntPtr) ptr1 == IntPtr.Zero)
        return (ArrayList) null;
      IntPtr ptr2 = (IntPtr) (void*) ptr1;
      ArrayList assemblyServices = new ArrayList();
      if (*ptr1 != (byte) 0)
      {
        do
        {
          string stringAnsi = Marshal.PtrToStringAnsi((IntPtr) (void*) ptr1);
          assemblyServices.Add((object) stringAnsi);
          ptr1 = (byte*) (stringAnsi.Length + (IntPtr) ptr1 + 1);
        }
        while (*ptr1 != (byte) 0);
      }
      Marshal.FreeCoTaskMem(ptr2);
      return assemblyServices;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool ProductKeyChecksumIsOk(Assembly pReserved, IntPtr pString)
    {
      int num;
      if (\u0082µ.\u0082\u0098((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pString.ToPointer(), &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool ConfigStringChecksumIsOk(Assembly pReserved, IntPtr pString)
    {
      int num;
      if (\u0082µ.\u0081\u00D7((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pString.ToPointer(), &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool LicenseKeyChecksumIsOk(Assembly pReserved, IntPtr pString)
    {
      int num;
      if (\u0082µ.\u0082\u00AC((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pString.ToPointer(), &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool IsDemo(Assembly pReserved)
    {
      int num;
      if (\u0082µ.\u0082\u00B1((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    public virtual unsafe int DaysLeft(Assembly pReserved)
    {
      int num;
      return \u0082µ.\u0081((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), &num) != 0 ? num : throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
    }

    public virtual unsafe int MinutesLeft(Assembly pReserved)
    {
      int num;
      return \u0082µ.\u0087((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), &num) != 0 ? num : throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
    }

    public virtual unsafe uint GetProductID(Assembly pReserved) => \u0082µ.\u0081ö((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer());

    public virtual unsafe IntPtr StartUsbDetect() => (IntPtr) \u0082µ.\u0091();

    public virtual unsafe void EndUsbDetect(IntPtr handle) => \u0082µ.\u0094(handle.ToPointer());

    public virtual unsafe IntPtr LoadNativeLibrary(Assembly pReserved, IntPtr[] pointers)
    {
      GCHandle gcHandle = GCHandle.Alloc((object) pointers, GCHandleType.Pinned);
      IntPtr num1 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) pointers, 0);
      IntPtr num2 = (IntPtr) \u0082µ.\u009B((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (void**) num1.ToPointer());
      gcHandle.Free();
      return num2;
    }

    public virtual unsafe void FreeNativeLibrary(IntPtr pLib) => \u0082µ.\u009D(pLib.ToPointer());

    public virtual StackFrame[] GetFrames(StackTrace trace) => trace == null ? new StackFrame[0] : trace.GetFrames();

    public virtual unsafe void EncodeTrace(Guid[] Guids, long[] Indexes, IntPtr[] Handles)
    {
      GCHandle gcHandle1 = GCHandle.Alloc((object) Guids, GCHandleType.Pinned);
      GCHandle gcHandle2 = GCHandle.Alloc((object) Indexes, GCHandleType.Pinned);
      GCHandle gcHandle3 = GCHandle.Alloc((object) Handles, GCHandleType.Pinned);
      IntPtr num1 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) Guids, 0);
      IntPtr num2 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) Indexes, 0);
      IntPtr num3 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) Handles, 0);
      \u0082µ.\u00A1(Handles.Length, num3.ToPointer(), num2.ToPointer(), num1.ToPointer());
      gcHandle1.Free();
      gcHandle2.Free();
      gcHandle3.Free();
    }
  }
}
