// Decompiled with JetBrains decompiler
// Type: Aura.Protection.INT.AddIntPhase
// Assembly: Kudeta Crypter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 16F9F4AC-EE0C-4DE1-A1E6-B297F2D4338B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-VirTool.MSIL.Crypto.gen-a09f476c823deb3aadbd99b5e979f18689723f0ab3b5690e0b9a42cf2007f2a8.exe

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;

namespace Aura.Protection.INT
{
  public static class AddIntPhase
  {
    public static void Execute2(ModuleDef md)
    {
      foreach (TypeDef type in md.GetTypes())
      {
        if (!type.IsGlobalModuleType)
        {
          foreach (MethodDef method in (IEnumerable<MethodDef>) type.Methods)
          {
            if (method.HasBody)
            {
              for (int index = 0; index < ((ICollection<Instruction>) method.Body.Instructions).Count; ++index)
              {
                if (method.Body.Instructions[index].IsLdcI4())
                {
                  int num1 = new Random(Guid.NewGuid().GetHashCode()).Next();
                  int num2 = new Random(Guid.NewGuid().GetHashCode()).Next();
                  int num3 = num1 ^ num2;
                  Instruction instruction = OpCodes.Nop.ToInstruction();
                  Local local = new Local(method.Module.ImportAsTypeSig(typeof (int)));
                  method.Body.Variables.Add(local);
                  method.Body.Instructions.Insert(index + 1, OpCodes.Stloc.ToInstruction(local));
                  method.Body.Instructions.Insert(index + 2, Instruction.Create(OpCodes.Ldc_I4, method.Body.Instructions[index].GetLdcI4Value() - 4));
                  method.Body.Instructions.Insert(index + 3, Instruction.Create(OpCodes.Ldc_I4, num3));
                  method.Body.Instructions.Insert(index + 4, Instruction.Create(OpCodes.Ldc_I4, num2));
                  method.Body.Instructions.Insert(index + 5, Instruction.Create(OpCodes.Xor));
                  method.Body.Instructions.Insert(index + 6, Instruction.Create(OpCodes.Ldc_I4, num1));
                  method.Body.Instructions.Insert(index + 7, Instruction.Create(OpCodes.Bne_Un, instruction));
                  method.Body.Instructions.Insert(index + 8, Instruction.Create(OpCodes.Ldc_I4, 2));
                  method.Body.Instructions.Insert(index + 9, OpCodes.Stloc.ToInstruction(local));
                  method.Body.Instructions.Insert(index + 10, Instruction.Create(OpCodes.Sizeof, method.Module.Import(typeof (float))));
                  method.Body.Instructions.Insert(index + 11, Instruction.Create(OpCodes.Add));
                  method.Body.Instructions.Insert(index + 12, instruction);
                  index += 12;
                }
              }
              method.Body.SimplifyBranches();
            }
          }
        }
      }
    }
  }
}
