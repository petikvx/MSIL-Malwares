// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Protected, Version=6.2.8400.0, Culture=neutral, PublicKeyToken=null
// MVID: 52CBE997-50C3-42B2-A704-C908D57869A5
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Backdoor.Win32.Generic-2a8dca5794c095ea67845468a3fd0a8e91a24bf3f0bb5e0ec6c16a6579cc4e90.exe

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using System.Text;

internal sealed class \uE01C : IDisposable
{
  public BinaryReader \uE000;
  private string[] \uE001;
  private \uE028[] \uE002;
  private \uE026[] \uE003;
  private string[] \uE004;

  public \uE01C(Stream _param1)
  {
    this.\uE000 = new BinaryReader(_param1, (Encoding) new UTF8Encoding(false, true));
    if ((!this.\uE000() ? 0 : 1) == 0)
      throw new InvalidOperationException();
  }

  ~\uE01C() => this.\uE000(false);

  private void \uE000(bool _param1)
  {
    if (!_param1)
      return;
    this.\uE000.Close();
  }

  public void Dispose()
  {
    this.\uE000(true);
    GC.SuppressFinalize((object) this);
  }

  public \uE018 \uE000(int _param1)
  {
    long offset = (long) (_param1 ^ 7664793);
label_2:
    int num1 = \uE000.\uE000(48);
    \uE018 obj;
    while (true)
    {
      int index;
      string str;
      int length;
      switch ((num1 ^ 57) + 66)
      {
        case 0:
          length = this.\uE000();
          num1 = -2;
          continue;
        case 1:
          obj.\uE003 = this.\uE000();
          num1 = -121;
          continue;
        case 2:
          index = 0;
          num1 = -15;
          continue;
        case 3:
label_6:
          obj.\uE001[index] = this.\uE000();
          num1 = -16;
          continue;
        case 4:
          this.\uE000.BaseStream.Seek(offset, SeekOrigin.Begin);
          num1 = -4;
          continue;
        case 5:
          obj.\uE000 = (int) this.\uE000.ReadUInt16();
          num1 = -122;
          continue;
        case 6:
          obj = new \uE018(str);
          num1 = -1;
          continue;
        case 7:
          str = this.\uE014(this.\uE000());
          num1 = -3;
          continue;
        case 8:
          this.\uE000((\uE000) obj);
          num1 = -6;
          continue;
        case 9:
          obj.\uE001 = new \uE028[length];
          num1 = -7;
          continue;
        case 10:
          if (index != 0)
          {
            num1 = -8;
            continue;
          }
          break;
        case 11:
          ++index;
          break;
        default:
          goto label_2;
      }
      if (index < length)
        goto label_6;
      else
        break;
    }
    int length1 = this.\uE000();
    \uE016[] objArray = new \uE016[length1];
    if (length1 > 0)
    {
      int index = 0;
      if (index == 0)
        goto label_20;
label_19:
      objArray[index] = this.\uE000(obj.\uE004);
      ++index;
label_20:
      if (index < length1)
        goto label_19;
    }
    obj.\uE002 = objArray;
label_23:
    int num2 = \uE01D.\uE000(54);
    while (true)
    {
      switch (num2 ^ 57)
      {
        case 56:
          obj.\uE006 = this;
          num2 = 3;
          continue;
        case 57:
          obj.\uE004 = this.\uE000.BaseStream.Position;
          num2 = 1;
          continue;
        case 58:
          goto label_26;
        default:
          goto label_23;
      }
    }
label_26:
    return obj;
  }

  public string \uE013(int _param1) => this.\uE004 == null ? string.Empty : this.\uE004[_param1 - 1];

  private \uE000 \uE000()
  {
    \uE000 obj = new \uE000(this.\uE014(this.\uE000()));
    this.\uE000(obj);
    return obj;
  }

  private void \uE000(\uE000 _param1)
  {
    ((\uE021) _param1).\uE001 = this.\uE000();
label_2:
    int num1 = \uE000.\uE000(46);
    while (true)
    {
      switch (num1 ^ 58)
      {
        case 61:
          _param1.\uE000 = (int) this.\uE000.ReadByte();
          num1 = 5;
          continue;
        case 62:
          _param1.\uE003 = this.\uE000();
          num1 = 122;
          continue;
        case 63:
          if (_param1.\uE003)
          {
            num1 = 123;
            continue;
          }
          goto label_10;
        case 64:
          _param1.\uE001 = this.\uE000();
          num1 = \uE026.\uE000(44);
          continue;
        case 65:
          goto label_9;
        default:
          goto label_2;
      }
    }
label_9:
    int num2 = 0;
    goto label_11;
label_10:
    num2 = 1;
label_11:
    if (num2 != 0)
      return;
    _param1.\uE002 = this.\uE000();
  }

  private \uE028[] \uE000()
  {
    int length = this.\uE000();
label_2:
    int num = \uE01D.\uE000(57);
    \uE028[] objArray;
    while (true)
    {
      int index;
      switch (num ^ 63)
      {
        case 64:
          if (index != 0)
          {
            num = 124;
            continue;
          }
          break;
        case 65:
          index = 0;
          num = (int) sbyte.MaxValue;
          continue;
        case 66:
          objArray = new \uE028[length];
          num = \uE01D.\uE000(66);
          continue;
        case 67:
label_7:
          objArray[index] = this.\uE000();
          num = 123;
          continue;
        case 68:
          ++index;
          break;
        default:
          goto label_2;
      }
      if (index < length)
        goto label_7;
      else
        break;
    }
    return objArray;
  }

  private \uE016 \uE000(bool _param1)
  {
    \uE016 obj = new \uE016();
label_2:
    int num = \uE01D.\uE000(71);
    while (true)
    {
      switch ((num ^ 59) + 64)
      {
        case 0:
          obj.\uE006 = this.\uE000();
          num = -4;
          continue;
        case 1:
          obj.\uE001 = this.\uE000();
          num = -3;
          continue;
        case 2:
          obj.\uE000 = (int) this.\uE000.ReadByte();
          num = \uE000.\uE000(50);
          continue;
        case 3:
          obj.\uE005 = this.\uE000();
          num = -5;
          continue;
        case 4:
          obj.\uE003 = this.\uE000();
          num = -2;
          continue;
        case 5:
          obj.\uE004 = this.\uE000();
          num = -8;
          continue;
        case 6:
          obj.\uE002 = this.\uE000();
          num = -1;
          continue;
        case 7:
          goto label_10;
        default:
          goto label_2;
      }
    }
label_10:
    return obj;
  }

  private int[] \uE000()
  {
    int length = this.\uE000();
label_2:
    int num = \uE026.\uE000(44);
    long index;
    int[] numArray;
    while (true)
    {
      switch (num ^ 69)
      {
        case 66:
          numArray = new int[length];
          num = 6;
          continue;
        case 67:
          index = 0L;
          num = 1;
          continue;
        case 68:
          goto label_6;
        default:
          goto label_2;
      }
    }
label_6:
    for (; index < (long) length; ++index)
      numArray[index] = this.\uE000.ReadInt32();
    return numArray;
  }

  private \uE01A \uE000()
  {
    \uE01A obj = new \uE01A();
label_2:
    int num = \uE026.\uE000(28);
    while (true)
    {
      switch ((num ^ 70) + 68)
      {
        case 0:
          obj.\uE002 = (CallingConvention) this.\uE000.ReadInt32();
          num = \uE01D.\uE000(71);
          continue;
        case 1:
          obj.\uE000 = this.\uE000();
          num = -6;
          continue;
        case 2:
          obj.\uE001 = this.\uE000();
          num = -5;
          continue;
        case 3:
          goto label_6;
        default:
          goto label_2;
      }
    }
label_6:
    return obj;
  }

  private \uE028 \uE000() => this.\uE000(this.\uE000());

  private \uE025 \uE000()
  {
    \uE025 obj = new \uE025(this.\uE014(this.\uE000()));
    obj.\uE001 = this.\uE000();
    return obj;
  }

  private bool \uE000()
  {
    if (this.\uE000.BaseStream.Length < 20L)
      return false;
    this.\uE000.BaseStream.Seek(-20L, SeekOrigin.End);
label_4:
    int num1 = \uE000.\uE000(40);
    uint num2;
    while (true)
    {
      switch (num1 ^ 69)
      {
        case 75:
          num2 = this.\uE000.ReadUInt32();
          num1 = 9;
          continue;
        case 76:
          if (num2 != 16826042U)
          {
            num1 = 8;
            continue;
          }
          goto label_9;
        case 77:
          goto label_8;
        default:
          goto label_4;
      }
    }
label_8:
    return false;
label_9:
    long num3 = (long) this.\uE000.ReadInt32();
label_11:
    int num4 = \uE026.\uE000(39);
    long num5;
    long num6;
    long num7;
    while (true)
    {
      switch (num4 ^ 70)
      {
        case 75:
          this.\uE013(num3);
          num4 = 20;
          continue;
        case 76:
          num5 = (long) this.\uE000.ReadInt32();
          num4 = 23;
          continue;
        case 77:
          num6 = (long) this.\uE000.ReadInt32();
          num4 = 10;
          continue;
        case 78:
          this.\uE012(num6);
          num4 = 13;
          continue;
        case 79:
          this.\uE010(num7);
          num4 = 22;
          continue;
        case 80:
          this.\uE011(num5);
          num4 = \uE01D.\uE000(73);
          continue;
        case 81:
          num7 = (long) this.\uE000.ReadInt32();
          num4 = 9;
          continue;
        case 82:
          goto label_19;
        default:
          goto label_11;
      }
    }
label_19:
    return true;
  }

  private void \uE010(long _param1)
  {
    this.\uE000.BaseStream.Seek(_param1, SeekOrigin.Begin);
label_2:
    int num = \uE000.\uE000(52);
    while (true)
    {
      int length;
      int index;
      switch ((num ^ 70) + 76)
      {
        case 0:
          index = 0;
          num = -2;
          continue;
        case 1:
          this.\uE001 = new string[length];
          num = -14;
          continue;
        case 2:
          length = this.\uE000();
          num = -13;
          continue;
        case 3:
label_6:
          this.\uE001[index] = this.\uE000.ReadString();
          num = \uE016.\uE000(68);
          continue;
        case 4:
          if (index != 0)
          {
            num = -15;
            continue;
          }
          break;
        case 5:
          ++index;
          break;
        default:
          goto label_2;
      }
      if (index < length)
        goto label_6;
      else
        break;
    }
  }

  private void \uE011(long _param1)
  {
    this.\uE000.BaseStream.Seek(_param1, SeekOrigin.Begin);
label_2:
    int num = \uE026.\uE000(31);
    while (true)
    {
      int length;
      int index;
      switch (num ^ 73)
      {
        case 67:
          index = 0;
          num = \uE000.\uE000(40);
          continue;
        case 68:
          this.\uE003 = new \uE026[length];
          num = 10;
          continue;
        case 69:
          length = this.\uE000();
          num = 13;
          continue;
        case 70:
label_6:
          this.\uE003[index] = new \uE026(this.\uE014(this.\uE000()));
          num = 1;
          continue;
        case 71:
          if (index != 0)
          {
            num = 15;
            continue;
          }
          break;
        case 72:
          ++index;
          break;
        default:
          goto label_2;
      }
      if (index < length)
        goto label_6;
      else
        break;
    }
  }

  private void \uE012(long _param1)
  {
    this.\uE000.BaseStream.Seek(_param1, SeekOrigin.Begin);
label_2:
    int num1 = \uE000.\uE000(50);
    Dictionary<\uE01E, ArrayList> dictionary;
    while (true)
    {
      int index;
      int num2;
      int num3;
      switch ((num1 ^ 66) + 74)
      {
        case 0:
          this.\uE002[index] = this.\uE000(num2, index, (IDictionary<\uE01E, ArrayList>) dictionary);
          num1 = -1;
          continue;
        case 1:
          this.\uE002 = new \uE028[num3 + 1];
          num1 = -2;
          continue;
        case 2:
          num3 = this.\uE000();
          num1 = -11;
          continue;
        case 3:
label_6:
          num2 = (int) this.\uE000.ReadByte();
          num1 = -12;
          continue;
        case 4:
          index = 1;
          num1 = -7;
          continue;
        case 5:
          if (index == 0)
          {
            num1 = -5;
            continue;
          }
          break;
        case 6:
          dictionary = new Dictionary<\uE01E, ArrayList>();
          num1 = -8;
          continue;
        case 7:
          ++index;
          break;
        default:
          goto label_2;
      }
      if (index <= num3)
        goto label_6;
      else
        break;
    }
    using (Dictionary<\uE01E, ArrayList>.Enumerator enumerator1 = dictionary.GetEnumerator())
    {
      while ((!enumerator1.MoveNext() ? 0 : 1) != 0)
      {
        KeyValuePair<\uE01E, ArrayList> current1 = enumerator1.Current;
        IEnumerator enumerator2 = current1.Value.GetEnumerator();
        try
        {
          while ((!enumerator2.MoveNext() ? 0 : 1) != 0)
          {
            KeyValuePair<int, int> current2 = (KeyValuePair<int, int>) enumerator2.Current;
            current1.Key.\uE001[current2.Key] = this.\uE000(current2.Value);
          }
        }
        finally
        {
          if ((!(enumerator2 is IDisposable disposable) ? 1 : 0) == 0)
            disposable.Dispose();
        }
      }
    }
  }

  private void \uE013(long _param1)
  {
    this.\uE000.BaseStream.Seek(_param1, SeekOrigin.Begin);
label_2:
    int num = \uE026.\uE000(30);
    while (true)
    {
      int length;
      int index;
      switch (num ^ 72)
      {
        case 71:
          this.\uE004 = new string[length];
          num = 3;
          continue;
        case 72:
          if (length > 0)
          {
            num = 15;
            continue;
          }
          goto label_11;
        case 73:
          length = this.\uE000();
          num = \uE01D.\uE000(54);
          continue;
        case 74:
label_7:
          this.\uE004[index] = this.\uE014(this.\uE000());
          num = 5;
          continue;
        case 75:
          index = 0;
          num = 4;
          continue;
        case 76:
          if (index != 0)
          {
            num = 2;
            continue;
          }
          break;
        case 77:
          ++index;
          break;
        default:
          goto label_2;
      }
      if (index < length)
        goto label_7;
      else
        goto label_10;
    }
label_11:
    return;
label_10:;
  }

  private \uE028 \uE000(int _param1, int _param2, IDictionary<\uE01E, ArrayList> _param3)
  {
    switch (_param1)
    {
      case 0:
        \uE028 obj = new \uE028(this.\uE014(this.\uE000()));
label_3:
        int num1 = \uE016.\uE000(65);
        while (true)
        {
          switch ((num1 ^ 76) + 72)
          {
            case 0:
              obj.\uE000 = this.\uE000(this.\uE000());
              num1 = -11;
              continue;
            case 1:
              ((\uE021) obj).\uE001 = this.\uE000(this.\uE000());
              num1 = -10;
              continue;
            case 2:
              goto label_6;
            default:
              goto label_3;
          }
        }
label_6:
        return obj;
      case 1:
        \uE01E key1 = new \uE01E(this.\uE000(this.\uE000()));
label_12:
        int num2 = \uE016.\uE000(83);
        ArrayList arrayList;
        \uE028[] objArray;
        while (true)
        {
          int key2;
          int num3;
          int length;
          switch (num2 ^ 66)
          {
            case 74:
label_13:
              num3 = this.\uE000();
              num2 = 12;
              continue;
            case 75:
              arrayList = new ArrayList();
              num2 = 18;
              continue;
            case 76:
              objArray[key2] = this.\uE000(num3);
              num2 = 17;
              continue;
            case 77:
              if (key2 != 0)
              {
                num2 = 8;
                continue;
              }
              break;
            case 78:
              if (num3 < _param2)
              {
                num2 = 14;
                continue;
              }
              arrayList.Add((object) new KeyValuePair<int, int>(key2, num3));
              goto case 83;
            case 79:
              key2 = 0;
              num2 = 15;
              continue;
            case 80:
              if (length > 0)
              {
                num2 = 19;
                continue;
              }
              goto label_30;
            case 81:
              objArray = new \uE028[length];
              num2 = 13;
              continue;
            case 82:
              length = this.\uE000();
              num2 = \uE016.\uE000(78);
              continue;
            case 83:
              ++key2;
              break;
            default:
              goto label_12;
          }
          if (key2 < length)
            goto label_13;
          else
            break;
        }
        key1.\uE001 = objArray;
        if (arrayList.Count > 0)
          _param3.Add(key1, arrayList);
label_30:
        return (\uE028) key1;
      case 2:
        return (\uE028) new \uE02A(this.\uE000(this.\uE000()));
      case 3:
        return (\uE028) new \uE015(this.\uE000(this.\uE000()), this.\uE000());
      case 4:
        return (\uE028) new \uE01B(this.\uE000(this.\uE000()));
      default:
        throw new InvalidOperationException();
    }
  }

  private int \uE000()
  {
    byte num = this.\uE000.ReadByte();
    if ((((int) num & 128) == 0 ? 0 : 1) == 0)
      return (int) num;
    return (((int) num & 64) == 0 ? 0 : 1) == 0 ? (((int) num & 63) << 8) + (int) this.\uE000.ReadByte() : (((int) num & 63) << 24) + ((int) this.\uE000.ReadByte() << 16) + ((int) this.\uE000.ReadByte() << 8) + (int) this.\uE000.ReadByte();
  }

  private string \uE014(int _param1) => this.\uE001[_param1];

  private \uE026 \uE000(int _param1) => this.\uE003[_param1];

  private \uE028 \uE000(int _param1) => this.\uE002[_param1];

  internal void \uE000(\uE018 _param1, BinaryWriter _param2, DynamicILInfo _param3)
  {
    this.\uE000.BaseStream.Seek(_param1.\uE004, SeekOrigin.Begin);
label_2:
    int num1 = \uE026.\uE000(38);
    while (true)
    {
      byte num2;
      byte num3;
      int num4;
      int num5;
      switch ((num1 ^ 74) + 78)
      {
        case 0:
          switch (num2)
          {
            case 0:
              _param2.Write(this.\uE000.ReadInt32());
              goto case 5;
            case 1:
              \uE01C.\uE000(this.\uE000(), _param2, _param3);
              goto case 5;
            case 2:
              _param2.Write(this.\uE000.ReadInt32());
              goto case 5;
            case 3:
              _param2.Write(this.\uE000.ReadInt64());
              goto case 5;
            case 4:
              \uE01C.\uE000(this.\uE000(), _param2, _param3);
              goto case 5;
            case 5:
              ++num4;
              break;
            case 6:
              _param2.Write(this.\uE000.ReadDouble());
              goto case 5;
            case 7:
              \uE01C.\uE000(this.\uE000(), _param2, _param3);
              goto case 5;
            case 8:
              string literal = this.\uE014(this.\uE000());
              int tokenFor = _param3.GetTokenFor(literal);
              _param2.Write(tokenFor);
              goto case 5;
            case 9:
              int[] numArray1 = this.\uE000();
label_31:
              int num6 = \uE016.\uE000(76);
              while (true)
              {
                int index;
                int[] numArray2;
                int num7;
                switch ((num6 ^ 86) + 79)
                {
                  case 0:
                    index = 0;
                    num6 = -29;
                    continue;
                  case 1:
                    numArray2 = numArray1;
                    num6 = -25;
                    continue;
                  case 2:
                    _param2.Write((uint) numArray1.Length);
                    num6 = -28;
                    continue;
                  case 3:
                    _param2.Write(num7);
                    num6 = -31;
                    continue;
                  case 4:
                    if (index != 0)
                    {
                      num6 = -32;
                      continue;
                    }
                    break;
                  case 5:
label_38:
                    num7 = numArray2[index];
                    num6 = \uE016.\uE000(86);
                    continue;
                  case 6:
                    ++index;
                    break;
                  default:
                    goto label_31;
                }
                if (index < numArray2.Length)
                  goto label_38;
                else
                  goto case 5;
              }
            case 10:
              this.\uE000(_param2, _param3);
              goto case 5;
            case 11:
              Type type = Type.GetType(this.\uE000().\uE009);
              _param2.Write(_param3.GetTokenFor(type.TypeHandle));
              goto case 5;
            case 12:
              _param2.Write(this.\uE000.ReadInt16());
              goto case 5;
            case 13:
              _param2.Write(this.\uE000.ReadByte());
              goto case 5;
            case 14:
              sbyte num8 = this.\uE000.ReadSByte();
              if (num8 < (sbyte) 0)
              {
                _param2.Write((byte) (256U + (uint) num8));
                goto case 5;
              }
              else
              {
                _param2.Write((byte) num8);
                goto case 5;
              }
            case 15:
              _param2.Write(this.\uE000.ReadSingle());
              goto case 5;
            case 16:
              _param2.Write(this.\uE000.ReadByte());
              goto case 5;
            default:
              num1 = -13;
              continue;
          }
          break;
        case 1:
          num4 = 0;
          num1 = \uE026.\uE000(37);
          continue;
        case 2:
          num5 = this.\uE000() ^ 100;
          num1 = -7;
          continue;
        case 3:
          num2 = num3;
          num1 = -8;
          continue;
        case 4:
label_8:
          \uE01C.ERKhpFUj(this.\uE000(), _param2);
          num1 = -3;
          continue;
        case 5:
          num3 = this.\uE000.ReadByte();
          num1 = -1;
          continue;
        case 6:
          if (num4 != 0)
          {
            num1 = -4;
            continue;
          }
          break;
        case 7:
          goto label_42;
        default:
          goto label_2;
      }
      if (num4 < num5)
        goto label_8;
      else
        goto label_41;
    }
label_42:
    throw new InvalidOperationException();
label_41:;
  }

  private void \uE000(BinaryWriter _param1, DynamicILInfo _param2)
  {
    int num1 = (int) this.\uE000.ReadByte();
label_2:
    int num2 = \uE026.\uE000(38);
    int num3;
    while (true)
    {
      switch ((num2 ^ 77) + 77)
      {
        case 0:
          num3 = num1;
          num2 = -7;
          continue;
        case 1:
          switch (num3)
          {
            case 0:
              goto label_6;
            case 1:
              goto label_8;
            case 2:
              goto label_7;
            default:
              num2 = -8;
              continue;
          }
        case 2:
          goto label_9;
        default:
          goto label_2;
      }
    }
label_6:
    Type type = Type.GetType(this.\uE000().\uE009);
    _param1.Write(_param2.GetTokenFor(type.TypeHandle));
    return;
label_7:
    \uE01C.\uE000(this.\uE000(), _param1, _param2);
    return;
label_8:
    \uE01C.\uE000(this.\uE000(), _param1, _param2);
    return;
label_9:
    throw new NotSupportedException();
  }

  private static void \uE000(\uE000 _param0, BinaryWriter _param1, DynamicILInfo _param2)
  {
    \uE028 obj = ((\uE021) _param0).\uE001;
label_2:
    int num1 = \uE000.\uE000(48);
    Type type1;
    Type[] types;
    while (true)
    {
      switch ((num1 ^ 77) + 74)
      {
        case 0:
          type1 = Type.GetType(obj.\uE009);
          num1 = -11;
          continue;
        case 1:
          if (_param0.\uE002)
          {
            num1 = \uE016.\uE000(65);
            continue;
          }
          goto label_8;
        case 2:
          types = \uE01C.\uE000(_param0.\uE001);
          num1 = -6;
          continue;
        case 3:
          goto label_7;
        default:
          goto label_2;
      }
    }
label_7:
    int num2 = 1;
    goto label_9;
label_8:
    num2 = 0;
label_9:
    BindingFlags bindingAttr = (BindingFlags) ((num2 != 0 ? 4 : 8) | 32 | 16);
    if ((!(_param0.\uE008 == ".ctor") ? 0 : 1) != 0 || (!(_param0.\uE008 == ".cctor") ? 1 : 0) == 0)
    {
      ConstructorInfo constructor = type1.GetConstructor(bindingAttr, (Binder) null, types, (ParameterModifier[]) null);
      int num3 = (!obj.\uE007 ? 0 : 1) != 0 ? _param2.GetTokenFor(constructor.MethodHandle, type1.TypeHandle) : _param2.GetTokenFor(constructor.MethodHandle);
      _param1.Write(num3);
    }
    else
    {
      Type type2 = Type.GetType(_param0.\uE003.\uE009);
      MethodInfo methodInfo = (MethodInfo) null;
      if ((!_param0.\uE003 ? 1 : 0) == 0)
      {
label_13:
        int num4 = \uE016.\uE000(85);
        Type[] typeArray;
        while (true)
        {
          switch ((num4 ^ 82) + 78)
          {
            case 0:
              typeArray = \uE01C.\uE000(_param0.\uE002);
              num4 = -26;
              continue;
            case 1:
              if (methodInfo.IsGenericMethodDefinition)
              {
                num4 = -25;
                continue;
              }
              goto label_19;
            case 2:
              methodInfo = type1.GetMethod(_param0.\uE008, bindingAttr, (Binder) new \uE027(type2, typeArray), types, (ParameterModifier[]) null);
              num4 = -31;
              continue;
            case 3:
              goto label_18;
            default:
              goto label_13;
          }
        }
label_18:
        int num5 = 0;
        goto label_20;
label_19:
        num5 = 1;
label_20:
        if (num5 == 0)
          methodInfo = methodInfo.MakeGenericMethod(typeArray);
      }
      else
        methodInfo = type1.GetMethod(_param0.\uE008, bindingAttr, (Binder) new \uE027(type2), types, (ParameterModifier[]) null);
      int num6 = (!obj.\uE007 ? 0 : 1) != 0 ? _param2.GetTokenFor(methodInfo.MethodHandle, type1.TypeHandle) : _param2.GetTokenFor(methodInfo.MethodHandle);
      _param1.Write(num6);
    }
  }

  private static void \uE000(\uE025 _param0, BinaryWriter _param1, DynamicILInfo _param2)
  {
    Type type = Type.GetType(_param0.\uE001.\uE009);
label_2:
    int num = \uE01D.\uE000(62);
    FieldInfo field;
    int tokenFor;
    while (true)
    {
      switch (num ^ 78)
      {
        case 76:
          field = type.GetField(_param0.\uE008, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
          num = 0;
          continue;
        case 77:
          _param1.Write(tokenFor);
          num = 1;
          continue;
        case 78:
          tokenFor = _param2.GetTokenFor(field.FieldHandle);
          num = \uE016.\uE000(81);
          continue;
        case 79:
          goto label_5;
        default:
          goto label_2;
      }
    }
label_5:;
  }

  private static void \uE000(\uE01A _param0, BinaryWriter _param1, DynamicILInfo _param2)
  {
    Type type = Type.GetType(_param0.\uE001.\uE009);
label_2:
    int num = \uE026.\uE000(38);
    SignatureHelper methodSigHelper;
    while (true)
    {
      Type clsArgument;
      Type[] typeArray1;
      int index;
      Type[] typeArray2;
      switch ((num ^ 74) + 82)
      {
        case 0:
          methodSigHelper.AddArgument(clsArgument);
          num = -1;
          continue;
        case 1:
label_4:
          clsArgument = typeArray1[index];
          num = -28;
          continue;
        case 2:
          methodSigHelper = SignatureHelper.GetMethodSigHelper(_param0.\uE002, type);
          num = -5;
          continue;
        case 3:
          typeArray1 = typeArray2;
          num = -7;
          continue;
        case 4:
          if (index != 0)
          {
            num = -27;
            continue;
          }
          break;
        case 5:
          index = 0;
          num = -8;
          continue;
        case 6:
          typeArray2 = \uE01C.\uE000(_param0.\uE000);
          num = \uE000.\uE000(50);
          continue;
        case 7:
          ++index;
          break;
        default:
          goto label_2;
      }
      if (index < typeArray1.Length)
        goto label_4;
      else
        break;
    }
    _param1.Write(_param2.GetTokenFor(methodSigHelper.GetSignature()));
  }

  internal static Type[] \uE000(\uE028[] _param0)
  {
    Type[] typeArray = new Type[_param0.Length];
label_2:
    int num = \uE016.\uE000(85);
    while (true)
    {
      int index;
      switch ((num ^ 80) + 80)
      {
        case 0:
          index = 0;
          num = -30;
          continue;
        case 1:
label_4:
          typeArray[index] = Type.GetType(_param0[index].\uE009);
          num = -29;
          continue;
        case 2:
          if (index != 0)
          {
            num = \uE016.\uE000(95);
            continue;
          }
          break;
        case 3:
          ++index;
          break;
        default:
          goto label_2;
      }
      if (index < _param0.Length)
        goto label_4;
      else
        break;
    }
    return typeArray;
  }

  internal static void ERKhpFUj(int value, BinaryWriter writer)
  {
  }
}
