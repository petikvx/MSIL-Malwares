// Decompiled with JetBrains decompiler
// Type: SpectraCyber.cCommunication
// Assembly: STAThreadAttrib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 6EE3DE1A-E148-4FBA-A193-65BEA1824C00
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-PSW.MSIL.Stealer.gen-f6a784c2aa30ddaf03919958455d18bf51533a475c21a73eff578df0174cc5d4.exe

using System;
using System.Data;
using System.IO.Ports;
using System.Threading;
using System.Windows.Forms;

namespace SpectraCyber
{
  internal class cCommunication
  {
    protected string mstrCommPort;
    protected int miBaudRate;
    protected Parity mparParity;
    protected int miDataBits;
    protected SerialPort mrSerialPort;
    protected int miCharInputBufferSize;
    protected Thread mCommunicationThread;
    protected Thread mReaderThread;
    protected Thread mDatabaseThread;
    protected cSpectraCyberBase mscSpectraCyber;
    protected int miTimeout;
    protected cPriorityQueue mCommandQueue;
    protected cPriorityQueue mReplyQueue;
    protected cDatabaseQueue mDatabaseQueue;
    private DataTable mdtDataTable;

    public cCommunication()
    {
      this.mCommandQueue = new cPriorityQueue();
      this.mReplyQueue = new cPriorityQueue();
      this.mDatabaseQueue = new cDatabaseQueue();
      this.mstrCommPort = "";
      this.miBaudRate = 2400;
      this.miDataBits = 8;
      this.mparParity = Parity.None;
      this.miCharInputBufferSize = 7;
      this.miTimeout = 1000;
    }

    public cSpectraCyberBase SpectraCyber
    {
      get => this.mscSpectraCyber;
      set => this.mscSpectraCyber = value;
    }

    public cPriorityQueue CommandQueue
    {
      get => this.mCommandQueue;
      set => this.mCommandQueue = value;
    }

    public cPriorityQueue ReplyQueue
    {
      get => this.mReplyQueue;
      set => this.mReplyQueue = value;
    }

    public cDatabaseQueue DatabaseQueue
    {
      get => this.mDatabaseQueue;
      set => this.mDatabaseQueue = value;
    }

    public int BufferSize
    {
      get => this.miCharInputBufferSize;
      set => this.miCharInputBufferSize = value;
    }

    public string CommPort
    {
      get => this.mstrCommPort;
      set => this.mstrCommPort = value;
    }

    public int BaudRate
    {
      get => this.miBaudRate;
      set => this.miBaudRate = value;
    }

    public int DataBits
    {
      get => this.miDataBits;
      set => this.miDataBits = value;
    }

    public Parity Parity
    {
      get => this.mparParity;
      set => this.mparParity = value;
    }

    public void Connect()
    {
      this.mCommunicationThread = new Thread(new ThreadStart(this.CommunicationThread));
      this.mReaderThread = new Thread(new ThreadStart(this.ReaderThread));
      this.mDatabaseThread = new Thread(new ThreadStart(this.DatabaseThread));
      this.mCommandQueue.Reduce();
      this.mReplyQueue.Clear();
      this.mCommunicationThread.Start();
      this.mReaderThread.Start();
      this.mDatabaseThread.Start();
    }

    public void Disconnect()
    {
    }

    public void Reset()
    {
      this.mCommandQueue.Clear();
      this.mReplyQueue.Clear();
    }

    public void CommunicationThread()
    {
      this.mrSerialPort = new SerialPort(this.mstrCommPort, this.miBaudRate, this.mparParity, this.miDataBits);
      this.mrSerialPort.ReadTimeout = this.miTimeout;
      this.mrSerialPort.Open();
      cCommandItem firstItem;
      string command;
      while (true)
      {
        firstItem = this.mCommandQueue.GetFirstItem();
        command = firstItem.Command;
        if (firstItem.CommandType != eCommandType.Termination)
        {
          if (firstItem.CommandType == eCommandType.ScanStop)
          {
            firstItem.Reply = command;
            this.mReplyQueue.Add(firstItem);
            this.mCommandQueue.Clear();
          }
          this.mrSerialPort.Write(command);
          if (firstItem.CommandType == eCommandType.DataDiscard)
            this.mrSerialPort.DiscardInBuffer();
          this.mscSpectraCyber.SetCommandWindowText(command);
          Thread.Sleep(firstItem.CommandWaitTime);
          if (firstItem.ExpectReply)
          {
            string str = "";
            try
            {
              char[] buffer = new char[this.miCharInputBufferSize];
              this.mrSerialPort.Read(buffer, 0, firstItem.NumCharactersToRead);
              foreach (char ch in buffer)
                str += ch.ToString();
              this.mrSerialPort.DiscardInBuffer();
            }
            catch (TimeoutException ex)
            {
              int num = (int) MessageBox.Show("Communication timeout reached");
              str = "COMM_TIMEOUT_ERROR";
            }
            firstItem.Reply = str;
          }
          else
            firstItem.Reply = command.Remove(0, 1);
          this.mReplyQueue.Add(firstItem);
          Thread.Sleep(firstItem.TimeToNextCommand);
        }
        else
          break;
      }
      firstItem.Reply = command;
      this.mReplyQueue.Add(firstItem);
      this.mrSerialPort.Close();
    }

    public void ReaderThread()
    {
      cCommandItem firstItem;
      do
      {
        firstItem = this.mReplyQueue.GetFirstItem();
        this.mscSpectraCyber.ProcessReply(firstItem.Reply, firstItem.CommandType);
      }
      while (firstItem.CommandType != eCommandType.Termination);
      this.mDatabaseQueue.Add(new cDatabaseItem(eDBCommandType.Terminate));
      this.mCommandQueue.Clear();
    }

    public void DatabaseThread()
    {
      int num1 = 0;
      int num2 = 0;
      cDatabaseAccess cDatabaseAccess = new cDatabaseAccess("./SCData.mdb");
      DataTable dtDataTable = new DataTable();
      cDatabaseAccess.Open();
      cDatabaseItem firstItem;
      while (true)
      {
        firstItem = this.mDatabaseQueue.GetFirstItem();
        if (firstItem.Type == eDBCommandType.Data)
        {
          string strSQL = "INSERT INTO tData (fSettingsID, " + firstItem.Fields + ") VALUES (" + num2.ToString() + ", " + firstItem.Values + ")";
          cDatabaseAccess.Insert(strSQL);
        }
        else if (firstItem.Type == eDBCommandType.Settings)
        {
          string strSQL1 = "INSERT INTO tSettings (fScanID, " + firstItem.Fields + ") VALUES (" + num1.ToString() + ", " + firstItem.Values + ")";
          cDatabaseAccess.Insert(strSQL1);
          string strSQL2 = "SELECT MAX(fSettingID) AS SettingID FROM tSettings";
          cDatabaseAccess.FillDataTable(dtDataTable, strSQL2);
          num2 = Convert.ToInt32(dtDataTable.Rows[0]["SettingID"]);
        }
        else if (firstItem.Type == eDBCommandType.ScanStart)
        {
          string strSQL3 = "INSERT INTO tScans (fStartTime) VALUES (NOW())";
          cDatabaseAccess.Insert(strSQL3);
          string strSQL4 = "SELECT MAX(fScanID) AS ScanID FROM tScans";
          cDatabaseAccess.FillDataTable(dtDataTable, strSQL4);
          num1 = Convert.ToInt32(dtDataTable.Rows[0]["ScanID"]);
        }
        else if (firstItem.Type == eDBCommandType.ScanStop)
        {
          string strSQL = "UPDATE tScans SET fEndTime = NOW() WHERE fScanID = " + num1.ToString();
          cDatabaseAccess.Update(strSQL);
        }
        else
          break;
      }
      if (firstItem.Type != eDBCommandType.Terminate)
      {
        int num3 = (int) MessageBox.Show("This type of database command type is not supported, it must be implmented before it is used.");
      }
      cDatabaseAccess.Close();
    }

    public delegate void SetCommandWindowDelegate(string strText);
  }
}
