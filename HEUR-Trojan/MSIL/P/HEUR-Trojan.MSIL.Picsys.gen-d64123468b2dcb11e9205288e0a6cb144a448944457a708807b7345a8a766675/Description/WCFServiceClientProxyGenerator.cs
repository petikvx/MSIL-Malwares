// Decompiled with JetBrains decompiler
// Type: System.ServiceModel.Description.WCFServiceClientProxyGenerator
// Assembly: Microsoft.Transactions.Bridge, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 51116F84-6FE2-4BD6-A908-2C88E06F45BB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Trojan.MSIL.Picsys.gen-d64123468b2dcb11e9205288e0a6cb144a448944457a708807b7345a8a766675.exe

using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.ServiceModel.Channels;
using System.ServiceModel.Web;
using System.Text;
using System.Web.Script.Services;
using System.Xml;

namespace System.ServiceModel.Description
{
  internal class WCFServiceClientProxyGenerator : ClientProxyGenerator
  {
    private const int MaxIdentifierLength = 511;
    private const string DataContractXsdBaseNamespace = "http://schemas.datacontract.org/2004/07/";
    private const string DefaultCallbackParameterName = "callback";
    private string path;
    private ServiceEndpoint serviceEndpoint;

    private static void AddToNamespace(StringBuilder builder, string fragment)
    {
      if (fragment == null)
        return;
      bool flag = true;
      for (int index = 0; index < fragment.Length && builder.Length < 511; ++index)
      {
        char c = fragment[index];
        if (WCFServiceClientProxyGenerator.IsValid(c))
        {
          if (flag && !WCFServiceClientProxyGenerator.IsValidStart(c))
            builder.Append("_");
          builder.Append(c);
          flag = false;
        }
        else if ((c == '.' || c == '/' || c == ':') && (builder.Length == 1 || builder.Length > 1 && builder[builder.Length - 1] != '.'))
        {
          builder.Append('.');
          flag = true;
        }
      }
    }

    protected override string GetProxyPath() => this.path;

    protected override string GetJsonpCallbackParameterName()
    {
      if (this.serviceEndpoint == null)
        return (string) null;
      WebMessageEncodingBindingElement encodingBindingElement = this.serviceEndpoint.Binding.CreateBindingElements().Find<WebMessageEncodingBindingElement>();
      if (encodingBindingElement == null || !encodingBindingElement.CrossDomainScriptAccessEnabled)
        return (string) null;
      return this.serviceEndpoint.Contract.Behaviors.Contains(typeof (JavascriptCallbackBehaviorAttribute)) ? ((JavascriptCallbackBehaviorAttribute) this.serviceEndpoint.Contract.Behaviors[typeof (JavascriptCallbackBehaviorAttribute)]).UrlParameterName : "callback";
    }

    protected override bool GetSupportsJsonp() => !string.IsNullOrEmpty(this.GetJsonpCallbackParameterName());

    private static System.Type ReplaceMessageWithObject(System.Type t) => !typeof (Message).IsAssignableFrom(t) ? t : typeof (object);

    private static WebServiceData GetWebServiceData(ContractDescription contract)
    {
      WebServiceData owner = new WebServiceData();
      Dictionary<string, WebServiceMethodData> methods = new Dictionary<string, WebServiceMethodData>();
      owner.Initialize(new WebServiceTypeData(XmlConvert.DecodeName(contract.Name), XmlConvert.DecodeName(contract.Namespace), contract.ContractType), methods);
      foreach (OperationDescription operation in (Collection<OperationDescription>) contract.Operations)
      {
        Dictionary<string, WebServiceParameterData> parameterData = new Dictionary<string, WebServiceParameterData>();
        bool useHttpGet = operation.Behaviors.Find<WebGetAttribute>() != null;
        WebServiceMethodData serviceMethodData = new WebServiceMethodData(owner, XmlConvert.DecodeName(operation.Name), parameterData, useHttpGet);
        MessageDescription message1 = operation.Messages[0];
        if (message1 != null)
        {
          int count = message1.Body.Parts.Count;
          for (int index = 0; index < count; ++index)
          {
            MessagePartDescription part = message1.Body.Parts[index];
            System.Type type = WCFServiceClientProxyGenerator.ReplaceMessageWithObject(part.Type);
            WebServiceParameterData serviceParameterData = new WebServiceParameterData(XmlConvert.DecodeName(part.Name), type, index);
            parameterData[serviceParameterData.ParameterName] = serviceParameterData;
            owner.ProcessClientType(type, false, true);
          }
        }
        if (operation.Messages.Count > 1)
        {
          MessageDescription message2 = operation.Messages[1];
          if (message2 != null && message2.Body.ReturnValue != null && message2.Body.ReturnValue.Type != (System.Type) null)
            owner.ProcessClientType(WCFServiceClientProxyGenerator.ReplaceMessageWithObject(message2.Body.ReturnValue.Type), false, true);
        }
        for (int index = 0; index < operation.KnownTypes.Count; ++index)
          owner.ProcessClientType(operation.KnownTypes[index], false, true);
        methods[serviceMethodData.MethodName] = serviceMethodData;
      }
      owner.ClearProcessedTypes();
      return owner;
    }

    internal static string GetClientProxyScript(
      System.Type contractType,
      string path,
      bool debugMode,
      ServiceEndpoint serviceEndpoint)
    {
      WebServiceData webServiceData = WCFServiceClientProxyGenerator.GetWebServiceData(ContractDescription.GetContract(contractType));
      return new WCFServiceClientProxyGenerator(path, debugMode, serviceEndpoint).GetClientProxyScript(webServiceData);
    }

    protected override string GetClientTypeNamespace(string ns)
    {
      if (string.IsNullOrEmpty(ns))
        return string.Empty;
      Uri result = (Uri) null;
      StringBuilder builder = new StringBuilder();
      if (Uri.TryCreate(ns, UriKind.RelativeOrAbsolute, out result))
      {
        if (!result.IsAbsoluteUri)
        {
          WCFServiceClientProxyGenerator.AddToNamespace(builder, result.OriginalString);
        }
        else
        {
          string absoluteUri = result.AbsoluteUri;
          if (absoluteUri.StartsWith("http://schemas.datacontract.org/2004/07/", StringComparison.Ordinal))
          {
            WCFServiceClientProxyGenerator.AddToNamespace(builder, absoluteUri.Substring("http://schemas.datacontract.org/2004/07/".Length));
          }
          else
          {
            string host = result.Host;
            if (host != null)
              WCFServiceClientProxyGenerator.AddToNamespace(builder, host);
            string pathAndQuery = result.PathAndQuery;
            if (pathAndQuery != null)
              WCFServiceClientProxyGenerator.AddToNamespace(builder, pathAndQuery);
          }
        }
      }
      if (builder.Length == 0)
        return string.Empty;
      int length1 = builder.Length;
      if (builder[builder.Length - 1] == '.')
        --length1;
      int length2 = Math.Min(511, length1);
      return builder.ToString(0, length2);
    }

    protected override string GetProxyTypeName(WebServiceData data) => this.GetClientTypeNamespace(data.TypeData.TypeName);

    private static bool IsValid(char c)
    {
      switch (char.GetUnicodeCategory(c))
      {
        case UnicodeCategory.UppercaseLetter:
        case UnicodeCategory.LowercaseLetter:
        case UnicodeCategory.TitlecaseLetter:
        case UnicodeCategory.ModifierLetter:
        case UnicodeCategory.OtherLetter:
        case UnicodeCategory.NonSpacingMark:
        case UnicodeCategory.SpacingCombiningMark:
        case UnicodeCategory.DecimalDigitNumber:
        case UnicodeCategory.ConnectorPunctuation:
          return true;
        default:
          return false;
      }
    }

    private static bool IsValidStart(char c) => char.GetUnicodeCategory(c) != UnicodeCategory.DecimalDigitNumber;

    internal WCFServiceClientProxyGenerator(
      string path,
      bool debugMode,
      ServiceEndpoint serviceEndpoint)
    {
      this.path = path;
      this._debugMode = debugMode;
      this.serviceEndpoint = serviceEndpoint;
    }
  }
}
