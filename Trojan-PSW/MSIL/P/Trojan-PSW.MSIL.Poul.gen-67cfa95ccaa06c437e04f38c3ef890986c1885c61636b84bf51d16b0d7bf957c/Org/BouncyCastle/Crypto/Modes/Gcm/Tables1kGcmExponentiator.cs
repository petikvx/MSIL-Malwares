// Decompiled with JetBrains decompiler
// Type: Org.BouncyCastle.Crypto.Modes.Gcm.Tables1kGcmExponentiator
// Assembly: Poullight, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A9555FC6-4E86-4D22-9A29-AD3955B2BC52
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\Trojan-PSW.MSIL.Poul.gen-67cfa95ccaa06c437e04f38c3ef890986c1885c61636b84bf51d16b0d7bf957c.exe

using Org.BouncyCastle.Utilities;
using System.Collections;

namespace Org.BouncyCastle.Crypto.Modes.Gcm
{
  public class Tables1kGcmExponentiator : IGcmExponentiator
  {
    private IList lookupPowX2;

    public void Init(byte[] x)
    {
      uint[] a = GcmUtilities.AsUints(x);
      if (this.lookupPowX2 != null && Arrays.AreEqual(a, (uint[]) this.lookupPowX2[0]))
        return;
      this.lookupPowX2 = Platform.CreateArrayList(8);
      this.lookupPowX2.Add((object) a);
    }

    public void ExponentiateX(long pow, byte[] output)
    {
      uint[] x = GcmUtilities.OneAsUints();
      int num = 0;
      for (; pow > 0L; pow >>= 1)
      {
        if ((pow & 1L) != 0L)
        {
          this.EnsureAvailable(num);
          GcmUtilities.Multiply(x, (uint[]) this.lookupPowX2[num]);
        }
        ++num;
      }
      GcmUtilities.AsBytes(x, output);
    }

    private void EnsureAvailable(int bit)
    {
      int count = this.lookupPowX2.Count;
      if (count > bit)
        return;
      uint[] numArray = (uint[]) this.lookupPowX2[count - 1];
      do
      {
        numArray = Arrays.Clone(numArray);
        GcmUtilities.Multiply(numArray, numArray);
        this.lookupPowX2.Add((object) numArray);
      }
      while (++count <= bit);
    }
  }
}
