// Decompiled with JetBrains decompiler
// Type: A.c24bbbfc29d3b80741f1cd57d241a8b07
// Assembly: HLoader, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 4C828FA1-EFB7-4355-AAE8-0E5D4BCC5CDE
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Trojan.Win32.Generic-97ab8c9bd2ba8ee42f1c3acbebe376215fab3fe82d8efb2999725ab905c04134.exe

using System;
using System.Reflection;
using System.Reflection.Emit;

namespace A
{
  internal sealed class c24bbbfc29d3b80741f1cd57d241a8b07
  {
    private static ModuleHandle c1bb68b14441232b1fc9eec2b3931fdfe;

    static c24bbbfc29d3b80741f1cd57d241a8b07()
    {
      if ((object) typeof (MulticastDelegate) == null)
        return;
      c24bbbfc29d3b80741f1cd57d241a8b07.c1bb68b14441232b1fc9eec2b3931fdfe = Assembly.GetExecutingAssembly().GetModules()[0].ModuleHandle;
    }

    public static void c9031f01336a7fa49e6b6f09504e8467f(int _param0, int _param1, int _param2)
    {
      Type typeFromHandle;
      MethodInfo methodInfo;
      try
      {
        typeFromHandle = Type.GetTypeFromHandle(c24bbbfc29d3b80741f1cd57d241a8b07.c1bb68b14441232b1fc9eec2b3931fdfe.ResolveTypeHandle(_param0));
        methodInfo = _param2 != 16777215 ? (MethodInfo) (object) MethodBase.GetMethodFromHandle(c24bbbfc29d3b80741f1cd57d241a8b07.c1bb68b14441232b1fc9eec2b3931fdfe.ResolveMethodHandle(_param1), c24bbbfc29d3b80741f1cd57d241a8b07.c1bb68b14441232b1fc9eec2b3931fdfe.ResolveTypeHandle(_param2)) : (MethodInfo) (object) MethodBase.GetMethodFromHandle(c24bbbfc29d3b80741f1cd57d241a8b07.c1bb68b14441232b1fc9eec2b3931fdfe.ResolveMethodHandle(_param1));
      }
      catch (Exception ex)
      {
        throw;
      }
      foreach (FieldInfo field in typeFromHandle.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.GetField))
      {
        try
        {
          Delegate @delegate;
          if (methodInfo.IsStatic)
          {
            @delegate = Delegate.CreateDelegate(field.FieldType, methodInfo);
          }
          else
          {
            ParameterInfo[] parameters = methodInfo.GetParameters();
            int length = parameters.Length + 1;
            Type[] parameterTypes = new Type[length];
            int num = methodInfo.DeclaringType.IsValueType ? 1 : 0;
            parameterTypes[0] = num == 0 ? typeof (object) : methodInfo.DeclaringType.MakeByRefType();
            for (int index = 1; index < length; ++index)
              parameterTypes[index] = parameters[index - 1].ParameterType;
            DynamicMethod dynamicMethod = new DynamicMethod(string.Empty, methodInfo.ReturnType, parameterTypes, typeFromHandle, true);
            ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
            ilGenerator.Emit(OpCodes.Ldarg_0);
            if (length > 1)
              ilGenerator.Emit(OpCodes.Ldarg_1);
            if (length > 2)
              ilGenerator.Emit(OpCodes.Ldarg_2);
            if (length > 3)
              ilGenerator.Emit(OpCodes.Ldarg_3);
            if (length > 4)
            {
              for (int index = 4; index < length; ++index)
                ilGenerator.Emit(OpCodes.Ldarg_S, index);
            }
            ilGenerator.Emit(field.IsFamilyOrAssembly ? OpCodes.Callvirt : OpCodes.Call, methodInfo);
            ilGenerator.Emit(OpCodes.Ret);
            @delegate = dynamicMethod.CreateDelegate(typeFromHandle);
          }
          field.SetValue((object) null, (object) @delegate);
        }
        catch (Exception ex)
        {
        }
      }
    }
  }
}
