// Decompiled with JetBrains decompiler
// Type: mmxAH.MonsterPrototype
// Assembly: X509Ut, Version=1.0.2.2, Culture=neutral, PublicKeyToken=null
// MVID: 1E869FE1-6699-4C5A-A346-E3A268AF0CFF
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcql-59417b76e826677caae54470d776ac97355fea2080e278b08439fa5229cc46a3.exe

using System;
using System.Collections.Generic;

namespace mmxAH
{
  public class MonsterPrototype
  {
    private GameEngine en;
    private string Title;
    private string FightTitle;
    private string EvadeTitle;
    private string CodeName;
    private short EvadeModif;
    private short HorrorModif;
    private short CombatModif;
    private byte HorrorDemage;
    private byte CombatDemage;
    private bool isHorrorCheck = true;
    private bool MR = false;
    private bool MI = false;
    private bool PR = false;
    private bool PI = false;
    private bool isEndless = false;
    private bool isAmbush = false;
    private byte ExtraCombat = 0;
    private byte ExtraHorror = 0;
    private byte Tougness = 1;
    private byte dsindex;
    private Effect SpecialDemageEffect = (Effect) null;
    private Effect SpecialMovementEffect = (Effect) null;
    private Effect SpecialTrofyEffect = (Effect) null;
    private Effect InsteadEncEffect = (Effect) null;
    private List<string> SpecAbilText;
    private MonsterMovementType moveType;
    private bool isUndead = false;
    private bool isMask = false;
    private bool isSpawn = false;
    public bool isPrinted = false;

    public string GetTitle() => this.Title;

    public string GetEvadeTitle() => this.EvadeTitle;

    public string GetFightTitle() => this.FightTitle;

    public short GetEvadeModif() => this.EvadeModif;

    public short GetHorrorModif() => this.HorrorModif;

    public short GetCombatModif() => this.CombatModif;

    public string GetCodeName() => this.CodeName;

    public byte GetDs() => this.dsindex;

    public byte GetSanityDemage() => this.HorrorDemage;

    public byte GetTougness() => this.Tougness;

    public bool GetIsHorror() => this.isHorrorCheck;

    public byte GetExtraSanity() => this.ExtraHorror;

    public byte GetExtraCombat() => this.ExtraCombat;

    public bool GetEndless() => this.isEndless;

    public bool GetAmbush() => this.isAmbush;

    public bool GetUndead() => this.isUndead;

    public bool GetMask() => this.isMask;

    public bool GetSpawn() => this.isSpawn;

    public MonsterMovementType GetMoveType() => this.moveType;

    public MonsterPrototype(GameEngine eng)
    {
      this.en = eng;
      this.SpecAbilText = new List<string>();
    }

    public void Print()
    {
      if (this.isPrinted)
        return;
      this.isPrinted = true;
      this.en.io.Print(this.Title, (byte) 14, true);
      this.en.io.Print("       " + this.en.sysstr.GetString(SSType.DS) + ": " + this.en.ds.GetTitle(this.dsindex));
      this.en.io.Print("       " + this.en.sysstr.GetMonsterMovementString(this.moveType));
      if (this.isUndead)
        this.en.io.Print("       " + this.en.sysstr.GetString(SSType.Undead), isBold: true, isItalic: true);
      if (this.isSpawn)
        this.en.io.Print("       " + this.en.sysstr.GetString(SSType.Spawn), isBold: true, isItalic: true);
      if (this.isMask)
        this.en.io.Print("       " + this.en.sysstr.GetString(SSType.Mask), isBold: true, isItalic: true);
      this.en.io.Print(Environment.NewLine + this.en.sysstr.GetString(SSType.Awerness), isBold: true);
      this.en.io.Print("  ");
      if (this.EvadeModif > (short) 0)
        this.en.io.Print("+");
      this.en.io.Print(this.EvadeModif.ToString());
      if (this.isAmbush)
        this.en.io.Print("       " + this.en.sysstr.GetString(SSType.Ambush), isBold: true);
      this.en.io.Print(Environment.NewLine + this.en.sysstr.GetString(SSType.HorrorModif) + "   ", isBold: true);
      if (this.InsteadEncEffect != null)
      {
        this.en.io.Print("-" + Environment.NewLine);
        this.en.io.Print(this.en.sysstr.GetString(SSType.CombatModif) + "   ", isBold: true);
        this.en.io.Print("-" + Environment.NewLine);
      }
      else
      {
        if (this.isHorrorCheck)
        {
          if (this.HorrorModif >= (short) 0)
            this.en.io.Print("+");
          this.en.io.Print(this.HorrorModif.ToString());
          this.en.io.Print("        " + this.en.sysstr.GetString(SSType.HorrorDemage) + "   ", isBold: true);
          this.en.io.Print(this.HorrorDemage.ToString());
          if (this.ExtraHorror > (byte) 0)
            this.en.io.Print("        " + this.en.sysstr.GetString(SSType.ExtraHorror) + " " + this.ExtraHorror.ToString(), isBold: true);
          this.en.io.Print(Environment.NewLine);
        }
        else
          this.en.io.Print("-" + Environment.NewLine);
        this.en.io.Print(this.en.sysstr.GetString(SSType.CombatModif) + "   ", isBold: true);
        if (this.CombatModif >= (short) 0)
          this.en.io.Print("+");
        this.en.io.Print(this.CombatModif.ToString());
        this.en.io.Print("        " + this.en.sysstr.GetString(SSType.CombatDemage) + "   ", isBold: true);
        if (this.CombatDemage == (byte) 0)
          this.en.io.Print("  " + this.en.sysstr.GetString(SSType.MonsterDemageSpecial));
        else
          this.en.io.Print(this.CombatDemage.ToString());
        if (this.ExtraCombat > (byte) 0)
          this.en.io.Print("        " + this.en.sysstr.GetString(SSType.ExtraCombat) + " " + this.ExtraCombat.ToString(), isBold: true);
        this.en.io.Print(Environment.NewLine);
      }
      this.en.io.Print(this.en.sysstr.GetString(SSType.Tougness), isBold: true);
      this.en.io.Print("  ");
      this.en.io.Print(this.Tougness.ToString());
      if (this.MR)
        this.en.io.Print("       " + this.en.sysstr.GetString(SSType.MR), isBold: true);
      if (this.MI)
        this.en.io.Print("       " + this.en.sysstr.GetString(SSType.MI), isBold: true);
      if (this.PR)
        this.en.io.Print("       " + this.en.sysstr.GetString(SSType.PR), isBold: true);
      if (this.PI)
        this.en.io.Print("       " + this.en.sysstr.GetString(SSType.PI), isBold: true);
      this.en.io.Print(Environment.NewLine);
      if (this.isEndless)
        this.en.io.Print(this.en.sysstr.GetString(SSType.Endless) + Environment.NewLine, isBold: true);
      foreach (string str in this.SpecAbilText)
        this.en.io.PrintTag(str + Environment.NewLine);
      this.en.io.Print(Environment.NewLine);
    }

    public bool FromTextFile(TextFileParser data, TextFileParser text)
    {
      this.CodeName = data.GetToken().ToUpper();
      this.Title = text.GetCurString();
      if (text.isMultiName)
      {
        this.EvadeTitle = text.GetCurString();
        this.FightTitle = text.GetCurString();
      }
      else
      {
        this.EvadeTitle = this.Title;
        this.FightTitle = this.Title;
      }
      int index1 = this.en.ds.GetIndex(data.GetToken());
      if (index1 == -1)
        return false;
      this.dsindex = (byte) index1;
      string upper = data.GetToken().ToUpper();
      if (!(upper == "NORMAL"))
      {
        if (!(upper == "FAST"))
        {
          if (!(upper == "FLY"))
          {
            if (!(upper == "INMOB"))
            {
              if (upper == "SPECIAL")
              {
                this.moveType = MonsterMovementType.Special;
                this.SpecialMovementEffect = Effect.FromTextFile(data, this.en);
                if (this.SpecialMovementEffect == null)
                  return false;
              }
            }
            else
              this.moveType = MonsterMovementType.Inmobile;
          }
          else
            this.moveType = MonsterMovementType.Fly;
        }
        else
          this.moveType = MonsterMovementType.Fast;
      }
      else
        this.moveType = MonsterMovementType.Normal;
      if (!short.TryParse(data.GetToken(), out this.EvadeModif))
        return false;
      string token = data.GetToken();
      if (token.ToUpper() == "INSENC")
      {
        this.InsteadEncEffect = Effect.FromTextFile(data, this.en);
        if (this.InsteadEncEffect == null)
          return false;
      }
      else
      {
        if (token.ToUpper() == "NONE")
          this.isHorrorCheck = false;
        else if (!short.TryParse(token, out this.HorrorModif) || !byte.TryParse(data.GetToken(), out this.HorrorDemage))
          return false;
        if (!short.TryParse(data.GetToken(), out this.CombatModif) || !byte.TryParse(data.GetToken(), out this.CombatDemage))
          return false;
        if (this.CombatDemage == (byte) 0)
        {
          this.SpecialDemageEffect = Effect.FromTextFile(data, this.en);
          if (this.SpecialDemageEffect == null)
            return false;
        }
      }
      byte result1;
      if (!byte.TryParse(data.GetToken(), out this.Tougness) || !byte.TryParse(data.GetToken(), out result1))
        return false;
      for (byte index2 = 0; (int) index2 < (int) result1; ++index2)
      {
        switch (data.GetToken().ToUpper())
        {
          case "AMBUSH":
            this.isAmbush = true;
            break;
          case "ENDLESS":
            this.isEndless = true;
            break;
          case "MASK":
            this.isMask = true;
            break;
          case "MI":
            this.MI = true;
            break;
          case "MR":
            this.MR = true;
            break;
          case "NIGHT":
            if (!byte.TryParse(data.GetToken(), out this.ExtraHorror))
              return false;
            break;
          case "OVER":
            if (!byte.TryParse(data.GetToken(), out this.ExtraCombat))
              return false;
            break;
          case "PI":
            this.PI = true;
            break;
          case "PR":
            this.PR = true;
            break;
          case "SPAWN":
            this.isSpawn = true;
            break;
          case "UNDEAD":
            this.isUndead = true;
            break;
          default:
            return false;
        }
      }
      if (!byte.TryParse(data.GetToken(), out result1))
        return false;
      for (byte index3 = 0; (int) index3 < (int) result1; ++index3)
        this.SpecAbilText.Add(text.GetCurString());
      byte result2;
      if (!byte.TryParse(data.GetToken(), out result2))
        return false;
      for (byte index4 = 0; (int) index4 < (int) result2; ++index4)
        this.en.MonstersCup.Add(new MonsterIndivid(this.en, this, this.en.MonstersCup.GetCountOfCards()));
      return true;
    }

    public void DoDemage(Func f, MonsterIndivid mons)
    {
      if (this.SpecialDemageEffect != null)
      {
        this.SpecialDemageEffect.Execute(new Func(mons.EndEncounter));
      }
      else
      {
        EffStaminaLose effStaminaLose = new EffStaminaLose(this.en);
        effStaminaLose.ChangeDemageCount((short) this.CombatDemage);
        effStaminaLose.Execute(f, (byte) 40);
      }
    }

    public byte AddItemModif(byte modifChange, bool isPhysical, bool isMagic)
    {
      if (this.PR & isPhysical)
        return (byte) Math.Round((double) modifChange / 2.0);
      if (this.PI & isPhysical)
        return 0;
      if (this.MR & isMagic)
        return (byte) Math.Round((double) modifChange / 2.0);
      return this.MI & isMagic ? (byte) 0 : modifChange;
    }

    public void ExecuteMoveEffect() => this.SpecialMovementEffect.Execute(new Func(this.en.curs.resolvingMythos.Step3Circle));
  }
}
