// Decompiled with JetBrains decompiler
// Type: Org.BouncyCastle.Crypto.Modes.GcmBlockCipher
// Assembly: Poullight, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A9555FC6-4E86-4D22-9A29-AD3955B2BC52
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\Trojan-PSW.MSIL.Poul.gen-67cfa95ccaa06c437e04f38c3ef890986c1885c61636b84bf51d16b0d7bf957c.exe

using Org.BouncyCastle.Crypto.Modes.Gcm;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Crypto.Utilities;
using Org.BouncyCastle.Utilities;
using System;

namespace Org.BouncyCastle.Crypto.Modes
{
  public class GcmBlockCipher
  {
    private const int BlockSize = 16;
    private readonly IBlockCipher cipher;
    private readonly IGcmMultiplier multiplier;
    private byte[] atBlock;
    private int atBlockPos;
    private ulong atLength;
    private ulong atLengthPre;
    private uint blocksRemaining;
    private byte[] bufBlock;
    private int bufOff;
    private byte[] counter;
    private IGcmExponentiator exp;
    private bool forEncryption;
    private byte[] H;
    private byte[] initialAssociatedText;
    private bool initialised;
    private byte[] J0;
    private byte[] lastKey;
    private byte[] macBlock;
    private int macSize;
    private byte[] nonce;
    private byte[] S;
    private byte[] S_at;
    private byte[] S_atPre;
    private ulong totalLength;

    public GcmBlockCipher(IBlockCipher c)
      : this(c, (IGcmMultiplier) null)
    {
    }

    public GcmBlockCipher(IBlockCipher c, IGcmMultiplier m)
    {
      if (c.GetBlockSize() != 16)
        throw new ArgumentException("cipher required with a block size of " + (object) 16 + ".");
      if (m == null)
        m = (IGcmMultiplier) new Tables8kGcmMultiplier();
      this.cipher = c;
      this.multiplier = m;
    }

    public virtual string AlgorithmName => this.cipher.AlgorithmName + "/GCM";

    public IBlockCipher GetUnderlyingCipher() => this.cipher;

    public virtual int GetBlockSize() => 16;

    public virtual void Init(bool forEncryption, ICipherParameters parameters)
    {
      this.forEncryption = forEncryption;
      this.macBlock = (byte[]) null;
      this.initialised = true;
      AeadParameters aeadParameters = parameters is AeadParameters ? (AeadParameters) parameters : throw new ArgumentException("invalid parameters passed to GCM");
      byte[] nonce = aeadParameters.GetNonce();
      this.initialAssociatedText = aeadParameters.GetAssociatedText();
      int macSize = aeadParameters.MacSize;
      if (macSize < 32 || macSize > 128 || macSize % 8 != 0)
        throw new ArgumentException("Invalid value for MAC size: " + (object) macSize);
      this.macSize = macSize / 8;
      KeyParameter key = aeadParameters.Key;
      this.bufBlock = new byte[forEncryption ? 16 : 16 + this.macSize];
      if (nonce == null || nonce.Length < 1)
        throw new ArgumentException("IV must be at least 1 byte");
      if (forEncryption && this.nonce != null && Arrays.AreEqual(this.nonce, nonce))
      {
        if (key == null)
          throw new ArgumentException("cannot reuse nonce for GCM encryption");
        if (this.lastKey != null && Arrays.AreEqual(this.lastKey, key.GetKey()))
          throw new ArgumentException("cannot reuse nonce for GCM encryption");
      }
      this.nonce = nonce;
      if (key != null)
        this.lastKey = key.GetKey();
      if (key != null)
      {
        this.cipher.Init(true, (ICipherParameters) key);
        this.H = new byte[16];
        this.cipher.ProcessBlock(this.H, 0, this.H, 0);
        this.multiplier.Init(this.H);
        this.exp = (IGcmExponentiator) null;
      }
      else if (this.H == null)
        throw new ArgumentException("Key must be specified in initial init");
      this.J0 = new byte[16];
      if (this.nonce.Length == 12)
      {
        Array.Copy((Array) this.nonce, 0, (Array) this.J0, 0, this.nonce.Length);
        this.J0[15] = (byte) 1;
      }
      else
      {
        this.gHASH(this.J0, this.nonce, this.nonce.Length);
        byte[] numArray = new byte[16];
        Pack.UInt64_To_BE((ulong) this.nonce.Length * 8UL, numArray, 8);
        this.gHASHBlock(this.J0, numArray);
      }
      this.S = new byte[16];
      this.S_at = new byte[16];
      this.S_atPre = new byte[16];
      this.atBlock = new byte[16];
      this.atBlockPos = 0;
      this.atLength = 0UL;
      this.atLengthPre = 0UL;
      this.counter = Arrays.Clone(this.J0);
      this.blocksRemaining = 4294967294U;
      this.bufOff = 0;
      this.totalLength = 0UL;
      if (this.initialAssociatedText == null)
        return;
      this.ProcessAadBytes(this.initialAssociatedText, 0, this.initialAssociatedText.Length);
    }

    public virtual byte[] GetMac() => this.macBlock != null ? Arrays.Clone(this.macBlock) : new byte[this.macSize];

    public virtual int GetOutputSize(int len)
    {
      int num = len + this.bufOff;
      if (this.forEncryption)
        return num + this.macSize;
      return num >= this.macSize ? num - this.macSize : 0;
    }

    public virtual int GetUpdateOutputSize(int len)
    {
      int num = len + this.bufOff;
      if (!this.forEncryption)
      {
        if (num < this.macSize)
          return 0;
        num -= this.macSize;
      }
      return num - num % 16;
    }

    public virtual void ProcessAadByte(byte input)
    {
      this.CheckStatus();
      this.atBlock[this.atBlockPos] = input;
      if (++this.atBlockPos != 16)
        return;
      this.gHASHBlock(this.S_at, this.atBlock);
      this.atBlockPos = 0;
      this.atLength += 16UL;
    }

    public virtual void ProcessAadBytes(byte[] inBytes, int inOff, int len)
    {
      this.CheckStatus();
      for (int index = 0; index < len; ++index)
      {
        this.atBlock[this.atBlockPos] = inBytes[inOff + index];
        if (++this.atBlockPos == 16)
        {
          this.gHASHBlock(this.S_at, this.atBlock);
          this.atBlockPos = 0;
          this.atLength += 16UL;
        }
      }
    }

    public virtual int ProcessByte(byte input, byte[] output, int outOff)
    {
      this.CheckStatus();
      this.bufBlock[this.bufOff] = input;
      if (++this.bufOff != this.bufBlock.Length)
        return 0;
      this.ProcessBlock(this.bufBlock, 0, output, outOff);
      if (this.forEncryption)
      {
        this.bufOff = 0;
      }
      else
      {
        Array.Copy((Array) this.bufBlock, 16, (Array) this.bufBlock, 0, this.macSize);
        this.bufOff = this.macSize;
      }
      return 16;
    }

    public virtual int ProcessBytes(byte[] input, int inOff, int len, byte[] output, int outOff)
    {
      this.CheckStatus();
      Org.BouncyCastle.Crypto.Check.DataLength(input, inOff, len, "input buffer too short");
      int num = 0;
      if (this.forEncryption)
      {
        if (this.bufOff != 0)
        {
          while (len > 0)
          {
            --len;
            this.bufBlock[this.bufOff] = input[inOff++];
            if (++this.bufOff == 16)
            {
              this.ProcessBlock(this.bufBlock, 0, output, outOff);
              this.bufOff = 0;
              num += 16;
              break;
            }
          }
        }
        while (len >= 16)
        {
          this.ProcessBlock(input, inOff, output, outOff + num);
          inOff += 16;
          len -= 16;
          num += 16;
        }
        if (len > 0)
        {
          Array.Copy((Array) input, inOff, (Array) this.bufBlock, 0, len);
          this.bufOff = len;
        }
      }
      else
      {
        for (int index = 0; index < len; ++index)
        {
          this.bufBlock[this.bufOff] = input[inOff + index];
          if (++this.bufOff == this.bufBlock.Length)
          {
            this.ProcessBlock(this.bufBlock, 0, output, outOff + num);
            Array.Copy((Array) this.bufBlock, 16, (Array) this.bufBlock, 0, this.macSize);
            this.bufOff = this.macSize;
            num += 16;
          }
        }
      }
      return num;
    }

    public int DoFinal(byte[] output, int outOff)
    {
      this.CheckStatus();
      if (this.totalLength == 0UL)
        this.InitCipher();
      int bufOff = this.bufOff;
      if (this.forEncryption)
      {
        Org.BouncyCastle.Crypto.Check.OutputLength(output, outOff, bufOff + this.macSize, "Output buffer too short");
      }
      else
      {
        if (bufOff < this.macSize)
          throw new CryptoException("data too short");
        bufOff -= this.macSize;
        Org.BouncyCastle.Crypto.Check.OutputLength(output, outOff, bufOff, "Output buffer too short");
      }
      if (bufOff > 0)
        this.ProcessPartial(this.bufBlock, 0, bufOff, output, outOff);
      this.atLength += (ulong) (uint) this.atBlockPos;
      if (this.atLength > this.atLengthPre)
      {
        if (this.atBlockPos > 0)
          this.gHASHPartial(this.S_at, this.atBlock, 0, this.atBlockPos);
        if (this.atLengthPre > 0UL)
          GcmUtilities.Xor(this.S_at, this.S_atPre);
        long pow = (long) (this.totalLength * 8UL + (ulong) sbyte.MaxValue >> 7);
        byte[] numArray = new byte[16];
        if (this.exp == null)
        {
          this.exp = (IGcmExponentiator) new Tables1kGcmExponentiator();
          this.exp.Init(this.H);
        }
        this.exp.ExponentiateX(pow, numArray);
        GcmUtilities.Multiply(this.S_at, numArray);
        GcmUtilities.Xor(this.S, this.S_at);
      }
      byte[] numArray1 = new byte[16];
      Pack.UInt64_To_BE(this.atLength * 8UL, numArray1, 0);
      Pack.UInt64_To_BE(this.totalLength * 8UL, numArray1, 8);
      this.gHASHBlock(this.S, numArray1);
      byte[] numArray2 = new byte[16];
      this.cipher.ProcessBlock(this.J0, 0, numArray2, 0);
      GcmUtilities.Xor(numArray2, this.S);
      int num = bufOff;
      this.macBlock = new byte[this.macSize];
      Array.Copy((Array) numArray2, 0, (Array) this.macBlock, 0, this.macSize);
      if (this.forEncryption)
      {
        Array.Copy((Array) this.macBlock, 0, (Array) output, outOff + this.bufOff, this.macSize);
        num += this.macSize;
      }
      else
      {
        byte[] numArray3 = new byte[this.macSize];
        Array.Copy((Array) this.bufBlock, bufOff, (Array) numArray3, 0, this.macSize);
        if (!Arrays.ConstantTimeAreEqual(this.macBlock, numArray3))
          throw new CryptoException("mac check in GCM failed");
      }
      this.Reset(false);
      return num;
    }

    public virtual void Reset() => this.Reset(true);

    private void InitCipher()
    {
      if (this.atLength > 0UL)
      {
        Array.Copy((Array) this.S_at, 0, (Array) this.S_atPre, 0, 16);
        this.atLengthPre = this.atLength;
      }
      if (this.atBlockPos > 0)
      {
        this.gHASHPartial(this.S_atPre, this.atBlock, 0, this.atBlockPos);
        this.atLengthPre += (ulong) (uint) this.atBlockPos;
      }
      if (this.atLengthPre <= 0UL)
        return;
      Array.Copy((Array) this.S_atPre, 0, (Array) this.S, 0, 16);
    }

    private void Reset(bool clearMac)
    {
      this.cipher.Reset();
      this.S = new byte[16];
      this.S_at = new byte[16];
      this.S_atPre = new byte[16];
      this.atBlock = new byte[16];
      this.atBlockPos = 0;
      this.atLength = 0UL;
      this.atLengthPre = 0UL;
      this.counter = Arrays.Clone(this.J0);
      this.blocksRemaining = 4294967294U;
      this.bufOff = 0;
      this.totalLength = 0UL;
      if (this.bufBlock != null)
        Arrays.Fill(this.bufBlock, (byte) 0);
      if (clearMac)
        this.macBlock = (byte[]) null;
      if (this.forEncryption)
      {
        this.initialised = false;
      }
      else
      {
        if (this.initialAssociatedText == null)
          return;
        this.ProcessAadBytes(this.initialAssociatedText, 0, this.initialAssociatedText.Length);
      }
    }

    private void ProcessBlock(byte[] buf, int bufOff, byte[] output, int outOff)
    {
      Org.BouncyCastle.Crypto.Check.OutputLength(output, outOff, 16, "Output buffer too short");
      if (this.totalLength == 0UL)
        this.InitCipher();
      byte[] numArray = new byte[16];
      this.GetNextCtrBlock(numArray);
      if (this.forEncryption)
      {
        GcmUtilities.Xor(numArray, buf, bufOff);
        this.gHASHBlock(this.S, numArray);
        Array.Copy((Array) numArray, 0, (Array) output, outOff, 16);
      }
      else
      {
        this.gHASHBlock(this.S, buf, bufOff);
        GcmUtilities.Xor(numArray, 0, buf, bufOff, output, outOff);
      }
      this.totalLength += 16UL;
    }

    private void ProcessPartial(byte[] buf, int off, int len, byte[] output, int outOff)
    {
      byte[] numArray = new byte[16];
      this.GetNextCtrBlock(numArray);
      if (this.forEncryption)
      {
        GcmUtilities.Xor(buf, off, numArray, 0, len);
        this.gHASHPartial(this.S, buf, off, len);
      }
      else
      {
        this.gHASHPartial(this.S, buf, off, len);
        GcmUtilities.Xor(buf, off, numArray, 0, len);
      }
      Array.Copy((Array) buf, off, (Array) output, outOff, len);
      this.totalLength += (ulong) (uint) len;
    }

    private void gHASH(byte[] Y, byte[] b, int len)
    {
      for (int off = 0; off < len; off += 16)
      {
        int len1 = Math.Min(len - off, 16);
        this.gHASHPartial(Y, b, off, len1);
      }
    }

    private void gHASHBlock(byte[] Y, byte[] b)
    {
      GcmUtilities.Xor(Y, b);
      this.multiplier.MultiplyH(Y);
    }

    private void gHASHBlock(byte[] Y, byte[] b, int off)
    {
      GcmUtilities.Xor(Y, b, off);
      this.multiplier.MultiplyH(Y);
    }

    private void gHASHPartial(byte[] Y, byte[] b, int off, int len)
    {
      GcmUtilities.Xor(Y, b, off, len);
      this.multiplier.MultiplyH(Y);
    }

    private void GetNextCtrBlock(byte[] block)
    {
      if (this.blocksRemaining == 0U)
        throw new InvalidOperationException("Attempt to process too many blocks");
      --this.blocksRemaining;
      uint num1 = 1U + (uint) this.counter[15];
      this.counter[15] = (byte) num1;
      uint num2 = (num1 >> 8) + (uint) this.counter[14];
      this.counter[14] = (byte) num2;
      uint num3 = (num2 >> 8) + (uint) this.counter[13];
      this.counter[13] = (byte) num3;
      this.counter[12] = (byte) ((num3 >> 8) + (uint) this.counter[12]);
      this.cipher.ProcessBlock(this.counter, 0, block, 0);
    }

    private void CheckStatus()
    {
      if (this.initialised)
        return;
      if (this.forEncryption)
        throw new InvalidOperationException("GCM cipher cannot be reused for encryption");
      throw new InvalidOperationException("GCM cipher needs to be initialised");
    }
  }
}
