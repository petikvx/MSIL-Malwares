// Decompiled with JetBrains decompiler
// Type: Aura.Protection.Arithmetic.ArithmeticEmulator
// Assembly: Kudeta Crypter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 16F9F4AC-EE0C-4DE1-A1E6-B297F2D4338B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-VirTool.MSIL.Crypto.gen-a09f476c823deb3aadbd99b5e979f18689723f0ab3b5690e0b9a42cf2007f2a8.exe

using System;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic
{
  public class ArithmeticEmulator
  {
    private readonly double x;
    private readonly double y;
    private readonly ArithmeticTypes arithmeticTypes;

    public ArithmeticTypes GetType { get; private set; }

    public ArithmeticEmulator(double x, double y, ArithmeticTypes arithmeticTypes)
    {
      this.x = x;
      this.y = y;
      this.arithmeticTypes = arithmeticTypes;
    }

    public double GetValue()
    {
      switch (this.arithmeticTypes)
      {
        case ArithmeticTypes.Add:
          return this.x - this.y;
        case ArithmeticTypes.Sub:
          return this.x + this.y;
        case ArithmeticTypes.Div:
          return this.x * this.y;
        case ArithmeticTypes.Mul:
          return this.x / this.y;
        case ArithmeticTypes.Xor:
          return (double) ((int) this.x ^ (int) this.y);
        default:
          return -1.0;
      }
    }

    public double GetValue(List<ArithmeticTypes> arithmetics)
    {
      Aura.Protection.Arithmetic.Generator.Generator generator = new Aura.Protection.Arithmetic.Generator.Generator();
      ArithmeticTypes arithmetic = arithmetics[generator.Next(arithmetics.Count)];
      this.GetType = arithmetic;
      switch (this.arithmeticTypes)
      {
        case ArithmeticTypes.Abs:
          if (arithmetic == ArithmeticTypes.Add)
            return this.x + Math.Abs(this.y) * -1.0;
          return arithmetic == ArithmeticTypes.Sub ? this.x - Math.Abs(this.y) * -1.0 : -1.0;
        case ArithmeticTypes.Log:
          if (arithmetic == ArithmeticTypes.Add)
            return this.x - Math.Log(this.y);
          return arithmetic == ArithmeticTypes.Sub ? this.x + Math.Log(this.y) : -1.0;
        case ArithmeticTypes.Log10:
          if (arithmetic == ArithmeticTypes.Add)
            return this.x - Math.Log10(this.y);
          return arithmetic == ArithmeticTypes.Sub ? this.x + Math.Log10(this.y) : -1.0;
        case ArithmeticTypes.Sin:
          if (arithmetic == ArithmeticTypes.Add)
            return this.x - Math.Sin(this.y);
          return arithmetic == ArithmeticTypes.Sub ? this.x + Math.Sin(this.y) : -1.0;
        case ArithmeticTypes.Cos:
          if (arithmetic == ArithmeticTypes.Add)
            return this.x - Math.Cos(this.y);
          return arithmetic == ArithmeticTypes.Sub ? this.x + Math.Cos(this.y) : -1.0;
        case ArithmeticTypes.Round:
          if (arithmetic == ArithmeticTypes.Add)
            return this.x - Math.Round(this.y);
          return arithmetic == ArithmeticTypes.Sub ? this.x + Math.Round(this.y) : -1.0;
        case ArithmeticTypes.Sqrt:
          if (arithmetic == ArithmeticTypes.Add)
            return this.x - Math.Sqrt(this.y);
          return arithmetic == ArithmeticTypes.Sub ? this.x + Math.Sqrt(this.y) : -1.0;
        case ArithmeticTypes.Ceiling:
          if (arithmetic == ArithmeticTypes.Add)
            return this.x - Math.Ceiling(this.y);
          return arithmetic == ArithmeticTypes.Sub ? this.x + Math.Ceiling(this.y) : -1.0;
        case ArithmeticTypes.Floor:
          if (arithmetic == ArithmeticTypes.Add)
            return this.x - Math.Floor(this.y);
          return arithmetic == ArithmeticTypes.Sub ? this.x + Math.Floor(this.y) : -1.0;
        case ArithmeticTypes.Tan:
          if (arithmetic == ArithmeticTypes.Add)
            return this.x - Math.Tan(this.y);
          return arithmetic == ArithmeticTypes.Sub ? this.x + Math.Tan(this.y) : -1.0;
        case ArithmeticTypes.Tanh:
          if (arithmetic == ArithmeticTypes.Add)
            return this.x - Math.Tanh(this.y);
          return arithmetic == ArithmeticTypes.Sub ? this.x + Math.Tanh(this.y) : -1.0;
        case ArithmeticTypes.Truncate:
          if (arithmetic == ArithmeticTypes.Add)
            return this.x - Math.Truncate(this.y);
          return arithmetic == ArithmeticTypes.Sub ? this.x + Math.Truncate(this.y) : -1.0;
        default:
          return -1.0;
      }
    }

    public double GetY() => this.y;
  }
}
