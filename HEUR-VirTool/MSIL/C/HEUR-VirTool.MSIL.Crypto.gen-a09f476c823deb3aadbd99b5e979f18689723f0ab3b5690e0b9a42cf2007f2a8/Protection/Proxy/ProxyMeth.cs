// Decompiled with JetBrains decompiler
// Type: Aura.Protection.Proxy.ProxyMeth
// Assembly: Kudeta Crypter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 16F9F4AC-EE0C-4DE1-A1E6-B297F2D4338B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-VirTool.MSIL.Crypto.gen-a09f476c823deb3aadbd99b5e979f18689723f0ab3b5690e0b9a42cf2007f2a8.exe

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Aura.Protection.Proxy
{
  public static class ProxyMeth
  {
    public static Random rand = new Random();
    public static List<MemberRef> MemberRefList = new List<MemberRef>();

    public static void ScanMemberRef(ModuleDef module)
    {
      foreach (TypeDef type in (IEnumerable<TypeDef>) module.Types)
      {
        foreach (MethodDef method in (IEnumerable<MethodDef>) type.Methods)
        {
          if (method.HasBody && method.Body.HasInstructions)
          {
            for (int index = 0; index < ((ICollection<Instruction>) method.Body.Instructions).Count - 1; ++index)
            {
              if (method.Body.Instructions[index].OpCode == OpCodes.Call)
              {
                try
                {
                  MemberRef operand = (MemberRef) method.Body.Instructions[index].Operand;
                  if (!operand.HasThis)
                    ProxyMeth.MemberRefList.Add(operand);
                }
                catch
                {
                }
              }
            }
          }
        }
      }
    }

    public static MethodDef GenerateSwitch(MemberRef original, ModuleDef md)
    {
      try
      {
        List<TypeSig> list = ((IEnumerable<TypeSig>) ((MethodBaseSig) original.MethodSig).Params).ToList<TypeSig>();
        list.Add((TypeSig) md.CorLibTypes.Int32);
        MethodImplAttributes methodImplAttributes = (MethodImplAttributes) 0;
        MethodAttributes methodAttributes = (MethodAttributes) 150;
        MethodDefUser methodDefUser = new MethodDefUser(UTF8String.op_Implicit(string.Format("{0}", (object) ProxyMeth.rand.Next(0, int.MaxValue))), MethodSig.CreateStatic(((MethodBaseSig) original.MethodSig).RetType, list.ToArray()), methodImplAttributes, methodAttributes);
        ((MethodDef) methodDefUser).Body = new CilBody();
        MethodDef methodDef = (MethodDef) methodDefUser;
        methodDef.Body.Variables.Add(new Local((TypeSig) md.CorLibTypes.Int32));
        methodDef.Body.Variables.Add(new Local((TypeSig) md.CorLibTypes.Int32));
        ((ICollection<Instruction>) methodDef.Body.Instructions).Add(Instruction.Create(OpCodes.Ldarg_0));
        List<Instruction> instructionList = new List<Instruction>();
        Instruction instruction1 = new Instruction(OpCodes.Switch);
        ((ICollection<Instruction>) methodDef.Body.Instructions).Add(instruction1);
        Instruction instruction2 = new Instruction(OpCodes.Br_S);
        ((ICollection<Instruction>) methodDef.Body.Instructions).Add(instruction2);
        for (int index1 = 0; index1 < 5; ++index1)
        {
          for (int index2 = 0; index2 <= ((ICollection<TypeSig>) ((MethodBaseSig) original.MethodSig).Params).Count - 1; ++index2)
          {
            ((ICollection<Instruction>) methodDef.Body.Instructions).Add(Instruction.Create(OpCodes.Ldarg, methodDef.Parameters[index2]));
            if (index2 == 0)
              instructionList.Add(Instruction.Create(OpCodes.Ldarg, methodDef.Parameters[index2]));
          }
          Instruction instruction3 = Instruction.Create(OpCodes.Ldc_I4, index1);
          ((ICollection<Instruction>) methodDef.Body.Instructions).Add(instruction3);
          ((ICollection<Instruction>) methodDef.Body.Instructions).Add(Instruction.Create(OpCodes.Ret));
        }
        Instruction instruction4 = Instruction.Create(OpCodes.Ldnull);
        ((ICollection<Instruction>) methodDef.Body.Instructions).Add(instruction4);
        ((ICollection<Instruction>) methodDef.Body.Instructions).Add(Instruction.Create(OpCodes.Ret));
        instruction2.Operand = (object) instruction4;
        instruction1.Operand = (object) instructionList;
        return methodDef;
      }
      catch
      {
        return (MethodDef) null;
      }
    }

    public static IEnumerable<T> Randomize<T>(IEnumerable<T> source)
    {
      Random rnd = new Random();
      return (IEnumerable<T>) source.OrderBy<T, int>((Func<T, int>) (item => rnd.Next()));
    }

    public static void Execute(ModuleDef module)
    {
      ProxyMeth.ScanMemberRef(module);
      foreach (TypeDef type in module.GetTypes())
      {
        if (!type.IsGlobalModuleType)
        {
          foreach (MethodDef methodDef1 in ((IEnumerable<MethodDef>) type.Methods).ToArray<MethodDef>())
          {
            if (methodDef1.HasBody && !methodDef1.Name.Contains("Proxy"))
            {
              IList<Instruction> instructions = methodDef1.Body.Instructions;
              for (int index1 = 0; index1 < ((ICollection<Instruction>) instructions).Count; ++index1)
              {
                if (methodDef1.Body.Instructions[index1].OpCode == OpCodes.Call)
                {
                  try
                  {
                    MemberRef original = (MemberRef) methodDef1.Body.Instructions[index1].Operand;
                    if (!original.HasThis)
                    {
                      MethodDef methodDef2 = ProxyMeth.GenerateSwitch(original, module);
                      ((ICollection<MethodDef>) methodDef1.DeclaringType.Methods).Add(methodDef2);
                      instructions[index1].OpCode = OpCodes.Call;
                      instructions[index1].Operand = (object) methodDef2;
                      int num = ProxyMeth.rand.Next(0, 5);
                      for (int index2 = 0; index2 < ((ICollection<Instruction>) methodDef2.Body.Instructions).Count - 1; ++index2)
                      {
                        if (methodDef2.Body.Instructions[index2].OpCode == OpCodes.Ldc_I4)
                        {
                          if (string.Compare(methodDef2.Body.Instructions[index2].Operand.ToString(), num.ToString(), StringComparison.Ordinal) != 0)
                          {
                            methodDef2.Body.Instructions[index2].OpCode = OpCodes.Call;
                            methodDef2.Body.Instructions[index2].Operand = (object) ((IEnumerable<MemberRef>) ((IEnumerable<MemberRef>) ProxyMeth.MemberRefList).Where<MemberRef>((Func<MemberRef, bool>) (m => ((ICollection<TypeSig>) ((MethodBaseSig) m.MethodSig).Params).Count == ((ICollection<TypeSig>) ((MethodBaseSig) original.MethodSig).Params).Count)).ToList<MemberRef>()).Random<MemberRef>();
                          }
                          else
                          {
                            methodDef2.Body.Instructions[index2].OpCode = OpCodes.Call;
                            methodDef2.Body.Instructions[index2].Operand = (object) original;
                          }
                        }
                      }
                      methodDef1.Body.Instructions.Insert(index1, Instruction.CreateLdcI4(num));
                    }
                  }
                  catch
                  {
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
