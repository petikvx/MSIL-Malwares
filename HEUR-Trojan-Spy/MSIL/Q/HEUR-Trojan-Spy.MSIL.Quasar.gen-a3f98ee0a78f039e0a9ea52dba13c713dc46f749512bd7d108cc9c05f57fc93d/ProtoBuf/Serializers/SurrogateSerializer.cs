// Decompiled with JetBrains decompiler
// Type: ProtoBuf.Serializers.SurrogateSerializer
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using ProtoBuf.Meta;
using System;
using System.Reflection;

namespace ProtoBuf.Serializers
{
  internal sealed class SurrogateSerializer : IProtoTypeSerializer, IProtoSerializer
  {
    private readonly Type forType;
    private readonly Type declaredType;
    private readonly MethodInfo toTail;
    private readonly MethodInfo fromTail;
    private IProtoTypeSerializer rootTail;

    bool IProtoTypeSerializer.HasCallbacks(TypeModel.CallbackType callbackType) => false;

    bool IProtoTypeSerializer.CanCreateInstance() => false;

    object IProtoTypeSerializer.CreateInstance(ProtoReader source) => throw new NotSupportedException();

    void IProtoTypeSerializer.Callback(
      object value,
      TypeModel.CallbackType callbackType,
      SerializationContext context)
    {
    }

    public bool ReturnsValue => false;

    public bool RequiresOldValue => true;

    public Type ExpectedType => this.forType;

    public SurrogateSerializer(
      TypeModel model,
      Type forType,
      Type declaredType,
      IProtoTypeSerializer rootTail)
    {
      this.forType = forType;
      this.declaredType = declaredType;
      this.rootTail = rootTail;
      this.toTail = this.GetConversion(model, true);
      this.fromTail = this.GetConversion(model, false);
    }

    private static bool HasCast(
      TypeModel model,
      Type type,
      Type from,
      Type to,
      out MethodInfo op)
    {
      MethodInfo[] methods = type.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
      Type attributeType = (Type) null;
      for (int index = 0; index < methods.Length; ++index)
      {
        MethodInfo methodInfo = methods[index];
        if ((object) methodInfo.ReturnType == (object) to)
        {
          ParameterInfo[] parameters = methodInfo.GetParameters();
          if (parameters.Length == 1 && (object) parameters[0].ParameterType == (object) from)
          {
            if ((object) attributeType == null)
            {
              attributeType = model.MapType(typeof (ProtoConverterAttribute), false);
              if ((object) attributeType == null)
                break;
            }
            if (methodInfo.IsDefined(attributeType, true))
            {
              op = methodInfo;
              return true;
            }
          }
        }
      }
      for (int index = 0; index < methods.Length; ++index)
      {
        MethodInfo methodInfo = methods[index];
        if ((!(methodInfo.Name != "op_Implicit") || !(methodInfo.Name != "op_Explicit")) && (object) methodInfo.ReturnType == (object) to)
        {
          ParameterInfo[] parameters = methodInfo.GetParameters();
          if (parameters.Length == 1 && (object) parameters[0].ParameterType == (object) from)
          {
            op = methodInfo;
            return true;
          }
        }
      }
      op = (MethodInfo) null;
      return false;
    }

    public MethodInfo GetConversion(TypeModel model, bool toTail)
    {
      Type to = toTail ? this.declaredType : this.forType;
      Type from = toTail ? this.forType : this.declaredType;
      MethodInfo op;
      if (SurrogateSerializer.HasCast(model, this.declaredType, from, to, out op) || SurrogateSerializer.HasCast(model, this.forType, from, to, out op))
        return op;
      throw new InvalidOperationException("No suitable conversion operator found for surrogate: " + this.forType.FullName + " / " + this.declaredType.FullName);
    }

    public void Write(object value, ProtoWriter writer) => this.rootTail.Write(this.toTail.Invoke((object) null, new object[1]
    {
      value
    }), writer);

    public object Read(object value, ProtoReader source)
    {
      object[] parameters = new object[1]{ value };
      value = this.toTail.Invoke((object) null, parameters);
      parameters[0] = this.rootTail.Read(value, source);
      return this.fromTail.Invoke((object) null, parameters);
    }
  }
}
