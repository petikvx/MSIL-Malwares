// Decompiled with JetBrains decompiler
// Type: SmartAssembly.SmartExceptionsCore.UnhandledExceptionHandler1
// Assembly: o4tdggb3, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: FA0844EB-EF82-404C-B76C-C092ABDB9392
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\Trojan-Ransom.Win32.Blocker.bzqq-b74e3dc76fae79b75c26f27ecb85aae1eae4082a42bfa080f7805f32dedc9d67.exe

using SmartAssembly.Shared;
using System;
using System.Net;
using System.Reflection;
using System.Security;
using System.Security.Permissions;
using System.Threading;
using System.Web.Services.Protocols;
using System.Windows.Forms;

namespace SmartAssembly.SmartExceptionsCore
{
  public abstract class UnhandledExceptionHandler1
  {
    public const string ApplicationName = "{1fe9e38e-05cc-46a3-ae48-6cda8fb62056}";
    public const string CompanyName = "{395edd3b-130e-4160-bb08-6931086cea46}";
    private static readonly bool AlwaysContinueOnError = Convert.ToBoolean("False");
    private static readonly string SecurityExceptionsHaveSpecialTreatment = "1";
    private static UnhandledExceptionHandler1 s_Handler;
    private IWebProxy m_Proxy;

    public event EventHandler DebuggerLaunched;

    public event SendingReportFeedbackEventHandler2 SendingReportFeedback;

    protected abstract void OnReportException(ReportExceptionEventArgs1 e);

    protected abstract void OnFatalException(FatalExceptionEventArgs1 e);

    protected abstract void OnSecurityException(SecurityExceptionEventArgs1 e);

    [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
    public static void AttachExceptionHandler(
      UnhandledExceptionHandler1 unhandledExceptionHandler)
    {
      if (unhandledExceptionHandler == null)
        return;
      UnhandledExceptionHandler1.s_Handler = unhandledExceptionHandler;
      AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(unhandledExceptionHandler.OnUnhandledException);
      Application.ThreadException += new ThreadExceptionEventHandler(unhandledExceptionHandler.OnThreadException);
    }

    private static UnhandledExceptionHandler1 Handler
    {
      get
      {
        if (UnhandledExceptionHandler1.s_Handler == null)
        {
          foreach (System.Type type in Assembly.GetExecutingAssembly().GetTypes())
          {
            if ((object) type != null && (object) type.BaseType != null)
            {
              if ((object) type.BaseType == (object) typeof (UnhandledExceptionHandler1))
              {
                try
                {
                  UnhandledExceptionHandler1.s_Handler = (UnhandledExceptionHandler1) Activator.CreateInstance(type, true);
                  if (UnhandledExceptionHandler1.s_Handler != null)
                    break;
                }
                catch
                {
                }
              }
            }
          }
        }
        return UnhandledExceptionHandler1.s_Handler;
      }
    }

    public static void EntryPointException(Exception exception, object[] objects)
    {
      if (exception != null && exception is SecurityException && UnhandledExceptionHandler1.SecurityExceptionsHaveSpecialTreatment == "1" && UnhandledExceptionHandler1.Handler.InvokeSecurityException((SecurityException) exception))
        return;
      StackFrameHelper1.CreateExceptionN(exception, objects);
      UnhandledExceptionHandler1.Handler.ReportException(exception, false, false);
    }

    public static Exception ReportWebMethodException(Exception exception, object[] objects)
    {
      try
      {
        if ((object) exception.GetType() == (object) typeof (Exception) && exception.Message == "{report}")
          exception = exception.InnerException;
        else
          StackFrameHelper1.CreateExceptionN(exception, objects);
        UnhandledExceptionHandler1.Handler.ReportException(exception, true, false);
      }
      catch
      {
      }
      return (Exception) new SoapException(exception.Message, SoapException.ServerFaultCode);
    }

    public static void ReportException(Exception exception, object[] objects)
    {
      try
      {
        if ((object) exception.GetType() == (object) typeof (Exception) && exception.Message == "{report}")
          exception = exception.InnerException;
        else
          StackFrameHelper1.CreateExceptionN(exception, objects);
        UnhandledExceptionHandler1.Handler.ReportException(exception, true, true);
      }
      catch
      {
      }
    }

    private void OnThreadException(object sender, ThreadExceptionEventArgs e)
    {
      try
      {
        Exception exception = e.Exception;
        System.Type type = exception.GetType();
        if (type.Name == "UnhandledException" && type.Namespace == "SmartAssembly.SmartExceptionsCore")
          exception = (Exception) type.GetField("PreviousException").GetValue((object) exception);
        if (exception is SecurityException && UnhandledExceptionHandler1.SecurityExceptionsHaveSpecialTreatment == "1" && this.InvokeSecurityException(exception as SecurityException))
          return;
        this.ReportException(exception, true, false);
      }
      catch
      {
      }
    }

    private void OnUnhandledException(object sender, UnhandledExceptionEventArgs e)
    {
      try
      {
        if (e.ExceptionObject is SecurityException && UnhandledExceptionHandler1.SecurityExceptionsHaveSpecialTreatment == "1" && this.InvokeSecurityException(e.ExceptionObject as SecurityException) || !(e.ExceptionObject is Exception))
          return;
        this.ReportException((Exception) e.ExceptionObject, !e.IsTerminating, false);
      }
      catch
      {
      }
    }

    public void SetProxy(IWebProxy proxy) => this.m_Proxy = proxy;

    protected virtual Guid GetUserID() => Guid.Empty;

    private bool InvokeSecurityException(SecurityException exception)
    {
      SecurityExceptionEventArgs1 e = new SecurityExceptionEventArgs1(exception);
      this.OnSecurityException(e);
      if (e.ReportException)
        return false;
      if (!e.TryToContinue)
        Application.Exit();
      return true;
    }

    [ReportUsageAttribute1("Unhandled Exception Encountered")]
    private void ReportException(Exception exception, bool canContinue, bool manuallyReported)
    {
      System.Type type = exception.GetType();
      if (type.Name == "UnhandledException" && type.Namespace == "SmartAssembly.SmartExceptionsCore")
        exception = (Exception) type.GetField("PreviousException").GetValue((object) exception);
      bool flag = true;
      if (exception == null)
        return;
      if (exception is ThreadAbortException)
        return;
      try
      {
        ErrorReportSender reportSender = new ErrorReportSender(this.GetUserID(), exception, this.m_Proxy);
        reportSender.SendingReportFeedback += new SendingReportFeedbackEventHandler2(this.InvokeSendingReportFeedback);
        reportSender.DebuggerLaunched += new EventHandler(this.InvokeDebuggerLaunched);
        reportSender.FatalException += new FatalExceptionEventHandler1(this.InvokeOnFatalException);
        ReportExceptionEventArgs1 e = new ReportExceptionEventArgs1(reportSender, exception);
        if (AppPathFinder1.ReadInstalledSaPath() != null)
          e.EnableDebug();
        if (!canContinue)
        {
          e.SetShowContinueCheckBox(false);
          e.TryToContinue = false;
        }
        else if (manuallyReported || UnhandledExceptionHandler1.AlwaysContinueOnError)
        {
          e.SetShowContinueCheckBox(false);
          e.TryToContinue = true;
        }
        this.OnReportException(e);
        flag = !e.TryToContinue;
      }
      catch (ThreadAbortException ex)
      {
      }
      catch (Exception ex)
      {
        this.OnFatalException(new FatalExceptionEventArgs1(ex));
      }
      if (!flag)
        return;
      foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
      {
        try
        {
          string fullName = assembly.FullName;
          if (fullName.EndsWith("31bf3856ad364e35"))
          {
            if (fullName.StartsWith("PresentationFramework,"))
            {
              object obj = assembly.GetType("System.Windows.Application").GetProperty("Current").GetGetMethod().Invoke((object) null, (object[]) null);
              obj.GetType().GetMethod("Shutdown", new System.Type[0]).Invoke(obj, (object[]) null);
            }
          }
        }
        catch
        {
        }
      }
      try
      {
        Application.Exit();
      }
      catch
      {
        try
        {
          Environment.Exit(0);
        }
        catch
        {
        }
      }
    }

    private void InvokeOnFatalException(
      object sender,
      FatalExceptionEventArgs1 fatalExceptionEventArgs)
    {
      this.OnFatalException(fatalExceptionEventArgs);
    }

    private void InvokeDebuggerLaunched(object sender, EventArgs eventArgs)
    {
      EventHandler debuggerLaunched = this.DebuggerLaunched;
      if (debuggerLaunched == null)
        return;
      debuggerLaunched(sender, eventArgs);
    }

    private void InvokeSendingReportFeedback(
      object sender,
      SendingReportFeedbackEventArgs2 sendingReportFeedbackEventArgs)
    {
      SendingReportFeedbackEventHandler2 sendingReportFeedback = this.SendingReportFeedback;
      if (sendingReportFeedback == null)
        return;
      sendingReportFeedback(sender, sendingReportFeedbackEventArgs);
    }
  }
}
