// Decompiled with JetBrains decompiler
// Type: .
// Assembly: 1m, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 9A9758D8-D673-4760-AFDD-69A3D20C59FF
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Blocker.krdt-d2cd288694c5883ae6364f17a60ae3fe9619748d94946bbd3e1ff8ba566b1e0f.exe

using \u0001;
using \u000E;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;

namespace \u0001
{
  internal static class \u0002
  {
    private static readonly object \u0020;
    private static Dictionary<int, string> \u0020;
    [NonSerialized]
    internal static \u0013 \u0005;

    static \u0002()
    {
      \u0003.\u0001(typeof (\u0002));
      \u0002.\u0020 = new object();
    }

    internal static string \u0020(int _param0, int _param1, int _param2)
    {
      lock (\u0002.\u0020)
      {
        int num1 = _param0 ^ 1607669752;
        if (\u0002.\u0020 != null && \u0002.\u0020.ContainsKey(num1))
          return \u0002.\u0020[num1];
        Assembly executingAssembly = Assembly.GetExecutingAssembly();
        byte[] buffer1;
        using (Stream manifestResourceStream = executingAssembly.GetManifestResourceStream(\u0002.\u0005(1547)))
        {
          buffer1 = new byte[manifestResourceStream.Length];
          manifestResourceStream.Read(buffer1, 0, Convert.ToInt32(manifestResourceStream.Length));
        }
        int num2 = _param1;
        byte[] publicKeyToken = executingAssembly.GetName().GetPublicKeyToken();
        int num3;
        if (publicKeyToken != null && publicKeyToken.Length == 8)
        {
          int int32_1 = BitConverter.ToInt32(publicKeyToken, 0);
          int int32_2 = BitConverter.ToInt32(publicKeyToken, 4);
          num3 = num2 ^ int32_1 ^ int32_2;
        }
        else
          num3 = num2 ^ 306750943;
        int length = _param2 ^ 656073751;
        byte[] bytes = new byte[length];
        int num4 = 0;
        for (int index = num3; index < num3 + length; ++index)
          bytes[num4++] = buffer1[index];
        byte[] buffer2 = new byte[length];
        new Random(num1).NextBytes(buffer2);
        for (int index = 0; index < length; ++index)
          bytes[index] ^= buffer2[index];
        string str = Encoding.Unicode.GetString(bytes);
        if (\u0002.\u0020 == null)
          \u0002.\u0020 = new Dictionary<int, string>();
        \u0002.\u0020.Add(num1, str);
        return str;
      }
    }
  }
}
