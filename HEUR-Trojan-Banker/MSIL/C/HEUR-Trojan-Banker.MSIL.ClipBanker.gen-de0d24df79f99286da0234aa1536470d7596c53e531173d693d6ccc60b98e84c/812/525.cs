// Decompiled with JetBrains decompiler
// Type: 812.525
// Assembly: uc5uTlQKZwvBJeUwoIoxWYL1o3uBI8gaMfnT9AO, Version=9.8.6.0, Culture=neutral, PublicKeyToken=null
// MVID: 66B519F9-803D-46C9-8343-EC24850CA08A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-de0d24df79f99286da0234aa1536470d7596c53e531173d693d6ccc60b98e84c.exe

using \u0031Y3;
using \u0032Zv;
using \u0037q5;
using hyS;
using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace \u003812
{
  internal sealed class \u003525 : Stream
  {
    private \u0035N5 Z15;
    private Stream \u0032v2;
    private LzE \u00354D;
    private int B77;
    private bool \u0031SJ;
    internal HMACSHA1 aM8;
    internal Aes \u003793;
    internal ICryptoTransform \u00387b;
    private byte[] \u003918 = new byte[16];
    private byte[] Qk4 = new byte[16];
    private long \u0039uK;
    private long Gv3;
    private byte[] f9T;
    private int \u0037k4;
    private byte[] HVq;
    private object EA4 = new object();

    internal \u003525([In] Stream obj0, [In] \u0035N5 obj1, [In] long obj2, [In] LzE obj3)
      : this(obj0, obj1, obj3)
    {
      if (obj0 == null)
        throw new ArgumentNullException("s");
      this.\u0039uK = obj2;
    }

    internal \u003525([In] Stream obj0, [In] \u0035N5 obj1, [In] LzE obj2)
    {
      this.Z15 = obj1;
      this.\u0032v2 = obj0;
      this.\u00354D = obj2;
      this.B77 = 1;
      if (this.Z15 == null)
        throw new D2v("Supply a password to use AES encryption.");
      int num = this.Z15.\u00372B().Length * 8;
      switch (num)
      {
        case 128:
        case 192:
        case 256:
          this.aM8 = new HMACSHA1(this.Z15.\u003941());
          this.\u003793 = Aes.Create();
          this.\u003793.BlockSize = 128;
          this.\u003793.KeySize = num;
          this.\u003793.Mode = CipherMode.ECB;
          this.\u003793.Padding = PaddingMode.None;
          byte[] rgbIV = new byte[16];
          this.\u00387b = this.\u003793.CreateEncryptor(this.Z15.\u00372B(), rgbIV);
          if (this.\u00354D != LzE.\u0023a)
            break;
          this.HVq = new byte[2048];
          this.f9T = new byte[16];
          break;
        default:
          throw new ArgumentOutOfRangeException("keysize", "size of key must be 128, 192, or 256");
      }
    }

    private void wUE([In] byte[] obj0, [In] int obj1, [In] int obj2)
    {
      for (int index = 0; index < obj2; ++index)
        obj0[obj1 + index] = (byte) ((uint) this.Qk4[index] ^ (uint) obj0[obj1 + index]);
    }

    private void \u0036f5([In] byte[] obj0, [In] int obj1)
    {
      Array.Copy((Array) BitConverter.GetBytes(this.B77++), 0, (Array) this.\u003918, 0, 4);
      this.\u00387b.TransformBlock(this.\u003918, 0, 16, this.Qk4, 0);
      this.wUE(obj0, obj1, 16);
      this.aM8.TransformBlock(obj0, obj1, 16, (byte[]) null, 0);
    }

    private void VkD([In] byte[] obj0, [In] int obj1, [In] int obj2)
    {
      int num = obj1;
      for (int index = obj2 + obj1; num < obj0.Length && num < index; num += 16)
        this.\u0036f5(obj0, num);
    }

    private void fCH()
    {
      if (this.\u0037k4 == 0)
        throw new InvalidOperationException("No bytes available.");
      if (this.\u0031SJ)
        throw new InvalidOperationException("The final block has already been transformed.");
      Array.Copy((Array) BitConverter.GetBytes(this.B77++), 0, (Array) this.\u003918, 0, 4);
      this.Qk4 = this.\u00387b.TransformFinalBlock(this.\u003918, 0, 16);
      this.wUE(this.f9T, 0, this.\u0037k4);
      this.aM8.TransformFinalBlock(this.f9T, 0, this.\u0037k4);
      this.\u0031SJ = true;
    }

    private int RM4([In] byte[] obj0, [In] int obj1, [In] int obj2)
    {
      if (this.\u0031SJ)
        throw new NotSupportedException();
      int num = obj2 - obj1;
      int inputCount = num > 16 ? 16 : num;
      Array.Copy((Array) BitConverter.GetBytes(this.B77++), 0, (Array) this.\u003918, 0, 4);
      if (inputCount == num && this.\u0039uK > 0L && this.Gv3 + (long) obj2 == this.\u0039uK)
      {
        this.aM8.TransformFinalBlock(obj0, obj1, inputCount);
        this.Qk4 = this.\u00387b.TransformFinalBlock(this.\u003918, 0, 16);
        this.\u0031SJ = true;
      }
      else
      {
        this.aM8.TransformBlock(obj0, obj1, inputCount, (byte[]) null, 0);
        this.\u00387b.TransformBlock(this.\u003918, 0, 16, this.Qk4, 0);
      }
      this.wUE(obj0, obj1, inputCount);
      return inputCount;
    }

    private void \u0038Z6([In] byte[] obj0, [In] int obj1, [In] int obj2)
    {
      int num1 = obj1;
      int num2;
      for (int index = obj2 + obj1; num1 < obj0.Length && num1 < index; num1 += num2)
        num2 = this.RM4(obj0, num1, index);
    }

    int Stream.\u0034v3([In] byte[] obj0, [In] int obj1, [In] int obj2)
    {
      if (this.\u00354D == LzE.\u0023a)
        throw new NotSupportedException();
      if (obj0 == null)
        throw new ArgumentNullException("buffer");
      if (obj1 < 0)
        throw new ArgumentOutOfRangeException("offset", "Must not be less than zero.");
      if (obj2 < 0)
        throw new ArgumentOutOfRangeException("count", "Must not be less than zero.");
      if (obj0.Length < obj1 + obj2)
        throw new ArgumentException("The buffer is too small");
      int count = obj2;
      if (this.Gv3 >= this.\u0039uK)
        return 0;
      long num1 = this.\u0039uK - this.Gv3;
      if (num1 < (long) obj2)
        count = (int) num1;
      int num2 = this.\u0032v2.Read(obj0, obj1, count);
      this.\u0038Z6(obj0, obj1, count);
      this.Gv3 += (long) num2;
      return num2;
    }

    [SpecialName]
    public byte[] M41()
    {
      if (!this.\u0031SJ)
      {
        if (this.Gv3 != 0L)
          throw new UW5("The final hash has not been computed.");
        this.aM8.ComputeHash(new byte[0]);
      }
      byte[] destinationArray = new byte[10];
      Array.Copy((Array) this.aM8.Hash, 0, (Array) destinationArray, 0, 10);
      return destinationArray;
    }

    void Stream.l17([In] byte[] obj0, [In] int obj1, [In] int obj2)
    {
      if (this.\u0031SJ)
        throw new InvalidOperationException("The final block has already been transformed.");
      if (this.\u00354D == LzE.\u0023b)
        throw new NotSupportedException();
      if (obj0 == null)
        throw new ArgumentNullException("buffer");
      if (obj1 < 0)
        throw new ArgumentOutOfRangeException("offset", "Must not be less than zero.");
      if (obj2 < 0)
        throw new ArgumentOutOfRangeException("count", "Must not be less than zero.");
      if (obj0.Length < obj1 + obj2)
        throw new ArgumentException("The offset and count are too large");
      if (obj2 == 0)
        return;
      if (obj2 + this.\u0037k4 <= 16)
      {
        Buffer.BlockCopy((Array) obj0, obj1, (Array) this.f9T, this.\u0037k4, obj2);
        this.\u0037k4 += obj2;
      }
      else
      {
        int num1 = obj2;
        int srcOffset = obj1;
        if (this.\u0037k4 != 0)
        {
          int count = 16 - this.\u0037k4;
          if (count > 0)
          {
            Buffer.BlockCopy((Array) obj0, obj1, (Array) this.f9T, this.\u0037k4, count);
            num1 -= count;
            srcOffset += count;
          }
          this.\u0036f5(this.f9T, 0);
          this.\u0032v2.Write(this.f9T, 0, 16);
          this.Gv3 += 16L;
          this.\u0037k4 = 0;
        }
        int num2 = (num1 - 1) / 16;
        this.\u0037k4 = num1 - num2 * 16;
        Buffer.BlockCopy((Array) obj0, srcOffset + num1 - this.\u0037k4, (Array) this.f9T, 0, this.\u0037k4);
        int num3 = num1 - this.\u0037k4;
        this.Gv3 += (long) num3;
        if (num2 <= 0)
          return;
        do
        {
          int count = this.HVq.Length;
          if (count > num3)
            count = num3;
          Buffer.BlockCopy((Array) obj0, srcOffset, (Array) this.HVq, 0, count);
          this.VkD(this.HVq, 0, count);
          this.\u0032v2.Write(this.HVq, 0, count);
          num3 -= count;
          srcOffset += count;
        }
        while (num3 > 0);
      }
    }

    void Stream.JeJ()
    {
      if (this.\u0037k4 > 0)
      {
        this.fCH();
        this.\u0032v2.Write(this.f9T, 0, this.\u0037k4);
        this.Gv3 += (long) this.\u0037k4;
        this.\u0037k4 = 0;
      }
      this.\u0032v2.Close();
      this.\u00387b.Dispose();
      this.\u003793.Dispose();
    }

    [SpecialName]
    bool Stream.SF6() => this.\u00354D == LzE.\u0023b;

    [SpecialName]
    bool Stream.ADH() => false;

    [SpecialName]
    bool Stream.x5C() => this.\u00354D == LzE.\u0023a;

    void Stream.f1D() => this.\u0032v2.Flush();

    [SpecialName]
    long Stream.Sm2() => throw new NotImplementedException();

    [SpecialName]
    long Stream.\u0036zI() => throw new NotImplementedException();

    [SpecialName]
    void Stream.\u0035C2([In] long obj0) => throw new NotImplementedException();

    long Stream.\u003659([In] long obj0, [In] SeekOrigin obj1) => throw new NotImplementedException();

    void Stream.\u0035RW([In] long obj0) => throw new NotImplementedException();
  }
}
