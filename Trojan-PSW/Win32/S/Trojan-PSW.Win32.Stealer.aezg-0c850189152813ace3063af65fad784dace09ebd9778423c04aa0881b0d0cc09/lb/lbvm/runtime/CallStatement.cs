// Decompiled with JetBrains decompiler
// Type: org.lb.lbvm.runtime.CallStatement
// Assembly: GCCollectionMo, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3A5CAC9E-800C-431E-83D8-5129C6781923
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\Trojan-PSW.Win32.Stealer.aezg-0c850189152813ace3063af65fad784dace09ebd9778423c04aa0881b0d0cc09.exe

using org.lb.lbvm.exceptions;

namespace org.lb.lbvm.runtime
{
  internal sealed class CallStatement : Statement
  {
    private readonly int NumberOfPushedArguments;

    internal CallStatement(int numberOfPushedArguments)
      : base(5, "CALL " + numberOfPushedArguments.ToString())
    {
      this.NumberOfPushedArguments = numberOfPushedArguments;
    }

    internal override void Execute(
      ref int ip,
      ValueStack valueStack,
      EnvironmentStack envStack,
      CallStack callStack)
    {
      object fromTop = valueStack.GetFromTop(this.NumberOfPushedArguments);
      switch (fromTop)
      {
        case IP _:
          callStack.Push(ip + this.Length, this.NumberOfPushedArguments);
          ip = ((IP) fromTop).Value;
          break;
        case Closure _:
          Closure closure = (Closure) fromTop;
          foreach (Variable closedOverValue in closure.ClosedOverValues)
            valueStack.Push((object) closedOverValue);
          callStack.Push(ip + this.Length, this.NumberOfPushedArguments + closure.ClosedOverValues.Count);
          ip = closure.Target;
          break;
        default:
          throw new RuntimeException("Invalid CALL target");
      }
    }
  }
}
