// Decompiled with JetBrains decompiler
// Type: forces.Forces
// Assembly: MuiResourceTypeIdIntEn, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 2C7C9528-88C0-45FF-AB6A-2AC0C29EABCB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Backdoor.MSIL.Androm.gen-0e10e646be7b3f9857a2994bedc1b808fabc112009cda3192df15b8eb4980ef8.exe

using System.Collections.Generic;
using System.Linq;

namespace forces
{
  public class Forces
  {
    private LinkedList<BeamForce> forces;

    public Forces(double weight, double beamLength)
    {
      this.forces = new LinkedList<BeamForce>();
      this.forces.AddFirst((BeamForce) new ReflectionBeamForce(weight / 2.0, 0.0, beamLength));
      this.forces.AddLast((BeamForce) new ReflectionBeamForce(weight / 2.0, beamLength, beamLength));
      this.forces.AddBefore(this.forces.Last, (BeamForce) new DistributedBeamForce(weight / beamLength, 0.0, beamLength, beamLength));
    }

    public BeamForce this[double value]
    {
      get
      {
        foreach (BeamForce force in this.forces)
        {
          if (force is PointBaemForce && (force as PointBaemForce).Position == value)
            return force;
        }
        return (BeamForce) null;
      }
    }

    public BeamForce this[double value1, double value2]
    {
      get
      {
        foreach (BeamForce force in this.forces)
        {
          if (force is DistributedBeamForce && (force as DistributedBeamForce).Start == value1 && (force as DistributedBeamForce).End == value2)
            return force;
        }
        return (BeamForce) null;
      }
    }

    public BeamForce this[int value] => this.forces.ElementAt<BeamForce>(value);

    public void Add(BeamForce item)
    {
      if (item is ReflectionBeamForce)
        return;
      bool flag = false;
      foreach (BeamForce force in this.forces)
      {
        if (force.canAdd((Force_) item))
        {
          force.add((Force_) item);
          flag = true;
          break;
        }
      }
      if (!flag)
        this.forces.AddBefore(this.forces.Last, item);
      this.forces.First.Value.add((Force_) item.getReflection(0));
      this.forces.Last.Value.add((Force_) item.getReflection(1));
    }

    public void AddAll(Forces alot)
    {
      foreach (BeamForce force in alot.forces)
        this.Add(force);
    }

    public double getShaer(double distance)
    {
      double shaer = 0.0;
      foreach (BeamForce force in this.forces)
        shaer += force.getShaer(distance);
      return shaer;
    }

    public double getMomentom(double distance)
    {
      double momentom = 0.0;
      foreach (BeamForce force in this.forces)
        momentom += force.getMomentom(distance);
      return momentom;
    }

    public double getfMomentomd2x(double distance)
    {
      double num = 0.0;
      foreach (BeamForce force in this.forces)
        num += force.getfMomentomd2x(distance);
      return num;
    }

    public void Clear() => this.forces.Clear();

    public bool Contains(BeamForce item) => this.forces.Contains(item);

    public void CopyTo(BeamForce[] array, int arrayIndex) => this.forces.CopyTo(array, arrayIndex);

    public int Count => this.forces.Count;

    public bool Remove(BeamForce item) => this.forces.Remove(item);
  }
}
