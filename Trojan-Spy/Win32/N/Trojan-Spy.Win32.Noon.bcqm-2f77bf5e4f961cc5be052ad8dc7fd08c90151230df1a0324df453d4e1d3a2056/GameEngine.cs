// Decompiled with JetBrains decompiler
// Type: mmxAH.GameEngine
// Assembly: PermissionTokenFact, Version=1.0.2.2, Culture=neutral, PublicKeyToken=null
// MVID: 0E8B010F-DA1B-42FA-9C31-C1DCAF557A03
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcqm-2f77bf5e4f961cc5be052ad8dc7fd08c90151230df1a0324df453d4e1d3a2056.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Windows.Forms;

namespace mmxAH
{
  public class GameEngine
  {
    public PairMeneger ds;
    public PairMeneger colors;
    private List<GameEngine.Limits> lims;
    private const string BinaryFileName = "data.bin";
    private const string TextFileName = "data.txt";
    private const string LangvFileName = "langv_eng.txt";
    public List<Locathion> locs;
    public Deck<GatePrototype> gates;
    public OWMeneger ows;
    public IOClass io;
    public List<Investigator> ActiveInvistigators;
    public List<MonsterPrototype> MonsterPrototypes;
    public List<MonsterIndivid> ActiveMonsters;
    public Deck<MonsterIndivid> MonstersCup;
    public SystemStrings sysstr;
    public PhasesClock clock;
    public MapOfCity map;
    private GameEngine.Limits lim;
    public Preference pref;
    private Deck<Investigator> invests;
    public SkillTestInfos GlobalModifs;
    public List<SpecialCardText> scTexts;
    private MainMenuForm mmFrm;
    public Deck<MythosCard> mythosDeck;
    public CurStorage curs;
    public GlobalActhions ga;
    public Deck<OWEncCard> owEnc;
    public Deck<ArcEncCard>[] archEncs;
    public GlobalStatus status;
    public List<MonsterIndivid> Outscirts;
    public List<MonsterIndivid> Scy;
    public List<GatePrototype> openGates;

    public GameEngine(MainMenuForm pMmFrm)
    {
      this.ds = new PairMeneger();
      this.colors = new PairMeneger();
      this.lims = new List<GameEngine.Limits>();
      this.locs = new List<Locathion>();
      this.gates = new Deck<GatePrototype>(true);
      this.ows = new OWMeneger(this);
      this.ActiveInvistigators = new List<Investigator>();
      this.ActiveMonsters = new List<MonsterIndivid>();
      this.MonstersCup = new Deck<MonsterIndivid>(true);
      this.sysstr = new SystemStrings();
      this.clock = new PhasesClock(this);
      this.pref = new Preference();
      this.invests = new Deck<Investigator>();
      this.GlobalModifs = new SkillTestInfos();
      this.scTexts = new List<SpecialCardText>();
      this.mmFrm = pMmFrm;
      this.mythosDeck = new Deck<MythosCard>();
      this.MonsterPrototypes = new List<MonsterPrototype>();
      this.curs = new CurStorage(this);
      this.ga = new GlobalActhions(this);
      this.owEnc = new Deck<OWEncCard>();
      this.status = new GlobalStatus(this);
      this.Outscirts = new List<MonsterIndivid>();
      this.Scy = new List<MonsterIndivid>();
      this.openGates = new List<GatePrototype>();
    }

    public bool Init() => File.Exists(TextFileParser.CreatePath("data.bin")) ? new BinaryWorker(this, "data.bin").BinaryInit() : new TextWorker(this).TextInit("data.txt", "langv_eng.txt");

    public bool LimitsFromText(TextFileParser prs)
    {
      int result;
      if (!int.TryParse(prs.GetToken(), out result))
        return false;
      GameEngine.Limits limits = new GameEngine.Limits();
      for (int index = 0; index < result; ++index)
      {
        if (!byte.TryParse(prs.GetToken(), out limits.players) || !byte.TryParse(prs.GetToken(), out limits.gates) || !byte.TryParse(prs.GetToken(), out limits.mA) || !byte.TryParse(prs.GetToken(), out limits.mO))
          return false;
        this.lims.Add(limits);
        limits = new GameEngine.Limits();
      }
      return true;
    }

    public bool InvestigatorsFromText(TextFileParser prs, TextFileParser text)
    {
      int result;
      if (!int.TryParse(prs.GetToken(), out result))
        return false;
      for (short pId = 0; (int) pId < result; ++pId)
      {
        Investigator c = new Investigator(this, pId);
        if (!c.FromTextFile(prs, text))
          return false;
        this.invests.Add(c);
      }
      return true;
    }

    private void Test()
    {
      ((ArchemUnstableLoc) this.locs[(int) this.map.GetNumberByCodeName("scienceBild")]).OpenGate();
      ((ArchemUnstableLoc) this.locs[(int) this.map.GetNumberByCodeName("cave")]).OpenGate();
      ((ArchemUnstableLoc) this.locs[(int) this.map.GetNumberByCodeName("indsqr")]).OpenGate();
      ((ArchemUnstableLoc) this.locs[(int) this.map.GetNumberByCodeName("road")]).OpenGate();
      this.mythosDeck.Draw().Execute();
    }

    public void LimitsFromBinary(BinaryReader rd)
    {
      int num = rd.ReadInt32();
      for (int index = 0; index < num; ++index)
        this.lims.Add(new GameEngine.Limits()
        {
          players = rd.ReadByte(),
          gates = rd.ReadByte(),
          mA = rd.ReadByte(),
          mO = rd.ReadByte()
        });
    }

    public void LimitsToBinary(BinaryWriter wr)
    {
      wr.Write(this.lims.Count);
      foreach (GameEngine.Limits lim in this.lims)
      {
        wr.Write(lim.players);
        wr.Write(lim.gates);
        wr.Write(lim.mA);
        wr.Write(lim.mO);
      }
    }

    public void newGame()
    {
      this.Reset();
      this.io.PrintToLog(this.sysstr.GetString(SSType.Setup_Started) + "  " + DateTime.Now.ToString() + "." + Environment.NewLine);
      List<IOOption> opts = new List<IOOption>();
      for (short p = 1; (int) p <= this.lims.Count; ++p)
        opts.Add((IOOption) new IOOptionWithParam(p.ToString(), new FuncWithParam(this.NewGame_NumOfInv), p));
      this.io.StartChoose(opts, this.sysstr.GetString(SSType.Setup_NumOfInv_Promt), this.sysstr.GetString(SSType.Confirm));
    }

    private void NewGame_NumOfInv(short num)
    {
      this.lim = this.lims[(int) num - 1];
      this.io.PrintToLog(this.sysstr.GetString(SSType.Setup_NumOfInv_Fact) + " : " + num.ToString() + "." + Environment.NewLine);
      this.status.Init(this.lim.gates, this.lim.mA, this.lim.mO);
      for (byte index = 0; (int) index < (int) num; ++index)
      {
        this.ActiveInvistigators.Add(this.invests.Draw());
        this.ActiveInvistigators[(int) index].Setup(index);
      }
      this.Test();
    }

    public void ToBin()
    {
      WorkForm mainForm = new WorkForm(this, true);
      this.io.StandAloneStart(new Func(this.ToBin2));
      Application.Run((Form) mainForm);
    }

    public void ToBin2()
    {
      this.io.Print("Convert text files to binary" + Environment.NewLine, (byte) 16, true);
      this.io.Print("Data file: data.txt" + Environment.NewLine);
      this.io.Print("Strings file: langv_eng.txt" + Environment.NewLine);
      this.io.Print("Loading data...");
      if (!new TextWorker(this).TextInit("data.txt", "langv_eng.txt"))
      {
        this.io.Print("Error !!!", (byte) 16, true);
      }
      else
      {
        this.io.Print("OK." + Environment.NewLine);
        new BinaryWorker(this, "data.bin").ToBin();
      }
    }

    public byte GetPlayersNumber() => this.lim.players;

    public void SetWorkForm(WorkForm frm) => this.io = new IOClass(frm, this, this.mmFrm);

    public void Reset()
    {
      this.curs.Reset();
      for (int index = 0; index < this.ActiveInvistigators.Count; ++index)
      {
        this.invests.Add(this.ActiveInvistigators[index]);
        this.ActiveInvistigators[index].Reset();
      }
      this.ActiveInvistigators.Clear();
      for (int index = 0; index < this.ActiveMonsters.Count; ++index)
        this.MonstersCup.Add(this.ActiveMonsters[index]);
      this.ActiveMonsters.Clear();
      foreach (Locathion loc in this.locs)
        loc.Reset();
      foreach (MonsterIndivid outscirt in this.Outscirts)
        this.MonstersCup.Add(outscirt);
      this.clock.Reset();
      this.status.Reset();
      this.ResetOutscirts();
      foreach (GatePrototype openGate in this.openGates)
        this.gates.Add(openGate);
      this.openGates.Clear();
      this.MonstersCup.Reset();
      this.mythosDeck.Reset();
      this.gates.Reset();
      this.invests.Reset();
      this.owEnc.Reset();
    }

    public void ResetOutscirts()
    {
      foreach (MonsterIndivid outscirt in this.Outscirts)
        this.MonstersCup.Add(outscirt);
      this.Outscirts.Clear();
    }

    public void SaveActive(BinaryWriter wr)
    {
      wr.Write(this.lim.players);
      foreach (Card activeInvistigator in this.ActiveInvistigators)
        activeInvistigator.WriteToSave(wr);
      wr.Write(this.ActiveMonsters.Count);
      foreach (Card activeMonster in this.ActiveMonsters)
        activeMonster.WriteToSave(wr);
      wr.Write(this.Outscirts.Count);
      foreach (Card outscirt in this.Outscirts)
        outscirt.WriteToSave(wr);
    }

    public void LoadActive(BinaryReader rd)
    {
      byte num1 = rd.ReadByte();
      this.lim = this.lims[(int) num1 - 1];
      this.status.Init(this.lim.gates, this.lim.mA, this.lim.mO);
      for (byte index = 0; (int) index < (int) num1; ++index)
      {
        this.ActiveInvistigators.Add(this.invests.GetCardById(rd.ReadInt16()));
        this.ActiveInvistigators[(int) index].ReadFromSave(rd);
      }
      int num2 = rd.ReadInt32();
      for (int index = 0; index < num2; ++index)
      {
        this.ActiveMonsters.Add(this.MonstersCup.GetCardById(rd.ReadInt16()));
        this.ActiveMonsters[index].ReadFromSave(rd);
      }
      int num3 = rd.ReadInt32();
      for (int index = 0; index < num3; ++index)
      {
        this.Outscirts.Add(this.MonstersCup.GetCardById(rd.ReadInt16()));
        this.Outscirts[index].ReadFromSave(rd);
      }
    }

    private struct Limits
    {
      public byte players;
      public byte gates;
      public byte mA;
      public byte mO;
    }
  }
}
