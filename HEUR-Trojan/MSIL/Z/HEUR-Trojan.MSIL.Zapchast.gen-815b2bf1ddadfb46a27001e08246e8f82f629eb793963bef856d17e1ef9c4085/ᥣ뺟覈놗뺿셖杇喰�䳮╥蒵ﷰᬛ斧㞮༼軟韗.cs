// Decompiled with JetBrains decompiler
// Type: ᥣ뺟覈놗뺿셖杇喰�䳮╥蒵ﷰᬛ斧㞮༼軟韗
// Assembly: $77-Venom, Version=2.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC8E8704-647D-4CA7-99AB-BB7BE936B486
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Zapchast.gen-815b2bf1ddadfb46a27001e08246e8f82f629eb793963bef856d17e1ef9c4085.exe

using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

public static class ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗
{
  private const int \uFFFD蔰\uE6B5ﳜ䦳\u0E70鼱꾩\uFB0E鬅솴肔ㆦ葪ᣠ즛쉿㕊㻚行 = 16;
  private const int 쪑頢薠\uF160\uE8C8偃侨ﺷ提嫠ꮭ\u2F03쭈ॻ귪蒧㪯\u20F2恥氶 = 32;
  private static byte[] 㰱쥐ᱢ뗯ⴙ\uFFBF킅쪆䕎\u0EC7胐ᆑꆹ\uA7CD芘깳崱\u0017䆭쀩;
  private static byte[] 僞茂袠\uF5DA㗝\uF2B8턕ᑐ\uFFFD䨕鍲ᨣﭜ峽筌⃫仳璼䮳\uE115;
  public static readonly byte[] 烃꣤잓ꩫ겮凌ᡴꞃ\uFFFD厢轞铫ￍ玕哠\uEB0D\uFFFD裱饝얌 = new byte[32]
  {
    (byte) 191,
    (byte) 235,
    (byte) 30,
    (byte) 86,
    (byte) 251,
    (byte) 205,
    (byte) 151,
    (byte) 59,
    (byte) 178,
    (byte) 25,
    (byte) 2,
    (byte) 36,
    (byte) 48,
    (byte) 165,
    (byte) 120,
    (byte) 67,
    (byte) 0,
    (byte) 61,
    (byte) 86,
    (byte) 68,
    (byte) 210,
    (byte) 30,
    (byte) 98,
    (byte) 185,
    (byte) 212,
    (byte) 241,
    (byte) 128,
    (byte) 231,
    (byte) 230,
    (byte) 195,
    (byte) 57,
    (byte) 65
  };

  public static void ᆫꇟ\uFFFDѕ丈䍝\u2A48캭䆂잢\uFFFD珶\u2A8Eス聯㵰㐲\uFFFD錇輜(string key)
  {
    using (Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(key, ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.烃꣤잓ꩫ겮凌ᡴꞃ\uFFFD厢轞铫ￍ玕哠\uEB0D\uFFFD裱饝얌, 50000))
    {
      ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.㰱쥐ᱢ뗯ⴙ\uFFBF킅쪆䕎\u0EC7胐ᆑꆹ\uA7CD芘깳崱\u0017䆭쀩 = rfc2898DeriveBytes.GetBytes(16);
      ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.僞茂袠\uF5DA㗝\uF2B8턕ᑐ\uFFFD䨕鍲ᨣﭜ峽筌⃫仳璼䮳\uE115 = rfc2898DeriveBytes.GetBytes(64);
    }
  }

  public static void 襾猰밗硑\u27DA터孯쨝䃤\uF35D\uE10F껷\uEE22\uE3F5朅깪㙓寱욏燙(string key, string authKey)
  {
    ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.㰱쥐ᱢ뗯ⴙ\uFFBF킅쪆䕎\u0EC7胐ᆑꆹ\uA7CD芘깳崱\u0017䆭쀩 = Convert.FromBase64String(key);
    ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.僞茂袠\uF5DA㗝\uF2B8턕ᑐ\uFFFD䨕鍲ᨣﭜ峽筌⃫仳璼䮳\uE115 = Convert.FromBase64String(authKey);
  }

  public static string \u2E46\u2E8E햔\u1754젳냋ꆢѯ몰稗쿅伧겹퇀\u2E37䫲돓\uEC02レ蠳(string input, string key) => Convert.ToBase64String(ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.뒜႓\u2357ꨎ\uFFFD쮕䑐픸ﾗ圗ﴖ퍭\u240C뮩ᶤ堓菬蟩뵩\uFFFD(Encoding.UTF8.GetBytes(input), Encoding.UTF8.GetBytes(key)));

  public static string \uF63Bꄯ\uDAFD\uDEF9柤蛓\uA4C0鵋\u278D\u2FF4\uFFFD襱캧貀腒嚁碜쫍뗂믞(string input) => Convert.ToBase64String(ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.周薞\uD7A7饮渡㭪졲麹殪\uE8C7毾鐭䘑菊ꬼ쁪\uE043จꬅ\uFB08(Encoding.UTF8.GetBytes(input)));

  public static byte[] 周薞\uD7A7饮渡㭪졲麹殪\uE8C7毾鐭䘑菊ꬼ쁪\uE043จꬅ\uFB08(byte[] input)
  {
    if (ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.㰱쥐ᱢ뗯ⴙ\uFFBF킅쪆䕎\u0EC7胐ᆑꆹ\uA7CD芘깳崱\u0017䆭쀩 == null || ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.㰱쥐ᱢ뗯ⴙ\uFFBF킅쪆䕎\u0EC7胐ᆑꆹ\uA7CD芘깳崱\u0017䆭쀩.Length == 0)
      throw new Exception("Key can not be empty.");
    byte[] buffer = input != null && input.Length != 0 ? input : throw new ArgumentException("Input can not be empty.");
    byte[] numArray = new byte[0];
    try
    {
      using (MemoryStream memoryStream = new MemoryStream())
      {
        memoryStream.Position = 32L;
        using (AesCryptoServiceProvider cryptoServiceProvider = new AesCryptoServiceProvider())
        {
          cryptoServiceProvider.KeySize = 128;
          cryptoServiceProvider.BlockSize = 128;
          cryptoServiceProvider.Mode = CipherMode.CBC;
          cryptoServiceProvider.Padding = PaddingMode.PKCS7;
          cryptoServiceProvider.Key = ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.㰱쥐ᱢ뗯ⴙ\uFFBF킅쪆䕎\u0EC7胐ᆑꆹ\uA7CD芘깳崱\u0017䆭쀩;
          cryptoServiceProvider.GenerateIV();
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, cryptoServiceProvider.CreateEncryptor(), CryptoStreamMode.Write))
          {
            memoryStream.Write(cryptoServiceProvider.IV, 0, cryptoServiceProvider.IV.Length);
            cryptoStream.Write(buffer, 0, buffer.Length);
            cryptoStream.FlushFinalBlock();
            using (HMACSHA256 hmacshA256 = new HMACSHA256(ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.僞茂袠\uF5DA㗝\uF2B8턕ᑐ\uFFFD䨕鍲ᨣﭜ峽筌⃫仳璼䮳\uE115))
            {
              byte[] hash = hmacshA256.ComputeHash(memoryStream.ToArray(), 32, memoryStream.ToArray().Length - 32);
              memoryStream.Position = 0L;
              memoryStream.Write(hash, 0, hash.Length);
            }
          }
        }
        numArray = memoryStream.ToArray();
      }
    }
    catch
    {
    }
    return numArray;
  }

  public static byte[] 뒜႓\u2357ꨎ\uFFFD쮕䑐픸ﾗ圗ﴖ퍭\u240C뮩ᶤ堓菬蟩뵩\uFFFD(byte[] input, byte[] key)
  {
    if (key == null || key.Length == 0)
      throw new Exception("Key can not be empty.");
    byte[] bytes;
    using (Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(key, ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.烃꣤잓ꩫ겮凌ᡴꞃ\uFFFD厢轞铫ￍ玕哠\uEB0D\uFFFD裱饝얌, 50000))
    {
      key = rfc2898DeriveBytes.GetBytes(16);
      bytes = rfc2898DeriveBytes.GetBytes(64);
    }
    byte[] buffer = input;
    byte[] numArray = new byte[0];
    try
    {
      using (MemoryStream memoryStream = new MemoryStream())
      {
        memoryStream.Position = 32L;
        using (AesCryptoServiceProvider cryptoServiceProvider = new AesCryptoServiceProvider())
        {
          cryptoServiceProvider.KeySize = 128;
          cryptoServiceProvider.BlockSize = 128;
          cryptoServiceProvider.Mode = CipherMode.CBC;
          cryptoServiceProvider.Padding = PaddingMode.PKCS7;
          cryptoServiceProvider.Key = key;
          cryptoServiceProvider.GenerateIV();
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, cryptoServiceProvider.CreateEncryptor(), CryptoStreamMode.Write))
          {
            memoryStream.Write(cryptoServiceProvider.IV, 0, cryptoServiceProvider.IV.Length);
            cryptoStream.Write(buffer, 0, buffer.Length);
            cryptoStream.FlushFinalBlock();
            using (HMACSHA256 hmacshA256 = new HMACSHA256(bytes))
            {
              byte[] hash = hmacshA256.ComputeHash(memoryStream.ToArray(), 32, memoryStream.ToArray().Length - 32);
              memoryStream.Position = 0L;
              memoryStream.Write(hash, 0, hash.Length);
            }
          }
        }
        numArray = memoryStream.ToArray();
      }
    }
    catch
    {
    }
    return numArray;
  }

  public static string 褙雨疂\uE79F\uEA06ឦ脮\uF343ꔆ\u2376趘䚐厏鯁ꏍ诔燡㸵\u266E缟(string input) => Encoding.UTF8.GetString(ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.乔쩆쏂ᆙ濣ⶈ\uE1B0老\uF053ঢ়㔱韰䈵ۜ老閯왼Ũ\uF532軟(Convert.FromBase64String(input)));

  public static byte[] 乔쩆쏂ᆙ濣ⶈ\uE1B0老\uF053ঢ়㔱韰䈵ۜ老閯왼Ũ\uF532軟(byte[] input)
  {
    if (ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.㰱쥐ᱢ뗯ⴙ\uFFBF킅쪆䕎\u0EC7胐ᆑꆹ\uA7CD芘깳崱\u0017䆭쀩 == null || ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.㰱쥐ᱢ뗯ⴙ\uFFBF킅쪆䕎\u0EC7胐ᆑꆹ\uA7CD芘깳崱\u0017䆭쀩.Length == 0)
      throw new Exception("Key can not be empty.");
    if (input == null || input.Length == 0)
      throw new ArgumentException("Input can not be empty.");
    byte[] dst = new byte[0];
    try
    {
      using (MemoryStream memoryStream = new MemoryStream(input))
      {
        using (AesCryptoServiceProvider cryptoServiceProvider = new AesCryptoServiceProvider())
        {
          cryptoServiceProvider.KeySize = 128;
          cryptoServiceProvider.BlockSize = 128;
          cryptoServiceProvider.Mode = CipherMode.CBC;
          cryptoServiceProvider.Padding = PaddingMode.PKCS7;
          cryptoServiceProvider.Key = ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.㰱쥐ᱢ뗯ⴙ\uFFBF킅쪆䕎\u0EC7胐ᆑꆹ\uA7CD芘깳崱\u0017䆭쀩;
          using (HMACSHA256 hmacshA256 = new HMACSHA256(ᥣ뺟覈놗뺿\uF27B셖杇喰\uFFFD䳮\u2565蒵ﷰᬛ斧㞮\u0F3C軟韗.僞茂袠\uF5DA㗝\uF2B8턕ᑐ\uFFFD䨕鍲ᨣﭜ峽筌⃫仳璼䮳\uE115))
          {
            byte[] hash = hmacshA256.ComputeHash(memoryStream.ToArray(), 32, memoryStream.ToArray().Length - 32);
            byte[] buffer = new byte[32];
            memoryStream.Read(buffer, 0, buffer.Length);
            byte[] a2 = buffer;
            if (!\u1714\u3016滶븰ᐩ唷\u201Eᝠ傊̞䕠ීዜ浝㠖蛻뵒ꐡ\uF763橊.쭭ሢ딄盃剅磨뎝\uFD44栁Ἐ斿작\u0BFEꅌ姵ᯠ뇅ᖜ傃닒(hash, a2))
              return dst;
          }
          byte[] buffer1 = new byte[16];
          memoryStream.Read(buffer1, 0, 16);
          cryptoServiceProvider.IV = buffer1;
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, cryptoServiceProvider.CreateDecryptor(), CryptoStreamMode.Read))
          {
            byte[] numArray = new byte[memoryStream.Length - 16L + 1L];
            dst = new byte[cryptoStream.Read(numArray, 0, numArray.Length)];
            Buffer.BlockCopy((Array) numArray, 0, (Array) dst, 0, dst.Length);
          }
        }
      }
    }
    catch
    {
    }
    return dst;
  }
}
