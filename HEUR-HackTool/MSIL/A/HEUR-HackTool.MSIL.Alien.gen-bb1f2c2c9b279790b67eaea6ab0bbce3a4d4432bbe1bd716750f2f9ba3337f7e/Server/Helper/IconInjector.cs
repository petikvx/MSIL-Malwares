// Decompiled with JetBrains decompiler
// Type: Server.Helper.IconInjector
// Assembly: AsyncRAT, Version=0.5.7.0, Culture=neutral, PublicKeyToken=null
// MVID: 51786A10-CF9D-455B-B8A4-B82CB9EDE322
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-HackTool.MSIL.Alien.gen-bb1f2c2c9b279790b67eaea6ab0bbce3a4d4432bbe1bd716750f2f9ba3337f7e.exe

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security;

namespace Server.Helper
{
  public static class IconInjector
  {
    public static void InjectIcon(string exeFileName, string iconFileName) => IconInjector.InjectIcon(exeFileName, iconFileName, 1U, 1U);

    public static void InjectIcon(
      string exeFileName,
      string iconFileName,
      uint iconGroupID,
      uint iconBaseID)
    {
      IconInjector.IconFile iconFile = IconInjector.IconFile.FromFile(iconFileName);
      IntPtr hUpdate = IconInjector.NativeMethods.BeginUpdateResource(exeFileName, false);
      byte[] iconGroupData = iconFile.CreateIconGroupData(iconBaseID);
      IconInjector.NativeMethods.UpdateResource(hUpdate, new IntPtr(14L), new IntPtr((long) iconGroupID), (short) 0, iconGroupData, iconGroupData.Length);
      for (int index = 0; index <= iconFile.ImageCount - 1; ++index)
      {
        byte[] data = iconFile.ImageData(index);
        IconInjector.NativeMethods.UpdateResource(hUpdate, new IntPtr(3L), new IntPtr((long) iconBaseID + (long) index), (short) 0, data, data.Length);
      }
      IconInjector.NativeMethods.EndUpdateResource(hUpdate, false);
    }

    [SuppressUnmanagedCodeSecurity]
    private class NativeMethods
    {
      [DllImport("kernel32")]
      public static extern IntPtr BeginUpdateResource(
        string fileName,
        [MarshalAs(UnmanagedType.Bool)] bool deleteExistingResources);

      [DllImport("kernel32")]
      [return: MarshalAs(UnmanagedType.Bool)]
      public static extern bool UpdateResource(
        IntPtr hUpdate,
        IntPtr type,
        IntPtr name,
        short language,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 5)] byte[] data,
        int dataSize);

      [DllImport("kernel32")]
      [return: MarshalAs(UnmanagedType.Bool)]
      public static extern bool EndUpdateResource(IntPtr hUpdate, [MarshalAs(UnmanagedType.Bool)] bool discard);
    }

    private struct ICONDIR
    {
      public ushort Reserved;
      public ushort Type;
      public ushort Count;
    }

    private struct ICONDIRENTRY
    {
      public byte Width;
      public byte Height;
      public byte ColorCount;
      public byte Reserved;
      public ushort Planes;
      public ushort BitCount;
      public int BytesInRes;
      public int ImageOffset;
    }

    private struct BITMAPINFOHEADER
    {
      public uint Size;
      public int Width;
      public int Height;
      public ushort Planes;
      public ushort BitCount;
      public uint Compression;
      public uint SizeImage;
      public int XPelsPerMeter;
      public int YPelsPerMeter;
      public uint ClrUsed;
      public uint ClrImportant;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 2)]
    private struct GRPICONDIRENTRY
    {
      public byte Width;
      public byte Height;
      public byte ColorCount;
      public byte Reserved;
      public ushort Planes;
      public ushort BitCount;
      public int BytesInRes;
      public ushort ID;
    }

    private class IconFile
    {
      private IconInjector.ICONDIR iconDir;
      private IconInjector.ICONDIRENTRY[] iconEntry;
      private byte[][] iconImage;

      public int ImageCount => (int) this.iconDir.Count;

      public byte[] ImageData(int index) => this.iconImage[index];

      public static IconInjector.IconFile FromFile(string filename)
      {
        IconInjector.IconFile iconFile = new IconInjector.IconFile();
        byte[] src = File.ReadAllBytes(filename);
        GCHandle gcHandle = GCHandle.Alloc((object) src, GCHandleType.Pinned);
        iconFile.iconDir = (IconInjector.ICONDIR) Marshal.PtrToStructure(gcHandle.AddrOfPinnedObject(), typeof (IconInjector.ICONDIR));
        iconFile.iconEntry = new IconInjector.ICONDIRENTRY[(int) iconFile.iconDir.Count];
        iconFile.iconImage = new byte[(int) iconFile.iconDir.Count][];
        int num1 = Marshal.SizeOf<IconInjector.ICONDIR>(iconFile.iconDir);
        Type type = typeof (IconInjector.ICONDIRENTRY);
        int num2 = Marshal.SizeOf(type);
        for (int index = 0; index <= (int) iconFile.iconDir.Count - 1; ++index)
        {
          IconInjector.ICONDIRENTRY structure = (IconInjector.ICONDIRENTRY) Marshal.PtrToStructure(new IntPtr(gcHandle.AddrOfPinnedObject().ToInt64() + (long) num1), type);
          iconFile.iconEntry[index] = structure;
          iconFile.iconImage[index] = new byte[structure.BytesInRes];
          Buffer.BlockCopy((Array) src, structure.ImageOffset, (Array) iconFile.iconImage[index], 0, structure.BytesInRes);
          num1 += num2;
        }
        gcHandle.Free();
        return iconFile;
      }

      public byte[] CreateIconGroupData(uint iconBaseID)
      {
        byte[] iconGroupData = new byte[Marshal.SizeOf(typeof (IconInjector.ICONDIR)) + Marshal.SizeOf(typeof (IconInjector.GRPICONDIRENTRY)) * this.ImageCount];
        GCHandle gcHandle1 = GCHandle.Alloc((object) iconGroupData, GCHandleType.Pinned);
        Marshal.StructureToPtr<IconInjector.ICONDIR>(this.iconDir, gcHandle1.AddrOfPinnedObject(), false);
        int num = Marshal.SizeOf<IconInjector.ICONDIR>(this.iconDir);
        for (int index = 0; index <= this.ImageCount - 1; ++index)
        {
          IconInjector.GRPICONDIRENTRY structure = new IconInjector.GRPICONDIRENTRY();
          IconInjector.BITMAPINFOHEADER bitmapinfoheader = new IconInjector.BITMAPINFOHEADER();
          GCHandle gcHandle2 = GCHandle.Alloc((object) bitmapinfoheader, GCHandleType.Pinned);
          Marshal.Copy(this.ImageData(index), 0, gcHandle2.AddrOfPinnedObject(), Marshal.SizeOf(typeof (IconInjector.BITMAPINFOHEADER)));
          gcHandle2.Free();
          structure.Width = this.iconEntry[index].Width;
          structure.Height = this.iconEntry[index].Height;
          structure.ColorCount = this.iconEntry[index].ColorCount;
          structure.Reserved = this.iconEntry[index].Reserved;
          structure.Planes = bitmapinfoheader.Planes;
          structure.BitCount = bitmapinfoheader.BitCount;
          structure.BytesInRes = this.iconEntry[index].BytesInRes;
          structure.ID = Convert.ToUInt16((long) iconBaseID + (long) index);
          Marshal.StructureToPtr<IconInjector.GRPICONDIRENTRY>(structure, new IntPtr(gcHandle1.AddrOfPinnedObject().ToInt64() + (long) num), false);
          num += Marshal.SizeOf(typeof (IconInjector.GRPICONDIRENTRY));
        }
        gcHandle1.Free();
        return iconGroupData;
      }
    }
  }
}
