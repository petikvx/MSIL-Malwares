// Decompiled with JetBrains decompiler
// Type: SmartAssembly.StringsEncoding.Strings
// Assembly: xU, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 15FBACA6-4EA1-48EF-94B8-EDBEAA61F9E6
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Gorgon.gen-c4129b34223aa76d82149dfb9d96165a2c415edb79c4eb534239035bd98047de.exe

using SmartAssembly.Zip;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;

namespace SmartAssembly.StringsEncoding
{
  public sealed class Strings
  {
    private static readonly string MustUseCache = "1";
    private static readonly string OffsetValue = "27";
    private static readonly byte[] bytes = (byte[]) null;
    private static readonly Dictionary<int, string> hashtable;
    private static readonly object hashtableLock = new object();
    private static readonly bool cacheStrings = false;
    private static readonly int offset = 0;

    public static string Get(int stringID)
    {
      stringID ^= 107396847;
      stringID -= Strings.offset;
      return !Strings.cacheStrings ? Strings.GetFromResource(stringID) : Strings.GetCachedOrResource(stringID);
    }

    public static string GetCachedOrResource(int stringID)
    {
      lock (Strings.hashtableLock)
      {
        string cachedOrResource;
        Strings.hashtable.TryGetValue(stringID, out cachedOrResource);
        if (cachedOrResource != null)
          return cachedOrResource;
      }
      return Strings.GetFromResource(stringID);
    }

    public static string GetFromResource(int stringID)
    {
      int num1 = stringID;
      byte[] bytes1 = Strings.bytes;
      int index1 = num1;
      int index2 = index1 + 1;
      int num2 = (int) bytes1[index1];
      int count;
      if ((num2 & 128) == 0)
      {
        count = num2;
        if (count == 0)
          return string.Empty;
      }
      else if ((num2 & 64) == 0)
      {
        count = ((num2 & 63) << 8) + (int) Strings.bytes[index2++];
      }
      else
      {
        int num3 = (num2 & 31) << 24;
        byte[] bytes2 = Strings.bytes;
        int index3 = index2;
        int num4 = index3 + 1;
        int num5 = (int) bytes2[index3] << 16;
        int num6 = num3 + num5;
        byte[] bytes3 = Strings.bytes;
        int index4 = num4;
        int num7 = index4 + 1;
        int num8 = (int) bytes3[index4] << 8;
        int num9 = num6 + num8;
        byte[] bytes4 = Strings.bytes;
        int index5 = num7;
        index2 = index5 + 1;
        int num10 = (int) bytes4[index5];
        count = num9 + num10;
      }
      try
      {
        byte[] bytes5 = Convert.FromBase64String(Encoding.UTF8.GetString(Strings.bytes, index2, count));
        string fromResource = string.Intern(Encoding.UTF8.GetString(bytes5, 0, bytes5.Length));
        if (Strings.cacheStrings)
          Strings.CacheString(stringID, fromResource);
        return fromResource;
      }
      catch
      {
        return (string) null;
      }
    }

    public static void CacheString(int stringID, string value)
    {
      try
      {
        lock (Strings.hashtableLock)
          Strings.hashtable.Add(stringID, value);
      }
      catch
      {
      }
    }

    static Strings()
    {
      if (Strings.MustUseCache == "1")
      {
        Strings.cacheStrings = true;
        Strings.hashtable = new Dictionary<int, string>();
      }
      Strings.offset = Convert.ToInt32(Strings.OffsetValue);
      using (Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("{da55bea8-6877-4ffa-8a8a-f6acd5188335}"))
      {
        int int32 = Convert.ToInt32(manifestResourceStream.Length);
        byte[] buffer = new byte[int32];
        manifestResourceStream.Read(buffer, 0, int32);
        Strings.bytes = SimpleZip.Unzip(buffer);
      }
    }
  }
}
