// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Core.NameFilter
// Assembly: TheBot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E6D888C-8D83-46CE-907A-18F99381A0FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Backdoor.MSIL.IrcBot.an-523fbc7f8f4234f5b7e59adb51579626a43c55d41ac674e758828414fbdebd93.exe

using System;
using System.Collections;
using System.Text;
using System.Text.RegularExpressions;

namespace ICSharpCode.SharpZipLib.Core
{
  public class NameFilter : IScanFilter
  {
    private string \uE002;
    private ArrayList \uE001;
    private ArrayList \uE000;

    public NameFilter(string filter)
    {
      this.\uE002 = filter;
      this.\uE001 = new ArrayList();
      this.\uE000 = new ArrayList();
      this.\uE000();
    }

    public static bool IsValidExpression(string expression)
    {
      bool flag = true;
      try
      {
        Regex regex = new Regex(expression, RegexOptions.IgnoreCase | RegexOptions.Singleline);
      }
      catch (ArgumentException ex)
      {
        flag = false;
      }
      return flag;
    }

    public static bool IsValidFilterExpression(string toTest)
    {
      switch (toTest)
      {
        case null:
          throw new ArgumentNullException(\uE01B.\uE000("\uEC26\uEC3D\uEC06\uEC37\uEC21\uEC26", 60498));
        default:
          bool flag = true;
          try
          {
            string[] strArray = NameFilter.SplitQuoted(toTest);
            for (int index = 0; index < strArray.Length; ++index)
            {
              if (strArray[index] != null && strArray[index].Length > 0)
              {
                Regex regex = new Regex(strArray[index][0] != '+' ? (strArray[index][0] != '-' ? strArray[index] : strArray[index].Substring(1, strArray[index].Length - 1)) : strArray[index].Substring(1, strArray[index].Length - 1), RegexOptions.IgnoreCase | RegexOptions.Singleline);
              }
            }
          }
          catch (ArgumentException ex)
          {
            flag = false;
          }
          return flag;
      }
    }

    public static string[] SplitQuoted(string original)
    {
      char ch = '\\';
      char[] array = new char[1]{ ';' };
      ArrayList arrayList = new ArrayList();
      if (original != null && original.Length > 0)
      {
        int index = -1;
        StringBuilder stringBuilder = new StringBuilder();
        while (index < original.Length)
        {
          ++index;
          if (index >= original.Length)
            arrayList.Add((object) stringBuilder.ToString());
          else if ((int) original[index] == (int) ch)
          {
            ++index;
            if (index >= original.Length)
              throw new ArgumentException(\uE01B.\uE000("\uF559\uF57D\uF567\uF567\uF57D\uF57A\uF573\uF534\uF560\uF571\uF566\uF579\uF57D\uF57A\uF575\uF560\uF57D\uF57A\uF573\uF534\uF571\uF567\uF577\uF575\uF564\uF571\uF534\uF577\uF57C\uF575\uF566\uF575\uF577\uF560\uF571\uF566", 62740), \uE01B.\uE000("\uF423\uF43E\uF425\uF42B\uF425\uF422\uF42D\uF420", 62540));
            stringBuilder.Append(original[index]);
          }
          else if (Array.IndexOf<char>(array, original[index]) >= 0)
          {
            arrayList.Add((object) stringBuilder.ToString());
            stringBuilder.Length = 0;
          }
          else
            stringBuilder.Append(original[index]);
        }
      }
      return (string[]) arrayList.ToArray(typeof (string));
    }

    public override string ToString() => this.\uE002;

    public bool IsIncluded(string name)
    {
      bool flag = false;
      if (this.\uE001.Count == 0)
      {
        flag = true;
      }
      else
      {
        foreach (Regex regex in this.\uE001)
        {
          if (regex.IsMatch(name))
          {
            flag = true;
            break;
          }
        }
      }
      return flag;
    }

    public bool IsExcluded(string name)
    {
      bool flag = false;
      foreach (Regex regex in this.\uE000)
      {
        if (regex.IsMatch(name))
        {
          flag = true;
          break;
        }
      }
      return flag;
    }

    public bool IsMatch(string name) => this.IsIncluded(name) && !this.IsExcluded(name);

    private void \uE000()
    {
      if (this.\uE002 == null)
        return;
      string[] strArray = NameFilter.SplitQuoted(this.\uE002);
      for (int index = 0; index < strArray.Length; index++)
      {
        if (strArray[index] != null && strArray[index].Length > 0)
        {
          bool flag = strArray[index][0] != '-';
          string pattern = strArray[index][0] != '+' ? (strArray[index][0] != '-' ? strArray[index] : strArray[index].Substring(1, strArray[index].Length - 1)) : strArray[index].Substring(1, strArray[index].Length - 1);
          if (flag)
            this.\uE001.Add((object) new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline));
          else
            this.\uE000.Add((object) new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline));
        }
      }
    }
  }
}
