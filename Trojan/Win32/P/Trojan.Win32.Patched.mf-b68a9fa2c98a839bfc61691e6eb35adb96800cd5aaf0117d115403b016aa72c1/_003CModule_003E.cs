// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: MobilityService, Version=1.0.2519.23335, Culture=neutral, PublicKeyToken=null
// MVID: DCE01E20-F0BF-43A3-ABD9-0E64E99A2DB6
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan.Win32.Patched.mf-b68a9fa2c98a839bfc61691e6eb35adb96800cd5aaf0117d115403b016aa72c1.exe

using \u003CCppImplementationDetails\u003E;
using \u003CCrtImplementationDetails\u003E;
using MobilityService;
using std;
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;
using System.ServiceProcess;
using System.Threading;

internal class \u003CModule\u003E
{
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040GHFPNOJB\u0040bad\u003F5allocation\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BM\u0040JEOLDKGI\u0040\u003F\u0024AAu\u003F\u0024AAS\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AAC\u003F\u0024AAh\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003F\u003F_C\u0040_09KOBJOHCF\u0040Notify\u003F\u0024CB\u003F\u0024CB\u003F\u0024CB\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BD\u0040JFCHHLPJ\u0040Memory\u003F5card\u003F5insert\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BF\u0040CPLEDEFJ\u0040Memory\u003F5card\u003F5pull\u003F5off\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BJ\u0040NLCNNPGJ\u0040Receive\u003F5unknown\u003F5value\u003F3\u003F\u0024CFX\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003F\u003F_C\u0040_1O\u0040KCNBCIIJ\u0040\u003F\u0024AAu\u003F\u0024AAS\u003F\u0024AAh\u003F\u0024AAo\u003F\u0024AAc\u003F\u0024AAk\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BD\u0040LNMIPNAF\u0040System\u003F5start\u003F5shock\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BC\u0040DDCMCHHE\u0040System\u003F5stop\u003F5shock\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CI\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CI\u0040ODCPIEAA\u0040Receive\u003F5unknown\u003F5value\u003F5from\u003F5G\u003F9Sen\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003F\u003F_C\u0040_1BC\u0040NGFAENII\u0040\u003F\u0024AAu\u003F\u0024AAH\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAP\u003F\u0024AAl\u003F\u0024AAu\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BD\u0040OKPDPLBM\u0040Acer\u003F5ePresentation\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BK\u0040BKFMMLBI\u0040Unknown\u003F5value\u003F5from\u003F5VGA\u003F3\u003F\u0024CFX\u003F\u0024AA\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4out_of_range\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAVout_of_range\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2GSink\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4EventSink\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_16 \u003F\u003F_R0\u003FAVEventSink\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_22 \u003F\u003F_R0\u003FAUIWbemObjectSink\u0040\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7runtime_error\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040exception\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040logic_error\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3EventSink\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2runtime_error\u0040std\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7failure\u0040ios_base\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2failure\u0040ios_base\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVexception\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2bad_alloc\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040IUnknown\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040bad_alloc\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3IWbemObjectSink\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05Q6AXXZ \u003F\u003F_7GSink\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3IUnknown\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7_com_error\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_27 \u003F\u003F_R0\u003FAVfailure\u0040ios_base\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_17 \u003F\u003F_R0\u003FAV_com_error\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2out_of_range\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_24 \u003F\u003F_R0\u003FAVruntime_error\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3runtime_error\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2EventSink\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_14 \u003F\u003F_R0\u003FAVVGASink\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4_com_error\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040GSink\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040_com_error\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040IWbemObjectSink\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2IUnknown\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040EventSink\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2IWbemObjectSink\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3bad_alloc\u0040std\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7out_of_range\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3_com_error\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4VGASink\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4logic_error\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2exception\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040runtime_error\u0040std\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05Q6AXXZ \u003F\u003F_7EventSink\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3exception\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3out_of_range\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3GSink\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040failure\u0040ios_base\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2logic_error\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3logic_error\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_15 \u003F\u003F_R0\u003FAUIUnknown\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_22 \u003F\u003F_R0\u003FAVlogic_error\u0040std\u0040\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05Q6AXXZ \u003F\u003F_7VGASink\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040VGASink\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_12 \u003F\u003F_R0\u003FAVGSink\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3failure\u0040ios_base\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2_com_error\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4failure\u0040ios_base\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3VGASink\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2VGASink\u0040\u00408;
  internal static int \u003Fbinary\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Openmode\u004012\u0040B;
  internal static int \u003F_Hardfail\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Iostate\u004012\u0040B;
  internal static int \u003Feofbit\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Iostate\u004012\u0040B;
  internal static int \u003Fapp\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Openmode\u004012\u0040B;
  internal static int \u003Fuppercase\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static unsafe sbyte* std\u002E\u003FA0xf46f2312\u002E_bad_alloc_Message;
  internal static int \u003Ftrunc\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Openmode\u004012\u0040B;
  internal static int \u003Fskipws\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fbasefield\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003F_Stdio\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fleft\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fshowpos\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fadjustfield\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fbadbit\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Iostate\u004012\u0040B;
  internal static int \u003Fin\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Openmode\u004012\u0040B;
  internal static int \u003Foct\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fhex\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fshowbase\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fshowpoint\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fcollate\u0040\u003F\u0024_Locbase\u0040H\u0040std\u0040\u00402HB;
  internal static int \u003Fbeg\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Seekdir\u004012\u0040B;
  internal static int \u003Ffailbit\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Iostate\u004012\u0040B;
  internal static int \u003Funitbuf\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fright\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fctype\u0040\u003F\u0024_Locbase\u0040H\u0040std\u0040\u00402HB;
  internal static int \u003Fout\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Openmode\u004012\u0040B;
  internal static int \u003Finternal\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fgoodbit\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Iostate\u004012\u0040B;
  internal static int \u003Fboolalpha\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fate\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Openmode\u004012\u0040B;
  internal static int \u003Fall\u0040\u003F\u0024_Locbase\u0040H\u0040std\u0040\u00402HB;
  internal static int \u003Fnumeric\u0040\u003F\u0024_Locbase\u0040H\u0040std\u0040\u00402HB;
  internal static int \u003Fend\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Seekdir\u004012\u0040B;
  internal static int \u003F_Noreplace\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Openmode\u004012\u0040B;
  internal static int \u003Fcur\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Seekdir\u004012\u0040B;
  internal static int \u003Ftime\u0040\u003F\u0024_Locbase\u0040H\u0040std\u0040\u00402HB;
  internal static int \u003Fmessages\u0040\u003F\u0024_Locbase\u0040H\u0040std\u0040\u00402HB;
  internal static int \u003Ffixed\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fnone\u0040\u003F\u0024_Locbase\u0040H\u0040std\u0040\u00402HB;
  internal static int \u003Ffloatfield\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003F_Nocreate\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Openmode\u004012\u0040B;
  internal static int \u003Fscientific\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static int \u003Fmonetary\u0040\u003F\u0024_Locbase\u0040H\u0040std\u0040\u00402HB;
  internal static int \u003Fdec\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00402W4_Fmtflags\u004012\u0040B;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4GSink\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4runtime_error\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040out_of_range\u0040std\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0N\u0040GEBNOFCA\u0040lanmanserver\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07BCFNLIJJ\u0040Browser\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0N\u0040DGECLGHJ\u0040explorer\u003F4exe\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003F\u003F_C\u0040_11LOCGONAA\u0040\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003F\u003F_C\u0040_1BA\u0040POAHONEM\u0040\u003F\u0024AAu\u003F\u0024AAS\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BK\u0040CKLOFOL\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAB\u003F\u0024AAl\u003F\u0024AAu\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAh\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DC\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1GE\u0040OBACBGCF\u0040\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u003F\u0024AAA\u003F\u0024AAC\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BG\u0040IMJCDLFP\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BK\u0040ICGNCIEN\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAB\u003F\u0024AAl\u003F\u0024AAu\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAh\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CA\u0040FPONMHDE\u0040\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BO\u0040GDAMCCI\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAE\u003F\u0024AAx\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1DI\u0040KLICGGKE\u0040\u003F\u0024AAS\u003F\u0024AAE\u003F\u0024AAL\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAT\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F5\u003F\u0024AAF\u003F\u0024AAR\u003F\u0024AAO\u003F\u0024AAM\u003F\u0024AA\u003F5\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAE\u003F\u0024AAx\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static int __\u0040\u0040_PchSym_\u004000\u0040UdlipUnlyrorgbhvierxvUhvierxvUivovzhvUhgwzucOlyq\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003F\u003F_C\u0040_1BC\u0040OJAPPONC\u0040\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AA\u003F2\u003F\u0024AAw\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003F\u003F_C\u0040_17NDCOOGJO\u0040\u003F\u0024AAW\u003F\u0024AAQ\u003F\u0024AAL\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BB\u0040NFPPEIG\u0040WMIDataBlockRead\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0O\u0040HILJBJEP\u0040Error\u003F5code\u003F3\u003F\u0024CFX\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BE\u0040GDLCFJHN\u0040Get\u003F5zero\u003F5enumerator\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BD\u0040HHAGDHNI\u0040GetMethod\u003F\u0024CI\u003F\u0024CJ\u003F5failed\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CC\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EE\u0040MECHOCGI\u0040\u003F\u0024AAS\u003F\u0024AAE\u003F\u0024AAL\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAT\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F5\u003F\u0024AAF\u003F\u0024AAR\u003F\u0024AAO\u003F\u0024AAM\u003F\u0024AA\u003F5\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAh\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAE\u003F\u0024AAv\u003F\u0024AAe\u003F\u0024AAn\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CE\u0040GMAAPLGF\u0040\u003F\u0024AAW\u003F\u0024AAM\u003F\u0024AAI\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAu\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAu\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAh\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003F\u003F_C\u0040_1M\u0040EJHKBOCC\u0040\u003F\u0024AAu\u003F\u0024AAF\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003F\u003F_C\u0040_1BC\u0040NACFIELM\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAA\u003F\u0024AAu\u003F\u0024AAd\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BG\u0040IILNJDCE\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAC\u003F\u0024AAa\u003F\u0024AAr\u003F\u0024AAd\u003F\u0024AAb\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003F\u003F_C\u0040_1BE\u0040MLLPAPGJ\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAL\u003F\u0024AAA\u003F\u0024AAN\u003F\u0024AAP\u003F\u0024AAh\u003F\u0024AAy\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BI\u0040OAEJPPHK\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAH\u003F\u0024AAa\u003F\u0024AAr\u003F\u0024AAd\u003F\u0024AAD\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAk\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003F\u003F_C\u0040_1BC\u0040CDEDCIEB\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAC\u003F\u0024AAD\u003F\u0024AAR\u003F\u0024AAO\u003F\u0024AAM\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BK\u0040KHKCEBIN\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAS\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAk\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAA\u003F\u0024AAm\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BG\u0040HHNPFIPB\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAM\u003F\u0024AAI\u003F\u0024AAN\u003F\u0024AAI\u003F\u0024AAP\u003F\u0024AAC\u003F\u0024AAI\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BK\u0040OHGLLKME\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAD\u003F\u0024AAi\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAz\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003F\u003F_C\u0040_1O\u0040OKJDINGG\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAM\u003F\u0024AAD\u003F\u0024AAC\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040FIAFCEFO\u0040ReadPowerPlane\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BC\u0040CMPEBGKF\u0040Wrong\u003F5bPlaneIndex\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DE\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1GI\u0040OFMCJHFO\u0040\u003F\u0024AAP\u003F\u0024AAo\u003F\u0024AAw\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAP\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BJ\u0040DMHMIHOB\u0040ReadPowerPlane\u003F5for\u003F5Audio\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BF\u0040BIFJCOLM\u0040Return\u003F5value\u003F5unknown\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040IMHNEAIK\u0040Error\u003F5code\u003F3\u003F5\u003F\u0024CFd\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BP\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BP\u0040OAKCPLMI\u0040Return\u003F5ErrorCode\u003F5for\u003F5Get\u003F5Audio\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003F\u003F_C\u0040_1BC\u0040PFCOAPKC\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAA\u003F\u0024AAu\u003F\u0024AAd\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BG\u0040HNOLEKGF\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAC\u003F\u0024AAa\u003F\u0024AAr\u003F\u0024AAd\u003F\u0024AAb\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003F\u003F_C\u0040_1BE\u0040GFJEEPBF\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAL\u003F\u0024AAA\u003F\u0024AAN\u003F\u0024AAP\u003F\u0024AAh\u003F\u0024AAy\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BI\u0040PGCEBOBI\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAH\u003F\u0024AAa\u003F\u0024AAr\u003F\u0024AAd\u003F\u0024AAD\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAk\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003F\u003F_C\u0040_1BC\u0040GEIKDFP\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAC\u003F\u0024AAD\u003F\u0024AAR\u003F\u0024AAO\u003F\u0024AAM\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BK\u0040CHGEIMCL\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAS\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAk\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAA\u003F\u0024AAm\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BG\u0040ICIJIBLA\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAM\u003F\u0024AAI\u003F\u0024AAN\u003F\u0024AAI\u003F\u0024AAP\u003F\u0024AAC\u003F\u0024AAI\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BK\u0040GHKNHHGC\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAD\u003F\u0024AAi\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAz\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003F\u003F_C\u0040_1O\u0040JFINDOBB\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAM\u003F\u0024AAD\u003F\u0024AAC\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BA\u0040MGHAKKOI\u0040WritePowerPlane\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CE\u0040OPAGCONO\u0040\u003F\u0024AAP\u003F\u0024AAo\u003F\u0024AAw\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAP\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CA\u0040IIKAHFCP\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAS\u003F\u0024AAB\u003F\u0024AAT\u003F\u0024AAh\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAl\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1GA\u0040PAGHLOKH\u0040\u003F\u0024AAS\u003F\u0024AAB\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAh\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAl\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u003F\u0024AAA\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAI\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CA\u0040OEHDABOM\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAS\u003F\u0024AAB\u003F\u0024AAT\u003F\u0024AAh\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAl\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BM\u0040NCGMAKNI\u0040\u003F\u0024AAS\u003F\u0024AAB\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAh\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAl\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003F\u003F_C\u0040_1BA\u0040EGOOFIGB\u0040\u003F\u0024AAu\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAn\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003F\u003F_C\u0040_1BE\u0040MHIFCKKG\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAC\u003F\u0024AA4\u003F\u0024AAO\u003F\u0024AAn\u003F\u0024AAC\u003F\u0024AA3\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CP\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FO\u0040EBCPLCKH\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u003F\u0024AAA\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAI\u003F\u0024AA\u003F2\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003F\u003F_C\u0040_1BE\u0040GJKOGKNK\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAC\u003F\u0024AA4\u003F\u0024AAO\u003F\u0024AAn\u003F\u0024AAC\u003F\u0024AA3\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BK\u0040OPKHIMHC\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BG\u0040CDJHFKP\u0040\u003F\u0024AAI\u003F\u0024AAs\u003F\u0024AAs\u003F\u0024AAu\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAU\u003F\u0024AAI\u003F\u0024AAD\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003F\u003F_C\u0040_1BC\u0040PDFCOEDN\u0040\u003F\u0024AAu\u003F\u0024AAF\u003F\u0024AAu\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAN\u003F\u0024AAu\u003F\u0024AAm\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003F\u003F_C\u0040_19PHBIHKOL\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAD\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003F\u003F_C\u0040_19OKBNEKFD\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003F\u003F_C\u0040_19CBEBJJPG\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAB\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003F\u003F_C\u0040_19KHNFOLFI\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAA\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003F\u003F_C\u0040_1BA\u0040GGLOFGMI\u0040\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAd\u003F\u0024AAM\u003F\u0024AAS\u003F\u0024AAR\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003F\u003F_C\u0040_1BC\u0040NOKNOPEO\u0040\u003F\u0024AAW\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAM\u003F\u0024AAS\u003F\u0024AAR\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003F\u003F_C\u0040_1BA\u0040EJNNHIKJ\u0040\u003F\u0024AAu\u003F\u0024AAO\u003F\u0024AAu\u003F\u0024AAt\u003F\u0024AAE\u003F\u0024AAA\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003F\u003F_C\u0040_1BA\u0040BJBAOJBK\u0040\u003F\u0024AAu\u003F\u0024AAO\u003F\u0024AAu\u003F\u0024AAt\u003F\u0024AAE\u003F\u0024AAD\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040CFHFONAE\u0040WMIReadPCI\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BG\u0040BAMKFGLF\u0040\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAd\u003F\u0024AAP\u003F\u0024AAC\u003F\u0024AAI\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003F\u003F_C\u0040_19EFMIIPMF\u0040\u003F\u0024AAu\u003F\u0024AAB\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003F\u003F_C\u0040_1BA\u0040OIPEINNN\u0040\u003F\u0024AAu\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003F\u003F_C\u0040_1BE\u0040PHLIKCD\u0040\u003F\u0024AAu\u003F\u0024AAF\u003F\u0024AAu\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003F\u003F_C\u0040_1BE\u0040DGAANMEA\u0040\u003F\u0024AAu\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003F\u003F_C\u0040_1BC\u0040LPDLBGDD\u0040\u003F\u0024AAu\u003F\u0024AAP\u003F\u0024AAC\u003F\u0024AAI\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAd\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BI\u0040EMBFJMMM\u0040\u003F\u0024AAW\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAP\u003F\u0024AAC\u003F\u0024AAI\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003F\u003F_C\u0040_1BA\u0040PJDHDEOI\u0040\u003F\u0024AAu\u003F\u0024AAB\u003F\u0024AAu\u003F\u0024AAf\u003F\u0024AAf\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1DG\u0040NEJGOBAI\u0040\u003F\u0024AAS\u003F\u0024AAE\u003F\u0024AAL\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAT\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F5\u003F\u0024AAF\u003F\u0024AAR\u003F\u0024AAO\u003F\u0024AAM\u003F\u0024AA\u003F5\u003F\u0024AAG\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAE\u003F\u0024AAv\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CG\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EM\u0040DCBPCLIG\u0040\u003F\u0024AAS\u003F\u0024AAE\u003F\u0024AAL\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAT\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F5\u003F\u0024AAF\u003F\u0024AAR\u003F\u0024AAO\u003F\u0024AAM\u003F\u0024AA\u003F5\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA_\u003F\u0024AAP\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AA_\u0040;
  internal static unsafe sbyte* std\u002E\u003FA0x2d2bccbe\u002E_bad_alloc_Message;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BE\u0040MJJAOGOJ\u0040MobilityService\u003F4exe\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040FLHLGODM\u0040CompileMOF\u003F4exe\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BJ\u0040BDEEFLHI\u0040MobilityCenterIpcService\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040NDEOKJKN\u0040MobilityRemote\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BA\u0040CMJKDMDI\u0040ServiceRemoting\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BA\u0040EFBKLIMN\u0040MobilityService\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003F\u003F_C\u0040_02IEBECDLA\u0040\u003F9i\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BK\u0040GAEHNIOP\u0040\u003F\u0024CFs\u003F5\u003F5is\u003F5already\u003F5installed\u003F6\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BO\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BO\u0040OBMPIDLI\u0040Install\u003F5\u003F\u0024CFs\u003F5failed\u003F4\u003F5Error\u003F3\u003F5\u003F\u0024CFu\u003F6\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BL\u0040KBLFEIFM\u0040Start\u003F5\u003F\u0024CFs\u003F5failed\u003F4\u003F5Error\u003F5\u003F\u0024CFu\u003F6\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003F\u003F_C\u0040_02GCGDHOON\u0040\u003F9u\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BF\u0040HICBAPIE\u0040\u003F\u0024CFs\u003F5is\u003F5not\u003F5installed\u003F6\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DA\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0DA\u0040JBFLEABC\u0040Could\u003F5not\u003F5remove\u003F5ControlService\u003F5\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05BILGFDLN\u0040\u003F\u0024CFs\u003F5\u003F9p\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DI\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0DI\u0040FBINAHLI\u0040StartControlService\u003F\u0024DN\u003F\u0024DN\u003F\u0024DO\u003F5Control\u003F5s\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DG\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0DG\u0040FDPPCNNC\u0040StartControlService\u003F\u0024DN\u003F\u0024DN\u003F\u0024DO\u003F5Control\u003F5s\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CO\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CO\u0040KIDGAGOI\u0040UnInstallControlService\u003F5STOP\u003F5ser\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DA\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0DA\u0040KEJMHEPD\u0040UnInstallControlService\u003F5DELETE\u003F5s\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DA\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0DA\u0040KAGAHLFF\u0040UnInstallControlService\u003F5DeleteRe\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D gc_szServiceName;
  internal static unsafe SC_HANDLE__* gh_SCMAsExe;
  internal static _SERVICE_STATUS gs_MyServiceStatus;
  internal static bool gb_Result;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x7d798523\u002E__xc_mp_z;
  [FixedAddressValueType]
  internal static int \u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FUninitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x7d798523\u002E__xi_vt_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FInitializedPerAppDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static bool \u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FIsDefaultDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x7d798523\u002E__xc_ma_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FInitializedNative\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static int \u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FInitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x7d798523\u002E__xc_ma_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FInitializedVtables\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x7d798523\u002E__xi_vt_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FInitializedPerProcess\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static bool \u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static int \u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA;
  internal static uint \u003FProcessAttach\u0040NativeDll\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400IB;
  internal static uint \u003FThreadAttach\u0040NativeDll\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400IB;
  internal static TriBool.State \u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static uint \u003FProcessDetach\u0040NativeDll\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400IB;
  internal static uint \u003FThreadDetach\u0040NativeDll\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400IB;
  internal static uint \u003FProcessVerifier\u0040NativeDll\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400IB;
  internal static TriBool.State \u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static bool \u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x7d798523\u002E__xc_mp_a;
  public static unsafe int** __unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  public static unsafe int** __unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  [FixedAddressValueType]
  internal static uint __exit_list_size_app_domain;
  [FixedAddressValueType]
  internal static Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E \u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x49040904\u002E\u003F_lock\u0024initializer\u0024\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0P6MXXZA;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitbegin_app_domain;
  internal static uint \u003FA0x49040904\u002E__exit_list_size;
  internal static unsafe __FnPtr<void ()>* \u003FA0x49040904\u002E__onexitend;
  internal static unsafe __FnPtr<void ()>* \u003FA0x49040904\u002E__onexitbegin;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitend_app_domain;
  public static _GUID IID_IWbemObjectSink;
  public static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7type_info\u0040\u00406B\u0040;
  public static _GUID IID_IUnknown;
  public static _GUID IID_IUnsecuredApartment;
  public static _GUID CLSID_WbemLocator;
  public static _GUID CLSID_UnsecuredApartment;
  public static _GUID IID_IWbemLocator;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_z;
  public static volatile uint __native_vcclrit_reason;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_a;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_a;
  public static volatile __enative_startup_state __native_startup_state;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_z;
  public static unsafe void* __native_startup_lock;
  public static volatile uint __native_dllmain_reason;

  internal static unsafe void std\u002Ebad_alloc\u002E\u007Bdtor\u007D([In] bad_alloc* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe void* std\u002Ebad_alloc\u002E__vecDelDtor([In] bad_alloc* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      bad_alloc* badAllocPtr = (bad_alloc*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 12U, *(int*) badAllocPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebad_alloc\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete((void*) badAllocPtr);
      return (void*) badAllocPtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Elogic_error\u002E\u007Bdtor\u007D([In] logic_error* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe sbyte* std\u002Elogic_error\u002Ewhat([In] logic_error* obj0) => \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));

  internal static unsafe void* std\u002Elogic_error\u002E__vecDelDtor(
    [In] logic_error* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      logic_error* logicErrorPtr = (logic_error*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 40U, *(int*) logicErrorPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Elogic_error\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) logicErrorPtr);
      return (void*) logicErrorPtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Eout_of_range\u002E\u007Bdtor\u007D([In] out_of_range* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7out_of_range\u0040std\u0040\u00406B\u0040;
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe void* std\u002Eout_of_range\u002E__vecDelDtor(
    [In] out_of_range* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      out_of_range* outOfRangePtr = (out_of_range*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 40U, *(int*) outOfRangePtr, (__FnPtr<void (void*)>) __methodptr(std\u002Eout_of_range\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) outOfRangePtr);
      return (void*) outOfRangePtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7out_of_range\u0040std\u0040\u00406B\u0040;
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Eruntime_error\u002E\u007Bdtor\u007D([In] runtime_error* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7runtime_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe sbyte* std\u002Eruntime_error\u002Ewhat([In] runtime_error* obj0) => \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));

  internal static unsafe void* std\u002Eruntime_error\u002E__vecDelDtor(
    [In] runtime_error* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      runtime_error* runtimeErrorPtr = (runtime_error*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 40U, *(int*) runtimeErrorPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Eruntime_error\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) runtimeErrorPtr);
      return (void*) runtimeErrorPtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7runtime_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  [SpecialName]
  internal static unsafe runtime_error* std\u002Eruntime_error\u002E\u007Bctor\u007D(
    [In] runtime_error* obj0,
    runtime_error* _param1)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) obj0, (exception*) _param1);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7runtime_error\u0040std\u0040\u00406B\u0040;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12), (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param1 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  [SpecialName]
  internal static unsafe out_of_range* std\u002Eout_of_range\u002E\u007Bctor\u007D(
    [In] out_of_range* obj0,
    out_of_range* _param1)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) obj0, (exception*) _param1);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12), (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param1 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7out_of_range\u0040std\u0040\u00406B\u0040;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elogic_error\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  [SpecialName]
  internal static unsafe logic_error* std\u002Elogic_error\u002E\u007Bctor\u007D(
    [In] logic_error* obj0,
    logic_error* _param1)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) obj0, (exception*) _param1);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12), (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param1 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Eios_base\u002Efailure\u002E\u007Bdtor\u007D(
    [In] ios_base.failure* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7failure\u0040ios_base\u0040std\u0040\u00406B\u0040;
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7runtime_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe void* std\u002Eios_base\u002Efailure\u002E__vecDelDtor(
    [In] ios_base.failure* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      ios_base.failure* failurePtr = (ios_base.failure*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 40U, *(int*) failurePtr, (__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002Efailure\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) failurePtr);
      return (void*) failurePtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7failure\u0040ios_base\u0040std\u0040\u00406B\u0040;
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7runtime_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  [SpecialName]
  internal static unsafe ios_base.failure* std\u002Eios_base\u002Efailure\u002E\u007Bctor\u007D(
    [In] ios_base.failure* obj0,
    ios_base.failure* _param1)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) obj0, (exception*) _param1);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7runtime_error\u0040std\u0040\u00406B\u0040;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12), (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param1 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7failure\u0040ios_base\u0040std\u0040\u00406B\u0040;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eruntime_error\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe int IsEqualGUID(_GUID* rguid1, _GUID* rguid2)
  {
    uint num1 = 16;
    _GUID* guidPtr = rguid2;
    sbyte num2 = *(sbyte*) rguid1;
    sbyte num3 = *(sbyte*) rguid2;
    int num4;
    if ((int) num2 >= (int) num3)
    {
      int num5 = (int) ((IntPtr) rguid1 - (IntPtr) rguid2);
      while ((int) num2 <= (int) num3)
      {
        if (num1 != 1U)
        {
          --num1;
          ++guidPtr;
          num2 = *(sbyte*) (num5 + (IntPtr) guidPtr);
          num3 = *(sbyte*) guidPtr;
          if ((int) num2 < (int) num3)
            break;
        }
        else
        {
          num4 = 1;
          goto label_7;
        }
      }
    }
    num4 = 0;
label_7:
    return num4;
  }

  internal static unsafe int \u003D\u003D(_GUID* guidOne, _GUID* guidOther) => \u003CModule\u003E.IsEqualGUID(guidOne, guidOther);

  internal static void _com_util\u002ECheckError(int hr)
  {
    if (hr >= 0)
      return;
    \u003CModule\u003E._com_issue_error(hr);
  }

  [SpecialName]
  internal static unsafe _bstr_t* _bstr_t\u002E\u007Bctor\u007D([In] _bstr_t* obj0, _bstr_t* s)
  {
    int num = *(int*) s;
    *(int*) obj0 = num;
    if (num != 0)
      \u003CModule\u003E.InterlockedIncrement((int*) (num + 8));
    return obj0;
  }

  internal static unsafe void _bstr_t\u002E_AddRef([In] _bstr_t* obj0)
  {
    uint num = (uint) *(int*) obj0;
    if (num == 0U)
      return;
    \u003CModule\u003E.InterlockedIncrement((int*) ((int) num + 8));
  }

  internal static unsafe uint _bstr_t\u002EData_t\u002EAddRef([In] _bstr_t.Data_t* obj0)
  {
    _bstr_t.Data_t* dataTPtr = (_bstr_t.Data_t*) ((IntPtr) obj0 + 8);
    \u003CModule\u003E.InterlockedIncrement((int*) dataTPtr);
    return (uint) *(int*) dataTPtr;
  }

  [SpecialName]
  internal static unsafe _variant_t* _variant_t\u002E\u007Bctor\u007D(
    [In] _variant_t* obj0,
    _variant_t* varSrc)
  {
    \u003CModule\u003E.VariantInit((tagVARIANT*) obj0);
    int num = \u003CModule\u003E.VariantCopy((tagVARIANT*) obj0, (tagVARIANT*) varSrc);
    if (num < 0)
      \u003CModule\u003E._com_issue_error(num);
    return obj0;
  }

  internal static unsafe void* _com_error\u002E__vecDelDtor([In] _com_error* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      _com_error* comErrorPtr = (_com_error*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) comErrorPtr, (__FnPtr<void (void*)>) __methodptr(_com_error\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) comErrorPtr);
      return (void*) comErrorPtr;
    }
    \u003CModule\u003E._com_error\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  [SpecialName]
  internal static unsafe _com_error* _com_error\u002E\u007Bctor\u007D(
    [In] _com_error* obj0,
    _com_error* that)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7_com_error\u0040\u00406B\u0040;
    *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) that + 4);
    *(int*) ((IntPtr) obj0 + 8) = *(int*) ((IntPtr) that + 8);
    *(int*) ((IntPtr) obj0 + 12) = 0;
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 8);
    if (num1 != 0U)
    {
      int num2 = (int) num1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num3 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) num2 + 4))((IntPtr) num2);
    }
    return obj0;
  }

  internal static unsafe void _com_error\u002E\u007Bdtor\u007D([In] _com_error* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7_com_error\u0040\u00406B\u0040;
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 8);
    if (num1 != 0U)
    {
      int num2 = (int) num1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num3 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) num2 + 8))((IntPtr) num2);
    }
    uint num4 = (uint) *(int*) ((IntPtr) obj0 + 12);
    if (num4 == 0U)
      return;
    \u003CModule\u003E.LocalFree((void*) num4);
  }

  internal static unsafe void EventSink\u002E\u007Bdtor\u007D([In] EventSink* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7EventSink\u0040\u00406B\u0040;
    *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
  }

  internal static unsafe void GSink\u002E\u007Bdtor\u007D([In] GSink* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7GSink\u0040\u00406B\u0040;
    *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
  }

  internal static unsafe void VGASink\u002E\u007Bdtor\u007D([In] VGASink* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7VGASink\u0040\u00406B\u0040;
    *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
  }

  internal static unsafe uint EventSink\u002EAddRef([In] EventSink* obj0) => (uint) \u003CModule\u003E.InterlockedIncrement((int*) ((IntPtr) obj0 + 4));

  internal static unsafe uint EventSink\u002ERelease([In] EventSink* obj0)
  {
    int num = \u003CModule\u003E.InterlockedDecrement((int*) ((IntPtr) obj0 + 4));
    if (num == 0 && (IntPtr) obj0 != IntPtr.Zero)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7EventSink\u0040\u00406B\u0040;
      *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
      \u003CModule\u003E.delete((void*) obj0);
    }
    return (uint) num;
  }

  internal static unsafe void* EventSink\u002E__delDtor([In] EventSink* obj0, uint _param1)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7EventSink\u0040\u00406B\u0040;
    *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe int EventSink\u002EQueryInterface(
    [In] EventSink* obj0,
    _GUID* riid,
    void** ppv)
  {
    if (\u003CModule\u003E.IsEqualGUID(riid, &\u003CModule\u003E.IID_IUnknown) == 0 && \u003CModule\u003E.IsEqualGUID(riid, &\u003CModule\u003E.IID_IWbemObjectSink) == 0)
      return -2147467262;
    *(int*) ppv = (int) obj0;
    EventSink* eventSinkPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) eventSinkPtr + 4))((IntPtr) eventSinkPtr);
    return 0;
  }

  internal static unsafe int EventSink\u002EIndicate(
    [In] EventSink* obj0,
    int lObjectCount,
    IWbemClassObject** apObjArray)
  {
    int num = 0;
    if (0 < lObjectCount)
    {
      do
      {
        IWbemClassObject* iwbemClassObjectPtr1 = (IWbemClassObject*) *(int*) (num * 4 + (IntPtr) apObjArray);
        \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
        // ISSUE: initblk instruction
        __memset(ref arrayTypeBy0EaD, 0, 64);
        IWbemClassObject* iwbemClassObjectPtr2 = iwbemClassObjectPtr1;
        ref \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W local1 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BM\u0040JEOLDKGI\u0040\u003F\u0024AAu\u003F\u0024AAS\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AAC\u003F\u0024AAh\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
        tagVARIANT tagVariant;
        ref tagVARIANT local2 = ref tagVariant;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        if (__calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr1 + 16))((int*) iwbemClassObjectPtr2, (int*) ref local1, (tagVARIANT*) 0, (int) ref local2, (char*) 0, IntPtr.Zero) == 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          switch ((uint) (^(int&) ((IntPtr) &tagVariant + 8) & 768))
          {
            case 256:
            case 512:
              \u003CModule\u003E.VariantClear(&tagVariant);
              break;
            case 768:
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              \u003CModule\u003E.PostMessageA((HWND__*) (int) ushort.MaxValue, 305U, (uint) (^(int&) ((IntPtr) &tagVariant + 8) & 15), 0);
              goto case 256;
            case 1024:
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              if ((^(int&) ((IntPtr) &tagVariant + 8) & 1) != 0)
              {
                \u003CModule\u003E.MessageBoxA((HWND__*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040JFCHHLPJ\u0040Memory\u003F5card\u003F5insert\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_09KOBJOHCF\u0040Notify\u003F\u0024CB\u003F\u0024CB\u003F\u0024CB\u003F\u0024AA\u0040, 0U);
                goto case 256;
              }
              else
              {
                \u003CModule\u003E.MessageBoxA((HWND__*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BF\u0040CPLEDEFJ\u0040Memory\u003F5card\u003F5pull\u003F5off\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_09KOBJOHCF\u0040Notify\u003F\u0024CB\u003F\u0024CB\u003F\u0024CB\u003F\u0024AA\u0040, 0U);
                goto case 256;
              }
            default:
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0EaD, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BJ\u0040NLCNNPGJ\u0040Receive\u003F5unknown\u003F5value\u003F3\u003F\u0024CFX\u003F\u0024AA\u0040, __arglist (^(int&) ((IntPtr) &tagVariant + 8)));
              \u003CModule\u003E.MessageBoxA((HWND__*) 0, (sbyte*) &arrayTypeBy0EaD, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_09KOBJOHCF\u0040Notify\u003F\u0024CB\u003F\u0024CB\u003F\u0024CB\u003F\u0024AA\u0040, 0U);
              goto case 256;
          }
        }
        ++num;
      }
      while (num < lObjectCount);
    }
    return 0;
  }

  internal static unsafe int EventSink\u002ESetStatus(
    [In] EventSink* obj0,
    int lFlags,
    int hResult,
    char* strParam,
    IWbemClassObject* pObjParam)
  {
    return 0;
  }

  internal static unsafe uint GSink\u002EAddRef([In] GSink* obj0) => (uint) \u003CModule\u003E.InterlockedIncrement((int*) ((IntPtr) obj0 + 4));

  internal static unsafe uint GSink\u002ERelease([In] GSink* obj0)
  {
    int num = \u003CModule\u003E.InterlockedDecrement((int*) ((IntPtr) obj0 + 4));
    if (num == 0 && (IntPtr) obj0 != IntPtr.Zero)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7GSink\u0040\u00406B\u0040;
      *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
      \u003CModule\u003E.delete((void*) obj0);
    }
    return (uint) num;
  }

  internal static unsafe void* GSink\u002E__delDtor([In] GSink* obj0, uint _param1)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7GSink\u0040\u00406B\u0040;
    *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe int GSink\u002EQueryInterface([In] GSink* obj0, _GUID* riid, void** ppv)
  {
    if (\u003CModule\u003E.IsEqualGUID(riid, &\u003CModule\u003E.IID_IUnknown) == 0 && \u003CModule\u003E.IsEqualGUID(riid, &\u003CModule\u003E.IID_IWbemObjectSink) == 0)
      return -2147467262;
    *(int*) ppv = (int) obj0;
    GSink* gsinkPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) gsinkPtr + 4))((IntPtr) gsinkPtr);
    return 0;
  }

  internal static unsafe int GSink\u002EIndicate(
    [In] GSink* obj0,
    int lObjectCount,
    IWbemClassObject** apObjArray)
  {
    int num = 0;
    if (0 < lObjectCount)
    {
      do
      {
        IWbemClassObject* iwbemClassObjectPtr1 = (IWbemClassObject*) *(int*) (num * 4 + (IntPtr) apObjArray);
        \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
        // ISSUE: initblk instruction
        __memset(ref arrayTypeBy0EaD, 0, 64);
        IWbemClassObject* iwbemClassObjectPtr2 = iwbemClassObjectPtr1;
        ref \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W local1 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1O\u0040KCNBCIIJ\u0040\u003F\u0024AAu\u003F\u0024AAS\u003F\u0024AAh\u003F\u0024AAo\u003F\u0024AAc\u003F\u0024AAk\u003F\u0024AA\u003F\u0024AA\u0040;
        tagVARIANT tagVariant;
        ref tagVARIANT local2 = ref tagVariant;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        if (__calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr1 + 16))((int*) iwbemClassObjectPtr2, (int*) ref local1, (tagVARIANT*) 0, (int) ref local2, (char*) 0, IntPtr.Zero) == 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (^(int&) ((IntPtr) &tagVariant + 8) == 1281)
          {
            \u003CModule\u003E.MessageBoxA((HWND__*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040LNMIPNAF\u0040System\u003F5start\u003F5shock\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_09KOBJOHCF\u0040Notify\u003F\u0024CB\u003F\u0024CB\u003F\u0024CB\u003F\u0024AA\u0040, 0U);
          }
          else
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            if (^(int&) ((IntPtr) &tagVariant + 8) == 1282)
            {
              \u003CModule\u003E.MessageBoxA((HWND__*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BC\u0040DDCMCHHE\u0040System\u003F5stop\u003F5shock\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_09KOBJOHCF\u0040Notify\u003F\u0024CB\u003F\u0024CB\u003F\u0024CB\u003F\u0024AA\u0040, 0U);
            }
            else
            {
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0EaD, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0CI\u0040ODCPIEAA\u0040Receive\u003F5unknown\u003F5value\u003F5from\u003F5G\u003F9Sen\u0040, __arglist (^(int&) ((IntPtr) &tagVariant + 8)));
              \u003CModule\u003E.MessageBoxA((HWND__*) 0, (sbyte*) &arrayTypeBy0EaD, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_09KOBJOHCF\u0040Notify\u003F\u0024CB\u003F\u0024CB\u003F\u0024CB\u003F\u0024AA\u0040, 0U);
            }
          }
          \u003CModule\u003E.VariantClear(&tagVariant);
        }
        ++num;
      }
      while (num < lObjectCount);
    }
    return 0;
  }

  internal static unsafe int GSink\u002ESetStatus(
    [In] GSink* obj0,
    int lFlags,
    int hResult,
    char* strParam,
    IWbemClassObject* pObjParam)
  {
    return 0;
  }

  internal static unsafe uint VGASink\u002EAddRef([In] VGASink* obj0) => (uint) \u003CModule\u003E.InterlockedIncrement((int*) ((IntPtr) obj0 + 4));

  internal static unsafe uint VGASink\u002ERelease([In] VGASink* obj0)
  {
    int num = \u003CModule\u003E.InterlockedDecrement((int*) ((IntPtr) obj0 + 4));
    if (num == 0 && (IntPtr) obj0 != IntPtr.Zero)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7VGASink\u0040\u00406B\u0040;
      *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
      \u003CModule\u003E.delete((void*) obj0);
    }
    return (uint) num;
  }

  internal static unsafe void* VGASink\u002E__delDtor([In] VGASink* obj0, uint _param1)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7VGASink\u0040\u00406B\u0040;
    *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe int VGASink\u002EQueryInterface([In] VGASink* obj0, _GUID* riid, void** ppv)
  {
    if (\u003CModule\u003E.IsEqualGUID(riid, &\u003CModule\u003E.IID_IUnknown) == 0 && \u003CModule\u003E.IsEqualGUID(riid, &\u003CModule\u003E.IID_IWbemObjectSink) == 0)
      return -2147467262;
    *(int*) ppv = (int) obj0;
    VGASink* vgaSinkPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) vgaSinkPtr + 4))((IntPtr) vgaSinkPtr);
    return 0;
  }

  internal static unsafe int VGASink\u002EIndicate(
    [In] VGASink* obj0,
    int lObjectCount,
    IWbemClassObject** apObjArray)
  {
    int num = 0;
    if (0 < lObjectCount)
    {
      do
      {
        IWbemClassObject* iwbemClassObjectPtr1 = (IWbemClassObject*) *(int*) (num * 4 + (IntPtr) apObjArray);
        \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
        // ISSUE: initblk instruction
        __memset(ref arrayTypeBy0EaD, 0, 64);
        IWbemClassObject* iwbemClassObjectPtr2 = iwbemClassObjectPtr1;
        ref \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W local1 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BC\u0040NGFAENII\u0040\u003F\u0024AAu\u003F\u0024AAH\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAP\u003F\u0024AAl\u003F\u0024AAu\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
        tagVARIANT tagVariant;
        ref tagVARIANT local2 = ref tagVariant;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        if (__calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr1 + 16))((int*) iwbemClassObjectPtr2, (int*) ref local1, (tagVARIANT*) 0, (int) ref local2, (char*) 0, IntPtr.Zero) == 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if ((uint) ^(int&) ((IntPtr) &tagVariant + 8) <= 65538U)
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            if (^(int&) ((IntPtr) &tagVariant + 8) != 65538)
            {
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              if (^(int&) ((IntPtr) &tagVariant + 8) != 1536)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if (^(int&) ((IntPtr) &tagVariant + 8) == 1537)
                {
                  \u003CModule\u003E.SendMessageA(\u003CModule\u003E.FindWindowA((sbyte*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040OKPDPLBM\u0040Acer\u003F5ePresentation\u003F\u0024AA\u0040), 13337U, 1U, 1);
                  goto label_12;
                }
              }
              else
              {
                \u003CModule\u003E.SendMessageA(\u003CModule\u003E.FindWindowA((sbyte*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040OKPDPLBM\u0040Acer\u003F5ePresentation\u003F\u0024AA\u0040), 13337U, 1U, 0);
                goto label_12;
              }
            }
            else
            {
              \u003CModule\u003E.SendMessageA(\u003CModule\u003E.FindWindowA((sbyte*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040OKPDPLBM\u0040Acer\u003F5ePresentation\u003F\u0024AA\u0040), 13337U, 3U, 0);
              goto label_12;
            }
          }
          else
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            if (^(int&) ((IntPtr) &tagVariant + 8) == 86017)
            {
              \u003CModule\u003E.SendMessageA(\u003CModule\u003E.FindWindowA((sbyte*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040OKPDPLBM\u0040Acer\u003F5ePresentation\u003F\u0024AA\u0040), 13337U, 2U, 0);
              goto label_12;
            }
          }
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0EaD, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BK\u0040BKFMMLBI\u0040Unknown\u003F5value\u003F5from\u003F5VGA\u003F3\u003F\u0024CFX\u003F\u0024AA\u0040, __arglist (^(int&) ((IntPtr) &tagVariant + 8)));
label_12:
          \u003CModule\u003E.VariantClear(&tagVariant);
        }
        ++num;
      }
      while (num < lObjectCount);
    }
    return 0;
  }

  internal static unsafe int VGASink\u002ESetStatus(
    [In] VGASink* obj0,
    int lFlags,
    int hResult,
    char* strParam,
    IWbemClassObject* pObjParam)
  {
    return 0;
  }

  [SpecialName]
  internal static unsafe bad_alloc* std\u002Ebad_alloc\u002E\u007Bctor\u007D(
    [In] bad_alloc* obj0,
    bad_alloc* _param1)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) obj0, (exception*) _param1);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe sbyte* _tcsstr(sbyte* _s1, sbyte* _s2) => (sbyte*) \u003CModule\u003E._mbsstr((byte*) _s1, (byte*) _s2);

  internal static unsafe sbyte* _tcsstr(sbyte* _S, sbyte* _P) => (sbyte*) \u003CModule\u003E._mbsstr((byte*) _S, (byte*) _P);

  internal static unsafe EventSink* EventSink\u002E\u007Bctor\u007D([In] EventSink* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7EventSink\u0040\u00406B\u0040;
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return obj0;
  }

  internal static unsafe IWbemObjectSink* IWbemObjectSink\u002E\u007Bctor\u007D(
    [In] IWbemObjectSink* obj0)
  {
    return obj0;
  }

  internal static unsafe IUnknown* IUnknown\u002E\u007Bctor\u007D([In] IUnknown* obj0) => obj0;

  internal static unsafe GSink* GSink\u002E\u007Bctor\u007D([In] GSink* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7GSink\u0040\u00406B\u0040;
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return obj0;
  }

  internal static unsafe VGASink* VGASink\u002E\u007Bctor\u007D([In] VGASink* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7VGASink\u0040\u00406B\u0040;
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return obj0;
  }

  internal static unsafe WMI* WMI\u002E\u007Bctor\u007D([In] WMI* obj0)
  {
    WMI* wmiPtr1 = (WMI*) ((IntPtr) obj0 + 4);
    *(int*) wmiPtr1 = 0;
    *(int*) obj0 = 0;
    *(int*) ((IntPtr) obj0 + 24) = 0;
    \u003CModule\u003E.CoInitializeEx((void*) 0, 0U);
    *(int*) ((IntPtr) obj0 + 8) = \u003CModule\u003E.CoInitializeSecurity((void*) 0, -1, (tagSOLE_AUTHENTICATION_SERVICE*) 0, (void*) 0, 0U, 3U, (void*) 0, 0U, (void*) 0);
    *(int*) ((IntPtr) obj0 + 8) = \u003CModule\u003E.CoCreateInstance(&\u003CModule\u003E.CLSID_WbemLocator, (IUnknown*) 0, 1U, &\u003CModule\u003E.IID_IWbemLocator, (void**) wmiPtr1);
    int num1 = *(int*) wmiPtr1;
    IntPtr num2 = (IntPtr) obj0 + 8;
    int num3 = num1;
    ref \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W local = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BC\u0040OJAPPONC\u0040\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AA\u003F2\u003F\u0024AAw\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AA\u003F\u0024AA\u0040;
    WMI* wmiPtr2 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num4 = __calli((__FnPtr<int (IntPtr, char*, char*, char*, char*, int, char*, IWbemContext*, IWbemServices**)>) *(int*) (*(int*) num1 + 12))((IWbemServices**) num3, (IWbemContext*) ref local, (char*) 0, 0, (char*) 0, (char*) 0, (char*) 0, (char*) 0, (IntPtr) wmiPtr2);
    *(int*) num2 = num4;
    *(int*) ((IntPtr) obj0 + 8) = \u003CModule\u003E.CoSetProxyBlanket((IUnknown*) *(int*) obj0, 10U, 0U, (char*) 0, 3U, 3U, (void*) 0, 0U);
    \u003CModule\u003E.WMI\u002EWMIAPExist(obj0, 1);
    return obj0;
  }

  internal static unsafe void WMI\u002E\u007Bdtor\u007D([In] WMI* obj0)
  {
    *(int*) ((IntPtr) obj0 + 8) = \u003CModule\u003E.WMI\u002EWMIEventUnRegister(obj0);
    *(int*) ((IntPtr) obj0 + 8) = \u003CModule\u003E.WMI\u002EWMIAPExist(obj0, 0);
    uint num1 = (uint) *(int*) obj0;
    if (num1 != 0U)
    {
      int num2 = (int) num1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num3 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) num2 + 8))((IntPtr) num2);
    }
    uint num4 = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num4 != 0U)
    {
      int num5 = (int) num4;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num6 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) num5 + 8))((IntPtr) num5);
    }
    \u003CModule\u003E.CoUninitialize();
  }

  internal static unsafe int WMI\u002EWMIDataBlockRead(
    [In] WMI* obj0,
    char* sQuery,
    char* sPropertyName,
    tagVARIANT* vtRead)
  {
    IEnumWbemClassObject* ienumWbemClassObjectPtr1 = (IEnumWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr1 = (IWbemClassObject*) 0;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int num1 = *(int*) obj0;
    int num2 = num1;
    ref \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W local1 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_17NDCOOGJO\u0040\u003F\u0024AAW\u003F\u0024AAQ\u003F\u0024AAL\u003F\u0024AA\u003F\u0024AA\u0040;
    char* chPtr1 = sQuery;
    ref IEnumWbemClassObject* local2 = ref ienumWbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr, char*, char*, int, IWbemContext*, IEnumWbemClassObject**)>) *(int*) (*(int*) num1 + 80))((IEnumWbemClassObject**) num2, (IWbemContext*) ref local1, (int) chPtr1, (char*) 48, (char*) 0, (IntPtr) ref local2);
    *(int*) ((IntPtr) obj0 + 8) = num3;
    if (num3 < 0)
      return num3;
    IEnumWbemClassObject* ienumWbemClassObjectPtr2 = ienumWbemClassObjectPtr1;
    ref IWbemClassObject* local3 = ref iwbemClassObjectPtr1;
    uint num4;
    ref uint local4 = ref num4;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = __calli((__FnPtr<int (IntPtr, int, uint, IWbemClassObject**, uint*)>) *(int*) (*(int*) ienumWbemClassObjectPtr1 + 16))((uint*) ienumWbemClassObjectPtr2, (IWbemClassObject**) -1, 1U, (int) ref local3, (IntPtr) ref local4);
    *(int*) ((IntPtr) obj0 + 8) = num5;
    if (num5 < 0)
    {
      \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaD, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0O\u0040HILJBJEP\u0040Error\u003F5code\u003F3\u003F\u0024CFX\u003F\u0024AA\u0040, __arglist (num5));
      return *(int*) ((IntPtr) obj0 + 8);
    }
    if (num4 != 0U)
    {
      IWbemClassObject* iwbemClassObjectPtr2 = iwbemClassObjectPtr1;
      char* chPtr2 = sPropertyName;
      tagVARIANT* tagVariantPtr = vtRead;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num6 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr1 + 16))((int*) iwbemClassObjectPtr2, (int*) chPtr2, (tagVARIANT*) 0, (int) tagVariantPtr, (char*) 0, IntPtr.Zero);
      *(int*) ((IntPtr) obj0 + 8) = num6;
      if (num6 < 0)
        return num6;
    }
    else
      \u003CModule\u003E.MessageBoxA((HWND__*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BE\u0040GDLCFJHN\u0040Get\u003F5zero\u003F5enumerator\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BB\u0040NFPPEIG\u0040WMIDataBlockRead\u003F\u0024AA\u0040, 0U);
    if ((IntPtr) iwbemClassObjectPtr1 != IntPtr.Zero)
    {
      IWbemClassObject* iwbemClassObjectPtr3 = iwbemClassObjectPtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num7 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 8))((IntPtr) iwbemClassObjectPtr3);
    }
    if ((IntPtr) ienumWbemClassObjectPtr1 != IntPtr.Zero)
    {
      IEnumWbemClassObject* ienumWbemClassObjectPtr3 = ienumWbemClassObjectPtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num8 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) ienumWbemClassObjectPtr3 + 8))((IntPtr) ienumWbemClassObjectPtr3);
    }
    return *(int*) ((IntPtr) obj0 + 8);
  }

  internal static unsafe int WMI\u002EWMIMethodExecGet(
    [In] WMI* obj0,
    char* sInstanceName,
    char* sMethodName,
    char* sOutArgName,
    tagVARIANT* vtRead)
  {
    IWbemClassObject* iwbemClassObjectPtr1 = (IWbemClassObject*) 0;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int num1 = *(int*) obj0;
    int num2 = num1;
    char* chPtr1 = sInstanceName;
    char* chPtr2 = sMethodName;
    ref IWbemClassObject* local = ref iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr, char*, char*, int, IWbemContext*, IWbemClassObject*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num1 + 96))((IWbemCallResult**) num2, (IWbemClassObject**) chPtr1, (IWbemClassObject*) chPtr2, (IWbemContext*) 0, 0, (char*) 0, (char*) ref local, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num3;
    if (num3 < 0)
      return num3;
    IWbemClassObject* iwbemClassObjectPtr2 = iwbemClassObjectPtr1;
    char* chPtr3 = sOutArgName;
    tagVARIANT* tagVariantPtr = vtRead;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num4 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr1 + 16))((int*) iwbemClassObjectPtr2, (int*) chPtr3, (tagVARIANT*) 0, (int) tagVariantPtr, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num4;
    if (num4 < 0)
      return num4;
    IWbemClassObject* iwbemClassObjectPtr3 = iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 8))((IntPtr) iwbemClassObjectPtr3);
    return *(int*) ((IntPtr) obj0 + 8);
  }

  internal static unsafe int WMI\u002EWMIMethodExecSet(
    [In] WMI* obj0,
    char* sClassName,
    char* sInstanceName,
    char* sMethodName,
    char* sInArgName,
    char* sOutArgName,
    tagVARIANT* vtWrite,
    tagVARIANT* vtRead)
  {
    IWbemClassObject* iwbemClassObjectPtr1 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr2 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr3 = (IWbemClassObject*) 0;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int num1 = *(int*) obj0;
    int num2 = num1;
    char* chPtr1 = sClassName;
    ref IWbemClassObject* local1 = ref iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemContext*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num1 + 24))((IWbemCallResult**) num2, (IWbemClassObject**) chPtr1, (IWbemContext*) 0, 0, (char*) ref local1, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num3;
    if (num3 < 0)
      return num3;
    IWbemClassObject* iwbemClassObjectPtr4 = iwbemClassObjectPtr1;
    char* chPtr2 = sMethodName;
    ref IWbemClassObject* local2 = ref iwbemClassObjectPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num4 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemClassObject**, IWbemClassObject**)>) *(int*) (*(int*) iwbemClassObjectPtr1 + 76))((IWbemClassObject**) iwbemClassObjectPtr4, (IWbemClassObject**) chPtr2, 0, (char*) ref local2, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num4;
    if (num4 < 0)
      return num4;
    IWbemClassObject* iwbemClassObjectPtr5 = iwbemClassObjectPtr2;
    char* chPtr3 = sInArgName;
    tagVARIANT* tagVariantPtr1 = vtWrite;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr5, (tagVARIANT*) chPtr3, 0, (char*) tagVariantPtr1, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num5;
    if (num5 < 0)
      return num5;
    int num6 = *(int*) obj0;
    int num7 = num6;
    char* chPtr4 = sInstanceName;
    char* chPtr5 = sMethodName;
    IWbemClassObject* iwbemClassObjectPtr6 = iwbemClassObjectPtr2;
    ref IWbemClassObject* local3 = ref iwbemClassObjectPtr3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num8 = __calli((__FnPtr<int (IntPtr, char*, char*, int, IWbemContext*, IWbemClassObject*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num6 + 96))((IWbemCallResult**) num7, (IWbemClassObject**) chPtr4, (IWbemClassObject*) chPtr5, (IWbemContext*) 0, 0, (char*) iwbemClassObjectPtr6, (char*) ref local3, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num8;
    if (num8 < 0)
      return num8;
    IntPtr num9 = (IntPtr) obj0 + 8;
    IWbemClassObject* iwbemClassObjectPtr7 = iwbemClassObjectPtr3;
    char* chPtr6 = sOutArgName;
    tagVARIANT* tagVariantPtr2 = vtRead;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num10 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr7, (int*) chPtr6, (tagVARIANT*) 0, (int) tagVariantPtr2, (char*) 0, IntPtr.Zero);
    *(int*) num9 = num10;
    IWbemClassObject* iwbemClassObjectPtr8 = iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num11 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr8 + 8))((IntPtr) iwbemClassObjectPtr8);
    IWbemClassObject* iwbemClassObjectPtr9 = iwbemClassObjectPtr3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num12 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr9 + 8))((IntPtr) iwbemClassObjectPtr9);
    IWbemClassObject* iwbemClassObjectPtr10 = iwbemClassObjectPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num13 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr10 + 8))((IntPtr) iwbemClassObjectPtr10);
    return *(int*) ((IntPtr) obj0 + 8);
  }

  internal static unsafe int WMI\u002EWMIEventRegister([In] WMI* obj0)
  {
    IUnsecuredApartment* iunsecuredApartmentPtr1 = (IUnsecuredApartment*) 0;
    IUnknown* iunknownPtr1 = (IUnknown*) 0;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int instance = \u003CModule\u003E.CoCreateInstance(&\u003CModule\u003E.CLSID_UnsecuredApartment, (IUnknown*) 0, 4U, &\u003CModule\u003E.IID_IUnsecuredApartment, (void**) &iunsecuredApartmentPtr1);
    *(int*) ((IntPtr) obj0 + 8) = instance;
    if (instance < 0)
      return instance;
    EventSink* eventSinkPtr1 = (EventSink*) \u003CModule\u003E.@new(12U);
    EventSink* eventSinkPtr2;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) eventSinkPtr1 != IntPtr.Zero)
      {
        *(int*) eventSinkPtr1 = (int) &\u003CModule\u003E.\u003F\u003F_7EventSink\u0040\u00406B\u0040;
        *(int*) ((IntPtr) eventSinkPtr1 + 4) = 0;
        eventSinkPtr2 = eventSinkPtr1;
      }
      else
        eventSinkPtr2 = (EventSink*) 0;
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) eventSinkPtr1);
    }
    EventSink* eventSinkPtr3 = eventSinkPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num1 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) eventSinkPtr3 + 4))((IntPtr) eventSinkPtr3);
    IUnsecuredApartment* iunsecuredApartmentPtr2 = iunsecuredApartmentPtr1;
    EventSink* eventSinkPtr4 = eventSinkPtr2;
    ref IUnknown* local1 = ref iunknownPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num2 = __calli((__FnPtr<int (IntPtr, IUnknown*, IUnknown**)>) *(int*) (*(int*) iunsecuredApartmentPtr1 + 12))((IUnknown**) iunsecuredApartmentPtr2, (IUnknown*) eventSinkPtr4, (IntPtr) ref local1);
    *(int*) ((IntPtr) obj0 + 8) = num2;
    if (num2 < 0)
      return num2;
    WMI* wmiPtr1 = (WMI*) ((IntPtr) obj0 + 12);
    *(int*) wmiPtr1 = 0;
    IUnknown* iunknownPtr2 = iunknownPtr1;
    ref _GUID local2 = ref \u003CModule\u003E.IID_IWbemObjectSink;
    WMI* wmiPtr2 = wmiPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr, _GUID*, void**)>) *(int*) *(int*) iunknownPtr1)((void**) iunknownPtr2, (_GUID*) ref local2, (IntPtr) wmiPtr2);
    *(int*) ((IntPtr) obj0 + 8) = num3;
    if (num3 < 0)
      return num3;
    int num4 = *(int*) obj0;
    int num5 = num4;
    ref \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W local3 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_17NDCOOGJO\u0040\u003F\u0024AAW\u003F\u0024AAQ\u003F\u0024AAL\u003F\u0024AA\u003F\u0024AA\u0040;
    ref \u0024ArrayType\u0024\u0024\u0024BY0CC\u0040\u0024\u0024CB_W local4 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1EE\u0040MECHOCGI\u0040\u003F\u0024AAS\u003F\u0024AAE\u003F\u0024AAL\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAT\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F5\u003F\u0024AAF\u003F\u0024AAR\u003F\u0024AAO\u003F\u0024AAM\u003F\u0024AA\u003F5\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAh\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAE\u003F\u0024AAv\u003F\u0024AAe\u003F\u0024AAn\u0040;
    int num6 = *(int*) wmiPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num7 = __calli((__FnPtr<int (IntPtr, char*, char*, int, IWbemContext*, IWbemObjectSink*)>) *(int*) (*(int*) num4 + 92))((IWbemObjectSink*) num5, (IWbemContext*) ref local3, (int) ref local4, (char*) 128, (char*) 0, (IntPtr) num6);
    *(int*) ((IntPtr) obj0 + 8) = num7;
    if (num7 < 0)
      return num7;
    IUnsecuredApartment* iunsecuredApartmentPtr3 = iunsecuredApartmentPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num8 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iunsecuredApartmentPtr3 + 8))((IntPtr) iunsecuredApartmentPtr3);
    IUnknown* iunknownPtr3 = iunknownPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num9 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iunknownPtr3 + 8))((IntPtr) iunknownPtr3);
    EventSink* eventSinkPtr5 = eventSinkPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num10 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) eventSinkPtr5 + 8))((IntPtr) eventSinkPtr5);
    return *(int*) ((IntPtr) obj0 + 8);
  }

  internal static unsafe int WMI\u002EWMIEventUnRegister([In] WMI* obj0)
  {
    *(int*) ((IntPtr) obj0 + 8) = 0;
    uint num1 = (uint) *(int*) obj0;
    if (num1 != 0U)
    {
      int num2 = (int) num1;
      int num3 = *(int*) ((IntPtr) obj0 + 12);
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num4 = __calli((__FnPtr<int (IntPtr, IWbemObjectSink*)>) *(int*) (*(int*) num1 + 16))((IWbemObjectSink*) num2, (IntPtr) num3);
      *(int*) ((IntPtr) obj0 + 8) = num4;
      if (num4 < 0)
        return num4;
    }
    int num5 = *(int*) ((IntPtr) obj0 + 12);
    if (num5 != 0)
    {
      int num6 = num5;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num7 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) num6 + 8))((IntPtr) num6);
    }
    return *(int*) ((IntPtr) obj0 + 8);
  }

  internal static unsafe int WMI\u002EWMIAPExist([In] WMI* obj0, int lFlag)
  {
    IWbemClassObject* iwbemClassObjectPtr1 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr2 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr3 = (IWbemClassObject*) 0;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int num1 = *(int*) obj0;
    IntPtr num2 = (IntPtr) obj0 + 8;
    int num3 = num1;
    ref \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W local1 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1CA\u0040FPONMHDE\u0040\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
    ref IWbemClassObject* local2 = ref iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num4 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemContext*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num1 + 24))((IWbemCallResult**) num3, (IWbemClassObject**) ref local1, (IWbemContext*) 0, 0, (char*) ref local2, IntPtr.Zero);
    *(int*) num2 = num4;
    tagVARIANT tagVariant1;
    \u003CModule\u003E.VariantInit(&tagVariant1);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ref tagVariant1 = (short) 3;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &tagVariant1 + 8) = lFlag;
    IntPtr num5 = (IntPtr) obj0 + 8;
    IWbemClassObject* iwbemClassObjectPtr4 = iwbemClassObjectPtr1;
    ref \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W local3 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1CE\u0040GMAAPLGF\u0040\u003F\u0024AAW\u003F\u0024AAM\u003F\u0024AAI\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAu\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAu\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAh\u003F\u0024AA\u003F\u0024AA\u0040;
    ref IWbemClassObject* local4 = ref iwbemClassObjectPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num6 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemClassObject**, IWbemClassObject**)>) *(int*) (*(int*) iwbemClassObjectPtr1 + 76))((IWbemClassObject**) iwbemClassObjectPtr4, (IWbemClassObject**) ref local3, 0, (char*) ref local4, IntPtr.Zero);
    *(int*) num5 = num6;
    IntPtr num7 = (IntPtr) obj0 + 8;
    IWbemClassObject* iwbemClassObjectPtr5 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W local5 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1M\u0040EJHKBOCC\u0040\u003F\u0024AAu\u003F\u0024AAF\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
    ref tagVARIANT local6 = ref tagVariant1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num8 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr5, (tagVARIANT*) ref local5, 0, (char*) ref local6, IntPtr.Zero);
    *(int*) num7 = num8;
    int num9 = *(int*) obj0;
    IntPtr num10 = (IntPtr) obj0 + 8;
    int num11 = num9;
    ref \u0024ArrayType\u0024\u0024\u0024BY0DC\u0040\u0024\u0024CB_W local7 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1GE\u0040OBACBGCF\u0040\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u003F\u0024AAA\u003F\u0024AAC\u0040;
    ref \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W local8 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1CE\u0040GMAAPLGF\u0040\u003F\u0024AAW\u003F\u0024AAM\u003F\u0024AAI\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAu\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAu\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAh\u003F\u0024AA\u003F\u0024AA\u0040;
    IWbemClassObject* iwbemClassObjectPtr6 = iwbemClassObjectPtr2;
    ref IWbemClassObject* local9 = ref iwbemClassObjectPtr3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num12 = __calli((__FnPtr<int (IntPtr, char*, char*, int, IWbemContext*, IWbemClassObject*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num9 + 96))((IWbemCallResult**) num11, (IWbemClassObject**) ref local7, (IWbemClassObject*) ref local8, (IWbemContext*) 0, 0, (char*) iwbemClassObjectPtr6, (char*) ref local9, IntPtr.Zero);
    *(int*) num10 = num12;
    tagVARIANT tagVariant2;
    \u003CModule\u003E.VariantInit(&tagVariant2);
    IntPtr num13 = (IntPtr) obj0 + 8;
    IWbemClassObject* iwbemClassObjectPtr7 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W local10 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040IMJCDLFP\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
    ref tagVARIANT local11 = ref tagVariant2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num14 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr7, (int*) ref local10, (tagVARIANT*) 0, (int) ref local11, (char*) 0, IntPtr.Zero);
    *(int*) num13 = num14;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ((IntPtr) &tagVariant2 + 8) == 0)
    {
      \u003CModule\u003E.VariantClear(&tagVariant2);
      \u003CModule\u003E.VariantClear(&tagVariant1);
      return 0;
    }
    \u003CModule\u003E.VariantClear(&tagVariant2);
    \u003CModule\u003E.VariantClear(&tagVariant1);
    return -2147217407;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool WMI\u002EReadPowerPlane([In] WMI* obj0, byte bPlaneIndex, byte bState)
  {
    char* sMethodName;
    switch (bPlaneIndex)
    {
      case 0:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BC\u0040NACFIELM\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAA\u003F\u0024AAu\u003F\u0024AAd\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 1:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040IILNJDCE\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAC\u003F\u0024AAa\u003F\u0024AAr\u003F\u0024AAd\u003F\u0024AAb\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 2:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BE\u0040MLLPAPGJ\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAL\u003F\u0024AAA\u003F\u0024AAN\u003F\u0024AAP\u003F\u0024AAh\u003F\u0024AAy\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 3:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BI\u0040OAEJPPHK\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAH\u003F\u0024AAa\u003F\u0024AAr\u003F\u0024AAd\u003F\u0024AAD\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAk\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 4:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BC\u0040CDEDCIEB\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAC\u003F\u0024AAD\u003F\u0024AAR\u003F\u0024AAO\u003F\u0024AAM\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 5:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BK\u0040KHKCEBIN\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAS\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAk\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAA\u003F\u0024AAm\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 6:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040HHNPFIPB\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAM\u003F\u0024AAI\u003F\u0024AAN\u003F\u0024AAI\u003F\u0024AAP\u003F\u0024AAC\u003F\u0024AAI\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 7:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BK\u0040OHGLLKME\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAD\u003F\u0024AAi\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAz\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 8:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1O\u0040OKJDINGG\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAM\u003F\u0024AAD\u003F\u0024AAC\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      default:
        \u003CModule\u003E.MessageBoxA((HWND__*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BC\u0040CMPEBGKF\u0040Wrong\u003F5bPlaneIndex\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0P\u0040FIAFCEFO\u0040ReadPowerPlane\u003F\u0024AA\u0040, 0U);
        return false;
    }
    tagVARIANT tagVariant;
    *(int*) ((IntPtr) obj0 + 8) = \u003CModule\u003E.WMI\u002EWMIMethodExecGet(obj0, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1GI\u0040OFMCJHFO\u0040\u003F\u0024AAP\u003F\u0024AAo\u003F\u0024AAw\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAP\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u0040, sMethodName, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040POAHONEM\u0040\u003F\u0024AAu\u003F\u0024AAS\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040, &tagVariant);
    \u003CModule\u003E.SysFreeString(sMethodName);
    if (*(int*) ((IntPtr) obj0 + 8) < 0)
      return false;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if ((^(int&) ((IntPtr) &tagVariant + 8) & -65536) == 0)
      return true;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ((IntPtr) &tagVariant + 8) > 2)
    {
      \u003CModule\u003E.MessageBoxA((HWND__*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BF\u0040BIFJCOLM\u0040Return\u003F5value\u003F5unknown\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BJ\u0040DMHMIHOB\u0040ReadPowerPlane\u003F5for\u003F5Audio\u003F\u0024AA\u0040, 0U);
      return false;
    }
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaD, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0P\u0040IMHNEAIK\u0040Error\u003F5code\u003F3\u003F5\u003F\u0024CFd\u003F\u0024AA\u0040, __arglist (^(int&) ((IntPtr) &tagVariant + 8)));
    \u003CModule\u003E.MessageBoxA((HWND__*) 0, (sbyte*) &arrayTypeBy0CaD, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BP\u0040OAKCPLMI\u0040Return\u003F5ErrorCode\u003F5for\u003F5Get\u003F5Audio\u003F\u0024AA\u0040, 0U);
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool WMI\u002EWritePowerPlane([In] WMI* obj0, byte bPlaneIndex, byte bState)
  {
    char* sMethodName;
    switch (bPlaneIndex)
    {
      case 0:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BC\u0040PFCOAPKC\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAA\u003F\u0024AAu\u003F\u0024AAd\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 1:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040HNOLEKGF\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAC\u003F\u0024AAa\u003F\u0024AAr\u003F\u0024AAd\u003F\u0024AAb\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 2:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BE\u0040GFJEEPBF\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAL\u003F\u0024AAA\u003F\u0024AAN\u003F\u0024AAP\u003F\u0024AAh\u003F\u0024AAy\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 3:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BI\u0040PGCEBOBI\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAH\u003F\u0024AAa\u003F\u0024AAr\u003F\u0024AAd\u003F\u0024AAD\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAk\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 4:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BC\u0040GEIKDFP\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAC\u003F\u0024AAD\u003F\u0024AAR\u003F\u0024AAO\u003F\u0024AAM\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 5:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BK\u0040CHGEIMCL\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAS\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAk\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAA\u003F\u0024AAm\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 6:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040ICIJIBLA\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAM\u003F\u0024AAI\u003F\u0024AAN\u003F\u0024AAI\u003F\u0024AAP\u003F\u0024AAC\u003F\u0024AAI\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 7:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BK\u0040GHKNHHGC\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAD\u003F\u0024AAi\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAz\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      case 8:
        sMethodName = \u003CModule\u003E.SysAllocString((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1O\u0040JFINDOBB\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAM\u003F\u0024AAD\u003F\u0024AAC\u003F\u0024AA\u003F\u0024AA\u0040);
        break;
      default:
        \u003CModule\u003E.MessageBoxA((HWND__*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BC\u0040CMPEBGKF\u0040Wrong\u003F5bPlaneIndex\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BA\u0040MGHAKKOI\u0040WritePowerPlane\u003F\u0024AA\u0040, 0U);
        return false;
    }
    tagVARIANT tagVariant1;
    \u003CModule\u003E.VariantInit(&tagVariant1);
    tagVARIANT tagVariant2;
    \u003CModule\u003E.VariantInit(&tagVariant2);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ref tagVariant1 = (short) 3;
    if (bPlaneIndex == (byte) 1)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &tagVariant1 + 8) = bState == (byte) 0 ? 0 : 7;
    }
    else
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &tagVariant1 + 8) = bState == (byte) 0 ? 0 : 1;
    }
    *(int*) ((IntPtr) obj0 + 8) = \u003CModule\u003E.WMI\u002EWMIMethodExecSet(obj0, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1CE\u0040OPAGCONO\u0040\u003F\u0024AAP\u003F\u0024AAo\u003F\u0024AAw\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAP\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1GI\u0040OFMCJHFO\u0040\u003F\u0024AAP\u003F\u0024AAo\u003F\u0024AAw\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAP\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u0040, sMethodName, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040POAHONEM\u0040\u003F\u0024AAu\u003F\u0024AAS\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040IMJCDLFP\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040, &tagVariant1, &tagVariant2);
    \u003CModule\u003E.SysFreeString(sMethodName);
    return *(int*) ((IntPtr) obj0 + 8) >= 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool WMI\u002EReadSBThrottle([In] WMI* obj0, uint* puLevel)
  {
    tagVARIANT tagVariant;
    \u003CModule\u003E.VariantInit(&tagVariant);
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int num = \u003CModule\u003E.WMI\u002EWMIMethodExecGet(obj0, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1GA\u0040PAGHLOKH\u0040\u003F\u0024AAS\u003F\u0024AAB\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAh\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAl\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u003F\u0024AAA\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAI\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1CA\u0040IIKAHFCP\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAS\u003F\u0024AAB\u003F\u0024AAT\u003F\u0024AAh\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAl\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040POAHONEM\u0040\u003F\u0024AAu\u003F\u0024AAS\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040, &tagVariant);
    *(int*) ((IntPtr) obj0 + 8) = num;
    if (num < 0)
      return false;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *puLevel = (uint) ^(int&) ((IntPtr) &tagVariant + 8);
    \u003CModule\u003E.VariantClear(&tagVariant);
    return true;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool WMI\u002EWriteSBThrolle([In] WMI* obj0, uint uLevel)
  {
    tagVARIANT tagVariant1;
    \u003CModule\u003E.VariantInit(&tagVariant1);
    tagVARIANT tagVariant2;
    \u003CModule\u003E.VariantInit(&tagVariant2);
    *(int*) ((IntPtr) obj0 + 8) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &tagVariant1 + 8) = (int) uLevel;
    int num = \u003CModule\u003E.WMI\u002EWMIMethodExecSet(obj0, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BM\u0040NCGMAKNI\u0040\u003F\u0024AAS\u003F\u0024AAB\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAh\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAl\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1GA\u0040PAGHLOKH\u0040\u003F\u0024AAS\u003F\u0024AAB\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAh\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAl\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u003F\u0024AAA\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAI\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1CA\u0040OEHDABOM\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAS\u003F\u0024AAB\u003F\u0024AAT\u003F\u0024AAh\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAl\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040POAHONEM\u0040\u003F\u0024AAu\u003F\u0024AAS\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040IMJCDLFP\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040, &tagVariant1, &tagVariant2);
    *(int*) ((IntPtr) obj0 + 8) = num;
    if (num < 0)
      return false;
    \u003CModule\u003E.VariantClear(&tagVariant1);
    return true;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool WMI\u002EReadC4OnC3([In] WMI* obj0, int* pbEnabled)
  {
    tagVARIANT tagVariant;
    \u003CModule\u003E.VariantInit(&tagVariant);
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int num = \u003CModule\u003E.WMI\u002EWMIMethodExecGet(obj0, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1FO\u0040EBCPLCKH\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u003F\u0024AAA\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAI\u003F\u0024AA\u003F2\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BE\u0040MHIFCKKG\u0040\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAC\u003F\u0024AA4\u003F\u0024AAO\u003F\u0024AAn\u003F\u0024AAC\u003F\u0024AA3\u003F\u0024AA\u003F\u0024AA\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040EGOOFIGB\u0040\u003F\u0024AAu\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAn\u003F\u0024AA\u003F\u0024AA\u0040, &tagVariant);
    *(int*) ((IntPtr) obj0 + 8) = num;
    if (num < 0)
      return false;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *pbEnabled = ^(int&) ((IntPtr) &tagVariant + 8);
    \u003CModule\u003E.VariantClear(&tagVariant);
    return true;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool WMI\u002EWriteC4OnC3([In] WMI* obj0, [MarshalAs(UnmanagedType.U1)] bool bEnabled)
  {
    tagVARIANT tagVariant1;
    \u003CModule\u003E.VariantInit(&tagVariant1);
    tagVARIANT tagVariant2;
    \u003CModule\u003E.VariantInit(&tagVariant2);
    *(int*) ((IntPtr) obj0 + 8) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &tagVariant1 + 8) = bEnabled ? 1 : 0;
    int num = \u003CModule\u003E.WMI\u002EWMIMethodExecSet(obj0, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BK\u0040OPKHIMHC\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1FO\u0040EBCPLCKH\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u003F\u0024AAA\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAI\u003F\u0024AA\u003F2\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BE\u0040GJKOGKNK\u0040\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAC\u003F\u0024AA4\u003F\u0024AAO\u003F\u0024AAn\u003F\u0024AAC\u003F\u0024AA3\u003F\u0024AA\u003F\u0024AA\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040POAHONEM\u0040\u003F\u0024AAu\u003F\u0024AAS\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040IMJCDLFP\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040, &tagVariant1, &tagVariant2);
    *(int*) ((IntPtr) obj0 + 8) = num;
    if (num < 0)
      return false;
    \u003CModule\u003E.VariantClear(&tagVariant1);
    return true;
  }

  internal static unsafe int WMI\u002EWMICPUID(
    [In] WMI* obj0,
    tagVARIANT* FunctionNo,
    tagVARIANT* vtEDX,
    tagVARIANT* vtECX,
    tagVARIANT* vtEBX,
    tagVARIANT* vtEAX,
    tagVARIANT* vtErrorCode)
  {
    IWbemClassObject* iwbemClassObjectPtr1 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr2 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr3 = (IWbemClassObject*) 0;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int num1 = *(int*) obj0;
    int num2 = num1;
    ref \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W local1 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BK\u0040OPKHIMHC\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
    ref IWbemClassObject* local2 = ref iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemContext*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num1 + 24))((IWbemCallResult**) num2, (IWbemClassObject**) ref local1, (IWbemContext*) 0, 0, (char*) ref local2, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num3;
    if (num3 < 0)
      return num3;
    IWbemClassObject* iwbemClassObjectPtr4 = iwbemClassObjectPtr1;
    ref \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W local3 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040CDJHFKP\u0040\u003F\u0024AAI\u003F\u0024AAs\u003F\u0024AAs\u003F\u0024AAu\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAU\u003F\u0024AAI\u003F\u0024AAD\u003F\u0024AA\u003F\u0024AA\u0040;
    ref IWbemClassObject* local4 = ref iwbemClassObjectPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num4 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemClassObject**, IWbemClassObject**)>) *(int*) (*(int*) iwbemClassObjectPtr1 + 76))((IWbemClassObject**) iwbemClassObjectPtr4, (IWbemClassObject**) ref local3, 0, (char*) ref local4, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num4;
    if (num4 < 0)
      return num4;
    IWbemClassObject* iwbemClassObjectPtr5 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W local5 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BC\u0040PDFCOEDN\u0040\u003F\u0024AAu\u003F\u0024AAF\u003F\u0024AAu\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAN\u003F\u0024AAu\u003F\u0024AAm\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr1 = FunctionNo;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr5, (tagVARIANT*) ref local5, 0, (char*) tagVariantPtr1, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num5;
    if (num5 < 0)
      return num5;
    int num6 = *(int*) obj0;
    int num7 = num6;
    ref \u0024ArrayType\u0024\u0024\u0024BY0CP\u0040\u0024\u0024CB_W local6 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1FO\u0040EBCPLCKH\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u003F\u0024AAA\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAI\u003F\u0024AA\u003F2\u0040;
    ref \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W local7 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040CDJHFKP\u0040\u003F\u0024AAI\u003F\u0024AAs\u003F\u0024AAs\u003F\u0024AAu\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAU\u003F\u0024AAI\u003F\u0024AAD\u003F\u0024AA\u003F\u0024AA\u0040;
    IWbemClassObject* iwbemClassObjectPtr6 = iwbemClassObjectPtr2;
    ref IWbemClassObject* local8 = ref iwbemClassObjectPtr3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num8 = __calli((__FnPtr<int (IntPtr, char*, char*, int, IWbemContext*, IWbemClassObject*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num6 + 96))((IWbemCallResult**) num7, (IWbemClassObject**) ref local6, (IWbemClassObject*) ref local7, (IWbemContext*) 0, 0, (char*) iwbemClassObjectPtr6, (char*) ref local8, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num8;
    if (num8 < 0)
      return num8;
    IWbemClassObject* iwbemClassObjectPtr7 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local9 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_19PHBIHKOL\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAD\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr2 = vtEDX;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num9 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr7, (int*) ref local9, (tagVARIANT*) 0, (int) tagVariantPtr2, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num9;
    if (num9 < 0)
      return num9;
    IWbemClassObject* iwbemClassObjectPtr8 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local10 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_19OKBNEKFD\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr3 = vtECX;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num10 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr8, (int*) ref local10, (tagVARIANT*) 0, (int) tagVariantPtr3, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num10;
    if (num10 < 0)
      return num10;
    IWbemClassObject* iwbemClassObjectPtr9 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local11 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_19CBEBJJPG\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAB\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr4 = vtEBX;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num11 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr9, (int*) ref local11, (tagVARIANT*) 0, (int) tagVariantPtr4, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num11;
    if (num11 < 0)
      return num11;
    IWbemClassObject* iwbemClassObjectPtr10 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local12 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_19KHNFOLFI\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAA\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr5 = vtEAX;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num12 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr10, (int*) ref local12, (tagVARIANT*) 0, (int) tagVariantPtr5, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num12;
    if (num12 < 0)
      return num12;
    IWbemClassObject* iwbemClassObjectPtr11 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W local13 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040IMJCDLFP\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr6 = vtErrorCode;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num13 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr11, (int*) ref local13, (tagVARIANT*) 0, (int) tagVariantPtr6, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num13;
    if (num13 < 0)
      return num13;
    IWbemClassObject* iwbemClassObjectPtr12 = iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num14 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr12 + 8))((IntPtr) iwbemClassObjectPtr12);
    IWbemClassObject* iwbemClassObjectPtr13 = iwbemClassObjectPtr3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num15 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr13 + 8))((IntPtr) iwbemClassObjectPtr13);
    IWbemClassObject* iwbemClassObjectPtr14 = iwbemClassObjectPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num16 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr14 + 8))((IntPtr) iwbemClassObjectPtr14);
    return *(int*) ((IntPtr) obj0 + 8);
  }

  internal static unsafe int WMI\u002EWMIReadMSR(
    [In] WMI* obj0,
    tagVARIANT* vtECX,
    tagVARIANT* vtEAX,
    tagVARIANT* vtEDX,
    tagVARIANT* vtErrorCode)
  {
    IWbemClassObject* iwbemClassObjectPtr1 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr2 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr3 = (IWbemClassObject*) 0;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int num1 = *(int*) obj0;
    int num2 = num1;
    ref \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W local1 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BK\u0040OPKHIMHC\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
    ref IWbemClassObject* local2 = ref iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemContext*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num1 + 24))((IWbemCallResult**) num2, (IWbemClassObject**) ref local1, (IWbemContext*) 0, 0, (char*) ref local2, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num3;
    if (num3 < 0)
      return num3;
    IWbemClassObject* iwbemClassObjectPtr4 = iwbemClassObjectPtr1;
    ref \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W local3 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040GGLOFGMI\u0040\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAd\u003F\u0024AAM\u003F\u0024AAS\u003F\u0024AAR\u003F\u0024AA\u003F\u0024AA\u0040;
    ref IWbemClassObject* local4 = ref iwbemClassObjectPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num4 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemClassObject**, IWbemClassObject**)>) *(int*) (*(int*) iwbemClassObjectPtr1 + 76))((IWbemClassObject**) iwbemClassObjectPtr4, (IWbemClassObject**) ref local3, 0, (char*) ref local4, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num4;
    if (num4 < 0)
      return num4;
    IWbemClassObject* iwbemClassObjectPtr5 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local5 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_19OKBNEKFD\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr1 = vtECX;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr5, (tagVARIANT*) ref local5, 0, (char*) tagVariantPtr1, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num5;
    if (num5 < 0)
      return num5;
    int num6 = *(int*) obj0;
    int num7 = num6;
    ref \u0024ArrayType\u0024\u0024\u0024BY0CP\u0040\u0024\u0024CB_W local6 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1FO\u0040EBCPLCKH\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u003F\u0024AAA\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAI\u003F\u0024AA\u003F2\u0040;
    ref \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W local7 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040GGLOFGMI\u0040\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAd\u003F\u0024AAM\u003F\u0024AAS\u003F\u0024AAR\u003F\u0024AA\u003F\u0024AA\u0040;
    IWbemClassObject* iwbemClassObjectPtr6 = iwbemClassObjectPtr2;
    ref IWbemClassObject* local8 = ref iwbemClassObjectPtr3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num8 = __calli((__FnPtr<int (IntPtr, char*, char*, int, IWbemContext*, IWbemClassObject*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num6 + 96))((IWbemCallResult**) num7, (IWbemClassObject**) ref local6, (IWbemClassObject*) ref local7, (IWbemContext*) 0, 0, (char*) iwbemClassObjectPtr6, (char*) ref local8, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num8;
    if (num8 < 0)
      return num8;
    IWbemClassObject* iwbemClassObjectPtr7 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local9 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_19KHNFOLFI\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAA\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr2 = vtEAX;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num9 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr7, (int*) ref local9, (tagVARIANT*) 0, (int) tagVariantPtr2, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num9;
    if (num9 < 0)
      return num9;
    IWbemClassObject* iwbemClassObjectPtr8 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local10 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_19PHBIHKOL\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAD\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr3 = vtEDX;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num10 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr8, (int*) ref local10, (tagVARIANT*) 0, (int) tagVariantPtr3, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num10;
    if (num10 < 0)
      return num10;
    IWbemClassObject* iwbemClassObjectPtr9 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W local11 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040IMJCDLFP\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr4 = vtErrorCode;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num11 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr9, (int*) ref local11, (tagVARIANT*) 0, (int) tagVariantPtr4, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num11;
    if (num11 < 0)
      return num11;
    IWbemClassObject* iwbemClassObjectPtr10 = iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num12 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr10 + 8))((IntPtr) iwbemClassObjectPtr10);
    IWbemClassObject* iwbemClassObjectPtr11 = iwbemClassObjectPtr3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num13 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr11 + 8))((IntPtr) iwbemClassObjectPtr11);
    IWbemClassObject* iwbemClassObjectPtr12 = iwbemClassObjectPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num14 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr12 + 8))((IntPtr) iwbemClassObjectPtr12);
    return *(int*) ((IntPtr) obj0 + 8);
  }

  internal static unsafe int WMI\u002EWMIWriteMSR(
    [In] WMI* obj0,
    tagVARIANT* vtInECX,
    tagVARIANT* vtInEAX,
    tagVARIANT* vtInEDX,
    tagVARIANT* vtOutEAX,
    tagVARIANT* vtOutEDX,
    tagVARIANT* vtErrorCode)
  {
    IWbemClassObject* iwbemClassObjectPtr1 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr2 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr3 = (IWbemClassObject*) 0;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int num1 = *(int*) obj0;
    int num2 = num1;
    ref \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W local1 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BK\u0040OPKHIMHC\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
    ref IWbemClassObject* local2 = ref iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemContext*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num1 + 24))((IWbemCallResult**) num2, (IWbemClassObject**) ref local1, (IWbemContext*) 0, 0, (char*) ref local2, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num3;
    if (num3 < 0)
      return num3;
    IWbemClassObject* iwbemClassObjectPtr4 = iwbemClassObjectPtr1;
    ref \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W local3 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BC\u0040NOKNOPEO\u0040\u003F\u0024AAW\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAM\u003F\u0024AAS\u003F\u0024AAR\u003F\u0024AA\u003F\u0024AA\u0040;
    ref IWbemClassObject* local4 = ref iwbemClassObjectPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num4 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemClassObject**, IWbemClassObject**)>) *(int*) (*(int*) iwbemClassObjectPtr1 + 76))((IWbemClassObject**) iwbemClassObjectPtr4, (IWbemClassObject**) ref local3, 0, (char*) ref local4, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num4;
    if (num4 < 0)
      return num4;
    IWbemClassObject* iwbemClassObjectPtr5 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local5 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_19OKBNEKFD\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr1 = vtInECX;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr5, (tagVARIANT*) ref local5, 0, (char*) tagVariantPtr1, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num5;
    if (num5 < 0)
      return num5;
    IWbemClassObject* iwbemClassObjectPtr6 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local6 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_19KHNFOLFI\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAA\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr2 = vtInEAX;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num6 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr6, (tagVARIANT*) ref local6, 0, (char*) tagVariantPtr2, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num6;
    if (num6 < 0)
      return num6;
    IWbemClassObject* iwbemClassObjectPtr7 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local7 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_19PHBIHKOL\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAD\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr3 = vtInEDX;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num7 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr7, (tagVARIANT*) ref local7, 0, (char*) tagVariantPtr3, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num7;
    if (num7 < 0)
      return num7;
    int num8 = *(int*) obj0;
    int num9 = num8;
    ref \u0024ArrayType\u0024\u0024\u0024BY0CP\u0040\u0024\u0024CB_W local8 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1FO\u0040EBCPLCKH\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u003F\u0024AAA\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAI\u003F\u0024AA\u003F2\u0040;
    ref \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W local9 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BC\u0040NOKNOPEO\u0040\u003F\u0024AAW\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAM\u003F\u0024AAS\u003F\u0024AAR\u003F\u0024AA\u003F\u0024AA\u0040;
    IWbemClassObject* iwbemClassObjectPtr8 = iwbemClassObjectPtr2;
    ref IWbemClassObject* local10 = ref iwbemClassObjectPtr3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num10 = __calli((__FnPtr<int (IntPtr, char*, char*, int, IWbemContext*, IWbemClassObject*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num8 + 96))((IWbemCallResult**) num9, (IWbemClassObject**) ref local8, (IWbemClassObject*) ref local9, (IWbemContext*) 0, 0, (char*) iwbemClassObjectPtr8, (char*) ref local10, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num10;
    if (num10 < 0)
      return num10;
    IWbemClassObject* iwbemClassObjectPtr9 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W local11 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040EJNNHIKJ\u0040\u003F\u0024AAu\u003F\u0024AAO\u003F\u0024AAu\u003F\u0024AAt\u003F\u0024AAE\u003F\u0024AAA\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr4 = vtOutEAX;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num11 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr9, (int*) ref local11, (tagVARIANT*) 0, (int) tagVariantPtr4, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num11;
    if (num11 < 0)
      return num11;
    IWbemClassObject* iwbemClassObjectPtr10 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W local12 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040BJBAOJBK\u0040\u003F\u0024AAu\u003F\u0024AAO\u003F\u0024AAu\u003F\u0024AAt\u003F\u0024AAE\u003F\u0024AAD\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr5 = vtOutEDX;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num12 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr10, (int*) ref local12, (tagVARIANT*) 0, (int) tagVariantPtr5, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num12;
    if (num12 < 0)
      return num12;
    IWbemClassObject* iwbemClassObjectPtr11 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W local13 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040IMJCDLFP\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr6 = vtErrorCode;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num13 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr11, (int*) ref local13, (tagVARIANT*) 0, (int) tagVariantPtr6, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num13;
    if (num13 < 0)
      return num13;
    IWbemClassObject* iwbemClassObjectPtr12 = iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num14 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr12 + 8))((IntPtr) iwbemClassObjectPtr12);
    IWbemClassObject* iwbemClassObjectPtr13 = iwbemClassObjectPtr3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num15 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr13 + 8))((IntPtr) iwbemClassObjectPtr13);
    IWbemClassObject* iwbemClassObjectPtr14 = iwbemClassObjectPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num16 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr14 + 8))((IntPtr) iwbemClassObjectPtr14);
    return *(int*) ((IntPtr) obj0 + 8);
  }

  internal static unsafe int WMI\u002EWMIReadPCI(
    [In] WMI* obj0,
    tagVARIANT* vtBusNp,
    tagVARIANT* vtDeviceNo,
    tagVARIANT* vtFuncitnNo,
    tagVARIANT* vtRegisterNo,
    tagVARIANT* vtFlag,
    tagVARIANT* vtPCIRead,
    tagVARIANT* vtErrorCode)
  {
    IWbemClassObject* iwbemClassObjectPtr1 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr2 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr3 = (IWbemClassObject*) 0;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int num1 = *(int*) obj0;
    int num2 = num1;
    ref \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W local1 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BK\u0040OPKHIMHC\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
    ref IWbemClassObject* local2 = ref iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemContext*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num1 + 24))((IWbemCallResult**) num2, (IWbemClassObject**) ref local1, (IWbemContext*) 0, 0, (char*) ref local2, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num3;
    if (num3 < 0)
      return num3;
    IWbemClassObject* iwbemClassObjectPtr4 = iwbemClassObjectPtr1;
    ref \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W local3 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040BAMKFGLF\u0040\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAd\u003F\u0024AAP\u003F\u0024AAC\u003F\u0024AAI\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
    ref IWbemClassObject* local4 = ref iwbemClassObjectPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num4 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemClassObject**, IWbemClassObject**)>) *(int*) (*(int*) iwbemClassObjectPtr1 + 76))((IWbemClassObject**) iwbemClassObjectPtr4, (IWbemClassObject**) ref local3, 0, (char*) ref local4, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num4;
    if (num4 < 0)
    {
      \u003CModule\u003E.MessageBoxA((HWND__*) 0, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040HHAGDHNI\u0040GetMethod\u003F\u0024CI\u003F\u0024CJ\u003F5failed\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0L\u0040CFHFONAE\u0040WMIReadPCI\u003F\u0024AA\u0040, 0U);
      return *(int*) ((IntPtr) obj0 + 8);
    }
    IWbemClassObject* iwbemClassObjectPtr5 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local5 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_19EFMIIPMF\u0040\u003F\u0024AAu\u003F\u0024AAB\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr1 = vtBusNp;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr5, (tagVARIANT*) ref local5, 0, (char*) tagVariantPtr1, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num5;
    if (num5 < 0)
      return num5;
    IWbemClassObject* iwbemClassObjectPtr6 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W local6 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040OIPEINNN\u0040\u003F\u0024AAu\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr2 = vtDeviceNo;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num6 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr6, (tagVARIANT*) ref local6, 0, (char*) tagVariantPtr2, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num6;
    if (num6 < 0)
      return num6;
    IWbemClassObject* iwbemClassObjectPtr7 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W local7 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BE\u0040PHLIKCD\u0040\u003F\u0024AAu\u003F\u0024AAF\u003F\u0024AAu\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr3 = vtFuncitnNo;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num7 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr7, (tagVARIANT*) ref local7, 0, (char*) tagVariantPtr3, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num7;
    if (num7 < 0)
      return num7;
    IWbemClassObject* iwbemClassObjectPtr8 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W local8 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BE\u0040DGAANMEA\u0040\u003F\u0024AAu\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr4 = vtRegisterNo;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num8 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr8, (tagVARIANT*) ref local8, 0, (char*) tagVariantPtr4, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num8;
    if (num8 < 0)
      return num8;
    IWbemClassObject* iwbemClassObjectPtr9 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W local9 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1M\u0040EJHKBOCC\u0040\u003F\u0024AAu\u003F\u0024AAF\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr5 = vtFlag;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num9 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr9, (tagVARIANT*) ref local9, 0, (char*) tagVariantPtr5, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num9;
    if (num9 < 0)
      return num9;
    int num10 = *(int*) obj0;
    int num11 = num10;
    ref \u0024ArrayType\u0024\u0024\u0024BY0CP\u0040\u0024\u0024CB_W local10 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1FO\u0040EBCPLCKH\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u003F\u0024AAA\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAI\u003F\u0024AA\u003F2\u0040;
    ref \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W local11 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040BAMKFGLF\u0040\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAd\u003F\u0024AAP\u003F\u0024AAC\u003F\u0024AAI\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
    IWbemClassObject* iwbemClassObjectPtr10 = iwbemClassObjectPtr2;
    ref IWbemClassObject* local12 = ref iwbemClassObjectPtr3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num12 = __calli((__FnPtr<int (IntPtr, char*, char*, int, IWbemContext*, IWbemClassObject*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num10 + 96))((IWbemCallResult**) num11, (IWbemClassObject**) ref local10, (IWbemClassObject*) ref local11, (IWbemContext*) 0, 0, (char*) iwbemClassObjectPtr10, (char*) ref local12, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num12;
    if (num12 < 0)
      return num12;
    IntPtr num13 = (IntPtr) obj0 + 8;
    IWbemClassObject* iwbemClassObjectPtr11 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W local13 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BC\u0040LPDLBGDD\u0040\u003F\u0024AAu\u003F\u0024AAP\u003F\u0024AAC\u003F\u0024AAI\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAd\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr6 = vtPCIRead;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num14 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr11, (int*) ref local13, (tagVARIANT*) 0, (int) tagVariantPtr6, (char*) 0, IntPtr.Zero);
    *(int*) num13 = num14;
    IWbemClassObject* iwbemClassObjectPtr12 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W local14 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040IMJCDLFP\u0040\u003F\u0024AAu\u003F\u0024AAE\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr7 = vtErrorCode;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num15 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr12, (int*) ref local14, (tagVARIANT*) 0, (int) tagVariantPtr7, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num15;
    if (num15 < 0)
      return num15;
    IWbemClassObject* iwbemClassObjectPtr13 = iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num16 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr13 + 8))((IntPtr) iwbemClassObjectPtr13);
    IWbemClassObject* iwbemClassObjectPtr14 = iwbemClassObjectPtr3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num17 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr14 + 8))((IntPtr) iwbemClassObjectPtr14);
    IWbemClassObject* iwbemClassObjectPtr15 = iwbemClassObjectPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num18 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr15 + 8))((IntPtr) iwbemClassObjectPtr15);
    return *(int*) ((IntPtr) obj0 + 8);
  }

  internal static unsafe int WMI\u002EWMIWritePCI(
    [In] WMI* obj0,
    tagVARIANT* vtInBuffer,
    tagVARIANT* vtBus,
    tagVARIANT* vtDevice,
    tagVARIANT* vtFunction,
    tagVARIANT* vtRegister,
    tagVARIANT* vtFlag,
    tagVARIANT* vtReturn)
  {
    IWbemClassObject* iwbemClassObjectPtr1 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr2 = (IWbemClassObject*) 0;
    IWbemClassObject* iwbemClassObjectPtr3 = (IWbemClassObject*) 0;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int num1 = *(int*) obj0;
    int num2 = num1;
    ref \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W local1 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BK\u0040OPKHIMHC\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
    ref IWbemClassObject* local2 = ref iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemContext*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num1 + 24))((IWbemCallResult**) num2, (IWbemClassObject**) ref local1, (IWbemContext*) 0, 0, (char*) ref local2, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num3;
    if (num3 < 0)
      return num3;
    IWbemClassObject* iwbemClassObjectPtr4 = iwbemClassObjectPtr1;
    ref \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W local3 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BI\u0040EMBFJMMM\u0040\u003F\u0024AAW\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAP\u003F\u0024AAC\u003F\u0024AAI\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
    ref IWbemClassObject* local4 = ref iwbemClassObjectPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num4 = __calli((__FnPtr<int (IntPtr, char*, int, IWbemClassObject**, IWbemClassObject**)>) *(int*) (*(int*) iwbemClassObjectPtr1 + 76))((IWbemClassObject**) iwbemClassObjectPtr4, (IWbemClassObject**) ref local3, 0, (char*) ref local4, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num4;
    if (num4 < 0)
      return num4;
    IWbemClassObject* iwbemClassObjectPtr5 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local5 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_19EFMIIPMF\u0040\u003F\u0024AAu\u003F\u0024AAB\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr1 = vtBus;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr5, (tagVARIANT*) ref local5, 0, (char*) tagVariantPtr1, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num5;
    if (num5 < 0)
      return num5;
    IWbemClassObject* iwbemClassObjectPtr6 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W local6 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040OIPEINNN\u0040\u003F\u0024AAu\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr2 = vtDevice;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num6 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr6, (tagVARIANT*) ref local6, 0, (char*) tagVariantPtr2, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num6;
    if (num6 < 0)
      return num6;
    IWbemClassObject* iwbemClassObjectPtr7 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W local7 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BE\u0040PHLIKCD\u0040\u003F\u0024AAu\u003F\u0024AAF\u003F\u0024AAu\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr3 = vtFunction;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num7 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr7, (tagVARIANT*) ref local7, 0, (char*) tagVariantPtr3, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num7;
    if (num7 < 0)
      return num7;
    IWbemClassObject* iwbemClassObjectPtr8 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W local8 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BE\u0040DGAANMEA\u0040\u003F\u0024AAu\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr4 = vtRegister;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num8 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr8, (tagVARIANT*) ref local8, 0, (char*) tagVariantPtr4, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num8;
    if (num8 < 0)
      return num8;
    IWbemClassObject* iwbemClassObjectPtr9 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W local9 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1M\u0040EJHKBOCC\u0040\u003F\u0024AAu\u003F\u0024AAF\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr5 = vtFlag;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num9 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr9, (tagVARIANT*) ref local9, 0, (char*) tagVariantPtr5, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num9;
    if (num9 < 0)
      return num9;
    IWbemClassObject* iwbemClassObjectPtr10 = iwbemClassObjectPtr2;
    ref \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W local10 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040PJDHDEOI\u0040\u003F\u0024AAu\u003F\u0024AAB\u003F\u0024AAu\u003F\u0024AAf\u003F\u0024AAf\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr6 = vtInBuffer;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num10 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int)>) *(int*) (*(int*) iwbemClassObjectPtr2 + 20))((int) iwbemClassObjectPtr10, (tagVARIANT*) ref local10, 0, (char*) tagVariantPtr6, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num10;
    if (num10 < 0)
      return num10;
    int num11 = *(int*) obj0;
    int num12 = num11;
    ref \u0024ArrayType\u0024\u0024\u0024BY0CP\u0040\u0024\u0024CB_W local11 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1FO\u0040EBCPLCKH\u0040\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAH\u003F\u0024AAw\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA\u003F4\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024DN\u003F\u0024AA\u003F\u0024CC\u003F\u0024AAA\u003F\u0024AAC\u003F\u0024AAP\u003F\u0024AAI\u003F\u0024AA\u003F2\u0040;
    ref \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W local12 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BI\u0040EMBFJMMM\u0040\u003F\u0024AAW\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAP\u003F\u0024AAC\u003F\u0024AAI\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
    IWbemClassObject* iwbemClassObjectPtr11 = iwbemClassObjectPtr2;
    ref IWbemClassObject* local13 = ref iwbemClassObjectPtr3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num13 = __calli((__FnPtr<int (IntPtr, char*, char*, int, IWbemContext*, IWbemClassObject*, IWbemClassObject**, IWbemCallResult**)>) *(int*) (*(int*) num11 + 96))((IWbemCallResult**) num12, (IWbemClassObject**) ref local11, (IWbemClassObject*) ref local12, (IWbemContext*) 0, 0, (char*) iwbemClassObjectPtr11, (char*) ref local13, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num13;
    if (num13 < 0)
      return num13;
    IWbemClassObject* iwbemClassObjectPtr12 = iwbemClassObjectPtr3;
    ref \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W local14 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1BA\u0040EGOOFIGB\u0040\u003F\u0024AAu\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAn\u003F\u0024AA\u003F\u0024AA\u0040;
    tagVARIANT* tagVariantPtr7 = vtReturn;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num14 = __calli((__FnPtr<int (IntPtr, char*, int, tagVARIANT*, int*, int*)>) *(int*) (*(int*) iwbemClassObjectPtr3 + 16))((int*) iwbemClassObjectPtr12, (int*) ref local14, (tagVARIANT*) 0, (int) tagVariantPtr7, (char*) 0, IntPtr.Zero);
    *(int*) ((IntPtr) obj0 + 8) = num14;
    if (num14 < 0)
      return num14;
    IWbemClassObject* iwbemClassObjectPtr13 = iwbemClassObjectPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num15 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr13 + 8))((IntPtr) iwbemClassObjectPtr13);
    IWbemClassObject* iwbemClassObjectPtr14 = iwbemClassObjectPtr3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num16 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr14 + 8))((IntPtr) iwbemClassObjectPtr14);
    IWbemClassObject* iwbemClassObjectPtr15 = iwbemClassObjectPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num17 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iwbemClassObjectPtr15 + 8))((IntPtr) iwbemClassObjectPtr15);
    return *(int*) ((IntPtr) obj0 + 8);
  }

  internal static unsafe int WMI\u002EWMIGEventRegister([In] WMI* obj0)
  {
    IUnsecuredApartment* iunsecuredApartmentPtr1 = (IUnsecuredApartment*) 0;
    IUnknown* iunknownPtr1 = (IUnknown*) 0;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int instance = \u003CModule\u003E.CoCreateInstance(&\u003CModule\u003E.CLSID_UnsecuredApartment, (IUnknown*) 0, 4U, &\u003CModule\u003E.IID_IUnsecuredApartment, (void**) &iunsecuredApartmentPtr1);
    *(int*) ((IntPtr) obj0 + 8) = instance;
    if (instance < 0)
      return instance;
    GSink* gsinkPtr1 = (GSink*) \u003CModule\u003E.@new(12U);
    GSink* gsinkPtr2;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) gsinkPtr1 != IntPtr.Zero)
      {
        *(int*) gsinkPtr1 = (int) &\u003CModule\u003E.\u003F\u003F_7GSink\u0040\u00406B\u0040;
        *(int*) ((IntPtr) gsinkPtr1 + 4) = 0;
        gsinkPtr2 = gsinkPtr1;
      }
      else
        gsinkPtr2 = (GSink*) 0;
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) gsinkPtr1);
    }
    GSink* gsinkPtr3 = gsinkPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num1 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) gsinkPtr3 + 4))((IntPtr) gsinkPtr3);
    IUnsecuredApartment* iunsecuredApartmentPtr2 = iunsecuredApartmentPtr1;
    GSink* gsinkPtr4 = gsinkPtr2;
    ref IUnknown* local1 = ref iunknownPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num2 = __calli((__FnPtr<int (IntPtr, IUnknown*, IUnknown**)>) *(int*) (*(int*) iunsecuredApartmentPtr1 + 12))((IUnknown**) iunsecuredApartmentPtr2, (IUnknown*) gsinkPtr4, (IntPtr) ref local1);
    *(int*) ((IntPtr) obj0 + 8) = num2;
    if (num2 < 0)
      return num2;
    WMI* wmiPtr1 = (WMI*) ((IntPtr) obj0 + 16);
    *(int*) wmiPtr1 = 0;
    IUnknown* iunknownPtr2 = iunknownPtr1;
    ref _GUID local2 = ref \u003CModule\u003E.IID_IWbemObjectSink;
    WMI* wmiPtr2 = wmiPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr, _GUID*, void**)>) *(int*) *(int*) iunknownPtr1)((void**) iunknownPtr2, (_GUID*) ref local2, (IntPtr) wmiPtr2);
    *(int*) ((IntPtr) obj0 + 8) = num3;
    if (num3 < 0)
      return num3;
    int num4 = *(int*) obj0;
    int num5 = num4;
    ref \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W local3 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_17NDCOOGJO\u0040\u003F\u0024AAW\u003F\u0024AAQ\u003F\u0024AAL\u003F\u0024AA\u003F\u0024AA\u0040;
    ref \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CB_W local4 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1DG\u0040NEJGOBAI\u0040\u003F\u0024AAS\u003F\u0024AAE\u003F\u0024AAL\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAT\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F5\u003F\u0024AAF\u003F\u0024AAR\u003F\u0024AAO\u003F\u0024AAM\u003F\u0024AA\u003F5\u003F\u0024AAG\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAE\u003F\u0024AAv\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AA\u003F\u0024AA\u0040;
    int num6 = *(int*) wmiPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num7 = __calli((__FnPtr<int (IntPtr, char*, char*, int, IWbemContext*, IWbemObjectSink*)>) *(int*) (*(int*) num4 + 92))((IWbemObjectSink*) num5, (IWbemContext*) ref local3, (int) ref local4, (char*) 128, (char*) 0, (IntPtr) num6);
    *(int*) ((IntPtr) obj0 + 8) = num7;
    if (num7 < 0)
      return num7;
    IUnsecuredApartment* iunsecuredApartmentPtr3 = iunsecuredApartmentPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num8 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iunsecuredApartmentPtr3 + 8))((IntPtr) iunsecuredApartmentPtr3);
    IUnknown* iunknownPtr3 = iunknownPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num9 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iunknownPtr3 + 8))((IntPtr) iunknownPtr3);
    GSink* gsinkPtr5 = gsinkPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num10 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) gsinkPtr5 + 8))((IntPtr) gsinkPtr5);
    return *(int*) ((IntPtr) obj0 + 8);
  }

  internal static unsafe int WMI\u002EWMIVGAEventRegister([In] WMI* obj0)
  {
    IUnsecuredApartment* iunsecuredApartmentPtr1 = (IUnsecuredApartment*) 0;
    IUnknown* iunknownPtr1 = (IUnknown*) 0;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    int instance = \u003CModule\u003E.CoCreateInstance(&\u003CModule\u003E.CLSID_UnsecuredApartment, (IUnknown*) 0, 4U, &\u003CModule\u003E.IID_IUnsecuredApartment, (void**) &iunsecuredApartmentPtr1);
    *(int*) ((IntPtr) obj0 + 8) = instance;
    if (instance < 0)
      return instance;
    VGASink* vgaSinkPtr1 = (VGASink*) \u003CModule\u003E.@new(12U);
    VGASink* vgaSinkPtr2;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) vgaSinkPtr1 != IntPtr.Zero)
      {
        *(int*) vgaSinkPtr1 = (int) &\u003CModule\u003E.\u003F\u003F_7VGASink\u0040\u00406B\u0040;
        *(int*) ((IntPtr) vgaSinkPtr1 + 4) = 0;
        vgaSinkPtr2 = vgaSinkPtr1;
      }
      else
        vgaSinkPtr2 = (VGASink*) 0;
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) vgaSinkPtr1);
    }
    VGASink* vgaSinkPtr3 = vgaSinkPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num1 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) vgaSinkPtr3 + 4))((IntPtr) vgaSinkPtr3);
    IUnsecuredApartment* iunsecuredApartmentPtr2 = iunsecuredApartmentPtr1;
    VGASink* vgaSinkPtr4 = vgaSinkPtr2;
    ref IUnknown* local1 = ref iunknownPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num2 = __calli((__FnPtr<int (IntPtr, IUnknown*, IUnknown**)>) *(int*) (*(int*) iunsecuredApartmentPtr1 + 12))((IUnknown**) iunsecuredApartmentPtr2, (IUnknown*) vgaSinkPtr4, (IntPtr) ref local1);
    *(int*) ((IntPtr) obj0 + 8) = num2;
    if (num2 < 0)
      return num2;
    WMI* wmiPtr1 = (WMI*) ((IntPtr) obj0 + 20);
    *(int*) wmiPtr1 = 0;
    IUnknown* iunknownPtr2 = iunknownPtr1;
    ref _GUID local2 = ref \u003CModule\u003E.IID_IWbemObjectSink;
    WMI* wmiPtr2 = wmiPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr, _GUID*, void**)>) *(int*) *(int*) iunknownPtr1)((void**) iunknownPtr2, (_GUID*) ref local2, (IntPtr) wmiPtr2);
    *(int*) ((IntPtr) obj0 + 8) = num3;
    if (num3 < 0)
      return num3;
    int num4 = *(int*) obj0;
    int num5 = num4;
    ref \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W local3 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_17NDCOOGJO\u0040\u003F\u0024AAW\u003F\u0024AAQ\u003F\u0024AAL\u003F\u0024AA\u003F\u0024AA\u0040;
    ref \u0024ArrayType\u0024\u0024\u0024BY0CG\u0040\u0024\u0024CB_W local4 = ref \u003CModule\u003E.\u003F\u003F_C\u0040_1EM\u0040DCBPCLIG\u0040\u003F\u0024AAS\u003F\u0024AAE\u003F\u0024AAL\u003F\u0024AAE\u003F\u0024AAC\u003F\u0024AAT\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F5\u003F\u0024AAF\u003F\u0024AAR\u003F\u0024AAO\u003F\u0024AAM\u003F\u0024AA\u003F5\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA_\u003F\u0024AAP\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AA_\u0040;
    int num6 = *(int*) wmiPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num7 = __calli((__FnPtr<int (IntPtr, char*, char*, int, IWbemContext*, IWbemObjectSink*)>) *(int*) (*(int*) num4 + 92))((IWbemObjectSink*) num5, (IWbemContext*) ref local3, (int) ref local4, (char*) 128, (char*) 0, (IntPtr) num6);
    *(int*) ((IntPtr) obj0 + 8) = num7;
    if (num7 < 0)
      return num7;
    IUnsecuredApartment* iunsecuredApartmentPtr3 = iunsecuredApartmentPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num8 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iunsecuredApartmentPtr3 + 8))((IntPtr) iunsecuredApartmentPtr3);
    IUnknown* iunknownPtr3 = iunknownPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num9 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iunknownPtr3 + 8))((IntPtr) iunknownPtr3);
    VGASink* vgaSinkPtr5 = vgaSinkPtr2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num10 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) vgaSinkPtr5 + 8))((IntPtr) vgaSinkPtr5);
    return *(int*) ((IntPtr) obj0 + 8);
  }

  internal static unsafe sbyte* strstr(sbyte* _Str, sbyte* _SubStr) => \u003CModule\u003E.strstr(_Str, _SubStr);

  internal static unsafe int _tcsicmp(sbyte* _String1, sbyte* _String2) => \u003CModule\u003E._mbsicmp((byte*) _String1, (byte*) _String2);

  internal static unsafe int main(int argc, sbyte** argv)
  {
    // ISSUE: cpblk instruction
    __memcpy(ref \u003CModule\u003E.gc_szServiceName, ref \u003CModule\u003E.\u003F\u003F_C\u0040_0BA\u0040EFBKLIMN\u0040MobilityService\u003F\u0024AA\u0040, 16);
    \u003CModule\u003E.gh_SCMAsExe = \u003CModule\u003E.OpenSCManagerA((sbyte*) 0, (sbyte*) 0, 983103U);
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD;
    if (\u003CModule\u003E._mbsicmp((byte*) *(int*) ((IntPtr) argv + 4), (byte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02IEBECDLA\u0040\u003F9i\u003F\u0024AA\u0040) == 0)
    {
      \u003CModule\u003E.gb_Result = false;
      if ((IntPtr) \u003CModule\u003E.gh_SCMAsExe != IntPtr.Zero)
      {
        SC_HANDLE__* scHandlePtr = \u003CModule\u003E.OpenServiceA(\u003CModule\u003E.gh_SCMAsExe, (sbyte*) &\u003CModule\u003E.gc_szServiceName, 1U);
        if ((IntPtr) scHandlePtr != IntPtr.Zero)
        {
          \u003CModule\u003E.gb_Result = true;
          \u003CModule\u003E.CloseServiceHandle(scHandlePtr);
        }
        if (\u003CModule\u003E.gb_Result)
        {
          \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BK\u0040GAEHNIOP\u0040\u003F\u0024CFs\u003F5\u003F5is\u003F5already\u003F5installed\u003F6\u003F\u0024AA\u0040, __arglist (out \u003CModule\u003E.gc_szServiceName));
          goto label_19;
        }
      }
      if (!\u003CModule\u003E.InstallControlService())
        \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BO\u0040OBMPIDLI\u0040Install\u003F5\u003F\u0024CFs\u003F5failed\u003F4\u003F5Error\u003F3\u003F5\u003F\u0024CFu\u003F6\u003F\u0024AA\u0040, __arglist (out \u003CModule\u003E.gc_szServiceName, (int) \u003CModule\u003E.GetLastError()));
      else if (!\u003CModule\u003E.StartControlService())
        \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BL\u0040KBLFEIFM\u0040Start\u003F5\u003F\u0024CFs\u003F5failed\u003F4\u003F5Error\u003F5\u003F\u0024CFu\u003F6\u003F\u0024AA\u0040, __arglist (out \u003CModule\u003E.gc_szServiceName, (int) \u003CModule\u003E.GetLastError()));
    }
    else if (\u003CModule\u003E._mbsicmp((byte*) *(int*) ((IntPtr) argv + 4), (byte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02GCGDHOON\u0040\u003F9u\u003F\u0024AA\u0040) == 0)
    {
      \u003CModule\u003E.gb_Result = false;
      if ((IntPtr) \u003CModule\u003E.gh_SCMAsExe != IntPtr.Zero)
      {
        SC_HANDLE__* scHandlePtr = \u003CModule\u003E.OpenServiceA(\u003CModule\u003E.gh_SCMAsExe, (sbyte*) &\u003CModule\u003E.gc_szServiceName, 1U);
        if ((IntPtr) scHandlePtr != IntPtr.Zero)
        {
          \u003CModule\u003E.gb_Result = true;
          \u003CModule\u003E.CloseServiceHandle(scHandlePtr);
        }
        if (\u003CModule\u003E.gb_Result)
        {
          if (!\u003CModule\u003E.UnInstallControlService((sbyte*) &\u003CModule\u003E.gc_szServiceName))
          {
            \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0DA\u0040JBFLEABC\u0040Could\u003F5not\u003F5remove\u003F5ControlService\u003F5\u0040, __arglist (out \u003CModule\u003E.gc_szServiceName, (int) \u003CModule\u003E.GetLastError()));
            goto label_19;
          }
          else
            goto label_19;
        }
      }
      \u003CModule\u003E.printf((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BF\u0040HICBAPIE\u0040\u003F\u0024CFs\u003F5is\u003F5not\u003F5installed\u003F6\u003F\u0024AA\u0040, __arglist (out \u003CModule\u003E.gc_szServiceName));
    }
    else
      ServiceBase.Run((ServiceBase) new MobilityServiceWinService());
label_19:
    return 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool IsInstalled()
  {
    \u003CModule\u003E.gb_Result = false;
    if ((IntPtr) \u003CModule\u003E.gh_SCMAsExe == IntPtr.Zero)
      return false;
    SC_HANDLE__* scHandlePtr = \u003CModule\u003E.OpenServiceA(\u003CModule\u003E.gh_SCMAsExe, (sbyte*) &\u003CModule\u003E.gc_szServiceName, 1U);
    if ((IntPtr) scHandlePtr != IntPtr.Zero)
    {
      \u003CModule\u003E.gb_Result = true;
      \u003CModule\u003E.CloseServiceHandle(scHandlePtr);
    }
    return \u003CModule\u003E.gb_Result;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool InstallControlService()
  {
    \u003CModule\u003E.gb_Result = false;
    if ((IntPtr) \u003CModule\u003E.gh_SCMAsExe == IntPtr.Zero)
      return false;
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD1;
    int moduleFileNameA = (int) \u003CModule\u003E.GetModuleFileNameA((HINSTANCE__*) 0, (sbyte*) &arrayTypeBy0CaaD1, 512U);
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD2;
    // ISSUE: initblk instruction
    __memset(ref arrayTypeBy0CaaD2, 0, 512);
    \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD2, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_05BILGFDLN\u0040\u003F\u0024CFs\u003F5\u003F9p\u003F\u0024AA\u0040, __arglist (out arrayTypeBy0CaaD1));
    SC_HANDLE__* serviceA = \u003CModule\u003E.CreateServiceA(\u003CModule\u003E.gh_SCMAsExe, (sbyte*) &\u003CModule\u003E.gc_szServiceName, (sbyte*) &\u003CModule\u003E.gc_szServiceName, 983551U, 272U, 2U, 1U, (sbyte*) &arrayTypeBy0CaaD2, (sbyte*) 0, (uint*) 0, (sbyte*) 0, (sbyte*) 0, (sbyte*) 0);
    if ((IntPtr) serviceA != IntPtr.Zero)
      \u003CModule\u003E.gb_Result = true;
    \u003CModule\u003E.CloseServiceHandle(serviceA);
    return \u003CModule\u003E.gb_Result;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool StartControlService()
  {
    \u003CModule\u003E.gb_Result = false;
    if ((IntPtr) \u003CModule\u003E.gh_SCMAsExe == IntPtr.Zero)
      return false;
    SC_HANDLE__* scHandlePtr = \u003CModule\u003E.OpenServiceA(\u003CModule\u003E.gh_SCMAsExe, (sbyte*) &\u003CModule\u003E.gc_szServiceName, 983551U);
    if ((IntPtr) scHandlePtr != IntPtr.Zero)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (\u003CModule\u003E.QueryServiceStatus(scHandlePtr, &\u003CModule\u003E.gs_MyServiceStatus) != 0 && ^(int&) ((IntPtr) &\u003CModule\u003E.gs_MyServiceStatus + 4) == 4)
      {
        \u003CModule\u003E.OutputDebugStringA((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0DI\u0040FBINAHLI\u0040StartControlService\u003F\u0024DN\u003F\u0024DN\u003F\u0024DO\u003F5Control\u003F5s\u0040);
        \u003CModule\u003E.gb_Result = true;
      }
      else if (\u003CModule\u003E.StartServiceA(scHandlePtr, 0U, (sbyte**) 0) != 0)
      {
        \u003CModule\u003E.OutputDebugStringA((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0DG\u0040FDPPCNNC\u0040StartControlService\u003F\u0024DN\u003F\u0024DN\u003F\u0024DO\u003F5Control\u003F5s\u0040);
        \u003CModule\u003E.gb_Result = true;
      }
    }
    \u003CModule\u003E.CloseServiceHandle(scHandlePtr);
    return \u003CModule\u003E.gb_Result;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool UnInstallControlService(sbyte* lpDriverName)
  {
    \u003CModule\u003E.gb_Result = false;
    if ((IntPtr) \u003CModule\u003E.gh_SCMAsExe != IntPtr.Zero)
    {
      SC_HANDLE__* scHandlePtr = \u003CModule\u003E.OpenServiceA(\u003CModule\u003E.gh_SCMAsExe, (sbyte*) &\u003CModule\u003E.gc_szServiceName, 983551U);
      if ((IntPtr) scHandlePtr != IntPtr.Zero)
      {
        if (\u003CModule\u003E.ControlService(scHandlePtr, 1U, &\u003CModule\u003E.gs_MyServiceStatus) != 0)
        {
          \u003CModule\u003E.gb_Result = true;
          \u003CModule\u003E.OutputDebugStringA((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0CO\u0040KIDGAGOI\u0040UnInstallControlService\u003F5STOP\u003F5ser\u0040);
          if (\u003CModule\u003E.DeleteService(scHandlePtr) != 0)
            \u003CModule\u003E.OutputDebugStringA((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0DA\u0040KEJMHEPD\u0040UnInstallControlService\u003F5DELETE\u003F5s\u0040);
        }
        \u003CModule\u003E.CloseServiceHandle(scHandlePtr);
      }
      \u003CModule\u003E.CloseServiceHandle(\u003CModule\u003E.gh_SCMAsExe);
      \u003CModule\u003E.OutputDebugStringA((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0DA\u0040KAGAHLFF\u0040UnInstallControlService\u003F5DeleteRe\u0040);
    }
    return \u003CModule\u003E.gb_Result;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsInDllMain() => \u003CModule\u003E.__native_dllmain_reason != uint.MaxValue;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsInProcessAttach() => \u003CModule\u003E.__native_dllmain_reason == 1U;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsInProcessDetach() => \u003CModule\u003E.__native_dllmain_reason == 0U;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsInVcclrit() => \u003CModule\u003E.__native_vcclrit_reason != uint.MaxValue;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode() => (\u003CModule\u003E.__native_dllmain_reason != uint.MaxValue ? 1 : 0) == 0 || (\u003CModule\u003E.__native_vcclrit_reason != uint.MaxValue ? 1 : 0) != 0 || \u003CModule\u003E.__native_dllmain_reason != 1U && \u003CModule\u003E.__native_dllmain_reason != 0U;

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EDoNothing(
    void* cookie)
  {
    GC.KeepAlive((object) int.MaxValue);
    return 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess()
  {
    if (\u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr = (void**) &\u003CModule\u003E.\u003FA0x7d798523\u002E__xc_mp_a;
    if (ref \u003CModule\u003E.\u003FA0x7d798523\u002E__xc_mp_a < ref \u003CModule\u003E.\u003FA0x7d798523\u002E__xc_mp_z)
    {
      while (*(int*) voidPtr == 0)
      {
        voidPtr += 4;
        if ((IntPtr) voidPtr >= ref \u003CModule\u003E.\u003FA0x7d798523\u002E__xc_mp_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative()
  {
    if (\u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr1 = (void**) &\u003CModule\u003E.__xi_a;
    if (ref \u003CModule\u003E.__xi_a < ref \u003CModule\u003E.__xi_z)
    {
      while (*(int*) voidPtr1 == 0)
      {
        voidPtr1 += 4;
        if ((IntPtr) voidPtr1 >= ref \u003CModule\u003E.__xi_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    void** voidPtr2 = (void**) &\u003CModule\u003E.__xc_a;
    if (ref \u003CModule\u003E.__xc_a < ref \u003CModule\u003E.__xc_z)
    {
      while (*(int*) voidPtr2 == 0)
      {
        voidPtr2 += 4;
        if ((IntPtr) voidPtr2 >= ref \u003CModule\u003E.__xc_z)
          goto label_9;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_9:
    \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess() && !\u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA || \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative() && !\u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA && \u003CModule\u003E.__native_startup_state == (__enative_startup_state) 0;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsUninitialization() => \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = false;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during vtable initialization.\n");
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x7d798523\u002E__xi_vt_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x7d798523\u002E__xi_vt_z);
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize();
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during native initialization.\n");
    \u003CModule\u003E.__security_init_cookie();
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode())
      \u003CModule\u003E._amsg_exit(33);
    switch (\u003CModule\u003E.__native_startup_state)
    {
      case (__enative_startup_state) 0:
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 1;
        if (\u003CModule\u003E._initterm_e((__FnPtr<int ()>*) &\u003CModule\u003E.__xi_a, (__FnPtr<int ()>*) &\u003CModule\u003E.__xi_z) != 0)
          \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0));
        \u003CModule\u003E._initterm((__FnPtr<void ()>*) &\u003CModule\u003E.__xc_a, (__FnPtr<void ()>*) &\u003CModule\u003E.__xc_z);
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 2;
        \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
        break;
      case (__enative_startup_state) 1:
        \u003CModule\u003E._amsg_exit(33);
        break;
    }
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during process initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_m();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x7d798523\u002E__xc_mp_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x7d798523\u002E__xc_mp_z);
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during appdomain initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_app_domain();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x7d798523\u002E__xc_ma_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x7d798523\u002E__xc_ma_z);
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during registration for the unload events.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(new EventHandler(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload));
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = AppDomain.CurrentDomain.IsDefaultAppDomain();
    if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation();
    void* fiberPtrId = \u003CModule\u003E._getFiberPtrId();
    int num1 = 0;
    int num2 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      while (num2 == 0)
      {
        try
        {
        }
        finally
        {
          IntPtr comparand = (IntPtr) 0;
          IntPtr num3 = (IntPtr) fiberPtrId;
          // ISSUE: cast to a reference type
          void* voidPtr = (void*) Interlocked.CompareExchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num3, comparand);
          if ((IntPtr) voidPtr == IntPtr.Zero)
            num2 = 1;
          else if (voidPtr == fiberPtrId)
          {
            num1 = 1;
            num2 = 1;
          }
        }
        if (num2 == 0)
          \u003CModule\u003E.Sleep(1000U);
      }
      if (!\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      {
        if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization())
          \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(obj0);
      }
    }
    finally
    {
      if (num1 == 0)
      {
        IntPtr num4 = (IntPtr) 0;
        // ISSUE: cast to a reference type
        Interlocked.Exchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num4);
      }
    }
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(obj0);
    if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(obj0);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(obj0);
    }
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(obj0);
    \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 1;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(obj0);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain() => \u003CModule\u003E._app_exit_callback();

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain(
    void* cookie)
  {
    \u003CModule\u003E._exit_callback();
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    if (\u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
    {
      \u003CModule\u003E._cexit();
      \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 0;
      \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    }
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    return 0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain()
  {
    if (!\u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
      return;
    if (AppDomain.CurrentDomain.IsDefaultAppDomain())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain((void*) 0);
    }
    else
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [PrePrepareMethod]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload(
    object source,
    EventArgs arguments)
  {
    if (\u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA == 0 || Interlocked.Exchange(ref \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA, 1) != 0)
      return;
    int num = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0 ? 1 : 0;
    \u003CModule\u003E._app_exit_callback();
    if ((byte) num == (byte) 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(
    [In] LanguageSupport* obj0,
    Exception innerException)
  {
    try
    {
      bool flag = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
      if (!flag)
        return;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, ex);
    }
    catch
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, (Exception) null);
    }
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(
    [In] LanguageSupport* obj0)
  {
    bool flag = false;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load.\n");
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        Interlocked.Increment(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA);
        flag = true;
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(obj0);
    }
    catch (Exception ex)
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, ex);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), ex);
    }
    catch
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, (Exception) null);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), (Exception) null);
    }
  }

  [DebuggerStepThrough]
  static unsafe \u003CModule\u003E()
  {
    LanguageSupport languageSupport;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(&languageSupport);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(&languageSupport);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D), (void*) &languageSupport);
    }
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) &languageSupport);
  }

  internal static unsafe LanguageSupport* \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
    return obj0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(int*) obj0 = (int) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
    *(int*) obj0 = 0;
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0,
    string t)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) t;
    return obj0;
  }

  internal static unsafe string gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    return (string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindDelDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindVecDtor(
    __FnPtr<void (void*, uint, int, __FnPtr<void (void*)>)> pVecDtor,
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    try
    {
      void* voidPtr = ptr;
      int num1 = (int) size;
      int num2 = count;
      __FnPtr<void (void*)> local = pDtor;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      __calli(pVecDtor)((__FnPtr<void (void*)>) (IntPtr) voidPtr, num1, (uint) num2, (void*) local);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ehvec_dtor(
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    int num = 0;
    ptr = (void*) ((int) size * count + (IntPtr) ptr);
    try
    {
      while (true)
      {
        --count;
        if (count >= 0)
        {
          ptr -= (int) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
      num = 1;
    }
    finally
    {
      if (num == 0)
        \u003CModule\u003E.__ArrayUnwind(ptr, size, count, pDtor);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe int \u003FA0xe6292fd0\u002EArrayUnwindFilter(_EXCEPTION_POINTERS* pExPtrs)
  {
    if (*(int*) *(int*) pExPtrs != -529697949)
      return 0;
    \u003CModule\u003E.terminate();
    return 0;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ArrayUnwind(
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    try
    {
      while (true)
      {
        --count;
        if (count >= 0)
        {
          ptr -= (int) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
    }
    catch (Exception ex) when (\u003CModule\u003E.\u003FA0xe6292fd0\u002EArrayUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EInitialize()
  {
    object obj = new object();
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A = 0;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002ESet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A, obj);
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A) != null;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EEnter() => Monitor.Enter(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A));

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EExit() => Monitor.Exit(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A));

  internal static void \u003FA0x49040904\u002E\u003F\u003F__E\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x49040904\u002E\u003F\u003F__F\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A\u0040\u0040YMXXZ));

  internal static unsafe void \u003FA0x49040904\u002E\u003F\u003F__F\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A);

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003FA0x49040904\u002E__global_lock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      Monitor.Enter(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A));
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003FA0x49040904\u002E__global_unlock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      Monitor.Exit(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A));
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x49040904\u002E__alloc_global_lock()
  {
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EInitialize();
    return \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized();
  }

  internal static unsafe int _atexit_helper(
    __FnPtr<void ()> func,
    uint* __pexit_list_size,
    __FnPtr<void ()>** __ponexitend,
    __FnPtr<void ()>** __ponexitbegin)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0;
    if (func == null)
      return -1;
    int num1;
    if (\u003CModule\u003E.\u003FA0x49040904\u002E__global_lock())
    {
      try
      {
        if (*__pexit_list_size - 1U < (uint) (*(int*) __ponexitend - *(int*) __ponexitbegin) >> 2)
        {
          try
          {
            uint num2 = *__pexit_list_size * 4U;
            uint num3 = num2 >= 2048U ? 2048U : num2;
            IntPtr cb = new IntPtr((int) num2 + (int) num3);
            IntPtr num4 = Marshal.ReAllocHGlobal(new IntPtr((void*) *(int*) __ponexitbegin), cb);
            __FnPtr<void ()>** local2 = __ponexitend;
            IntPtr num5 = *(int*) local2 + ((IntPtr) num4.ToPointer() - *(int*) __ponexitbegin);
            *(int*) local2 = (int) num5;
            *(int*) __ponexitbegin = (int) num4.ToPointer();
            uint num6 = *__pexit_list_size;
            uint num7 = 512U >= num6 ? num6 : 512U;
            *__pexit_list_size = num6 + num7;
          }
          catch (OutOfMemoryException ex)
          {
            IntPtr cb = new IntPtr((int) *__pexit_list_size * 4 + 8);
            IntPtr num8 = Marshal.ReAllocHGlobal(new IntPtr((void*) *(int*) __ponexitbegin), cb);
            __FnPtr<void ()>** local3 = __ponexitend;
            IntPtr num9 = *(int*) local3 + ((IntPtr) num8.ToPointer() - *(int*) __ponexitbegin);
            *(int*) local3 = (int) num9;
            *(int*) __ponexitbegin = (int) num8.ToPointer();
            uint* numPtr = __pexit_list_size;
            int num10 = (int) *numPtr + 4;
            *numPtr = (uint) num10;
          }
        }
        *(int*) *(int*) __ponexitend = (int) func;
        __FnPtr<void ()>** local4 = __ponexitend;
        int num11 = *(int*) local4 + 4;
        *(int*) local4 = num11;
        local1 = func;
      }
      catch (OutOfMemoryException ex)
      {
      }
      finally
      {
        \u003CModule\u003E.\u003FA0x49040904\u002E__global_unlock();
      }
      if (local1 != null)
      {
        num1 = 0;
        goto label_12;
      }
    }
    num1 = -1;
label_12:
    return num1;
  }

  internal static unsafe void _exit_callback()
  {
    if ((IntPtr) \u003CModule\u003E.\u003FA0x49040904\u002E__onexitbegin == new IntPtr(-1) || (IntPtr) \u003CModule\u003E.\u003FA0x49040904\u002E__onexitbegin == IntPtr.Zero || (IntPtr) \u003CModule\u003E.\u003FA0x49040904\u002E__onexitend == IntPtr.Zero)
      return;
    \u003CModule\u003E.\u003FA0x49040904\u002E__onexitend -= 4;
    if (\u003CModule\u003E.\u003FA0x49040904\u002E__onexitend >= \u003CModule\u003E.\u003FA0x49040904\u002E__onexitbegin)
    {
      do
      {
        if (*(int*) \u003CModule\u003E.\u003FA0x49040904\u002E__onexitend != 0)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) *(int*) \u003CModule\u003E.\u003FA0x49040904\u002E__onexitend)();
        }
        \u003CModule\u003E.\u003FA0x49040904\u002E__onexitend -= 4;
      }
      while (\u003CModule\u003E.\u003FA0x49040904\u002E__onexitend >= \u003CModule\u003E.\u003FA0x49040904\u002E__onexitbegin);
    }
    Marshal.FreeHGlobal(new IntPtr((void*) \u003CModule\u003E.\u003FA0x49040904\u002E__onexitbegin));
  }

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_m()
  {
    if (!\u003CModule\u003E.\u003FA0x49040904\u002E__alloc_global_lock())
      return 0;
    \u003CModule\u003E.\u003FA0x49040904\u002E__onexitbegin = (__FnPtr<void ()>*) Marshal.AllocHGlobal(128).ToPointer();
    \u003CModule\u003E.\u003FA0x49040904\u002E__onexitend = \u003CModule\u003E.\u003FA0x49040904\u002E__onexitbegin;
    \u003CModule\u003E.\u003FA0x49040904\u002E__exit_list_size = 32U;
    return 1;
  }

  internal static __FnPtr<int ()> _onexit_m(__FnPtr<int ()> _Function) => \u003CModule\u003E._atexit_m((__FnPtr<void ()>) _Function) != -1 ? _Function : (__FnPtr<int ()>) 0;

  internal static unsafe int _atexit_m(__FnPtr<void ()> func) => \u003CModule\u003E._atexit_helper(func, &\u003CModule\u003E.\u003FA0x49040904\u002E__exit_list_size, &\u003CModule\u003E.\u003FA0x49040904\u002E__onexitend, &\u003CModule\u003E.\u003FA0x49040904\u002E__onexitbegin);

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_app_domain()
  {
    if (\u003CModule\u003E.\u003FA0x49040904\u002E__alloc_global_lock())
    {
      \u003CModule\u003E.__onexitbegin_app_domain = (__FnPtr<void ()>*) Marshal.AllocHGlobal(128).ToPointer();
      \u003CModule\u003E.__onexitend_app_domain = \u003CModule\u003E.__onexitbegin_app_domain;
      \u003CModule\u003E.__exit_list_size_app_domain = 32U;
    }
    return 1;
  }

  internal static unsafe void _app_exit_callback()
  {
    if ((IntPtr) \u003CModule\u003E.__onexitbegin_app_domain == new IntPtr(-1) || (IntPtr) \u003CModule\u003E.__onexitbegin_app_domain == IntPtr.Zero)
      return;
    if ((IntPtr) \u003CModule\u003E.__onexitend_app_domain == IntPtr.Zero)
      return;
    try
    {
      while (true)
      {
        do
        {
          \u003CModule\u003E.__onexitend_app_domain -= 4;
          if (\u003CModule\u003E.__onexitend_app_domain < \u003CModule\u003E.__onexitbegin_app_domain)
            goto label_8;
        }
        while (*(int*) \u003CModule\u003E.__onexitend_app_domain == 0);
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) *(int*) \u003CModule\u003E.__onexitend_app_domain)();
      }
label_8:;
    }
    finally
    {
      Marshal.FreeHGlobal(new IntPtr((void*) \u003CModule\u003E.__onexitbegin_app_domain));
    }
  }

  internal static __FnPtr<int ()> _onexit_m_appdomain(__FnPtr<int ()> _Function) => \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) _Function) != -1 ? _Function : (__FnPtr<int ()>) 0;

  [DebuggerStepThrough]
  internal static unsafe int _atexit_m_appdomain(__FnPtr<void ()> func) => \u003CModule\u003E._atexit_helper(func, &\u003CModule\u003E.__exit_list_size_app_domain, &\u003CModule\u003E.__onexitend_app_domain, &\u003CModule\u003E.__onexitbegin_app_domain);

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EConstruct(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0,
    object value)
  {
    *(int*) obj0 = 0;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002ESet(obj0, value);
  }

  [DebuggerStepThrough]
  internal static unsafe object \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E_handle(obj0);
    return valueType != null ? ((GCHandle) valueType).Target : (object) null;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E_handle(obj0);
    if (valueType == null)
      return;
    ((GCHandle) valueType).Free();
    *(int*) obj0 = 0;
  }

  [DebuggerStepThrough]
  internal static unsafe ValueType \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E_handle(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0)
  {
    uint num = (uint) *(int*) obj0;
    return num != 0U ? (ValueType) GCHandle.FromIntPtr(new IntPtr((void*) num)) : (ValueType) null;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002ESet(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0,
    object value)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E_handle(obj0);
    if (valueType == null)
    {
      IntPtr intPtr = GCHandle.ToIntPtr(GCHandle.Alloc(value));
      *(int*) obj0 = (int) intPtr.ToPointer();
    }
    else
      ((GCHandle) valueType).Target = value;
  }

  [DebuggerStepThrough]
  internal static unsafe int _initterm_e(__FnPtr<int ()>* pfbegin, __FnPtr<int ()>* pfend)
  {
    int num1 = 0;
    if (pfbegin < pfend)
    {
      while (num1 == 0)
      {
        uint num2 = (uint) *(int*) pfbegin;
        if (num2 != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          num1 = __calli((__FnPtr<int ()>) (int) num2)();
        }
        pfbegin += 4;
        if (pfbegin >= pfend)
          break;
      }
    }
    return num1;
  }

  [DebuggerStepThrough]
  internal static unsafe void _initterm(__FnPtr<void ()>* pfbegin, __FnPtr<void ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint num = (uint) *(int*) pfbegin;
      if (num != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) (int) num)();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static ModuleHandle \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle() => typeof (ThisModule).Module.ModuleHandle;

  [DebuggerStepThrough]
  internal static unsafe void _initterm_m(__FnPtr<void* ()>* pfbegin, __FnPtr<void* ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint methodToken = (uint) *(int*) pfbegin;
      if (methodToken != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        void* voidPtr = __calli(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E((__FnPtr<void* ()>) (int) methodToken))();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static unsafe __FnPtr<void* ()> \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E(
    __FnPtr<void* ()> methodToken)
  {
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void* ()>) (IntPtr) \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle().ResolveMethodHandle((int) methodToken).GetFunctionPointer().ToPointer();
  }

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern uint _mainCRTStartup();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe allocator\u003Cchar\u003E* std\u002Eallocator\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] allocator\u003Cchar\u003E* obj0,
    [In] allocator\u003Cchar\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe allocator\u003Cwchar_t\u003E* std\u002Eallocator\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] allocator\u003Cwchar_t\u003E* obj0,
    [In] allocator\u003Cwchar_t\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* LocalFree([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int sprintf([In] sbyte* obj0, [In] sbyte* obj1, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern void _com_issue_error([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void delete([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int SendMessageA([In] HWND__* obj0, [In] uint obj1, [In] uint obj2, [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void delete\u005B\u005D([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int MessageBoxA([In] HWND__* obj0, [In] sbyte* obj1, [In] sbyte* obj2, [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void VariantInit([In] tagVARIANT* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int VariantCopy([In] tagVARIANT* obj0, [In] tagVARIANT* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int PostMessageA([In] HWND__* obj0, [In] uint obj1, [In] uint obj2, [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int InterlockedDecrement([In] int* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int InterlockedIncrement([In] int* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe HWND__* FindWindowA([In] sbyte* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int VariantClear([In] tagVARIANT* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe exception* std\u002Eexception\u002E\u007Bctor\u007D(
    [In] exception* obj0,
    [In] exception* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Eexception\u002E\u007Bdtor\u007D([In] exception* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* @new([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int __CxxQueryExceptionSize();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxDetectRethrow([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int ControlService(
    [In] SC_HANDLE__* obj0,
    [In] uint obj1,
    [In] _SERVICE_STATUS* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint WTSGetActiveConsoleSessionId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint NetShareAdd([In] char* obj0, [In] uint obj1, [In] byte* obj2, [In] uint* obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe SC_HANDLE__* OpenSCManagerA(
    [In] sbyte* obj0,
    [In] sbyte* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* LocalAlloc([In] uint obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int SetSecurityDescriptorOwner([In] void* obj0, [In] void* obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void __CxxUnregisterExceptionObject([In] void* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int QueryServiceStatus([In] SC_HANDLE__* obj0, [In] _SERVICE_STATUS* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxExceptionFilter(
    [In] void* obj0,
    [In] void* obj1,
    [In] int obj2,
    [In] void* obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint NetShareDel([In] char* obj0, [In] char* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int SetSecurityDescriptorDacl(
    [In] void* obj0,
    [In] int obj1,
    [In] _ACL* obj2,
    [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int StartServiceA([In] SC_HANDLE__* obj0, [In] uint obj1, [In] sbyte** obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int InitializeSecurityDescriptor([In] void* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void Sleep([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void SHChangeNotify([In] int obj0, [In] uint obj1, [In] void* obj2, [In] void* obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe byte* _mbsstr([In] byte* obj0, [In] byte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxRegisterExceptionObject([In] void* obj0, [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void BuildTrusteeWithSidA([In] _TRUSTEE_A* obj0, [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void WTSFreeMemory([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int WTSEnumerateProcessesA(
    [In] void* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] _WTS_PROCESS_INFOA** obj3,
    [In] uint* obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint SetEntriesInAclA(
    [In] uint obj0,
    [In] _EXPLICIT_ACCESS_A* obj1,
    [In] _ACL* obj2,
    [In] _ACL** obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CloseServiceHandle([In] SC_HANDLE__* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe SC_HANDLE__* OpenServiceA(
    [In] SC_HANDLE__* obj0,
    [In] sbyte* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CoInitializeEx([In] void* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void SysFreeString([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CoInitializeSecurity(
    [In] void* obj0,
    [In] int obj1,
    [In] tagSOLE_AUTHENTICATION_SERVICE* obj2,
    [In] void* obj3,
    [In] uint obj4,
    [In] uint obj5,
    [In] void* obj6,
    [In] uint obj7,
    [In] void* obj8);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void CoUninitialize();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CoSetProxyBlanket(
    [In] IUnknown* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] char* obj3,
    [In] uint obj4,
    [In] uint obj5,
    [In] void* obj6,
    [In] uint obj7);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CoCreateInstance(
    [In] _GUID* obj0,
    [In] IUnknown* obj1,
    [In] uint obj2,
    [In] _GUID* obj3,
    [In] void** obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe char* SysAllocString([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CloseHandle([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void OutputDebugStringA([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint GetModuleFileNameA([In] HINSTANCE__* obj0, [In] sbyte* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint GetLastError();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int printf([In] sbyte* obj0, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CreateProcessA(
    [In] sbyte* obj0,
    [In] sbyte* obj1,
    [In] _SECURITY_ATTRIBUTES* obj2,
    [In] _SECURITY_ATTRIBUTES* obj3,
    [In] int obj4,
    [In] uint obj5,
    [In] void* obj6,
    [In] sbyte* obj7,
    [In] _STARTUPINFOA* obj8,
    [In] _PROCESS_INFORMATION* obj9);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe SC_HANDLE__* CreateServiceA(
    [In] SC_HANDLE__* obj0,
    [In] sbyte* obj1,
    [In] sbyte* obj2,
    [In] uint obj3,
    [In] uint obj4,
    [In] uint obj5,
    [In] uint obj6,
    [In] sbyte* obj7,
    [In] sbyte* obj8,
    [In] uint* obj9,
    [In] sbyte* obj10,
    [In] sbyte* obj11,
    [In] sbyte* obj12);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* strstr([In] sbyte* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int DeleteService([In] SC_HANDLE__* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int _mbsicmp([In] byte* obj0, [In] byte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _getFiberPtrId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _amsg_exit([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern void __security_init_cookie();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    [In] string obj0,
    [In] Exception obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    [In] string obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(
    [In] Exception obj0,
    [In] Exception obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(
    [In] EventHandler obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void \u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain(
    [In] __FnPtr<int (void*)> obj0,
    [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _cexit();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __FrameUnwindFilter([In] _EXCEPTION_POINTERS* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void terminate();
}
