// Decompiled with JetBrains decompiler
// Type: Newtonsoft.Json.Utilities.ReflectionUtils
// Assembly: BitGenerator, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=70e4c26ef2031892
// MVID: D3922F89-E00A-4D10-8BC9-9309D5539F14
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Trojan.Win32.Scar.nxii-31823040d8ccb20eab0b8653d01af370a6537017e69ead69f6f7b73d6ef7ac14.exe

using \u0014;
using SmartAssembly.Delegates;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;

namespace Newtonsoft.Json.Utilities
{
  internal static class ReflectionUtils
  {
    public static readonly Type[] \u0001;
    [NonSerialized]
    internal static GetString \u001B;

    static ReflectionUtils()
    {
      SmartAssembly.HouseOfCards.Strings.CreateGetStringDelegate(typeof (ReflectionUtils));
      ReflectionUtils.\u0001 = Type.EmptyTypes;
    }

    public static bool \u0001([In] PropertyInfo obj0)
    {
      \u0006.\u0001((object) obj0, ReflectionUtils.\u001B(4589));
label_1:
      MethodInfo methodInfo;
      if (true)
        methodInfo = \u008C\u0002.\u007E\u0003\u0006((object) obj0);
      if ((object) methodInfo == null)
        goto label_6;
label_3:
      if (\u0015\u0002.\u007E\u009B\u0004((object) methodInfo))
        return true;
label_6:
      methodInfo = \u008C\u0002.\u007E\u0004\u0006((object) obj0);
      if (true)
      {
        if (true)
        {
          int num;
          if ((object) methodInfo != null && \u0015\u0002.\u007E\u009B\u0004((object) methodInfo))
            num = 1;
          else
            goto label_12;
label_10:
          if (num != 0)
            return num != 0;
          goto label_13;
label_12:
          num = 0;
label_13:
          if (num == 0)
            return num != 0;
          goto label_10;
        }
        else
          goto label_3;
      }
      else
        goto label_1;
    }

    public static MethodInfo \u0001([In] PropertyInfo obj0)
    {
      if (true)
        goto label_8;
label_7:
      return (MethodInfo) null;
label_8:
      \u0006.\u0001((object) obj0, ReflectionUtils.\u001B(4589));
      if (true)
      {
        if (true)
        {
          MethodInfo methodInfo = \u008C\u0002.\u007E\u0003\u0006((object) obj0);
          if ((object) methodInfo != null)
            return \u008C\u0002.\u007E\u0005\u0006((object) methodInfo);
        }
        else
          goto label_6;
      }
      MethodInfo methodInfo1;
      do
      {
        methodInfo1 = \u008C\u0002.\u007E\u0004\u0006((object) obj0);
      }
      while (false);
      if ((object) methodInfo1 == null)
        goto label_7;
label_6:
      return \u008C\u0002.\u007E\u0005\u0006((object) methodInfo1);
    }

    public static \u0001 \u0001<\u0001>([In] object obj0) where \u0001 : Attribute => ReflectionUtils.\u0001<\u0001>(obj0, true);

    public static \u0001 \u0001<\u0001>([In] object obj0, [In] bool obj1) where \u0001 : Attribute
    {
      \u0001[] source;
      while (true)
      {
        source = ReflectionUtils.\u0001<\u0001>(obj0, obj1);
        if (true)
        {
          if (source == null)
          {
            \u0001 obj;
            if (true)
              obj = default (\u0001);
            return obj;
          }
          break;
        }
      }
      return ((IEnumerable<\u0001>) source).FirstOrDefault<\u0001>();
    }

    public static \u0001[] \u0001<\u0001>([In] object obj0, [In] bool obj1) where \u0001 : Attribute
    {
      Attribute[] source = \u0006.\u0001(obj1, typeof (\u0001), obj0);
      \u0001[] objArray = source as \u0001[];
      while (objArray == null)
      {
        if (true)
          return source.Cast<\u0001>().ToArray<\u0001>();
      }
      return objArray;
    }

    public static BindingFlags \u0001([In] BindingFlags obj0, [In] BindingFlags obj1)
    {
      while ((obj0 & obj1) != obj1)
      {
        if (true)
          return obj0;
      }
      return obj0 ^ obj1;
    }
  }
}
