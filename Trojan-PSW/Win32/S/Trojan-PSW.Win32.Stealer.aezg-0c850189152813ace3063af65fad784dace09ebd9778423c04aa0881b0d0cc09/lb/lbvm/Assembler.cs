// Decompiled with JetBrains decompiler
// Type: org.lb.lbvm.Assembler
// Assembly: GCCollectionMo, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3A5CAC9E-800C-431E-83D8-5129C6781923
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\Trojan-PSW.Win32.Stealer.aezg-0c850189152813ace3063af65fad784dace09ebd9778423c04aa0881b0d0cc09.exe

using org.lb.lbvm.exceptions;
using org.lb.lbvm.runtime;
using System;
using System.Collections.Generic;
using System.Globalization;

namespace org.lb.lbvm
{
  internal sealed class Assembler
  {
    private readonly List<byte> Bytecode = new List<byte>();
    private readonly List<string> SymbolTable = new List<string>();
    private readonly CoreCodes Program;
    private readonly Dictionary<string, int> Labels = new Dictionary<string, int>();
    private readonly List<Assembler.WantedLabel> WantedLabels = new List<Assembler.WantedLabel>();
    private readonly Stack<Assembler.FunctionStatement> functionStatements = new Stack<Assembler.FunctionStatement>();
    private int generatedLabelNumber;

    public static CoreCodes Assemble(IEnumerable<string> sourceLines) => new Assembler(sourceLines).Program;

    private Assembler(IEnumerable<string> sourceLines)
    {
      foreach (string sourceLine in sourceLines)
        this.ParseLine(sourceLine.Trim());
      this.SetLabelPositions();
      this.Program = new CoreCodes(1, this.Bytecode.ToArray(), this.SymbolTable.ToArray());
    }

    private void ParseLine(string line)
    {
      if (line.ToUpper().StartsWith("FUNCTION"))
        this.HandleFunction(line.Split());
      else if (line.ToUpper().StartsWith("ENDFUNCTION"))
        this.HandleEndFunction(line.Split());
      else if (line.EndsWith(":"))
        this.AddLabel(line.TrimEnd(':'));
      else
        this.AddStatement(Assembler.SplitLine(line));
    }

    private void HandleFunction(string[] line)
    {
      string name = line.Length >= 1 ? line[1] : throw new AssemblerException("Syntax error in FUNCTION definition");
      string label1 = this.generateLabel();
      string label2 = this.generateLabel();
      List<string> collection = new List<string>();
      List<string> stringList1 = new List<string>();
      List<string> stringList2 = new List<string>();
      string str1 = "";
      this.functionStatements.Push(new Assembler.FunctionStatement(name, label1, label2, stringList1));
      if (str1 != "")
        collection.Add(str1);
      this.ParseLine("JMP " + label2);
      this.ParseLine(label1 + ":");
      if (str1 == "")
      {
        this.ParseLine("ENTER " + (collection.Count + stringList1.Count).ToString() + " " + name);
      }
      else
      {
        string[] strArray = new string[6];
        strArray[0] = "ENTERR ";
        int num = collection.Count + stringList1.Count;
        strArray[1] = num.ToString();
        strArray[2] = " ";
        num = stringList1.Count;
        strArray[3] = num.ToString();
        strArray[4] = " ";
        strArray[5] = name;
        this.ParseLine(string.Concat(strArray));
      }
      foreach (string str2 in stringList2)
        this.ParseLine("MAKEVAR " + str2);
      List<string> stringList3 = new List<string>((IEnumerable<string>) stringList1);
      stringList3.Reverse();
      foreach (string str3 in stringList3)
        this.ParseLine("DEFINE " + str3);
      List<string> stringList4 = new List<string>((IEnumerable<string>) collection);
      stringList4.Reverse();
      foreach (string str4 in stringList4)
        this.ParseLine("DEFINE " + str4);
      this.ParseLine("POP");
    }

    private string generateLabel() => "##generated_label##" + this.generatedLabelNumber++.ToString();

    private void HandleEndFunction(string[] line)
    {
      Assembler.FunctionStatement functionStatement = this.functionStatements.Pop();
      this.ParseLine(functionStatement.LabelEnd + ":");
      this.ParseLine("PUSHLABEL " + functionStatement.LabelStart);
      this.ParseLine("DEFINE " + functionStatement.Name);
      if (functionStatement.ClosingOverVariables.Count <= 0)
        return;
      this.ParseLine("PUSHVAR " + functionStatement.Name);
      foreach (string closingOverVariable in functionStatement.ClosingOverVariables)
        this.ParseLine("PUSHSYM " + closingOverVariable);
      this.ParseLine("MAKECLOSURE " + functionStatement.ClosingOverVariables.Count.ToString());
      this.ParseLine("SET " + functionStatement.Name);
    }

    private void AddLabel(string label)
    {
      if (this.Labels.ContainsKey(label))
        throw new AssemblerException("Label defined twice: " + label);
      this.Labels[label] = this.Bytecode.Count;
    }

    private void AddStatement(string[] line)
    {
      int parameterCount = line.Length - 1;
      string upper = line[0].ToUpper();
      Dictionary<string, byte> dictionary1 = new Dictionary<string, byte>()
      {
        {
          "END",
          (byte) 0
        },
        {
          "POP",
          (byte) 1
        },
        {
          "NUMEQUAL",
          (byte) 5
        },
        {
          "ADD",
          (byte) 6
        },
        {
          "SUB",
          (byte) 7
        },
        {
          "MUL",
          (byte) 8
        },
        {
          "DIV",
          (byte) 9
        },
        {
          "IDIV",
          (byte) 10
        },
        {
          "RET",
          (byte) 13
        },
        {
          "IMOD",
          (byte) 18
        },
        {
          "PUSHTRUE",
          (byte) 21
        },
        {
          "PUSHFALSE",
          (byte) 22
        },
        {
          "NUMLT",
          (byte) 24
        },
        {
          "NUMLE",
          (byte) 25
        },
        {
          "NUMGT",
          (byte) 26
        },
        {
          "NUMGE",
          (byte) 27
        },
        {
          "MAKEPAIR",
          (byte) 30
        },
        {
          "ISPAIR",
          (byte) 31
        },
        {
          "PAIR1",
          (byte) 32
        },
        {
          "PAIR2",
          (byte) 33
        },
        {
          "PUSHNIL",
          (byte) 34
        },
        {
          "RANDOM",
          (byte) 36
        },
        {
          "OBJEQUAL",
          (byte) 37
        },
        {
          "ISNULL",
          (byte) 38
        },
        {
          "PRINT",
          (byte) 39
        },
        {
          "ISNUMBER",
          (byte) 41
        },
        {
          "ISSTRING",
          (byte) 42
        },
        {
          "STREQUAL",
          (byte) 43
        },
        {
          "STREQUALCI",
          (byte) 44
        },
        {
          "STRLT",
          (byte) 45
        },
        {
          "STRLTCI",
          (byte) 46
        },
        {
          "STRGT",
          (byte) 47
        },
        {
          "STRGTCI",
          (byte) 48
        },
        {
          "STRLEN",
          (byte) 49
        },
        {
          "SUBSTR",
          (byte) 50
        },
        {
          "STRAPPEND",
          (byte) 51
        },
        {
          "ISCHAR",
          (byte) 53
        },
        {
          "CHREQUAL",
          (byte) 54
        },
        {
          "CHREQUALCI",
          (byte) 55
        },
        {
          "CHRLT",
          (byte) 56
        },
        {
          "CHRLTCI",
          (byte) 57
        },
        {
          "CHRGT",
          (byte) 58
        },
        {
          "CHRGTCI",
          (byte) 59
        },
        {
          "CHRTOINT",
          (byte) 60
        },
        {
          "INTTOCHR",
          (byte) 61
        },
        {
          "STRREF",
          (byte) 62
        },
        {
          "SETSTRREF",
          (byte) 63
        },
        {
          "MAKESTR",
          (byte) 64
        },
        {
          "STRTONUM",
          (byte) 65
        },
        {
          "NUMTOSTR",
          (byte) 66
        },
        {
          "STRTOSYM",
          (byte) 67
        },
        {
          "SYMTOSTR",
          (byte) 68
        },
        {
          "THROW",
          (byte) 69
        },
        {
          "ISBOOL",
          (byte) 70
        },
        {
          "ISSYMBOL",
          (byte) 71
        },
        {
          "ISINT",
          (byte) 72
        },
        {
          "ISFLOAT",
          (byte) 73
        },
        {
          "ERROR",
          byte.MaxValue
        }
      };
      Dictionary<string, byte> dictionary2 = new Dictionary<string, byte>()
      {
        {
          "PUSHINT",
          (byte) 2
        },
        {
          "CALL",
          (byte) 14
        },
        {
          "TAILCALL",
          (byte) 15
        },
        {
          "MAKECLOSURE",
          (byte) 23
        }
      };
      Dictionary<string, byte> dictionary3 = new Dictionary<string, byte>()
      {
        {
          "DEFINE",
          (byte) 3
        },
        {
          "PUSHVAR",
          (byte) 4
        },
        {
          "SET",
          (byte) 19
        },
        {
          "PUSHSYM",
          (byte) 20
        },
        {
          "MAKEVAR",
          (byte) 29
        }
      };
      Dictionary<string, byte> dictionary4 = new Dictionary<string, byte>()
      {
        {
          "BFALSE",
          (byte) 11
        },
        {
          "JMP",
          (byte) 16
        },
        {
          "PUSHLABEL",
          (byte) 17
        }
      };
      if (dictionary1.ContainsKey(upper))
      {
        this.AssertParameterCount(parameterCount, 0, upper);
        this.Emit(dictionary1[upper]);
      }
      else if (dictionary2.ContainsKey(upper))
      {
        this.AssertParameterCount(parameterCount, 1, upper);
        this.Emit(dictionary2[upper]);
        this.EmitInt(int.Parse(line[1]));
      }
      else if (dictionary3.ContainsKey(upper))
      {
        this.AssertParameterCount(parameterCount, 1, upper);
        this.Emit(dictionary3[upper]);
        this.EmitSymbol(line[1]);
      }
      else if (dictionary4.ContainsKey(upper))
      {
        this.AssertParameterCount(parameterCount, 1, upper);
        this.Emit(dictionary4[upper]);
        this.EmitLabel(line[1]);
      }
      else
      {
        string str = upper;
        if (!(str == "PUSHDBL"))
        {
          if (!(str == "ENTER"))
          {
            if (!(str == "ENTERR"))
            {
              if (!(str == "PUSHSTR"))
              {
                if (!(str == "PUSHCHR"))
                  throw new AssemblerException("Invalid opcode: " + upper);
                this.AssertParameterCount(parameterCount, 1, upper);
                this.Emit((byte) 52);
                this.EmitInt(int.Parse(line[1]));
              }
              else
              {
                this.AssertParameterCount(parameterCount, 1, upper);
                this.Emit((byte) 40);
                this.EmitString(line[1]);
              }
            }
            else
            {
              this.AssertParameterCount(parameterCount, 3, upper);
              this.Emit((byte) 35);
              this.EmitInt(int.Parse(line[1]));
              this.EmitInt(int.Parse(line[2]));
              this.EmitSymbol(line[3]);
            }
          }
          else
          {
            this.AssertParameterCount(parameterCount, 2, upper);
            this.Emit((byte) 12);
            this.EmitInt(int.Parse(line[1]));
            this.EmitSymbol(line[2]);
          }
        }
        else
        {
          this.AssertParameterCount(parameterCount, 1, upper);
          this.Emit((byte) 28);
          this.EmitDouble(double.Parse(line[1], NumberStyles.Any, (IFormatProvider) CultureInfo.InvariantCulture));
        }
      }
    }

    private void AssertParameterCount(int parameterCount, int wanted, string opcode)
    {
      if (parameterCount != wanted)
        throw new AssemblerException("Invalid parameter count in opcode " + opcode);
    }

    private void Emit(byte code) => this.Bytecode.Add(code);

    private void EmitInt(int valueAsInt)
    {
      foreach (byte code in BitConverter.GetBytes(valueAsInt))
        this.Emit(code);
    }

    private void EmitSymbol(string symbol)
    {
      if (!this.SymbolTable.Contains(symbol))
        this.SymbolTable.Add(symbol);
      this.EmitInt(this.SymbolTable.IndexOf(symbol));
    }

    private void EmitLabel(string label)
    {
      this.WantedLabels.Add(new Assembler.WantedLabel(label, this.Bytecode.Count));
      this.EmitInt(0);
    }

    private void EmitDouble(double valueAsDouble)
    {
      foreach (byte code in BitConverter.GetBytes(valueAsDouble))
        this.Emit(code);
    }

    private void EmitString(string value)
    {
      value = StringObject.Unescape(value);
      this.EmitInt(value.Length);
      foreach (byte code in value)
        this.Emit(code);
    }

    private void SetLabelPositions()
    {
      foreach (Assembler.WantedLabel wantedLabel in this.WantedLabels)
      {
        int bytecodePosition = wantedLabel.BytecodePosition;
        int label = this.Labels[wantedLabel.Label];
        for (int index = 0; index < 4; ++index)
        {
          this.Bytecode[bytecodePosition++] = (byte) (label % 256);
          label /= 256;
        }
      }
    }

    private static string[] SplitLine(string line)
    {
      List<string> stringList = new List<string>();
      line = line.TrimEnd();
      while (line != "")
        stringList.Add(Assembler.GetNextPartOfString(ref line));
      return stringList.ToArray();
    }

    private static string GetNextPartOfString(ref string line)
    {
      line = line.TrimStart();
      string nextPartOfString;
      if (line.StartsWith("\""))
      {
        int num = line.IndexOf('"', 1);
        if (num == -1)
          throw new AssemblerException("Unterminated string literal");
        nextPartOfString = line.Substring(1, num - 1);
        line = line.Substring(num + 1);
      }
      else
      {
        int length = line.IndexOfAny(" \n\r\t".ToCharArray());
        if (length == -1)
        {
          nextPartOfString = line;
          line = "";
        }
        else
        {
          nextPartOfString = line.Substring(0, length);
          line = line.Substring(length + 1);
        }
      }
      return nextPartOfString;
    }

    private sealed class WantedLabel
    {
      public readonly string Label;
      public readonly int BytecodePosition;

      public WantedLabel(string label, int bytecodePosition)
      {
        this.Label = label;
        this.BytecodePosition = bytecodePosition;
      }
    }

    private enum Mode
    {
      Parameter,
      Rest,
      ClosingOverVariable,
      LocalDefines,
    }

    private sealed class FunctionStatement
    {
      public readonly string LabelStart;
      public readonly string LabelEnd;
      public readonly string Name;
      public readonly List<string> ClosingOverVariables;

      public FunctionStatement(
        string name,
        string labelStart,
        string labelEnd,
        List<string> closingOverVariables)
      {
        this.LabelStart = labelStart;
        this.LabelEnd = labelEnd;
        this.Name = name;
        this.ClosingOverVariables = closingOverVariables;
      }
    }
  }
}
