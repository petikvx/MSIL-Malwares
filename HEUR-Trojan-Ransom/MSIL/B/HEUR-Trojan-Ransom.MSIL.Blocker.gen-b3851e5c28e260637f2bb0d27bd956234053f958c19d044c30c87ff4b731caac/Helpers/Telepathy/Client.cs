// Decompiled with JetBrains decompiler
// Type: VanillaStub.Helpers.Telepathy.Client
// Assembly: VanillaStub, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EA90E0E3-D3F0-4587-A40F-47A7FA59CCA7
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.06-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-b3851e5c28e260637f2bb0d27bd956234053f958c19d044c30c87ff4b731caac.exe

using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Threading;

namespace VanillaStub.Helpers.Telepathy
{
  public class Client : Common
  {
    private readonly ManualResetEvent sendPending = new ManualResetEvent(false);
    private readonly SafeQueue<byte[]> sendQueue = new SafeQueue<byte[]>();
    private volatile bool _Connecting;
    public TcpClient client;
    private Thread receiveThread;
    private Thread sendThread;

    public bool Connected => this.client != null && this.client.Client != null && this.client.Client.Connected;

    public bool Connecting => this._Connecting;

    private void ReceiveThreadFunction(string ip, int port)
    {
      try
      {
        this.client.Connect(ip, port);
        this._Connecting = false;
        this.sendThread = new Thread((ThreadStart) (() => Common.SendLoop(0, this.client, this.sendQueue, this.sendPending)));
        this.sendThread.IsBackground = true;
        this.sendThread.Start();
        Common.ReceiveLoop(0, this.client, this.receiveQueue, this.MaxMessageSize);
      }
      catch (SocketException ex)
      {
        Logger.Log("Client Recv: failed to connect to ip=" + ip + " port=" + (object) port + " reason=" + (object) ex);
        this.receiveQueue.Enqueue(new Message(0, EventType.Disconnected, (byte[]) null));
      }
      catch (Exception ex)
      {
        Logger.LogError("Client Recv Exception: " + (object) ex);
      }
      this.sendThread?.Interrupt();
      this._Connecting = false;
      this.client.Close();
    }

    public void Connect(string ip, int port)
    {
      if (this.Connecting || this.Connected)
        return;
      this._Connecting = true;
      this.client = new TcpClient();
      this.client.NoDelay = this.NoDelay;
      this.client.SendTimeout = this.SendTimeout;
      this.receiveQueue = new ConcurrentQueue<Message>();
      this.sendQueue.Clear();
      this.receiveThread = new Thread((ThreadStart) (() => this.ReceiveThreadFunction(ip, port)));
      this.receiveThread.IsBackground = true;
      this.receiveThread.Start();
    }

    public void Disconnect()
    {
      if (!this.Connecting && !this.Connected)
        return;
      this.client.Close();
      this.receiveThread?.Join();
      this.sendQueue.Clear();
      this.client = (TcpClient) null;
    }

    public bool Send(byte[] data)
    {
      if (this.Connected)
      {
        if (data.Length <= this.MaxMessageSize)
        {
          this.sendQueue.Enqueue(data);
          this.sendPending.Set();
          return true;
        }
        Logger.LogError("Client.Send: message too big: " + (object) data.Length + ". Limit: " + (object) this.MaxMessageSize);
        return false;
      }
      Logger.LogWarning("Client.Send: not connected!");
      return false;
    }
  }
}
